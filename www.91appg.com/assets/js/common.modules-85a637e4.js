window.getBuildInfo = function() {
    return {
        buildTime: "4/18/2025, 8:14:29 PM",
        branch: " commitId:8f7cd864d454367470bdc5356c065914ead7b152"
    }
};
const CF = "modulepreload",
    PF = function(t) {
        return "/" + t
    },
    Tw = {},
    Vf = function(e, n, r) {
        if (!n || n.length === 0) return e();
        const i = document.getElementsByTagName("link");
        return Promise.all(n.map(s => {
            if (s = PF(s), s in Tw) return;
            Tw[s] = !0;
            const o = s.endsWith(".css"),
                a = o ? '[rel="stylesheet"]' : "";
            if (!!r)
                for (let u = i.length - 1; u >= 0; u--) {
                    const d = i[u];
                    if (d.href === s && (!o || d.rel === "stylesheet")) return
                } else if (document.querySelector(`link[href="${s}"]${a}`)) return;
            const c = document.createElement("link");
            if (c.rel = o ? "stylesheet" : CF, o || (c.as = "script", c.crossOrigin = ""), c.href = s, document.head.appendChild(c), o) return new Promise((u, d) => {
                c.addEventListener("load", u), c.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${s}`)))
            })
        })).then(() => e()).catch(s => {
            const o = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (o.payload = s, window.dispatchEvent(o), !o.defaultPrevented) throw s
        })
    };

function AF(t, e) {
    const n = Object.create(null),
        r = t.split(",");
    for (let i = 0; i < r.length; i++) n[r[i]] = !0;
    return e ? i => !!n[i.toLowerCase()] : i => !!n[i]
}
const Mu = Object.assign,
    OF = Object.prototype.hasOwnProperty,
    Fh = (t, e) => OF.call(t, e),
    Ii = Array.isArray,
    wc = t => BP(t) === "[object Map]",
    q0 = t => typeof t == "function",
    IF = t => typeof t == "string",
    J0 = t => typeof t == "symbol",
    ku = t => t !== null && typeof t == "object",
    RF = Object.prototype.toString,
    BP = t => RF.call(t),
    DP = t => BP(t).slice(8, -1),
    Z0 = t => IF(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t,
    MF = t => {
        const e = Object.create(null);
        return n => e[n] || (e[n] = t(n))
    },
    kF = MF(t => t.charAt(0).toUpperCase() + t.slice(1)),
    Q0 = (t, e) => !Object.is(t, e),
    BF = (t, e, n) => {
        Object.defineProperty(t, e, {
            configurable: !0,
            enumerable: !1,
            value: n
        })
    };

function Wf(t, ...e) {
    console.warn(`[Vue warn] ${t}`, ...e)
}
let Hn;
class e_ {
    constructor(e = !1) {
        this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Hn, !e && Hn && (this.index = (Hn.scopes || (Hn.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(e) {
        if (this._active) {
            const n = Hn;
            try {
                return Hn = this, e()
            } finally {
                Hn = n
            }
        } else Wf("cannot run an inactive effect scope.")
    }
    on() {
        Hn = this
    }
    off() {
        Hn = this.parent
    }
    stop(e) {
        if (this._active) {
            let n, r;
            for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop();
            for (n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]();
            if (this.scopes)
                for (n = 0, r = this.scopes.length; n < r; n++) this.scopes[n].stop(!0);
            if (!this.detached && this.parent && !e) {
                const i = this.parent.scopes.pop();
                i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index)
            }
            this.parent = void 0, this._active = !1
        }
    }
}

function Bu(t) {
    return new e_(t)
}

function $P(t, e = Hn) {
    e && e.active && e.effects.push(t)
}

function Du() {
    return Hn
}

function t_(t) {
    Hn ? Hn.cleanups.push(t) : Wf("onScopeDispose() is called when there is no active effect scope to be associated with.")
}
const n_ = t => {
        const e = new Set(t);
        return e.w = 0, e.n = 0, e
    },
    FP = t => (t.w & Is) > 0,
    LP = t => (t.n & Is) > 0,
    DF = ({
        deps: t
    }) => {
        if (t.length)
            for (let e = 0; e < t.length; e++) t[e].w |= Is
    },
    $F = t => {
        const {
            deps: e
        } = t;
        if (e.length) {
            let n = 0;
            for (let r = 0; r < e.length; r++) {
                const i = e[r];
                FP(i) && !LP(i) ? i.delete(t) : e[n++] = i, i.w &= ~Is, i.n &= ~Is
            }
            e.length = n
        }
    },
    Yf = new WeakMap;
let mc = 0,
    Is = 1;
const Cv = 30;
let _n;
const Oo = Symbol("iterate"),
    Pv = Symbol("Map key iterate");
class $u {
    constructor(e, n = null, r) {
        this.fn = e, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, $P(this, r)
    }
    run() {
        if (!this.active) return this.fn();
        let e = _n,
            n = Es;
        for (; e;) {
            if (e === this) return;
            e = e.parent
        }
        try {
            return this.parent = _n, _n = this, Es = !0, Is = 1 << ++mc, mc <= Cv ? DF(this) : Cw(this), this.fn()
        } finally {
            mc <= Cv && $F(this), Is = 1 << --mc, _n = this.parent, Es = n, this.parent = void 0, this.deferStop && this.stop()
        }
    }
    stop() {
        _n === this ? this.deferStop = !0 : this.active && (Cw(this), this.onStop && this.onStop(), this.active = !1)
    }
}

function Cw(t) {
    const {
        deps: e
    } = t;
    if (e.length) {
        for (let n = 0; n < e.length; n++) e[n].delete(t);
        e.length = 0
    }
}

function FF(t, e) {
    t.effect && (t = t.effect.fn);
    const n = new $u(t);
    e && (Mu(n, e), e.scope && $P(n, e.scope)), (!e || !e.lazy) && n.run();
    const r = n.run.bind(n);
    return r.effect = n, r
}

function LF(t) {
    t.effect.stop()
}
let Es = !0;
const NP = [];

function ia() {
    NP.push(Es), Es = !1
}

function sa() {
    const t = NP.pop();
    Es = t === void 0 ? !0 : t
}

function pn(t, e, n) {
    if (Es && _n) {
        let r = Yf.get(t);
        r || Yf.set(t, r = new Map);
        let i = r.get(n);
        i || r.set(n, i = n_()), UP(i, {
            effect: _n,
            target: t,
            type: e,
            key: n
        })
    }
}

function UP(t, e) {
    let n = !1;
    mc <= Cv ? LP(t) || (t.n |= Is, n = !FP(t)) : n = !t.has(_n), n && (t.add(_n), _n.deps.push(t), _n.onTrack && _n.onTrack(Mu({
        effect: _n
    }, e)))
}

function ri(t, e, n, r, i, s) {
    const o = Yf.get(t);
    if (!o) return;
    let a = [];
    if (e === "clear") a = [...o.values()];
    else if (n === "length" && Ii(t)) {
        const c = Number(r);
        o.forEach((u, d) => {
            (d === "length" || d >= c) && a.push(u)
        })
    } else switch (n !== void 0 && a.push(o.get(n)), e) {
        case "add":
            Ii(t) ? Z0(n) && a.push(o.get("length")) : (a.push(o.get(Oo)), wc(t) && a.push(o.get(Pv)));
            break;
        case "delete":
            Ii(t) || (a.push(o.get(Oo)), wc(t) && a.push(o.get(Pv)));
            break;
        case "set":
            wc(t) && a.push(o.get(Oo));
            break
    }
    const l = {
        target: t,
        type: e,
        key: n,
        newValue: r,
        oldValue: i,
        oldTarget: s
    };
    if (a.length === 1) a[0] && Av(a[0], l);
    else {
        const c = [];
        for (const u of a) u && c.push(...u);
        Av(n_(c), l)
    }
}

function Av(t, e) {
    const n = Ii(t) ? t : [...t];
    for (const r of n) r.computed && Pw(r, e);
    for (const r of n) r.computed || Pw(r, e)
}

function Pw(t, e) {
    (t !== _n || t.allowRecurse) && (t.onTrigger && t.onTrigger(Mu({
        effect: t
    }, e)), t.scheduler ? t.scheduler() : t.run())
}

function NF(t, e) {
    var n;
    return (n = Yf.get(t)) == null ? void 0 : n.get(e)
}
const UF = AF("__proto__,__v_isRef,__isVue"),
    GP = new Set(Object.getOwnPropertyNames(Symbol).filter(t => t !== "arguments" && t !== "caller").map(t => Symbol[t]).filter(J0)),
    GF = Lh(),
    HF = Lh(!1, !0),
    zF = Lh(!0),
    jF = Lh(!0, !0),
    Aw = VF();

function VF() {
    const t = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
        t[e] = function(...n) {
            const r = Oe(this);
            for (let s = 0, o = this.length; s < o; s++) pn(r, "get", s + "");
            const i = r[e](...n);
            return i === -1 || i === !1 ? r[e](...n.map(Oe)) : i
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
        t[e] = function(...n) {
            ia();
            const r = Oe(this)[e].apply(this, n);
            return sa(), r
        }
    }), t
}

function WF(t) {
    const e = Oe(this);
    return pn(e, "has", t), e.hasOwnProperty(t)
}

function Lh(t = !1, e = !1) {
    return function(r, i, s) {
        if (i === "__v_isReactive") return !t;
        if (i === "__v_isReadonly") return t;
        if (i === "__v_isShallow") return e;
        if (i === "__v_raw" && s === (t ? e ? KP : XP : e ? YP : WP).get(r)) return r;
        const o = Ii(r);
        if (!t) {
            if (o && Fh(Aw, i)) return Reflect.get(Aw, i, s);
            if (i === "hasOwnProperty") return WF
        }
        const a = Reflect.get(r, i, s);
        return (J0(i) ? GP.has(i) : UF(i)) || (t || pn(r, "get", i), e) ? a : tt(a) ? o && Z0(i) ? a : a.value : ku(a) ? t ? oa(a) : ht(a) : a
    }
}
const YF = HP(),
    XF = HP(!0);

function HP(t = !1) {
    return function(n, r, i, s) {
        let o = n[r];
        if (Ui(o) && tt(o) && !tt(i)) return !1;
        if (!t && (!Kc(i) && !Ui(i) && (o = Oe(o), i = Oe(i)), !Ii(n) && tt(o) && !tt(i))) return o.value = i, !0;
        const a = Ii(n) && Z0(r) ? Number(r) < n.length : Fh(n, r),
            l = Reflect.set(n, r, i, s);
        return n === Oe(s) && (a ? Q0(i, o) && ri(n, "set", r, i, o) : ri(n, "add", r, i)), l
    }
}

function KF(t, e) {
    const n = Fh(t, e),
        r = t[e],
        i = Reflect.deleteProperty(t, e);
    return i && n && ri(t, "delete", e, void 0, r), i
}

function qF(t, e) {
    const n = Reflect.has(t, e);
    return (!J0(e) || !GP.has(e)) && pn(t, "has", e), n
}

function JF(t) {
    return pn(t, "iterate", Ii(t) ? "length" : Oo), Reflect.ownKeys(t)
}
const zP = {
        get: GF,
        set: YF,
        deleteProperty: KF,
        has: qF,
        ownKeys: JF
    },
    jP = {
        get: zF,
        set(t, e) {
            return Wf(`Set operation on key "${String(e)}" failed: target is readonly.`, t), !0
        },
        deleteProperty(t, e) {
            return Wf(`Delete operation on key "${String(e)}" failed: target is readonly.`, t), !0
        }
    },
    ZF = Mu({}, zP, {
        get: HF,
        set: XF
    }),
    QF = Mu({}, jP, {
        get: jF
    }),
    r_ = t => t,
    Nh = t => Reflect.getPrototypeOf(t);

function vd(t, e, n = !1, r = !1) {
    t = t.__v_raw;
    const i = Oe(t),
        s = Oe(e);
    n || (e !== s && pn(i, "get", e), pn(i, "get", s));
    const {
        has: o
    } = Nh(i), a = r ? r_ : n ? i_ : Jc;
    if (o.call(i, e)) return a(t.get(e));
    if (o.call(i, s)) return a(t.get(s));
    t !== i && t.get(e)
}

function yd(t, e = !1) {
    const n = this.__v_raw,
        r = Oe(n),
        i = Oe(t);
    return e || (t !== i && pn(r, "has", t), pn(r, "has", i)), t === i ? n.has(t) : n.has(t) || n.has(i)
}

function _d(t, e = !1) {
    return t = t.__v_raw, !e && pn(Oe(t), "iterate", Oo), Reflect.get(t, "size", t)
}

function Ow(t) {
    t = Oe(t);
    const e = Oe(this);
    return Nh(e).has.call(e, t) || (e.add(t), ri(e, "add", t, t)), this
}

function Iw(t, e) {
    e = Oe(e);
    const n = Oe(this),
        {
            has: r,
            get: i
        } = Nh(n);
    let s = r.call(n, t);
    s ? VP(n, r, t) : (t = Oe(t), s = r.call(n, t));
    const o = i.call(n, t);
    return n.set(t, e), s ? Q0(e, o) && ri(n, "set", t, e, o) : ri(n, "add", t, e), this
}

function Rw(t) {
    const e = Oe(this),
        {
            has: n,
            get: r
        } = Nh(e);
    let i = n.call(e, t);
    i ? VP(e, n, t) : (t = Oe(t), i = n.call(e, t));
    const s = r ? r.call(e, t) : void 0,
        o = e.delete(t);
    return i && ri(e, "delete", t, void 0, s), o
}

function Mw() {
    const t = Oe(this),
        e = t.size !== 0,
        n = wc(t) ? new Map(t) : new Set(t),
        r = t.clear();
    return e && ri(t, "clear", void 0, void 0, n), r
}

function bd(t, e) {
    return function(r, i) {
        const s = this,
            o = s.__v_raw,
            a = Oe(o),
            l = e ? r_ : t ? i_ : Jc;
        return !t && pn(a, "iterate", Oo), o.forEach((c, u) => r.call(i, l(c), l(u), s))
    }
}

function xd(t, e, n) {
    return function(...r) {
        const i = this.__v_raw,
            s = Oe(i),
            o = wc(s),
            a = t === "entries" || t === Symbol.iterator && o,
            l = t === "keys" && o,
            c = i[t](...r),
            u = n ? r_ : e ? i_ : Jc;
        return !e && pn(s, "iterate", l ? Pv : Oo), {
            next() {
                const {
                    value: d,
                    done: f
                } = c.next();
                return f ? {
                    value: d,
                    done: f
                } : {
                    value: a ? [u(d[0]), u(d[1])] : u(d),
                    done: f
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function Zi(t) {
    return function(...e) {
        {
            const n = e[0] ? `on key "${e[0]}" ` : "";
            console.warn(`${kF(t)} operation ${n}failed: target is readonly.`, Oe(this))
        }
        return t === "delete" ? !1 : this
    }
}

function eL() {
    const t = {
            get(s) {
                return vd(this, s)
            },
            get size() {
                return _d(this)
            },
            has: yd,
            add: Ow,
            set: Iw,
            delete: Rw,
            clear: Mw,
            forEach: bd(!1, !1)
        },
        e = {
            get(s) {
                return vd(this, s, !1, !0)
            },
            get size() {
                return _d(this)
            },
            has: yd,
            add: Ow,
            set: Iw,
            delete: Rw,
            clear: Mw,
            forEach: bd(!1, !0)
        },
        n = {
            get(s) {
                return vd(this, s, !0)
            },
            get size() {
                return _d(this, !0)
            },
            has(s) {
                return yd.call(this, s, !0)
            },
            add: Zi("add"),
            set: Zi("set"),
            delete: Zi("delete"),
            clear: Zi("clear"),
            forEach: bd(!0, !1)
        },
        r = {
            get(s) {
                return vd(this, s, !0, !0)
            },
            get size() {
                return _d(this, !0)
            },
            has(s) {
                return yd.call(this, s, !0)
            },
            add: Zi("add"),
            set: Zi("set"),
            delete: Zi("delete"),
            clear: Zi("clear"),
            forEach: bd(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(s => {
        t[s] = xd(s, !1, !1), n[s] = xd(s, !0, !1), e[s] = xd(s, !1, !0), r[s] = xd(s, !0, !0)
    }), [t, n, e, r]
}
const [tL, nL, rL, iL] = eL();

function Uh(t, e) {
    const n = e ? t ? iL : rL : t ? nL : tL;
    return (r, i, s) => i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? r : Reflect.get(Fh(n, i) && i in r ? n : r, i, s)
}
const sL = {
        get: Uh(!1, !1)
    },
    oL = {
        get: Uh(!1, !0)
    },
    aL = {
        get: Uh(!0, !1)
    },
    lL = {
        get: Uh(!0, !0)
    };

function VP(t, e, n) {
    const r = Oe(n);
    if (r !== n && e.call(t, r)) {
        const i = DP(t);
        console.warn(`Reactive ${i} contains both the raw and reactive versions of the same object${i==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)
    }
}
const WP = new WeakMap,
    YP = new WeakMap,
    XP = new WeakMap,
    KP = new WeakMap;

function cL(t) {
    switch (t) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}

function uL(t) {
    return t.__v_skip || !Object.isExtensible(t) ? 0 : cL(DP(t))
}

function ht(t) {
    return Ui(t) ? t : Gh(t, !1, zP, sL, WP)
}

function qP(t) {
    return Gh(t, !1, ZF, oL, YP)
}

function oa(t) {
    return Gh(t, !0, jP, aL, XP)
}

function Ua(t) {
    return Gh(t, !0, QF, lL, KP)
}

function Gh(t, e, n, r, i) {
    if (!ku(t)) return console.warn(`value cannot be made reactive: ${String(t)}`), t;
    if (t.__v_raw && !(e && t.__v_isReactive)) return t;
    const s = i.get(t);
    if (s) return s;
    const o = uL(t);
    if (o === 0) return t;
    const a = new Proxy(t, o === 2 ? r : n);
    return i.set(t, a), a
}

function Tr(t) {
    return Ui(t) ? Tr(t.__v_raw) : !!(t && t.__v_isReactive)
}

function Ui(t) {
    return !!(t && t.__v_isReadonly)
}

function Kc(t) {
    return !!(t && t.__v_isShallow)
}

function qc(t) {
    return Tr(t) || Ui(t)
}

function Oe(t) {
    const e = t && t.__v_raw;
    return e ? Oe(e) : t
}

function Zr(t) {
    return BF(t, "__v_skip", !0), t
}
const Jc = t => ku(t) ? ht(t) : t,
    i_ = t => ku(t) ? oa(t) : t;

function s_(t) {
    Es && _n && (t = Oe(t), UP(t.dep || (t.dep = n_()), {
        target: t,
        type: "get",
        key: "value"
    }))
}

function Hh(t, e) {
    t = Oe(t);
    const n = t.dep;
    n && Av(n, {
        target: t,
        type: "set",
        key: "value",
        newValue: e
    })
}

function tt(t) {
    return !!(t && t.__v_isRef === !0)
}

function J(t) {
    return JP(t, !1)
}

function zh(t) {
    return JP(t, !0)
}

function JP(t, e) {
    return tt(t) ? t : new dL(t, e)
}
class dL {
    constructor(e, n) {
        this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : Oe(e), this._value = n ? e : Jc(e)
    }
    get value() {
        return s_(this), this._value
    }
    set value(e) {
        const n = this.__v_isShallow || Kc(e) || Ui(e);
        e = n ? e : Oe(e), Q0(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : Jc(e), Hh(this, e))
    }
}

function fL(t) {
    Hh(t, t.value)
}

function En(t) {
    return tt(t) ? t.value : t
}

function hL(t) {
    return q0(t) ? t() : En(t)
}
const pL = {
    get: (t, e, n) => En(Reflect.get(t, e, n)),
    set: (t, e, n, r) => {
        const i = t[e];
        return tt(i) && !tt(n) ? (i.value = n, !0) : Reflect.set(t, e, n, r)
    }
};

function o_(t) {
    return Tr(t) ? t : new Proxy(t, pL)
}
class mL {
    constructor(e) {
        this.dep = void 0, this.__v_isRef = !0;
        const {
            get: n,
            set: r
        } = e(() => s_(this), () => Hh(this));
        this._get = n, this._set = r
    }
    get value() {
        return this._get()
    }
    set value(e) {
        this._set(e)
    }
}

function ZP(t) {
    return new mL(t)
}

function Ov(t) {
    qc(t) || console.warn("toRefs() expects a reactive object but received a plain one.");
    const e = Ii(t) ? new Array(t.length) : {};
    for (const n in t) e[n] = QP(t, n);
    return e
}
class gL {
    constructor(e, n, r) {
        this._object = e, this._key = n, this._defaultValue = r, this.__v_isRef = !0
    }
    get value() {
        const e = this._object[this._key];
        return e === void 0 ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
    get dep() {
        return NF(Oe(this._object), this._key)
    }
}
class vL {
    constructor(e) {
        this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0
    }
    get value() {
        return this._getter()
    }
}

function Ec(t, e, n) {
    return tt(t) ? t : q0(t) ? new vL(t) : ku(t) && arguments.length > 1 ? QP(t, e, n) : J(t)
}

function QP(t, e, n) {
    const r = t[e];
    return tt(r) ? r : new gL(t, e, n)
}
class yL {
    constructor(e, n, r, i) {
        this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new $u(e, () => {
            this._dirty || (this._dirty = !0, Hh(this))
        }), this.effect.computed = this, this.effect.active = this._cacheable = !i, this.__v_isReadonly = r
    }
    get value() {
        const e = Oe(this);
        return s_(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value
    }
    set value(e) {
        this._setter(e)
    }
}

function _L(t, e, n = !1) {
    let r, i;
    const s = q0(t);
    s ? (r = t, i = () => {
        console.warn("Write operation failed: computed value is readonly")
    }) : (r = t.get, i = t.set);
    const o = new yL(r, i, s || !i, n);
    return e && !n && (o.effect.onTrack = e.onTrack, o.effect.onTrigger = e.onTrigger), o
}

function Fu(t, e) {
    const n = Object.create(null),
        r = t.split(",");
    for (let i = 0; i < r.length; i++) n[r[i]] = !0;
    return e ? i => !!n[i.toLowerCase()] : i => !!n[i]
}
const st = Object.freeze({}),
    Wa = Object.freeze([]),
    kn = () => {},
    eA = () => !1,
    bL = /^on[^a-z]/,
    Lu = t => bL.test(t),
    Iv = t => t.startsWith("onUpdate:"),
    Et = Object.assign,
    a_ = (t, e) => {
        const n = t.indexOf(e);
        n > -1 && t.splice(n, 1)
    },
    xL = Object.prototype.hasOwnProperty,
    qe = (t, e) => xL.call(t, e),
    Be = Array.isArray,
    tA = t => Nu(t) === "[object Map]",
    nA = t => Nu(t) === "[object Set]",
    wL = t => Nu(t) === "[object RegExp]",
    ke = t => typeof t == "function",
    It = t => typeof t == "string",
    ut = t => t !== null && typeof t == "object",
    jh = t => ut(t) && ke(t.then) && ke(t.catch),
    rA = Object.prototype.toString,
    Nu = t => rA.call(t),
    EL = t => Nu(t).slice(8, -1),
    iA = t => Nu(t) === "[object Object]",
    Sc = Fu(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    SL = Fu("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"),
    Vh = t => {
        const e = Object.create(null);
        return n => e[n] || (e[n] = t(n))
    },
    TL = /-(\w)/g,
    Rr = Vh(t => t.replace(TL, (e, n) => n ? n.toUpperCase() : "")),
    CL = /\B([A-Z])/g,
    nl = Vh(t => t.replace(CL, "-$1").toLowerCase()),
    rl = Vh(t => t.charAt(0).toUpperCase() + t.slice(1)),
    Si = Vh(t => t ? `on${rl(t)}` : ""),
    Rv = (t, e) => !Object.is(t, e),
    mo = (t, e) => {
        for (let n = 0; n < t.length; n++) t[n](e)
    },
    Mv = (t, e, n) => {
        Object.defineProperty(t, e, {
            configurable: !0,
            enumerable: !1,
            value: n
        })
    },
    PL = t => {
        const e = parseFloat(t);
        return isNaN(e) ? t : e
    },
    AL = t => {
        const e = It(t) ? Number(t) : NaN;
        return isNaN(e) ? t : e
    };
let kw;
const Xf = () => kw || (kw = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}),
    OL = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console",
    IL = Fu(OL);

function Uu(t) {
    if (Be(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const r = t[n],
                i = It(r) ? BL(r) : Uu(r);
            if (i)
                for (const s in i) e[s] = i[s]
        }
        return e
    } else {
        if (It(t)) return t;
        if (ut(t)) return t
    }
}
const RL = /;(?![^(]*\))/g,
    ML = /:([^]+)/,
    kL = /\/\*[^]*?\*\//g;

function BL(t) {
    const e = {};
    return t.replace(kL, "").split(RL).forEach(n => {
        if (n) {
            const r = n.split(ML);
            r.length > 1 && (e[r[0].trim()] = r[1].trim())
        }
    }), e
}

function Gu(t) {
    let e = "";
    if (It(t)) e = t;
    else if (Be(t))
        for (let n = 0; n < t.length; n++) {
            const r = Gu(t[n]);
            r && (e += r + " ")
        } else if (ut(t))
            for (const n in t) t[n] && (e += n + " ");
    return e.trim()
}

function DL(t) {
    if (!t) return null;
    let {
        class: e,
        style: n
    } = t;
    return e && !It(e) && (t.class = Gu(e)), n && (t.style = Uu(n)), t
}
const $L = t => It(t) ? t : t == null ? "" : Be(t) || ut(t) && (t.toString === rA || !ke(t.toString)) ? JSON.stringify(t, sA, 2) : String(t),
    sA = (t, e) => e && e.__v_isRef ? sA(t, e.value) : tA(e) ? {
        [`Map(${e.size})`]: [...e.entries()].reduce((n, [r, i]) => (n[`${r} =>`] = i, n), {})
    } : nA(e) ? {
        [`Set(${e.size})`]: [...e.values()]
    } : ut(e) && !Be(e) && !iA(e) ? String(e) : e,
    Io = [];

function Tc(t) {
    Io.push(t)
}

function Cc() {
    Io.pop()
}

function re(t, ...e) {
    ia();
    const n = Io.length ? Io[Io.length - 1].component : null,
        r = n && n.appContext.config.warnHandler,
        i = FL();
    if (r) ei(r, n, 11, [t + e.join(""), n && n.proxy, i.map(({
        vnode: s
    }) => `at <${np(n,s.type)}>`).join(`
`), i]);
    else {
        const s = [`[Vue warn]: ${t}`, ...e];
        i.length && s.push(`
`, ...LL(i)), console.warn(...s)
    }
    sa()
}

function FL() {
    let t = Io[Io.length - 1];
    if (!t) return [];
    const e = [];
    for (; t;) {
        const n = e[0];
        n && n.vnode === t ? n.recurseCount++ : e.push({
            vnode: t,
            recurseCount: 0
        });
        const r = t.component && t.component.parent;
        t = r && r.vnode
    }
    return e
}

function LL(t) {
    const e = [];
    return t.forEach((n, r) => {
        e.push(...r === 0 ? [] : [`
`], ...NL(n))
    }), e
}

function NL({
    vnode: t,
    recurseCount: e
}) {
    const n = e > 0 ? `... (${e} recursive calls)` : "",
        r = t.component ? t.component.parent == null : !1,
        i = ` at <${np(t.component,t.type,r)}`,
        s = ">" + n;
    return t.props ? [i, ...UL(t.props), s] : [i + s]
}

function UL(t) {
    const e = [],
        n = Object.keys(t);
    return n.slice(0, 3).forEach(r => {
        e.push(...oA(r, t[r]))
    }), n.length > 3 && e.push(" ..."), e
}

function oA(t, e, n) {
    return It(e) ? (e = JSON.stringify(e), n ? e : [`${t}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? n ? e : [`${t}=${e}`] : tt(e) ? (e = oA(t, Oe(e.value), !0), n ? e : [`${t}=Ref<`, e, ">"]) : ke(e) ? [`${t}=fn${e.name?`<${e.name}>`:""}`] : (e = Oe(e), n ? e : [`${t}=`, e])
}

function l_(t, e) {
    t !== void 0 && (typeof t != "number" ? re(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && re(`${e} is NaN - the duration expression might be incorrect.`))
}
const c_ = {
    sp: "serverPrefetch hook",
    bc: "beforeCreate hook",
    c: "created hook",
    bm: "beforeMount hook",
    m: "mounted hook",
    bu: "beforeUpdate hook",
    u: "updated",
    bum: "beforeUnmount hook",
    um: "unmounted hook",
    a: "activated hook",
    da: "deactivated hook",
    ec: "errorCaptured hook",
    rtc: "renderTracked hook",
    rtg: "renderTriggered hook",
    0: "setup function",
    1: "render function",
    2: "watcher getter",
    3: "watcher callback",
    4: "watcher cleanup function",
    5: "native event handler",
    6: "component event handler",
    7: "vnode hook",
    8: "directive hook",
    9: "transition hook",
    10: "app errorHandler",
    11: "app warnHandler",
    12: "ref function",
    13: "async component loader",
    14: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};

function ei(t, e, n, r) {
    let i;
    try {
        i = r ? t(...r) : t()
    } catch (s) {
        aa(s, e, n)
    }
    return i
}

function Wn(t, e, n, r) {
    if (ke(t)) {
        const s = ei(t, e, n, r);
        return s && jh(s) && s.catch(o => {
            aa(o, e, n)
        }), s
    }
    const i = [];
    for (let s = 0; s < t.length; s++) i.push(Wn(t[s], e, n, r));
    return i
}

function aa(t, e, n, r = !0) {
    const i = e ? e.vnode : null;
    if (e) {
        let s = e.parent;
        const o = e.proxy,
            a = c_[n];
        for (; s;) {
            const c = s.ec;
            if (c) {
                for (let u = 0; u < c.length; u++)
                    if (c[u](t, o, a) === !1) return
            }
            s = s.parent
        }
        const l = e.appContext.config.errorHandler;
        if (l) {
            ei(l, null, 10, [t, o, a]);
            return
        }
    }
    GL(t, n, i, r)
}

function GL(t, e, n, r = !0) {
    {
        const i = c_[e];
        if (n && Tc(n), re(`Unhandled error${i?` during execution of ${i}`:""}`), n && Cc(), r) throw t;
        console.error(t)
    }
}
let Zc = !1,
    kv = !1;
const cn = [];
let Kr = 0;
const Ya = [];
let jr = null,
    as = 0;
const aA = Promise.resolve();
let u_ = null;
const HL = 100;

function Ue(t) {
    const e = u_ || aA;
    return t ? e.then(this ? t.bind(this) : t) : e
}

function zL(t) {
    let e = Kr + 1,
        n = cn.length;
    for (; e < n;) {
        const r = e + n >>> 1;
        Qc(cn[r]) < t ? e = r + 1 : n = r
    }
    return e
}

function Hu(t) {
    (!cn.length || !cn.includes(t, Zc && t.allowRecurse ? Kr + 1 : Kr)) && (t.id == null ? cn.push(t) : cn.splice(zL(t.id), 0, t), lA())
}

function lA() {
    !Zc && !kv && (kv = !0, u_ = aA.then(cA))
}

function jL(t) {
    const e = cn.indexOf(t);
    e > Kr && cn.splice(e, 1)
}

function Wh(t) {
    Be(t) ? Ya.push(...t) : (!jr || !jr.includes(t, t.allowRecurse ? as + 1 : as)) && Ya.push(t), lA()
}

function Bw(t, e = Zc ? Kr + 1 : 0) {
    for (t = t || new Map; e < cn.length; e++) {
        const n = cn[e];
        if (n && n.pre) {
            if (d_(t, n)) continue;
            cn.splice(e, 1), e--, n()
        }
    }
}

function Kf(t) {
    if (Ya.length) {
        const e = [...new Set(Ya)];
        if (Ya.length = 0, jr) {
            jr.push(...e);
            return
        }
        for (jr = e, t = t || new Map, jr.sort((n, r) => Qc(n) - Qc(r)), as = 0; as < jr.length; as++) d_(t, jr[as]) || jr[as]();
        jr = null, as = 0
    }
}
const Qc = t => t.id == null ? 1 / 0 : t.id,
    VL = (t, e) => {
        const n = Qc(t) - Qc(e);
        if (n === 0) {
            if (t.pre && !e.pre) return -1;
            if (e.pre && !t.pre) return 1
        }
        return n
    };

function cA(t) {
    kv = !1, Zc = !0, t = t || new Map, cn.sort(VL);
    const e = n => d_(t, n);
    try {
        for (Kr = 0; Kr < cn.length; Kr++) {
            const n = cn[Kr];
            if (n && n.active !== !1) {
                if (e(n)) continue;
                ei(n, null, 14)
            }
        }
    } finally {
        Kr = 0, cn.length = 0, Kf(t), Zc = !1, u_ = null, (cn.length || Ya.length) && cA(t)
    }
}

function d_(t, e) {
    if (!t.has(e)) t.set(e, 1);
    else {
        const n = t.get(e);
        if (n > HL) {
            const r = e.ownerInstance,
                i = r && iu(r.type);
            return re(`Maximum recursive updates exceeded${i?` in component <${i}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`), !0
        } else t.set(e, n + 1)
    }
}
let Ss = !1;
const $a = new Set;
Xf().__VUE_HMR_RUNTIME__ = {
    createRecord: lm(uA),
    rerender: lm(XL),
    reload: lm(KL)
};
const No = new Map;

function WL(t) {
    const e = t.type.__hmrId;
    let n = No.get(e);
    n || (uA(e, t.type), n = No.get(e)), n.instances.add(t)
}

function YL(t) {
    No.get(t.type.__hmrId).instances.delete(t)
}

function uA(t, e) {
    return No.has(t) ? !1 : (No.set(t, {
        initialDef: Pc(e),
        instances: new Set
    }), !0)
}

function Pc(t) {
    return eO(t) ? t.__vccOpts : t
}

function XL(t, e) {
    const n = No.get(t);
    n && (n.initialDef.render = e, [...n.instances].forEach(r => {
        e && (r.render = e, Pc(r.type).render = e), r.renderCache = [], Ss = !0, r.update(), Ss = !1
    }))
}

function KL(t, e) {
    const n = No.get(t);
    if (!n) return;
    e = Pc(e), Dw(n.initialDef, e);
    const r = [...n.instances];
    for (const i of r) {
        const s = Pc(i.type);
        $a.has(s) || (s !== n.initialDef && Dw(s, e), $a.add(s)), i.appContext.propsCache.delete(i.type), i.appContext.emitsCache.delete(i.type), i.appContext.optionsCache.delete(i.type), i.ceReload ? ($a.add(s), i.ceReload(e.styles), $a.delete(s)) : i.parent ? Hu(i.parent.update) : i.appContext.reload ? i.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn("[HMR] Root or manually mounted instance modified. Full reload required.")
    }
    Wh(() => {
        for (const i of r) $a.delete(Pc(i.type))
    })
}

function Dw(t, e) {
    Et(t, e);
    for (const n in t) n !== "__file" && !(n in e) && delete t[n]
}

function lm(t) {
    return (e, n) => {
        try {
            return t(e, n)
        } catch (r) {
            console.error(r), console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")
        }
    }
}
let br, gc = [],
    Bv = !1;

function zu(t, ...e) {
    br ? br.emit(t, ...e) : Bv || gc.push({
        event: t,
        args: e
    })
}

function f_(t, e) {
    var n, r;
    br = t, br ? (br.enabled = !0, gc.forEach(({
        event: i,
        args: s
    }) => br.emit(i, ...s)), gc = []) : typeof window < "u" && window.HTMLElement && !((r = (n = window.navigator) == null ? void 0 : n.userAgent) != null && r.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(s => {
        f_(s, e)
    }), setTimeout(() => {
        br || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Bv = !0, gc = [])
    }, 3e3)) : (Bv = !0, gc = [])
}

function qL(t, e) {
    zu("app:init", t, e, {
        Fragment: gt,
        Text: ii,
        Comment: Ot,
        Static: Ts
    })
}

function JL(t) {
    zu("app:unmount", t)
}
const Dv = h_("component:added"),
    dA = h_("component:updated"),
    ZL = h_("component:removed"),
    QL = t => {
        br && typeof br.cleanupBuffer == "function" && !br.cleanupBuffer(t) && ZL(t)
    };

function h_(t) {
    return e => {
        zu(t, e.appContext.app, e.uid, e.parent ? e.parent.uid : void 0, e)
    }
}
const eN = fA("perf:start"),
    tN = fA("perf:end");

function fA(t) {
    return (e, n, r) => {
        zu(t, e.appContext.app, e.uid, e, n, r)
    }
}

function nN(t, e, n) {
    zu("component:emit", t.appContext.app, t, e, n)
}

function rN(t, e, ...n) {
    if (t.isUnmounted) return;
    const r = t.vnode.props || st; {
        const {
            emitsOptions: u,
            propsOptions: [d]
        } = t;
        if (u)
            if (!(e in u))(!d || !(Si(e) in d)) && re(`Component emitted event "${e}" but it is neither declared in the emits option nor as an "${Si(e)}" prop.`);
            else {
                const f = u[e];
                ke(f) && (f(...n) || re(`Invalid event arguments: event validation failed for event "${e}".`))
            }
    }
    let i = n;
    const s = e.startsWith("update:"),
        o = s && e.slice(7);
    if (o && o in r) {
        const u = `${o==="modelValue"?"model":o}Modifiers`,
            {
                number: d,
                trim: f
            } = r[u] || st;
        f && (i = n.map(h => It(h) ? h.trim() : h)), d && (i = n.map(PL))
    }
    nN(t, e, i); {
        const u = e.toLowerCase();
        u !== e && r[Si(u)] && re(`Event "${u}" is emitted in component ${np(t,t.type)} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${nl(e)}" instead of "${e}".`)
    }
    let a, l = r[a = Si(e)] || r[a = Si(Rr(e))];
    !l && s && (l = r[a = Si(nl(e))]), l && Wn(l, t, 6, i);
    const c = r[a + "Once"];
    if (c) {
        if (!t.emitted) t.emitted = {};
        else if (t.emitted[a]) return;
        t.emitted[a] = !0, Wn(c, t, 6, i)
    }
}

function hA(t, e, n = !1) {
    const r = e.emitsCache,
        i = r.get(t);
    if (i !== void 0) return i;
    const s = t.emits;
    let o = {},
        a = !1;
    if (!ke(t)) {
        const l = c => {
            const u = hA(c, e, !0);
            u && (a = !0, Et(o, u))
        };
        !n && e.mixins.length && e.mixins.forEach(l), t.extends && l(t.extends), t.mixins && t.mixins.forEach(l)
    }
    return !s && !a ? (ut(t) && r.set(t, null), null) : (Be(s) ? s.forEach(l => o[l] = null) : Et(o, s), ut(t) && r.set(t, o), o)
}

function Yh(t, e) {
    return !t || !Lu(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), qe(t, e[0].toLowerCase() + e.slice(1)) || qe(t, nl(e)) || qe(t, e))
}
let Bt = null,
    Xh = null;

function eu(t) {
    const e = Bt;
    return Bt = t, Xh = t && t.type.__scopeId || null, e
}

function iN(t) {
    Xh = t
}

function sN() {
    Xh = null
}
const oN = t => p_;

function p_(t, e = Bt, n) {
    if (!e || t._n) return t;
    const r = (...i) => {
        r._d && zv(-1);
        const s = eu(e);
        let o;
        try {
            o = t(...i)
        } finally {
            eu(s), r._d && zv(1)
        }
        return dA(e), o
    };
    return r._n = !0, r._c = !0, r._d = !0, r
}
let $v = !1;

function qf() {
    $v = !0
}

function bf(t) {
    const {
        type: e,
        vnode: n,
        proxy: r,
        withProxy: i,
        props: s,
        propsOptions: [o],
        slots: a,
        attrs: l,
        emit: c,
        render: u,
        renderCache: d,
        data: f,
        setupState: h,
        ctx: p,
        inheritAttrs: b
    } = t;
    let y, m;
    const g = eu(t);
    $v = !1;
    try {
        if (n.shapeFlag & 4) {
            const x = i || r;
            y = Rn(u.call(x, x, d, s, h, f, p)), m = l
        } else {
            const x = e;
            l === s && qf(), y = Rn(x.length > 1 ? x(s, {
                get attrs() {
                    return qf(), l
                },
                slots: a,
                emit: c
            }) : x(s, null)), m = e.props ? l : lN(l)
        }
    } catch (x) {
        Oc.length = 0, aa(x, t, 1), y = I(Ot)
    }
    let v = y,
        _;
    if (y.patchFlag > 0 && y.patchFlag & 2048 && ([v, _] = aN(y)), m && b !== !1) {
        const x = Object.keys(m),
            {
                shapeFlag: w
            } = v;
        if (x.length) {
            if (w & 7) o && x.some(Iv) && (m = cN(m, o)), v = hr(v, m);
            else if (!$v && v.type !== Ot) {
                const S = Object.keys(l),
                    C = [],
                    A = [];
                for (let T = 0, E = S.length; T < E; T++) {
                    const P = S[T];
                    Lu(P) ? Iv(P) || C.push(P[2].toLowerCase() + P.slice(3)) : A.push(P)
                }
                A.length && re(`Extraneous non-props attributes (${A.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`), C.length && re(`Extraneous non-emits event listeners (${C.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`)
            }
        }
    }
    return n.dirs && ($w(v) || re("Runtime directive used on component with non-element root node. The directives will not function as intended."), v = hr(v), v.dirs = v.dirs ? v.dirs.concat(n.dirs) : n.dirs), n.transition && ($w(v) || re("Component inside <Transition> renders non-element root node that cannot be animated."), v.transition = n.transition), _ ? _(v) : y = v, eu(g), y
}
const aN = t => {
    const e = t.children,
        n = t.dynamicChildren,
        r = m_(e);
    if (!r) return [t, void 0];
    const i = e.indexOf(r),
        s = n ? n.indexOf(r) : -1,
        o = a => {
            e[i] = a, n && (s > -1 ? n[s] = a : a.patchFlag > 0 && (t.dynamicChildren = [...n, a]))
        };
    return [Rn(r), o]
};

function m_(t) {
    let e;
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if (si(r)) {
            if (r.type !== Ot || r.children === "v-if") {
                if (e) return;
                e = r
            }
        } else return
    }
    return e
}
const lN = t => {
        let e;
        for (const n in t)(n === "class" || n === "style" || Lu(n)) && ((e || (e = {}))[n] = t[n]);
        return e
    },
    cN = (t, e) => {
        const n = {};
        for (const r in t)(!Iv(r) || !(r.slice(9) in e)) && (n[r] = t[r]);
        return n
    },
    $w = t => t.shapeFlag & 7 || t.type === Ot;

function uN(t, e, n) {
    const {
        props: r,
        children: i,
        component: s
    } = t, {
        props: o,
        children: a,
        patchFlag: l
    } = e, c = s.emitsOptions;
    if ((i || a) && Ss || e.dirs || e.transition) return !0;
    if (n && l >= 0) {
        if (l & 1024) return !0;
        if (l & 16) return r ? Fw(r, o, c) : !!o;
        if (l & 8) {
            const u = e.dynamicProps;
            for (let d = 0; d < u.length; d++) {
                const f = u[d];
                if (o[f] !== r[f] && !Yh(c, f)) return !0
            }
        }
    } else return (i || a) && (!a || !a.$stable) ? !0 : r === o ? !1 : r ? o ? Fw(r, o, c) : !0 : !!o;
    return !1
}

function Fw(t, e, n) {
    const r = Object.keys(e);
    if (r.length !== Object.keys(t).length) return !0;
    for (let i = 0; i < r.length; i++) {
        const s = r[i];
        if (e[s] !== t[s] && !Yh(n, s)) return !0
    }
    return !1
}

function g_({
    vnode: t,
    parent: e
}, n) {
    for (; e && e.subTree === t;)(t = e.vnode).el = n, e = e.parent
}
const pA = t => t.__isSuspense,
    dN = {
        name: "Suspense",
        __isSuspense: !0,
        process(t, e, n, r, i, s, o, a, l, c) {
            t == null ? hN(e, n, r, i, s, o, a, l, c) : pN(t, e, n, r, i, o, a, l, c)
        },
        hydrate: mN,
        create: v_,
        normalize: gN
    },
    fN = dN;

function tu(t, e) {
    const n = t.props && t.props[e];
    ke(n) && n()
}

function hN(t, e, n, r, i, s, o, a, l) {
    const {
        p: c,
        o: {
            createElement: u
        }
    } = l, d = u("div"), f = t.suspense = v_(t, i, r, e, d, n, s, o, a, l);
    c(null, f.pendingBranch = t.ssContent, d, null, r, f, s, o), f.deps > 0 ? (tu(t, "onPending"), tu(t, "onFallback"), c(null, t.ssFallback, e, n, r, null, s, o), Xa(f, t.ssFallback)) : f.resolve(!1, !0)
}

function pN(t, e, n, r, i, s, o, a, {
    p: l,
    um: c,
    o: {
        createElement: u
    }
}) {
    const d = e.suspense = t.suspense;
    d.vnode = e, e.el = t.el;
    const f = e.ssContent,
        h = e.ssFallback,
        {
            activeBranch: p,
            pendingBranch: b,
            isInFallback: y,
            isHydrating: m
        } = d;
    if (b) d.pendingBranch = f, xr(f, b) ? (l(b, f, d.hiddenContainer, null, i, d, s, o, a), d.deps <= 0 ? d.resolve() : y && (l(p, h, n, r, i, null, s, o, a), Xa(d, h))) : (d.pendingId++, m ? (d.isHydrating = !1, d.activeBranch = b) : c(b, i, d), d.deps = 0, d.effects.length = 0, d.hiddenContainer = u("div"), y ? (l(null, f, d.hiddenContainer, null, i, d, s, o, a), d.deps <= 0 ? d.resolve() : (l(p, h, n, r, i, null, s, o, a), Xa(d, h))) : p && xr(f, p) ? (l(p, f, n, r, i, d, s, o, a), d.resolve(!0)) : (l(null, f, d.hiddenContainer, null, i, d, s, o, a), d.deps <= 0 && d.resolve()));
    else if (p && xr(f, p)) l(p, f, n, r, i, d, s, o, a), Xa(d, f);
    else if (tu(e, "onPending"), d.pendingBranch = f, d.pendingId++, l(null, f, d.hiddenContainer, null, i, d, s, o, a), d.deps <= 0) d.resolve();
    else {
        const {
            timeout: g,
            pendingId: v
        } = d;
        g > 0 ? setTimeout(() => {
            d.pendingId === v && d.fallback(h)
        }, g) : g === 0 && d.fallback(h)
    }
}
let Lw = !1;

function v_(t, e, n, r, i, s, o, a, l, c, u = !1) {
    Lw || (Lw = !0, console[console.info ? "info" : "log"]("<Suspense> is an experimental feature and its API will likely change."));
    const {
        p: d,
        m: f,
        um: h,
        n: p,
        o: {
            parentNode: b,
            remove: y
        }
    } = c;
    let m;
    const g = vN(t);
    g && e != null && e.pendingBranch && (m = e.pendingId, e.deps++);
    const v = t.props ? AL(t.props.timeout) : void 0;
    l_(v, "Suspense timeout");
    const _ = {
        vnode: t,
        parent: e,
        parentComponent: n,
        isSVG: o,
        container: r,
        hiddenContainer: i,
        anchor: s,
        deps: 0,
        pendingId: 0,
        timeout: typeof v == "number" ? v : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !0,
        isHydrating: u,
        isUnmounted: !1,
        effects: [],
        resolve(x = !1, w = !1) {
            {
                if (!x && !_.pendingBranch) throw new Error("suspense.resolve() is called without a pending branch.");
                if (_.isUnmounted) throw new Error("suspense.resolve() is called on an already unmounted suspense boundary.")
            }
            const {
                vnode: S,
                activeBranch: C,
                pendingBranch: A,
                pendingId: T,
                effects: E,
                parentComponent: P,
                container: B
            } = _;
            if (_.isHydrating) _.isHydrating = !1;
            else if (!x) {
                const k = C && A.transition && A.transition.mode === "out-in";
                k && (C.transition.afterLeave = () => {
                    T === _.pendingId && f(A, B, N, 0)
                });
                let {
                    anchor: N
                } = _;
                C && (N = p(C), h(C, P, _, !0)), k || f(A, B, N, 0)
            }
            Xa(_, A), _.pendingBranch = null, _.isInFallback = !1;
            let F = _.parent,
                H = !1;
            for (; F;) {
                if (F.pendingBranch) {
                    F.effects.push(...E), H = !0;
                    break
                }
                F = F.parent
            }
            H || Wh(E), _.effects = [], g && e && e.pendingBranch && m === e.pendingId && (e.deps--, e.deps === 0 && !w && e.resolve()), tu(S, "onResolve")
        },
        fallback(x) {
            if (!_.pendingBranch) return;
            const {
                vnode: w,
                activeBranch: S,
                parentComponent: C,
                container: A,
                isSVG: T
            } = _;
            tu(w, "onFallback");
            const E = p(S),
                P = () => {
                    _.isInFallback && (d(null, x, A, E, C, null, T, a, l), Xa(_, x))
                },
                B = x.transition && x.transition.mode === "out-in";
            B && (S.transition.afterLeave = P), _.isInFallback = !0, h(S, C, null, !0), B || P()
        },
        move(x, w, S) {
            _.activeBranch && f(_.activeBranch, x, w, S), _.container = x
        },
        next() {
            return _.activeBranch && p(_.activeBranch)
        },
        registerDep(x, w) {
            const S = !!_.pendingBranch;
            S && _.deps++;
            const C = x.vnode.el;
            x.asyncDep.catch(A => {
                aa(A, x, 0)
            }).then(A => {
                if (x.isUnmounted || _.isUnmounted || _.pendingId !== x.suspenseId) return;
                x.asyncResolved = !0;
                const {
                    vnode: T
                } = x;
                Tc(T), Wv(x, A, !1), C && (T.el = C);
                const E = !C && x.subTree.el;
                w(x, T, b(C || x.subTree.el), C ? null : p(x.subTree), _, o, l), E && y(E), g_(x, T.el), Cc(), S && --_.deps === 0 && _.resolve()
            })
        },
        unmount(x, w) {
            _.isUnmounted = !0, _.activeBranch && h(_.activeBranch, n, x, w), _.pendingBranch && h(_.pendingBranch, n, x, w)
        }
    };
    return _
}

function mN(t, e, n, r, i, s, o, a, l) {
    const c = e.suspense = v_(e, r, n, t.parentNode, document.createElement("div"), null, i, s, o, a, !0),
        u = l(t, c.pendingBranch = e.ssContent, n, c, s, o);
    return c.deps === 0 && c.resolve(!1, !0), u
}

function gN(t) {
    const {
        shapeFlag: e,
        children: n
    } = t, r = e & 32;
    t.ssContent = Nw(r ? n.default : n), t.ssFallback = r ? Nw(n.fallback) : I(Ot)
}

function Nw(t) {
    let e;
    if (ke(t)) {
        const n = Go && t._c;
        n && (t._d = !1, Zh()), t = t(), n && (t._d = !0, e = Bn, jA())
    }
    if (Be(t)) {
        const n = m_(t);
        n || re("<Suspense> slots expect a single root node."), t = n
    }
    return t = Rn(t), e && !t.dynamicChildren && (t.dynamicChildren = e.filter(n => n !== t)), t
}

function mA(t, e) {
    e && e.pendingBranch ? Be(t) ? e.effects.push(...t) : e.effects.push(t) : Wh(t)
}

function Xa(t, e) {
    t.activeBranch = e;
    const {
        vnode: n,
        parentComponent: r
    } = t, i = n.el = e.el;
    r && r.subTree === n && (r.vnode.el = i, g_(r, i))
}

function vN(t) {
    var e;
    return ((e = t.props) == null ? void 0 : e.suspensible) != null && t.props.suspensible !== !1
}

function Il(t, e) {
    return ju(t, null, e)
}

function gA(t, e) {
    return ju(t, null, Et({}, e, {
        flush: "post"
    }))
}

function yN(t, e) {
    return ju(t, null, Et({}, e, {
        flush: "sync"
    }))
}
const wd = {};

function pe(t, e, n) {
    return ke(e) || re("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."), ju(t, e, n)
}

function ju(t, e, {
    immediate: n,
    deep: r,
    flush: i,
    onTrack: s,
    onTrigger: o
} = st) {
    var a;
    e || (n !== void 0 && re('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'), r !== void 0 && re('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));
    const l = x => {
            re("Invalid watch source: ", x, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")
        },
        c = Du() === ((a = kt) == null ? void 0 : a.scope) ? kt : null;
    let u, d = !1,
        f = !1;
    if (tt(t) ? (u = () => t.value, d = Kc(t)) : Tr(t) ? (u = () => t, r = !0) : Be(t) ? (f = !0, d = t.some(x => Tr(x) || Kc(x)), u = () => t.map(x => {
            if (tt(x)) return x.value;
            if (Tr(x)) return _o(x);
            if (ke(x)) return ei(x, c, 2);
            l(x)
        })) : ke(t) ? e ? u = () => ei(t, c, 2) : u = () => {
            if (!(c && c.isUnmounted)) return h && h(), Wn(t, c, 3, [p])
        } : (u = kn, l(t)), e && r) {
        const x = u;
        u = () => _o(x())
    }
    let h, p = x => {
            h = v.onStop = () => {
                ei(x, c, 4)
            }
        },
        b;
    if (sl)
        if (p = kn, e ? n && Wn(e, c, 3, [u(), f ? [] : void 0, p]) : u(), i === "sync") {
            const x = nO();
            b = x.__watcherHandles || (x.__watcherHandles = [])
        } else return kn;
    let y = f ? new Array(t.length).fill(wd) : wd;
    const m = () => {
        if (v.active)
            if (e) {
                const x = v.run();
                (r || d || (f ? x.some((w, S) => Rv(w, y[S])) : Rv(x, y))) && (h && h(), Wn(e, c, 3, [x, y === wd ? void 0 : f && y[0] === wd ? [] : y, p]), y = x)
            } else v.run()
    };
    m.allowRecurse = !!e;
    let g;
    i === "sync" ? g = m : i === "post" ? g = () => tn(m, c && c.suspense) : (m.pre = !0, c && (m.id = c.uid), g = () => Hu(m));
    const v = new $u(u, g);
    v.onTrack = s, v.onTrigger = o, e ? n ? m() : y = v.run() : i === "post" ? tn(v.run.bind(v), c && c.suspense) : v.run();
    const _ = () => {
        v.stop(), c && c.scope && a_(c.scope.effects, v)
    };
    return b && b.push(_), _
}

function _N(t, e, n) {
    const r = this.proxy,
        i = It(t) ? t.includes(".") ? vA(r, t) : () => r[t] : t.bind(r, r);
    let s;
    ke(e) ? s = e : (s = e.handler, n = e);
    const o = kt;
    Rs(this);
    const a = ju(i, s.bind(r), n);
    return o ? Rs(o) : Cs(), a
}

function vA(t, e) {
    const n = e.split(".");
    return () => {
        let r = t;
        for (let i = 0; i < n.length && r; i++) r = r[n[i]];
        return r
    }
}

function _o(t, e) {
    if (!ut(t) || t.__v_skip || (e = e || new Set, e.has(t))) return t;
    if (e.add(t), tt(t)) _o(t.value, e);
    else if (Be(t))
        for (let n = 0; n < t.length; n++) _o(t[n], e);
    else if (nA(t) || tA(t)) t.forEach(n => {
        _o(n, e)
    });
    else if (iA(t))
        for (const n in t) _o(t[n], e);
    return t
}

function yA(t) {
    SL(t) && re("Do not use built-in directive ids as custom directive id: " + t)
}

function Cr(t, e) {
    const n = Bt;
    if (n === null) return re("withDirectives can only be used inside render functions."), t;
    const r = tp(n) || n.proxy,
        i = t.dirs || (t.dirs = []);
    for (let s = 0; s < e.length; s++) {
        let [o, a, l, c = st] = e[s];
        o && (ke(o) && (o = {
            mounted: o,
            updated: o
        }), o.deep && _o(a), i.push({
            dir: o,
            instance: r,
            value: a,
            oldValue: void 0,
            arg: l,
            modifiers: c
        }))
    }
    return t
}

function Wr(t, e, n, r) {
    const i = t.dirs,
        s = e && e.dirs;
    for (let o = 0; o < i.length; o++) {
        const a = i[o];
        s && (a.oldValue = s[o].value);
        let l = a.dir[r];
        l && (ia(), Wn(l, n, 8, [t.el, a, t, e]), sa())
    }
}

function y_() {
    const t = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return St(() => {
        t.isMounted = !0
    }), er(() => {
        t.isUnmounting = !0
    }), t
}
const ir = [Function, Array],
    __ = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: ir,
        onEnter: ir,
        onAfterEnter: ir,
        onEnterCancelled: ir,
        onBeforeLeave: ir,
        onLeave: ir,
        onAfterLeave: ir,
        onLeaveCancelled: ir,
        onBeforeAppear: ir,
        onAppear: ir,
        onAfterAppear: ir,
        onAppearCancelled: ir
    },
    bN = {
        name: "BaseTransition",
        props: __,
        setup(t, {
            slots: e
        }) {
            const n = it(),
                r = y_();
            let i;
            return () => {
                const s = e.default && Kh(e.default(), !0);
                if (!s || !s.length) return;
                let o = s[0];
                if (s.length > 1) {
                    let b = !1;
                    for (const y of s)
                        if (y.type !== Ot) {
                            if (b) {
                                re("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
                                break
                            }
                            o = y, b = !0
                        }
                }
                const a = Oe(t),
                    {
                        mode: l
                    } = a;
                if (l && l !== "in-out" && l !== "out-in" && l !== "default" && re(`invalid <transition> mode: ${l}`), r.isLeaving) return cm(o);
                const c = Uw(o);
                if (!c) return cm(o);
                const u = il(c, a, r, n);
                Uo(c, u);
                const d = n.subTree,
                    f = d && Uw(d);
                let h = !1;
                const {
                    getTransitionKey: p
                } = c.type;
                if (p) {
                    const b = p();
                    i === void 0 ? i = b : b !== i && (i = b, h = !0)
                }
                if (f && f.type !== Ot && (!xr(c, f) || h)) {
                    const b = il(f, a, r, n);
                    if (Uo(f, b), l === "out-in") return r.isLeaving = !0, b.afterLeave = () => {
                        r.isLeaving = !1, n.update.active !== !1 && n.update()
                    }, cm(o);
                    l === "in-out" && c.type !== Ot && (b.delayLeave = (y, m, g) => {
                        const v = bA(r, f);
                        v[String(f.key)] = f, y._leaveCb = () => {
                            m(), y._leaveCb = void 0, delete u.delayedLeave
                        }, u.delayedLeave = g
                    })
                }
                return o
            }
        }
    },
    _A = bN;

function bA(t, e) {
    const {
        leavingVNodes: n
    } = t;
    let r = n.get(e.type);
    return r || (r = Object.create(null), n.set(e.type, r)), r
}

function il(t, e, n, r) {
    const {
        appear: i,
        mode: s,
        persisted: o = !1,
        onBeforeEnter: a,
        onEnter: l,
        onAfterEnter: c,
        onEnterCancelled: u,
        onBeforeLeave: d,
        onLeave: f,
        onAfterLeave: h,
        onLeaveCancelled: p,
        onBeforeAppear: b,
        onAppear: y,
        onAfterAppear: m,
        onAppearCancelled: g
    } = e, v = String(t.key), _ = bA(n, t), x = (C, A) => {
        C && Wn(C, r, 9, A)
    }, w = (C, A) => {
        const T = A[1];
        x(C, A), Be(C) ? C.every(E => E.length <= 1) && T() : C.length <= 1 && T()
    }, S = {
        mode: s,
        persisted: o,
        beforeEnter(C) {
            let A = a;
            if (!n.isMounted)
                if (i) A = b || a;
                else return;
            C._leaveCb && C._leaveCb(!0);
            const T = _[v];
            T && xr(t, T) && T.el._leaveCb && T.el._leaveCb(), x(A, [C])
        },
        enter(C) {
            let A = l,
                T = c,
                E = u;
            if (!n.isMounted)
                if (i) A = y || l, T = m || c, E = g || u;
                else return;
            let P = !1;
            const B = C._enterCb = F => {
                P || (P = !0, F ? x(E, [C]) : x(T, [C]), S.delayedLeave && S.delayedLeave(), C._enterCb = void 0)
            };
            A ? w(A, [C, B]) : B()
        },
        leave(C, A) {
            const T = String(t.key);
            if (C._enterCb && C._enterCb(!0), n.isUnmounting) return A();
            x(d, [C]);
            let E = !1;
            const P = C._leaveCb = B => {
                E || (E = !0, A(), B ? x(p, [C]) : x(h, [C]), C._leaveCb = void 0, _[T] === t && delete _[T])
            };
            _[T] = t, f ? w(f, [C, P]) : P()
        },
        clone(C) {
            return il(C, e, n, r)
        }
    };
    return S
}

function cm(t) {
    if (Rl(t)) return t = hr(t), t.children = null, t
}

function Uw(t) {
    return Rl(t) ? t.children ? t.children[0] : void 0 : t
}

function Uo(t, e) {
    t.shapeFlag & 6 && t.component ? Uo(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e
}

function Kh(t, e = !1, n) {
    let r = [],
        i = 0;
    for (let s = 0; s < t.length; s++) {
        let o = t[s];
        const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : s);
        o.type === gt ? (o.patchFlag & 128 && i++, r = r.concat(Kh(o.children, e, a))) : (e || o.type !== Ot) && r.push(a != null ? hr(o, {
            key: a
        }) : o)
    }
    if (i > 1)
        for (let s = 0; s < r.length; s++) r[s].patchFlag = -2;
    return r
}

function ye(t, e) {
    return ke(t) ? (() => Et({
        name: t.name
    }, e, {
        setup: t
    }))() : t
}
const Ro = t => !!t.type.__asyncLoader;

function xN(t) {
    ke(t) && (t = {
        loader: t
    });
    const {
        loader: e,
        loadingComponent: n,
        errorComponent: r,
        delay: i = 200,
        timeout: s,
        suspensible: o = !0,
        onError: a
    } = t;
    let l = null,
        c, u = 0;
    const d = () => (u++, l = null, f()),
        f = () => {
            let h;
            return l || (h = l = e().catch(p => {
                if (p = p instanceof Error ? p : new Error(String(p)), a) return new Promise((b, y) => {
                    a(p, () => b(d()), () => y(p), u + 1)
                });
                throw p
            }).then(p => {
                if (h !== l && l) return l;
                if (p || re("Async component loader resolved to undefined. If you are using retry(), make sure to return its return value."), p && (p.__esModule || p[Symbol.toStringTag] === "Module") && (p = p.default), p && !ut(p) && !ke(p)) throw new Error(`Invalid async component load result: ${p}`);
                return c = p, p
            }))
        };
    return ye({
        name: "AsyncComponentWrapper",
        __asyncLoader: f,
        get __asyncResolved() {
            return c
        },
        setup() {
            const h = kt;
            if (c) return () => um(c, h);
            const p = g => {
                l = null, aa(g, h, 13, !r)
            };
            if (o && h.suspense || sl) return f().then(g => () => um(g, h)).catch(g => (p(g), () => r ? I(r, {
                error: g
            }) : null));
            const b = J(!1),
                y = J(),
                m = J(!!i);
            return i && setTimeout(() => {
                m.value = !1
            }, i), s != null && setTimeout(() => {
                if (!b.value && !y.value) {
                    const g = new Error(`Async component timed out after ${s}ms.`);
                    p(g), y.value = g
                }
            }, s), f().then(() => {
                b.value = !0, h.parent && Rl(h.parent.vnode) && Hu(h.parent.update)
            }).catch(g => {
                p(g), y.value = g
            }), () => {
                if (b.value && c) return um(c, h);
                if (y.value && r) return I(r, {
                    error: y.value
                });
                if (n && !m.value) return I(n)
            }
        }
    })
}

function um(t, e) {
    const {
        ref: n,
        props: r,
        children: i,
        ce: s
    } = e.vnode, o = I(t, r, i);
    return o.ref = n, o.ce = s, delete e.vnode.ce, o
}
const Rl = t => t.type.__isKeepAlive,
    wN = {
        name: "KeepAlive",
        __isKeepAlive: !0,
        props: {
            include: [String, RegExp, Array],
            exclude: [String, RegExp, Array],
            max: [String, Number]
        },
        setup(t, {
            slots: e
        }) {
            const n = it(),
                r = n.ctx;
            if (!r.renderer) return () => {
                const g = e.default && e.default();
                return g && g.length === 1 ? g[0] : g
            };
            const i = new Map,
                s = new Set;
            let o = null;
            n.__v_cache = i;
            const a = n.suspense,
                {
                    renderer: {
                        p: l,
                        m: c,
                        um: u,
                        o: {
                            createElement: d
                        }
                    }
                } = r,
                f = d("div");
            r.activate = (g, v, _, x, w) => {
                const S = g.component;
                c(g, v, _, 0, a), l(S.vnode, g, v, _, S, a, x, g.slotScopeIds, w), tn(() => {
                    S.isDeactivated = !1, S.a && mo(S.a);
                    const C = g.props && g.props.onVnodeMounted;
                    C && An(C, S.parent, g)
                }, a), Dv(S)
            }, r.deactivate = g => {
                const v = g.component;
                c(g, f, null, 1, a), tn(() => {
                    v.da && mo(v.da);
                    const _ = g.props && g.props.onVnodeUnmounted;
                    _ && An(_, v.parent, g), v.isDeactivated = !0
                }, a), Dv(v)
            };

            function h(g) {
                dm(g), u(g, n, a, !0)
            }

            function p(g) {
                i.forEach((v, _) => {
                    const x = iu(v.type);
                    x && (!g || !g(x)) && b(_)
                })
            }

            function b(g) {
                const v = i.get(g);
                !o || !xr(v, o) ? h(v) : o && dm(o), i.delete(g), s.delete(g)
            }
            pe(() => [t.include, t.exclude], ([g, v]) => {
                g && p(_ => vc(g, _)), v && p(_ => !vc(v, _))
            }, {
                flush: "post",
                deep: !0
            });
            let y = null;
            const m = () => {
                y != null && i.set(y, fm(n.subTree))
            };
            return St(m), la(m), er(() => {
                i.forEach(g => {
                    const {
                        subTree: v,
                        suspense: _
                    } = n, x = fm(v);
                    if (g.type === x.type && g.key === x.key) {
                        dm(x);
                        const w = x.component.da;
                        w && tn(w, _);
                        return
                    }
                    h(g)
                })
            }), () => {
                if (y = null, !e.default) return null;
                const g = e.default(),
                    v = g[0];
                if (g.length > 1) return re("KeepAlive should contain exactly one component child."), o = null, g;
                if (!si(v) || !(v.shapeFlag & 4) && !(v.shapeFlag & 128)) return o = null, v;
                let _ = fm(v);
                const x = _.type,
                    w = iu(Ro(_) ? _.type.__asyncResolved || {} : x),
                    {
                        include: S,
                        exclude: C,
                        max: A
                    } = t;
                if (S && (!w || !vc(S, w)) || C && w && vc(C, w)) return o = _, v;
                const T = _.key == null ? x : _.key,
                    E = i.get(T);
                return _.el && (_ = hr(_), v.shapeFlag & 128 && (v.ssContent = _)), y = T, E ? (_.el = E.el, _.component = E.component, _.transition && Uo(_, _.transition), _.shapeFlag |= 512, s.delete(T), s.add(T)) : (s.add(T), A && s.size > parseInt(A, 10) && b(s.values().next().value)), _.shapeFlag |= 256, o = _, pA(v.type) ? v : _
            }
        }
    },
    EN = wN;

function vc(t, e) {
    return Be(t) ? t.some(n => vc(n, e)) : It(t) ? t.split(",").includes(e) : wL(t) ? t.test(e) : !1
}

function zs(t, e) {
    xA(t, "a", e)
}

function Yi(t, e) {
    xA(t, "da", e)
}

function xA(t, e, n = kt) {
    const r = t.__wdc || (t.__wdc = () => {
        let i = n;
        for (; i;) {
            if (i.isDeactivated) return;
            i = i.parent
        }
        return t()
    });
    if (qh(e, r, n), n) {
        let i = n.parent;
        for (; i && i.parent;) Rl(i.parent.vnode) && SN(r, e, n, i), i = i.parent
    }
}

function SN(t, e, n, r) {
    const i = qh(e, t, r, !0);
    Ki(() => {
        a_(r[e], i)
    }, n)
}

function dm(t) {
    t.shapeFlag &= -257, t.shapeFlag &= -513
}

function fm(t) {
    return t.shapeFlag & 128 ? t.ssContent : t
}

function qh(t, e, n = kt, r = !1) {
    if (n) {
        const i = n[t] || (n[t] = []),
            s = e.__weh || (e.__weh = (...o) => {
                if (n.isUnmounted) return;
                ia(), Rs(n);
                const a = Wn(e, n, t, o);
                return Cs(), sa(), a
            });
        return r ? i.unshift(s) : i.push(s), s
    } else {
        const i = Si(c_[t].replace(/ hook$/, ""));
        re(`${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`)
    }
}
const Xi = t => (e, n = kt) => (!sl || t === "sp") && qh(t, (...r) => e(...r), n),
    wA = Xi("bm"),
    St = Xi("m"),
    Jh = Xi("bu"),
    la = Xi("u"),
    er = Xi("bum"),
    Ki = Xi("um"),
    EA = Xi("sp"),
    SA = Xi("rtg"),
    TA = Xi("rtc");

function CA(t, e = kt) {
    qh("ec", t, e)
}
const Jf = "components",
    TN = "directives";

function CN(t, e) {
    return b_(Jf, t, !0, e) || t
}
const PA = Symbol.for("v-ndc");

function PN(t) {
    return It(t) ? b_(Jf, t, !1) || t : t || PA
}

function AA(t) {
    return b_(TN, t)
}

function b_(t, e, n = !0, r = !1) {
    const i = Bt || kt;
    if (i) {
        const s = i.type;
        if (t === Jf) {
            const a = iu(s, !1);
            if (a && (a === e || a === Rr(e) || a === rl(Rr(e)))) return s
        }
        const o = Gw(i[t] || s[t], e) || Gw(i.appContext[t], e);
        if (!o && r) return s;
        if (n && !o) {
            const a = t === Jf ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
            re(`Failed to resolve ${t.slice(0,-1)}: ${e}${a}`)
        }
        return o
    } else re(`resolve${rl(t.slice(0,-1))} can only be used in render() or setup().`)
}

function Gw(t, e) {
    return t && (t[e] || t[Rr(e)] || t[rl(Rr(e))])
}

function AN(t, e, n, r) {
    let i;
    const s = n && n[r];
    if (Be(t) || It(t)) {
        i = new Array(t.length);
        for (let o = 0, a = t.length; o < a; o++) i[o] = e(t[o], o, void 0, s && s[o])
    } else if (typeof t == "number") {
        Number.isInteger(t) || re(`The v-for range expect an integer value but got ${t}.`), i = new Array(t);
        for (let o = 0; o < t; o++) i[o] = e(o + 1, o, void 0, s && s[o])
    } else if (ut(t))
        if (t[Symbol.iterator]) i = Array.from(t, (o, a) => e(o, a, void 0, s && s[a]));
        else {
            const o = Object.keys(t);
            i = new Array(o.length);
            for (let a = 0, l = o.length; a < l; a++) {
                const c = o[a];
                i[a] = e(t[c], c, a, s && s[a])
            }
        }
    else i = [];
    return n && (n[r] = i), i
}

function ON(t, e) {
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        if (Be(r))
            for (let i = 0; i < r.length; i++) t[r[i].name] = r[i].fn;
        else r && (t[r.name] = r.key ? (...i) => {
            const s = r.fn(...i);
            return s && (s.key = r.key), s
        } : r.fn)
    }
    return t
}

function IN(t, e, n = {}, r, i) {
    if (Bt.isCE || Bt.parent && Ro(Bt.parent) && Bt.parent.isCE) return e !== "default" && (n.name = e), I("slot", n, r && r());
    let s = t[e];
    s && s.length > 1 && (re("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."), s = () => []), s && s._c && (s._d = !1), Zh();
    const o = s && OA(s(n)),
        a = T_(gt, {
            key: n.key || o && o.key || `_${e}`
        }, o || (r ? r() : []), o && t._ === 1 ? 64 : -2);
    return !i && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), s && s._c && (s._d = !0), a
}

function OA(t) {
    return t.some(e => si(e) ? !(e.type === Ot || e.type === gt && !OA(e.children)) : !0) ? t : null
}

function RN(t, e) {
    const n = {};
    if (!ut(t)) return re("v-on with no argument expects an object value."), n;
    for (const r in t) n[e && /[A-Z]/.test(r) ? `on:${r}` : Si(r)] = t[r];
    return n
}
const Fv = t => t ? qA(t) ? tp(t) || t.proxy : Fv(t.parent) : null,
    Mo = Et(Object.create(null), {
        $: t => t,
        $el: t => t.vnode.el,
        $data: t => t.data,
        $props: t => Ua(t.props),
        $attrs: t => Ua(t.attrs),
        $slots: t => Ua(t.slots),
        $refs: t => Ua(t.refs),
        $parent: t => Fv(t.parent),
        $root: t => Fv(t.root),
        $emit: t => t.emit,
        $options: t => w_(t),
        $forceUpdate: t => t.f || (t.f = () => Hu(t.update)),
        $nextTick: t => t.n || (t.n = Ue.bind(t.proxy)),
        $watch: t => _N.bind(t)
    }),
    x_ = t => t === "_" || t === "$",
    hm = (t, e) => t !== st && !t.__isScriptSetup && qe(t, e),
    Ac = {
        get({
            _: t
        }, e) {
            const {
                ctx: n,
                setupState: r,
                data: i,
                props: s,
                accessCache: o,
                type: a,
                appContext: l
            } = t;
            if (e === "__isVue") return !0;
            let c;
            if (e[0] !== "$") {
                const h = o[e];
                if (h !== void 0) switch (h) {
                    case 1:
                        return r[e];
                    case 2:
                        return i[e];
                    case 4:
                        return n[e];
                    case 3:
                        return s[e]
                } else {
                    if (hm(r, e)) return o[e] = 1, r[e];
                    if (i !== st && qe(i, e)) return o[e] = 2, i[e];
                    if ((c = t.propsOptions[0]) && qe(c, e)) return o[e] = 3, s[e];
                    if (n !== st && qe(n, e)) return o[e] = 4, n[e];
                    Lv && (o[e] = 0)
                }
            }
            const u = Mo[e];
            let d, f;
            if (u) return e === "$attrs" ? (pn(t, "get", e), qf()) : e === "$slots" && pn(t, "get", e), u(t);
            if ((d = a.__cssModules) && (d = d[e])) return d;
            if (n !== st && qe(n, e)) return o[e] = 4, n[e];
            if (f = l.config.globalProperties, qe(f, e)) return f[e];
            Bt && (!It(e) || e.indexOf("__v") !== 0) && (i !== st && x_(e[0]) && qe(i, e) ? re(`Property ${JSON.stringify(e)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`) : t === Bt && re(`Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`))
        },
        set({
            _: t
        }, e, n) {
            const {
                data: r,
                setupState: i,
                ctx: s
            } = t;
            return hm(i, e) ? (i[e] = n, !0) : i.__isScriptSetup && qe(i, e) ? (re(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : r !== st && qe(r, e) ? (r[e] = n, !0) : qe(t.props, e) ? (re(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in t ? (re(`Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`), !1) : (e in t.appContext.config.globalProperties ? Object.defineProperty(s, e, {
                enumerable: !0,
                configurable: !0,
                value: n
            }) : s[e] = n, !0)
        },
        has({
            _: {
                data: t,
                setupState: e,
                accessCache: n,
                ctx: r,
                appContext: i,
                propsOptions: s
            }
        }, o) {
            let a;
            return !!n[o] || t !== st && qe(t, o) || hm(e, o) || (a = s[0]) && qe(a, o) || qe(r, o) || qe(Mo, o) || qe(i.config.globalProperties, o)
        },
        defineProperty(t, e, n) {
            return n.get != null ? t._.accessCache[e] = 0 : qe(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n)
        }
    };
Ac.ownKeys = t => (re("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."), Reflect.ownKeys(t));
const MN = Et({}, Ac, {
    get(t, e) {
        if (e !== Symbol.unscopables) return Ac.get(t, e, t)
    },
    has(t, e) {
        const n = e[0] !== "_" && !IL(e);
        return !n && Ac.has(t, e) && re(`Property ${JSON.stringify(e)} should not start with _ which is a reserved prefix for Vue internals.`), n
    }
});

function kN(t) {
    const e = {};
    return Object.defineProperty(e, "_", {
        configurable: !0,
        enumerable: !1,
        get: () => t
    }), Object.keys(Mo).forEach(n => {
        Object.defineProperty(e, n, {
            configurable: !0,
            enumerable: !1,
            get: () => Mo[n](t),
            set: kn
        })
    }), e
}

function BN(t) {
    const {
        ctx: e,
        propsOptions: [n]
    } = t;
    n && Object.keys(n).forEach(r => {
        Object.defineProperty(e, r, {
            enumerable: !0,
            configurable: !0,
            get: () => t.props[r],
            set: kn
        })
    })
}

function DN(t) {
    const {
        ctx: e,
        setupState: n
    } = t;
    Object.keys(Oe(n)).forEach(r => {
        if (!n.__isScriptSetup) {
            if (x_(r[0])) {
                re(`setup() return property ${JSON.stringify(r)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
                return
            }
            Object.defineProperty(e, r, {
                enumerable: !0,
                configurable: !0,
                get: () => n[r],
                set: kn
            })
        }
    })
}
const ca = t => re(`${t}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);

function $N() {
    return ca("defineProps"), null
}

function FN() {
    return ca("defineEmits"), null
}

function LN(t) {
    ca("defineExpose")
}

function NN(t) {
    ca("defineOptions")
}

function UN() {
    return ca("defineSlots"), null
}

function GN() {
    ca("defineModel")
}

function HN(t, e) {
    return ca("withDefaults"), null
}

function zN() {
    return IA().slots
}

function jN() {
    return IA().attrs
}

function VN(t, e, n) {
    const r = it();
    if (!r) return re("useModel() called without active instance."), J();
    if (!r.propsOptions[0][e]) return re(`useModel() called with prop "${e}" which is not declared.`), J();
    if (n && n.local) {
        const i = J(t[e]);
        return pe(() => t[e], s => i.value = s), pe(i, s => {
            s !== t[e] && r.emit(`update:${e}`, s)
        }), i
    } else return {
        __v_isRef: !0,
        get value() {
            return t[e]
        },
        set value(i) {
            r.emit(`update:${e}`, i)
        }
    }
}

function IA() {
    const t = it();
    return t || re("useContext() called without active instance."), t.setupContext || (t.setupContext = QA(t))
}

function nu(t) {
    return Be(t) ? t.reduce((e, n) => (e[n] = null, e), {}) : t
}

function WN(t, e) {
    const n = nu(t);
    for (const r in e) {
        if (r.startsWith("__skip")) continue;
        let i = n[r];
        i ? Be(i) || ke(i) ? i = n[r] = {
            type: i,
            default: e[r]
        } : i.default = e[r] : i === null ? i = n[r] = {
            default: e[r]
        } : re(`props default key "${r}" has no corresponding declaration.`), i && e[`__skip_${r}`] && (i.skipFactory = !0)
    }
    return n
}

function YN(t, e) {
    return !t || !e ? t || e : Be(t) && Be(e) ? t.concat(e) : Et({}, nu(t), nu(e))
}

function XN(t, e) {
    const n = {};
    for (const r in t) e.includes(r) || Object.defineProperty(n, r, {
        enumerable: !0,
        get: () => t[r]
    });
    return n
}

function KN(t) {
    const e = it();
    e || re("withAsyncContext called without active current instance. This is likely a bug.");
    let n = t();
    return Cs(), jh(n) && (n = n.catch(r => {
        throw Rs(e), r
    })), [n, () => Rs(e)]
}

function qN() {
    const t = Object.create(null);
    return (e, n) => {
        t[n] ? re(`${e} property "${n}" is already defined in ${t[n]}.`) : t[n] = e
    }
}
let Lv = !0;

function JN(t) {
    const e = w_(t),
        n = t.proxy,
        r = t.ctx;
    Lv = !1, e.beforeCreate && Hw(e.beforeCreate, t, "bc");
    const {
        data: i,
        computed: s,
        methods: o,
        watch: a,
        provide: l,
        inject: c,
        created: u,
        beforeMount: d,
        mounted: f,
        beforeUpdate: h,
        updated: p,
        activated: b,
        deactivated: y,
        beforeDestroy: m,
        beforeUnmount: g,
        destroyed: v,
        unmounted: _,
        render: x,
        renderTracked: w,
        renderTriggered: S,
        errorCaptured: C,
        serverPrefetch: A,
        expose: T,
        inheritAttrs: E,
        components: P,
        directives: B,
        filters: F
    } = e, H = qN(); {
        const [N] = t.propsOptions;
        if (N)
            for (const V in N) H("Props", V)
    }
    if (c && ZN(c, r, H), o)
        for (const N in o) {
            const V = o[N];
            ke(V) ? (Object.defineProperty(r, N, {
                value: V.bind(n),
                configurable: !0,
                enumerable: !0,
                writable: !0
            }), H("Methods", N)) : re(`Method "${N}" has type "${typeof V}" in the component definition. Did you reference the function correctly?`)
        }
    if (i) {
        ke(i) || re("The data option must be a function. Plain object usage is no longer supported.");
        const N = i.call(n, n);
        if (jh(N) && re("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."), !ut(N)) re("data() should return an object.");
        else {
            t.data = ht(N);
            for (const V in N) H("Data", V), x_(V[0]) || Object.defineProperty(r, V, {
                configurable: !0,
                enumerable: !0,
                get: () => N[V],
                set: kn
            })
        }
    }
    if (Lv = !0, s)
        for (const N in s) {
            const V = s[N],
                Y = ke(V) ? V.bind(n, n) : ke(V.get) ? V.get.bind(n, n) : kn;
            Y === kn && re(`Computed property "${N}" has no getter.`);
            const le = !ke(V) && ke(V.set) ? V.set.bind(n) : () => {
                    re(`Write operation failed: computed property "${N}" is readonly.`)
                },
                ae = ne({
                    get: Y,
                    set: le
                });
            Object.defineProperty(r, N, {
                enumerable: !0,
                configurable: !0,
                get: () => ae.value,
                set: W => ae.value = W
            }), H("Computed", N)
        }
    if (a)
        for (const N in a) RA(a[N], r, n, N);
    if (l) {
        const N = ke(l) ? l.call(n) : l;
        Reflect.ownKeys(N).forEach(V => {
            Pr(V, N[V])
        })
    }
    u && Hw(u, t, "c");

    function k(N, V) {
        Be(V) ? V.forEach(Y => N(Y.bind(n))) : V && N(V.bind(n))
    }
    if (k(wA, d), k(St, f), k(Jh, h), k(la, p), k(zs, b), k(Yi, y), k(CA, C), k(TA, w), k(SA, S), k(er, g), k(Ki, _), k(EA, A), Be(T))
        if (T.length) {
            const N = t.exposed || (t.exposed = {});
            T.forEach(V => {
                Object.defineProperty(N, V, {
                    get: () => n[V],
                    set: Y => n[V] = Y
                })
            })
        } else t.exposed || (t.exposed = {});
    x && t.render === kn && (t.render = x), E != null && (t.inheritAttrs = E), P && (t.components = P), B && (t.directives = B)
}

function ZN(t, e, n = kn) {
    Be(t) && (t = Nv(t));
    for (const r in t) {
        const i = t[r];
        let s;
        ut(i) ? "default" in i ? s = Nt(i.from || r, i.default, !0) : s = Nt(i.from || r) : s = Nt(i), tt(s) ? Object.defineProperty(e, r, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: o => s.value = o
        }) : e[r] = s, n("Inject", r)
    }
}

function Hw(t, e, n) {
    Wn(Be(t) ? t.map(r => r.bind(e.proxy)) : t.bind(e.proxy), e, n)
}

function RA(t, e, n, r) {
    const i = r.includes(".") ? vA(n, r) : () => n[r];
    if (It(t)) {
        const s = e[t];
        ke(s) ? pe(i, s) : re(`Invalid watch handler specified by key "${t}"`, s)
    } else if (ke(t)) pe(i, t.bind(n));
    else if (ut(t))
        if (Be(t)) t.forEach(s => RA(s, e, n, r));
        else {
            const s = ke(t.handler) ? t.handler.bind(n) : e[t.handler];
            ke(s) ? pe(i, s, t) : re(`Invalid watch handler specified by key "${t.handler}"`, s)
        }
    else re(`Invalid watch option: "${r}"`, t)
}

function w_(t) {
    const e = t.type,
        {
            mixins: n,
            extends: r
        } = e,
        {
            mixins: i,
            optionsCache: s,
            config: {
                optionMergeStrategies: o
            }
        } = t.appContext,
        a = s.get(e);
    let l;
    return a ? l = a : !i.length && !n && !r ? l = e : (l = {}, i.length && i.forEach(c => Zf(l, c, o, !0)), Zf(l, e, o)), ut(e) && s.set(e, l), l
}

function Zf(t, e, n, r = !1) {
    const {
        mixins: i,
        extends: s
    } = e;
    s && Zf(t, s, n, !0), i && i.forEach(o => Zf(t, o, n, !0));
    for (const o in e)
        if (r && o === "expose") re('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');
        else {
            const a = QN[o] || n && n[o];
            t[o] = a ? a(t[o], e[o]) : e[o]
        }
    return t
}
const QN = {
    data: zw,
    props: jw,
    emits: jw,
    methods: yc,
    computed: yc,
    beforeCreate: gn,
    created: gn,
    beforeMount: gn,
    mounted: gn,
    beforeUpdate: gn,
    updated: gn,
    beforeDestroy: gn,
    beforeUnmount: gn,
    destroyed: gn,
    unmounted: gn,
    activated: gn,
    deactivated: gn,
    errorCaptured: gn,
    serverPrefetch: gn,
    components: yc,
    directives: yc,
    watch: t4,
    provide: zw,
    inject: e4
};

function zw(t, e) {
    return e ? t ? function() {
        return Et(ke(t) ? t.call(this, this) : t, ke(e) ? e.call(this, this) : e)
    } : e : t
}

function e4(t, e) {
    return yc(Nv(t), Nv(e))
}

function Nv(t) {
    if (Be(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) e[t[n]] = t[n];
        return e
    }
    return t
}

function gn(t, e) {
    return t ? [...new Set([].concat(t, e))] : e
}

function yc(t, e) {
    return t ? Et(Object.create(null), t, e) : e
}

function jw(t, e) {
    return t ? Be(t) && Be(e) ? [...new Set([...t, ...e])] : Et(Object.create(null), nu(t), nu(e ? ? {})) : e
}

function t4(t, e) {
    if (!t) return e;
    if (!e) return t;
    const n = Et(Object.create(null), t);
    for (const r in e) n[r] = gn(t[r], e[r]);
    return n
}

function MA() {
    return {
        app: null,
        config: {
            isNativeTag: eA,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let n4 = 0;

function r4(t, e) {
    return function(r, i = null) {
        ke(r) || (r = Et({}, r)), i != null && !ut(i) && (re("root props passed to app.mount() must be an object."), i = null);
        const s = MA();
        Object.defineProperty(s.config, "unwrapInjectedRef", {
            get() {
                return !0
            },
            set() {
                re("app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API.")
            }
        });
        const o = new Set;
        let a = !1;
        const l = s.app = {
            _uid: n4++,
            _component: r,
            _props: i,
            _container: null,
            _context: s,
            _instance: null,
            version: Xv,
            get config() {
                return s.config
            },
            set config(c) {
                re("app.config cannot be replaced. Modify individual options instead.")
            },
            use(c, ...u) {
                return o.has(c) ? re("Plugin has already been applied to target app.") : c && ke(c.install) ? (o.add(c), c.install(l, ...u)) : ke(c) ? (o.add(c), c(l, ...u)) : re('A plugin must either be a function or an object with an "install" function.'), l
            },
            mixin(c) {
                return s.mixins.includes(c) ? re("Mixin has already been applied to target app" + (c.name ? `: ${c.name}` : "")) : s.mixins.push(c), l
            },
            component(c, u) {
                return Vv(c, s.config), u ? (s.components[c] && re(`Component "${c}" has already been registered in target app.`), s.components[c] = u, l) : s.components[c]
            },
            directive(c, u) {
                return yA(c), u ? (s.directives[c] && re(`Directive "${c}" has already been registered in target app.`), s.directives[c] = u, l) : s.directives[c]
            },
            mount(c, u, d) {
                if (a) re("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");
                else {
                    c.__vue_app__ && re("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");
                    const f = I(r, i);
                    return f.appContext = s, s.reload = () => {
                        t(hr(f), c, d)
                    }, u && e ? e(f, c) : t(f, c, d), a = !0, l._container = c, c.__vue_app__ = l, l._instance = f.component, qL(l, Xv), tp(f.component) || f.component.proxy
                }
            },
            unmount() {
                a ? (t(null, l._container), l._instance = null, JL(l), delete l._container.__vue_app__) : re("Cannot unmount an app that is not mounted.")
            },
            provide(c, u) {
                return c in s.provides && re(`App already provides property with key "${String(c)}". It will be overwritten with the new value.`), s.provides[c] = u, l
            },
            runWithContext(c) {
                ru = l;
                try {
                    return c()
                } finally {
                    ru = null
                }
            }
        };
        return l
    }
}
let ru = null;

function Pr(t, e) {
    if (!kt) re("provide() can only be used inside setup().");
    else {
        let n = kt.provides;
        const r = kt.parent && kt.parent.provides;
        r === n && (n = kt.provides = Object.create(r)), n[t] = e
    }
}

function Nt(t, e, n = !1) {
    const r = kt || Bt;
    if (r || ru) {
        const i = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : ru._context.provides;
        if (i && t in i) return i[t];
        if (arguments.length > 1) return n && ke(e) ? e.call(r && r.proxy) : e;
        re(`injection "${String(t)}" not found.`)
    } else re("inject() can only be used inside setup() or functional components.")
}

function kA() {
    return !!(kt || Bt || ru)
}

function i4(t, e, n, r = !1) {
    const i = {},
        s = {};
    Mv(s, Qh, 1), t.propsDefaults = Object.create(null), BA(t, e, i, s);
    for (const o in t.propsOptions[0]) o in i || (i[o] = void 0);
    $A(e || {}, i, t), n ? t.props = r ? i : qP(i) : t.type.props ? t.props = i : t.props = s, t.attrs = s
}

function s4(t) {
    for (; t;) {
        if (t.type.__hmrId) return !0;
        t = t.parent
    }
}

function o4(t, e, n, r) {
    const {
        props: i,
        attrs: s,
        vnode: {
            patchFlag: o
        }
    } = t, a = Oe(i), [l] = t.propsOptions;
    let c = !1;
    if (!s4(t) && (r || o > 0) && !(o & 16)) {
        if (o & 8) {
            const u = t.vnode.dynamicProps;
            for (let d = 0; d < u.length; d++) {
                let f = u[d];
                if (Yh(t.emitsOptions, f)) continue;
                const h = e[f];
                if (l)
                    if (qe(s, f)) h !== s[f] && (s[f] = h, c = !0);
                    else {
                        const p = Rr(f);
                        i[p] = Uv(l, a, p, h, t, !1)
                    }
                else h !== s[f] && (s[f] = h, c = !0)
            }
        }
    } else {
        BA(t, e, i, s) && (c = !0);
        let u;
        for (const d in a)(!e || !qe(e, d) && ((u = nl(d)) === d || !qe(e, u))) && (l ? n && (n[d] !== void 0 || n[u] !== void 0) && (i[d] = Uv(l, a, d, void 0, t, !0)) : delete i[d]);
        if (s !== a)
            for (const d in s)(!e || !qe(e, d)) && (delete s[d], c = !0)
    }
    c && ri(t, "set", "$attrs"), $A(e || {}, i, t)
}

function BA(t, e, n, r) {
    const [i, s] = t.propsOptions;
    let o = !1,
        a;
    if (e)
        for (let l in e) {
            if (Sc(l)) continue;
            const c = e[l];
            let u;
            i && qe(i, u = Rr(l)) ? !s || !s.includes(u) ? n[u] = c : (a || (a = {}))[u] = c : Yh(t.emitsOptions, l) || (!(l in r) || c !== r[l]) && (r[l] = c, o = !0)
        }
    if (s) {
        const l = Oe(n),
            c = a || st;
        for (let u = 0; u < s.length; u++) {
            const d = s[u];
            n[d] = Uv(i, l, d, c[d], t, !qe(c, d))
        }
    }
    return o
}

function Uv(t, e, n, r, i, s) {
    const o = t[n];
    if (o != null) {
        const a = qe(o, "default");
        if (a && r === void 0) {
            const l = o.default;
            if (o.type !== Function && !o.skipFactory && ke(l)) {
                const {
                    propsDefaults: c
                } = i;
                n in c ? r = c[n] : (Rs(i), r = c[n] = l.call(null, e), Cs())
            } else r = l
        }
        o[0] && (s && !a ? r = !1 : o[1] && (r === "" || r === nl(n)) && (r = !0))
    }
    return r
}

function DA(t, e, n = !1) {
    const r = e.propsCache,
        i = r.get(t);
    if (i) return i;
    const s = t.props,
        o = {},
        a = [];
    let l = !1;
    if (!ke(t)) {
        const u = d => {
            l = !0;
            const [f, h] = DA(d, e, !0);
            Et(o, f), h && a.push(...h)
        };
        !n && e.mixins.length && e.mixins.forEach(u), t.extends && u(t.extends), t.mixins && t.mixins.forEach(u)
    }
    if (!s && !l) return ut(t) && r.set(t, Wa), Wa;
    if (Be(s))
        for (let u = 0; u < s.length; u++) {
            It(s[u]) || re("props must be strings when using array syntax.", s[u]);
            const d = Rr(s[u]);
            Vw(d) && (o[d] = st)
        } else if (s) {
            ut(s) || re("invalid props options", s);
            for (const u in s) {
                const d = Rr(u);
                if (Vw(d)) {
                    const f = s[u],
                        h = o[d] = Be(f) || ke(f) ? {
                            type: f
                        } : Et({}, f);
                    if (h) {
                        const p = Yw(Boolean, h.type),
                            b = Yw(String, h.type);
                        h[0] = p > -1, h[1] = b < 0 || p < b, (p > -1 || qe(h, "default")) && a.push(d)
                    }
                }
            }
        }
    const c = [o, a];
    return ut(t) && r.set(t, c), c
}

function Vw(t) {
    return t[0] !== "$" ? !0 : (re(`Invalid prop name: "${t}" is a reserved property.`), !1)
}

function Gv(t) {
    const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
    return e ? e[2] : t === null ? "null" : ""
}

function Ww(t, e) {
    return Gv(t) === Gv(e)
}

function Yw(t, e) {
    return Be(e) ? e.findIndex(n => Ww(n, t)) : ke(e) && Ww(e, t) ? 0 : -1
}

function $A(t, e, n) {
    const r = Oe(e),
        i = n.propsOptions[0];
    for (const s in i) {
        let o = i[s];
        o != null && a4(s, r[s], o, !qe(t, s) && !qe(t, nl(s)))
    }
}

function a4(t, e, n, r) {
    const {
        type: i,
        required: s,
        validator: o,
        skipCheck: a
    } = n;
    if (s && r) {
        re('Missing required prop: "' + t + '"');
        return
    }
    if (!(e == null && !s)) {
        if (i != null && i !== !0 && !a) {
            let l = !1;
            const c = Be(i) ? i : [i],
                u = [];
            for (let d = 0; d < c.length && !l; d++) {
                const {
                    valid: f,
                    expectedType: h
                } = c4(e, c[d]);
                u.push(h || ""), l = f
            }
            if (!l) {
                re(u4(t, e, u));
                return
            }
        }
        o && !o(e) && re('Invalid prop: custom validator check failed for prop "' + t + '".')
    }
}
const l4 = Fu("String,Number,Boolean,Function,Symbol,BigInt");

function c4(t, e) {
    let n;
    const r = Gv(e);
    if (l4(r)) {
        const i = typeof t;
        n = i === r.toLowerCase(), !n && i === "object" && (n = t instanceof e)
    } else r === "Object" ? n = ut(t) : r === "Array" ? n = Be(t) : r === "null" ? n = t === null : n = t instanceof e;
    return {
        valid: n,
        expectedType: r
    }
}

function u4(t, e, n) {
    let r = `Invalid prop: type check failed for prop "${t}". Expected ${n.map(rl).join(" | ")}`;
    const i = n[0],
        s = EL(e),
        o = Xw(e, i),
        a = Xw(e, s);
    return n.length === 1 && Kw(i) && !d4(i, s) && (r += ` with value ${o}`), r += `, got ${s} `, Kw(s) && (r += `with value ${a}.`), r
}

function Xw(t, e) {
    return e === "String" ? `"${t}"` : e === "Number" ? `${Number(t)}` : `${t}`
}

function Kw(t) {
    return ["string", "number", "boolean"].some(n => t.toLowerCase() === n)
}

function d4(...t) {
    return t.some(e => e.toLowerCase() === "boolean")
}
const FA = t => t[0] === "_" || t === "$stable",
    E_ = t => Be(t) ? t.map(Rn) : [Rn(t)],
    f4 = (t, e, n) => {
        if (e._n) return e;
        const r = p_((...i) => (kt && re(`Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`), E_(e(...i))), n);
        return r._c = !1, r
    },
    LA = (t, e, n) => {
        const r = t._ctx;
        for (const i in t) {
            if (FA(i)) continue;
            const s = t[i];
            if (ke(s)) e[i] = f4(i, s, r);
            else if (s != null) {
                re(`Non-function value encountered for slot "${i}". Prefer function slots for better performance.`);
                const o = E_(s);
                e[i] = () => o
            }
        }
    },
    NA = (t, e) => {
        Rl(t.vnode) || re("Non-function value encountered for default slot. Prefer function slots for better performance.");
        const n = E_(e);
        t.slots.default = () => n
    },
    h4 = (t, e) => {
        if (t.vnode.shapeFlag & 32) {
            const n = e._;
            n ? (t.slots = Oe(e), Mv(e, "_", n)) : LA(e, t.slots = {})
        } else t.slots = {}, e && NA(t, e);
        Mv(t.slots, Qh, 1)
    },
    p4 = (t, e, n) => {
        const {
            vnode: r,
            slots: i
        } = t;
        let s = !0,
            o = st;
        if (r.shapeFlag & 32) {
            const a = e._;
            a ? Ss ? (Et(i, e), ri(t, "set", "$slots")) : n && a === 1 ? s = !1 : (Et(i, e), !n && a === 1 && delete i._) : (s = !e.$stable, LA(e, i)), o = e
        } else e && (NA(t, e), o = {
            default: 1
        });
        if (s)
            for (const a in i) !FA(a) && !(a in o) && delete i[a]
    };

function Qf(t, e, n, r, i = !1) {
    if (Be(t)) {
        t.forEach((f, h) => Qf(f, e && (Be(e) ? e[h] : e), n, r, i));
        return
    }
    if (Ro(r) && !i) return;
    const s = r.shapeFlag & 4 ? tp(r.component) || r.component.proxy : r.el,
        o = i ? null : s,
        {
            i: a,
            r: l
        } = t;
    if (!a) {
        re("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");
        return
    }
    const c = e && e.r,
        u = a.refs === st ? a.refs = {} : a.refs,
        d = a.setupState;
    if (c != null && c !== l && (It(c) ? (u[c] = null, qe(d, c) && (d[c] = null)) : tt(c) && (c.value = null)), ke(l)) ei(l, a, 12, [o, u]);
    else {
        const f = It(l),
            h = tt(l);
        if (f || h) {
            const p = () => {
                if (t.f) {
                    const b = f ? qe(d, l) ? d[l] : u[l] : l.value;
                    i ? Be(b) && a_(b, s) : Be(b) ? b.includes(s) || b.push(s) : f ? (u[l] = [s], qe(d, l) && (d[l] = u[l])) : (l.value = [s], t.k && (u[t.k] = l.value))
                } else f ? (u[l] = o, qe(d, l) && (d[l] = o)) : h ? (l.value = o, t.k && (u[t.k] = o)) : re("Invalid template ref type:", l, `(${typeof l})`)
            };
            o ? (p.id = -1, tn(p, n)) : p()
        } else re("Invalid template ref type:", l, `(${typeof l})`)
    }
}
let Qi = !1;
const Ed = t => /svg/.test(t.namespaceURI) && t.tagName !== "foreignObject",
    Wl = t => t.nodeType === 8;

function m4(t) {
    const {
        mt: e,
        p: n,
        o: {
            patchProp: r,
            createText: i,
            nextSibling: s,
            parentNode: o,
            remove: a,
            insert: l,
            createComment: c
        }
    } = t, u = (m, g) => {
        if (!g.hasChildNodes()) {
            re("Attempting to hydrate existing markup but container is empty. Performing full mount instead."), n(null, m, g), Kf(), g._vnode = m;
            return
        }
        Qi = !1, d(g.firstChild, m, null, null, null), Kf(), g._vnode = m, Qi && console.error("Hydration completed but contains mismatches.")
    }, d = (m, g, v, _, x, w = !1) => {
        const S = Wl(m) && m.data === "[",
            C = () => b(m, g, v, _, x, S),
            {
                type: A,
                ref: T,
                shapeFlag: E,
                patchFlag: P
            } = g;
        let B = m.nodeType;
        g.el = m, P === -2 && (w = !1, g.dynamicChildren = null);
        let F = null;
        switch (A) {
            case ii:
                B !== 3 ? g.children === "" ? (l(g.el = i(""), o(m), m), F = m) : F = C() : (m.data !== g.children && (Qi = !0, re(`Hydration text mismatch:
- Client: ${JSON.stringify(m.data)}
- Server: ${JSON.stringify(g.children)}`), m.data = g.children), F = s(m));
                break;
            case Ot:
                B !== 8 || S ? F = C() : F = s(m);
                break;
            case Ts:
                if (S && (m = s(m), B = m.nodeType), B === 1 || B === 3) {
                    F = m;
                    const H = !g.children.length;
                    for (let k = 0; k < g.staticCount; k++) H && (g.children += F.nodeType === 1 ? F.outerHTML : F.data), k === g.staticCount - 1 && (g.anchor = F), F = s(F);
                    return S ? s(F) : F
                } else C();
                break;
            case gt:
                S ? F = p(m, g, v, _, x, w) : F = C();
                break;
            default:
                if (E & 1) B !== 1 || g.type.toLowerCase() !== m.tagName.toLowerCase() ? F = C() : F = f(m, g, v, _, x, w);
                else if (E & 6) {
                    g.slotScopeIds = x;
                    const H = o(m);
                    if (e(g, H, null, v, _, Ed(H), w), F = S ? y(m) : s(m), F && Wl(F) && F.data === "teleport end" && (F = s(F)), Ro(g)) {
                        let k;
                        S ? (k = I(gt), k.anchor = F ? F.previousSibling : H.lastChild) : k = m.nodeType === 3 ? ep("") : I("div"), k.el = m, g.component.subTree = k
                    }
                } else E & 64 ? B !== 8 ? F = C() : F = g.type.hydrate(m, g, v, _, x, w, t, h) : E & 128 ? F = g.type.hydrate(m, g, v, _, Ed(o(m)), x, w, t, d) : re("Invalid HostVNode type:", A, `(${typeof A})`)
        }
        return T != null && Qf(T, null, _, g), F
    }, f = (m, g, v, _, x, w) => {
        w = w || !!g.dynamicChildren;
        const {
            type: S,
            props: C,
            patchFlag: A,
            shapeFlag: T,
            dirs: E
        } = g, P = S === "input" && E || S === "option"; {
            if (E && Wr(g, null, v, "created"), C)
                if (P || !w || A & 48)
                    for (const F in C)(P && F.endsWith("value") || Lu(F) && !Sc(F)) && r(m, F, null, C[F], !1, void 0, v);
                else C.onClick && r(m, "onClick", null, C.onClick, !1, void 0, v);
            let B;
            if ((B = C && C.onVnodeBeforeMount) && An(B, v, g), E && Wr(g, null, v, "beforeMount"), ((B = C && C.onVnodeMounted) || E) && mA(() => {
                    B && An(B, v, g), E && Wr(g, null, v, "mounted")
                }, _), T & 16 && !(C && (C.innerHTML || C.textContent))) {
                let F = h(m.firstChild, g, m, v, _, x, w),
                    H = !1;
                for (; F;) {
                    Qi = !0, H || (re(`Hydration children mismatch in <${g.type}>: server rendered element contains more child nodes than client vdom.`), H = !0);
                    const k = F;
                    F = F.nextSibling, a(k)
                }
            } else T & 8 && m.textContent !== g.children && (Qi = !0, re(`Hydration text content mismatch in <${g.type}>:
- Client: ${m.textContent}
- Server: ${g.children}`), m.textContent = g.children)
        }
        return m.nextSibling
    }, h = (m, g, v, _, x, w, S) => {
        S = S || !!g.dynamicChildren;
        const C = g.children,
            A = C.length;
        let T = !1;
        for (let E = 0; E < A; E++) {
            const P = S ? C[E] : C[E] = Rn(C[E]);
            if (m) m = d(m, P, _, x, w, S);
            else {
                if (P.type === ii && !P.children) continue;
                Qi = !0, T || (re(`Hydration children mismatch in <${v.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`), T = !0), n(null, P, v, null, _, x, Ed(v), w)
            }
        }
        return m
    }, p = (m, g, v, _, x, w) => {
        const {
            slotScopeIds: S
        } = g;
        S && (x = x ? x.concat(S) : S);
        const C = o(m),
            A = h(s(m), g, C, v, _, x, w);
        return A && Wl(A) && A.data === "]" ? s(g.anchor = A) : (Qi = !0, l(g.anchor = c("]"), C, A), A)
    }, b = (m, g, v, _, x, w) => {
        if (Qi = !0, re(`Hydration node mismatch:
- Client vnode:`, g.type, `
- Server rendered DOM:`, m, m.nodeType === 3 ? "(text)" : Wl(m) && m.data === "[" ? "(start of fragment)" : ""), g.el = null, w) {
            const A = y(m);
            for (;;) {
                const T = s(m);
                if (T && T !== A) a(T);
                else break
            }
        }
        const S = s(m),
            C = o(m);
        return a(m), n(null, g, C, S, v, _, Ed(C), x), S
    }, y = m => {
        let g = 0;
        for (; m;)
            if (m = s(m), m && Wl(m) && (m.data === "[" && g++, m.data === "]")) {
                if (g === 0) return s(m);
                g--
            }
        return m
    };
    return [u, d]
}
let Yl, us;

function yi(t, e) {
    t.appContext.config.performance && eh() && us.mark(`vue-${e}-${t.uid}`), eN(t, e, eh() ? us.now() : Date.now())
}

function _i(t, e) {
    if (t.appContext.config.performance && eh()) {
        const n = `vue-${e}-${t.uid}`,
            r = n + ":end";
        us.mark(r), us.measure(`<${np(t,t.type)}> ${e}`, n, r), us.clearMarks(n), us.clearMarks(r)
    }
    tN(t, e, eh() ? us.now() : Date.now())
}

function eh() {
    return Yl !== void 0 || (typeof window < "u" && window.performance ? (Yl = !0, us = window.performance) : Yl = !1), Yl
}

function g4() {
    const t = [];
    if (t.length) {
        const e = t.length > 1;
        console.warn(`Feature flag${e?"s":""} ${t.join(", ")} ${e?"are":"is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`)
    }
}
const tn = mA;

function UA(t) {
    return HA(t)
}

function GA(t) {
    return HA(t, m4)
}

function HA(t, e) {
    g4();
    const n = Xf();
    n.__VUE__ = !0, f_(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
    const {
        insert: r,
        remove: i,
        patchProp: s,
        createElement: o,
        createText: a,
        createComment: l,
        setText: c,
        setElementText: u,
        parentNode: d,
        nextSibling: f,
        setScopeId: h = kn,
        insertStaticContent: p
    } = t, b = (O, L, j, ie = null, oe = null, R = null, M = !1, U = null, q = Ss ? !1 : !!L.dynamicChildren) => {
        if (O === L) return;
        O && !xr(O, L) && (ie = Z(O), Q(O, oe, R, !0), O = null), L.patchFlag === -2 && (q = !1, L.dynamicChildren = null);
        const {
            type: se,
            ref: he,
            shapeFlag: ue
        } = L;
        switch (se) {
            case ii:
                y(O, L, j, ie);
                break;
            case Ot:
                m(O, L, j, ie);
                break;
            case Ts:
                O == null ? g(L, j, ie, M) : v(O, L, j, M);
                break;
            case gt:
                B(O, L, j, ie, oe, R, M, U, q);
                break;
            default:
                ue & 1 ? w(O, L, j, ie, oe, R, M, U, q) : ue & 6 ? F(O, L, j, ie, oe, R, M, U, q) : ue & 64 || ue & 128 ? se.process(O, L, j, ie, oe, R, M, U, q, ce) : re("Invalid VNode type:", se, `(${typeof se})`)
        }
        he != null && oe && Qf(he, O && O.ref, R, L || O, !L)
    }, y = (O, L, j, ie) => {
        if (O == null) r(L.el = a(L.children), j, ie);
        else {
            const oe = L.el = O.el;
            L.children !== O.children && c(oe, L.children)
        }
    }, m = (O, L, j, ie) => {
        O == null ? r(L.el = l(L.children || ""), j, ie) : L.el = O.el
    }, g = (O, L, j, ie) => {
        [O.el, O.anchor] = p(O.children, L, j, ie, O.el, O.anchor)
    }, v = (O, L, j, ie) => {
        if (L.children !== O.children) {
            const oe = f(O.anchor);
            x(O), [L.el, L.anchor] = p(L.children, j, oe, ie)
        } else L.el = O.el, L.anchor = O.anchor
    }, _ = ({
        el: O,
        anchor: L
    }, j, ie) => {
        let oe;
        for (; O && O !== L;) oe = f(O), r(O, j, ie), O = oe;
        r(L, j, ie)
    }, x = ({
        el: O,
        anchor: L
    }) => {
        let j;
        for (; O && O !== L;) j = f(O), i(O), O = j;
        i(L)
    }, w = (O, L, j, ie, oe, R, M, U, q) => {
        M = M || L.type === "svg", O == null ? S(L, j, ie, oe, R, M, U, q) : T(O, L, oe, R, M, U, q)
    }, S = (O, L, j, ie, oe, R, M, U) => {
        let q, se;
        const {
            type: he,
            props: ue,
            shapeFlag: z,
            transition: ee,
            dirs: xe
        } = O;
        if (q = O.el = o(O.type, R, ue && ue.is, ue), z & 8 ? u(q, O.children) : z & 16 && A(O.children, q, null, ie, oe, R && he !== "foreignObject", M, U), xe && Wr(O, null, ie, "created"), C(q, O, O.scopeId, M, ie), ue) {
            for (const Ve in ue) Ve !== "value" && !Sc(Ve) && s(q, Ve, null, ue[Ve], R, O.children, ie, oe, $);
            "value" in ue && s(q, "value", null, ue.value), (se = ue.onVnodeBeforeMount) && An(se, ie, O)
        }
        Object.defineProperty(q, "__vnode", {
            value: O,
            enumerable: !1
        }), Object.defineProperty(q, "__vueParentComponent", {
            value: ie,
            enumerable: !1
        }), xe && Wr(O, null, ie, "beforeMount");
        const Re = (!oe || oe && !oe.pendingBranch) && ee && !ee.persisted;
        Re && ee.beforeEnter(q), r(q, L, j), ((se = ue && ue.onVnodeMounted) || Re || xe) && tn(() => {
            se && An(se, ie, O), Re && ee.enter(q), xe && Wr(O, null, ie, "mounted")
        }, oe)
    }, C = (O, L, j, ie, oe) => {
        if (j && h(O, j), ie)
            for (let R = 0; R < ie.length; R++) h(O, ie[R]);
        if (oe) {
            let R = oe.subTree;
            if (R.patchFlag > 0 && R.patchFlag & 2048 && (R = m_(R.children) || R), L === R) {
                const M = oe.vnode;
                C(O, M, M.scopeId, M.slotScopeIds, oe.parent)
            }
        }
    }, A = (O, L, j, ie, oe, R, M, U, q = 0) => {
        for (let se = q; se < O.length; se++) {
            const he = O[se] = U ? ls(O[se]) : Rn(O[se]);
            b(null, he, L, j, ie, oe, R, M, U)
        }
    }, T = (O, L, j, ie, oe, R, M) => {
        const U = L.el = O.el;
        let {
            patchFlag: q,
            dynamicChildren: se,
            dirs: he
        } = L;
        q |= O.patchFlag & 16;
        const ue = O.props || st,
            z = L.props || st;
        let ee;
        j && to(j, !1), (ee = z.onVnodeBeforeUpdate) && An(ee, j, L, O), he && Wr(L, O, j, "beforeUpdate"), j && to(j, !0), Ss && (q = 0, M = !1, se = null);
        const xe = oe && L.type !== "foreignObject";
        if (se ? (E(O.dynamicChildren, se, U, j, ie, xe, R), th(O, L)) : M || Y(O, L, U, null, j, ie, xe, R, !1), q > 0) {
            if (q & 16) P(U, L, ue, z, j, ie, oe);
            else if (q & 2 && ue.class !== z.class && s(U, "class", null, z.class, oe), q & 4 && s(U, "style", ue.style, z.style, oe), q & 8) {
                const Re = L.dynamicProps;
                for (let Ve = 0; Ve < Re.length; Ve++) {
                    const pt = Re[Ve],
                        Wt = ue[pt],
                        Pn = z[pt];
                    (Pn !== Wt || pt === "value") && s(U, pt, Wt, Pn, oe, O.children, j, ie, $)
                }
            }
            q & 1 && O.children !== L.children && u(U, L.children)
        } else !M && se == null && P(U, L, ue, z, j, ie, oe);
        ((ee = z.onVnodeUpdated) || he) && tn(() => {
            ee && An(ee, j, L, O), he && Wr(L, O, j, "updated")
        }, ie)
    }, E = (O, L, j, ie, oe, R, M) => {
        for (let U = 0; U < L.length; U++) {
            const q = O[U],
                se = L[U],
                he = q.el && (q.type === gt || !xr(q, se) || q.shapeFlag & 70) ? d(q.el) : j;
            b(q, se, he, null, ie, oe, R, M, !0)
        }
    }, P = (O, L, j, ie, oe, R, M) => {
        if (j !== ie) {
            if (j !== st)
                for (const U in j) !Sc(U) && !(U in ie) && s(O, U, j[U], null, M, L.children, oe, R, $);
            for (const U in ie) {
                if (Sc(U)) continue;
                const q = ie[U],
                    se = j[U];
                q !== se && U !== "value" && s(O, U, se, q, M, L.children, oe, R, $)
            }
            "value" in ie && s(O, "value", j.value, ie.value)
        }
    }, B = (O, L, j, ie, oe, R, M, U, q) => {
        const se = L.el = O ? O.el : a(""),
            he = L.anchor = O ? O.anchor : a("");
        let {
            patchFlag: ue,
            dynamicChildren: z,
            slotScopeIds: ee
        } = L;
        (Ss || ue & 2048) && (ue = 0, q = !1, z = null), ee && (U = U ? U.concat(ee) : ee), O == null ? (r(se, j, ie), r(he, j, ie), A(L.children, j, he, oe, R, M, U, q)) : ue > 0 && ue & 64 && z && O.dynamicChildren ? (E(O.dynamicChildren, z, j, oe, R, M, U), th(O, L)) : Y(O, L, j, he, oe, R, M, U, q)
    }, F = (O, L, j, ie, oe, R, M, U, q) => {
        L.slotScopeIds = U, O == null ? L.shapeFlag & 512 ? oe.ctx.activate(L, j, ie, M, q) : H(L, j, ie, oe, R, M, q) : k(O, L, q)
    }, H = (O, L, j, ie, oe, R, M) => {
        const U = O.component = KA(O, ie, oe);
        if (U.type.__hmrId && WL(U), Tc(O), yi(U, "mount"), Rl(O) && (U.ctx.renderer = ce), yi(U, "init"), JA(U), _i(U, "init"), U.asyncDep) {
            if (oe && oe.registerDep(U, N), !O.el) {
                const q = U.subTree = I(Ot);
                m(null, q, L, j)
            }
            return
        }
        N(U, O, L, j, oe, R, M), Cc(), _i(U, "mount")
    }, k = (O, L, j) => {
        const ie = L.component = O.component;
        if (uN(O, L, j))
            if (ie.asyncDep && !ie.asyncResolved) {
                Tc(L), V(ie, L, j), Cc();
                return
            } else ie.next = L, jL(ie.update), ie.update();
        else L.el = O.el, ie.vnode = L
    }, N = (O, L, j, ie, oe, R, M) => {
        const U = () => {
                if (O.isMounted) {
                    let {
                        next: he,
                        bu: ue,
                        u: z,
                        parent: ee,
                        vnode: xe
                    } = O, Re = he, Ve;
                    Tc(he || O.vnode), to(O, !1), he ? (he.el = xe.el, V(O, he, M)) : he = xe, ue && mo(ue), (Ve = he.props && he.props.onVnodeBeforeUpdate) && An(Ve, ee, he, xe), to(O, !0), yi(O, "render");
                    const pt = bf(O);
                    _i(O, "render");
                    const Wt = O.subTree;
                    O.subTree = pt, yi(O, "patch"), b(Wt, pt, d(Wt.el), Z(Wt), O, oe, R), _i(O, "patch"), he.el = pt.el, Re === null && g_(O, pt.el), z && tn(z, oe), (Ve = he.props && he.props.onVnodeUpdated) && tn(() => An(Ve, ee, he, xe), oe), dA(O), Cc()
                } else {
                    let he;
                    const {
                        el: ue,
                        props: z
                    } = L, {
                        bm: ee,
                        m: xe,
                        parent: Re
                    } = O, Ve = Ro(L);
                    if (to(O, !1), ee && mo(ee), !Ve && (he = z && z.onVnodeBeforeMount) && An(he, Re, L), to(O, !0), ue && ge) {
                        const pt = () => {
                            yi(O, "render"), O.subTree = bf(O), _i(O, "render"), yi(O, "hydrate"), ge(ue, O.subTree, O, oe, null), _i(O, "hydrate")
                        };
                        Ve ? L.type.__asyncLoader().then(() => !O.isUnmounted && pt()) : pt()
                    } else {
                        yi(O, "render");
                        const pt = O.subTree = bf(O);
                        _i(O, "render"), yi(O, "patch"), b(null, pt, j, ie, O, oe, R), _i(O, "patch"), L.el = pt.el
                    }
                    if (xe && tn(xe, oe), !Ve && (he = z && z.onVnodeMounted)) {
                        const pt = L;
                        tn(() => An(he, Re, pt), oe)
                    }(L.shapeFlag & 256 || Re && Ro(Re.vnode) && Re.vnode.shapeFlag & 256) && O.a && tn(O.a, oe), O.isMounted = !0, Dv(O), L = j = ie = null
                }
            },
            q = O.effect = new $u(U, () => Hu(se), O.scope),
            se = O.update = () => q.run();
        se.id = O.uid, to(O, !0), q.onTrack = O.rtc ? he => mo(O.rtc, he) : void 0, q.onTrigger = O.rtg ? he => mo(O.rtg, he) : void 0, se.ownerInstance = O, se()
    }, V = (O, L, j) => {
        L.component = O;
        const ie = O.vnode.props;
        O.vnode = L, O.next = null, o4(O, L.props, ie, j), p4(O, L.children, j), ia(), Bw(), sa()
    }, Y = (O, L, j, ie, oe, R, M, U, q = !1) => {
        const se = O && O.children,
            he = O ? O.shapeFlag : 0,
            ue = L.children,
            {
                patchFlag: z,
                shapeFlag: ee
            } = L;
        if (z > 0) {
            if (z & 128) {
                ae(se, ue, j, ie, oe, R, M, U, q);
                return
            } else if (z & 256) {
                le(se, ue, j, ie, oe, R, M, U, q);
                return
            }
        }
        ee & 8 ? (he & 16 && $(se, oe, R), ue !== se && u(j, ue)) : he & 16 ? ee & 16 ? ae(se, ue, j, ie, oe, R, M, U, q) : $(se, oe, R, !0) : (he & 8 && u(j, ""), ee & 16 && A(ue, j, ie, oe, R, M, U, q))
    }, le = (O, L, j, ie, oe, R, M, U, q) => {
        O = O || Wa, L = L || Wa;
        const se = O.length,
            he = L.length,
            ue = Math.min(se, he);
        let z;
        for (z = 0; z < ue; z++) {
            const ee = L[z] = q ? ls(L[z]) : Rn(L[z]);
            b(O[z], ee, j, null, oe, R, M, U, q)
        }
        se > he ? $(O, oe, R, !0, !1, ue) : A(L, j, ie, oe, R, M, U, q, ue)
    }, ae = (O, L, j, ie, oe, R, M, U, q) => {
        let se = 0;
        const he = L.length;
        let ue = O.length - 1,
            z = he - 1;
        for (; se <= ue && se <= z;) {
            const ee = O[se],
                xe = L[se] = q ? ls(L[se]) : Rn(L[se]);
            if (xr(ee, xe)) b(ee, xe, j, null, oe, R, M, U, q);
            else break;
            se++
        }
        for (; se <= ue && se <= z;) {
            const ee = O[ue],
                xe = L[z] = q ? ls(L[z]) : Rn(L[z]);
            if (xr(ee, xe)) b(ee, xe, j, null, oe, R, M, U, q);
            else break;
            ue--, z--
        }
        if (se > ue) {
            if (se <= z) {
                const ee = z + 1,
                    xe = ee < he ? L[ee].el : ie;
                for (; se <= z;) b(null, L[se] = q ? ls(L[se]) : Rn(L[se]), j, xe, oe, R, M, U, q), se++
            }
        } else if (se > z)
            for (; se <= ue;) Q(O[se], oe, R, !0), se++;
        else {
            const ee = se,
                xe = se,
                Re = new Map;
            for (se = xe; se <= z; se++) {
                const mn = L[se] = q ? ls(L[se]) : Rn(L[se]);
                mn.key != null && (Re.has(mn.key) && re("Duplicate keys found during update:", JSON.stringify(mn.key), "Make sure keys are unique."), Re.set(mn.key, se))
            }
            let Ve, pt = 0;
            const Wt = z - xe + 1;
            let Pn = !1,
                gd = 0;
            const Ji = new Array(Wt);
            for (se = 0; se < Wt; se++) Ji[se] = 0;
            for (se = ee; se <= ue; se++) {
                const mn = O[se];
                if (pt >= Wt) {
                    Q(mn, oe, R, !0);
                    continue
                }
                let Lr;
                if (mn.key != null) Lr = Re.get(mn.key);
                else
                    for (Ve = xe; Ve <= z; Ve++)
                        if (Ji[Ve - xe] === 0 && xr(mn, L[Ve])) {
                            Lr = Ve;
                            break
                        }
                Lr === void 0 ? Q(mn, oe, R, !0) : (Ji[Lr - xe] = se + 1, Lr >= gd ? gd = Lr : Pn = !0, b(mn, L[Lr], j, null, oe, R, M, U, q), pt++)
            }
            const Ew = Pn ? v4(Ji) : Wa;
            for (Ve = Ew.length - 1, se = Wt - 1; se >= 0; se--) {
                const mn = xe + se,
                    Lr = L[mn],
                    Sw = mn + 1 < he ? L[mn + 1].el : ie;
                Ji[se] === 0 ? b(null, Lr, j, Sw, oe, R, M, U, q) : Pn && (Ve < 0 || se !== Ew[Ve] ? W(Lr, j, Sw, 2) : Ve--)
            }
        }
    }, W = (O, L, j, ie, oe = null) => {
        const {
            el: R,
            type: M,
            transition: U,
            children: q,
            shapeFlag: se
        } = O;
        if (se & 6) {
            W(O.component.subTree, L, j, ie);
            return
        }
        if (se & 128) {
            O.suspense.move(L, j, ie);
            return
        }
        if (se & 64) {
            M.move(O, L, j, ce);
            return
        }
        if (M === gt) {
            r(R, L, j);
            for (let ue = 0; ue < q.length; ue++) W(q[ue], L, j, ie);
            r(O.anchor, L, j);
            return
        }
        if (M === Ts) {
            _(O, L, j);
            return
        }
        if (ie !== 2 && se & 1 && U)
            if (ie === 0) U.beforeEnter(R), r(R, L, j), tn(() => U.enter(R), oe);
            else {
                const {
                    leave: ue,
                    delayLeave: z,
                    afterLeave: ee
                } = U, xe = () => r(R, L, j), Re = () => {
                    ue(R, () => {
                        xe(), ee && ee()
                    })
                };
                z ? z(R, xe, Re) : Re()
            }
        else r(R, L, j)
    }, Q = (O, L, j, ie = !1, oe = !1) => {
        const {
            type: R,
            props: M,
            ref: U,
            children: q,
            dynamicChildren: se,
            shapeFlag: he,
            patchFlag: ue,
            dirs: z
        } = O;
        if (U != null && Qf(U, null, j, O, !0), he & 256) {
            L.ctx.deactivate(O);
            return
        }
        const ee = he & 1 && z,
            xe = !Ro(O);
        let Re;
        if (xe && (Re = M && M.onVnodeBeforeUnmount) && An(Re, L, O), he & 6) X(O.component, j, ie);
        else {
            if (he & 128) {
                O.suspense.unmount(j, ie);
                return
            }
            ee && Wr(O, null, L, "beforeUnmount"), he & 64 ? O.type.remove(O, L, j, oe, ce, ie) : se && (R !== gt || ue > 0 && ue & 64) ? $(se, L, j, !1, !0) : (R === gt && ue & 384 || !oe && he & 16) && $(q, L, j), ie && fe(O)
        }(xe && (Re = M && M.onVnodeUnmounted) || ee) && tn(() => {
            Re && An(Re, L, O), ee && Wr(O, null, L, "unmounted")
        }, j)
    }, fe = O => {
        const {
            type: L,
            el: j,
            anchor: ie,
            transition: oe
        } = O;
        if (L === gt) {
            O.patchFlag > 0 && O.patchFlag & 2048 && oe && !oe.persisted ? O.children.forEach(M => {
                M.type === Ot ? i(M.el) : fe(M)
            }) : D(j, ie);
            return
        }
        if (L === Ts) {
            x(O);
            return
        }
        const R = () => {
            i(j), oe && !oe.persisted && oe.afterLeave && oe.afterLeave()
        };
        if (O.shapeFlag & 1 && oe && !oe.persisted) {
            const {
                leave: M,
                delayLeave: U
            } = oe, q = () => M(j, R);
            U ? U(O.el, R, q) : q()
        } else R()
    }, D = (O, L) => {
        let j;
        for (; O !== L;) j = f(O), i(O), O = j;
        i(L)
    }, X = (O, L, j) => {
        O.type.__hmrId && YL(O);
        const {
            bum: ie,
            scope: oe,
            update: R,
            subTree: M,
            um: U
        } = O;
        ie && mo(ie), oe.stop(), R && (R.active = !1, Q(M, O, L, j)), U && tn(U, L), tn(() => {
            O.isUnmounted = !0
        }, L), L && L.pendingBranch && !L.isUnmounted && O.asyncDep && !O.asyncResolved && O.suspenseId === L.pendingId && (L.deps--, L.deps === 0 && L.resolve()), QL(O)
    }, $ = (O, L, j, ie = !1, oe = !1, R = 0) => {
        for (let M = R; M < O.length; M++) Q(O[M], L, j, ie, oe)
    }, Z = O => O.shapeFlag & 6 ? Z(O.component.subTree) : O.shapeFlag & 128 ? O.suspense.next() : f(O.anchor || O.el), K = (O, L, j) => {
        O == null ? L._vnode && Q(L._vnode, null, null, !0) : b(L._vnode || null, O, L, null, null, null, j), Bw(), Kf(), L._vnode = O
    }, ce = {
        p: b,
        um: Q,
        m: W,
        r: fe,
        mt: H,
        mc: A,
        pc: Y,
        pbc: E,
        n: Z,
        o: t
    };
    let de, ge;
    return e && ([de, ge] = e(ce)), {
        render: K,
        hydrate: de,
        createApp: r4(K, de)
    }
}

function to({
    effect: t,
    update: e
}, n) {
    t.allowRecurse = e.allowRecurse = n
}

function th(t, e, n = !1) {
    const r = t.children,
        i = e.children;
    if (Be(r) && Be(i))
        for (let s = 0; s < r.length; s++) {
            const o = r[s];
            let a = i[s];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[s] = ls(i[s]), a.el = o.el), n || th(o, a)), a.type === ii && (a.el = o.el), a.type === Ot && !a.el && (a.el = o.el)
        }
}

function v4(t) {
    const e = t.slice(),
        n = [0];
    let r, i, s, o, a;
    const l = t.length;
    for (r = 0; r < l; r++) {
        const c = t[r];
        if (c !== 0) {
            if (i = n[n.length - 1], t[i] < c) {
                e[r] = i, n.push(r);
                continue
            }
            for (s = 0, o = n.length - 1; s < o;) a = s + o >> 1, t[n[a]] < c ? s = a + 1 : o = a;
            c < t[n[s]] && (s > 0 && (e[r] = n[s - 1]), n[s] = r)
        }
    }
    for (s = n.length, o = n[s - 1]; s-- > 0;) n[s] = o, o = e[o];
    return n
}
const y4 = t => t.__isTeleport,
    Ka = t => t && (t.disabled || t.disabled === ""),
    qw = t => typeof SVGElement < "u" && t instanceof SVGElement,
    Hv = (t, e) => {
        const n = t && t.to;
        if (It(n))
            if (e) {
                const r = e(n);
                return r || re(`Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`), r
            } else return re("Current renderer does not support string target for Teleports. (missing querySelector renderer option)"), null;
        else return !n && !Ka(t) && re(`Invalid Teleport target: ${n}`), n
    },
    _4 = {
        __isTeleport: !0,
        process(t, e, n, r, i, s, o, a, l, c) {
            const {
                mc: u,
                pc: d,
                pbc: f,
                o: {
                    insert: h,
                    querySelector: p,
                    createText: b,
                    createComment: y
                }
            } = c, m = Ka(e.props);
            let {
                shapeFlag: g,
                children: v,
                dynamicChildren: _
            } = e;
            if (Ss && (l = !1, _ = null), t == null) {
                const x = e.el = y("teleport start"),
                    w = e.anchor = y("teleport end");
                h(x, n, r), h(w, n, r);
                const S = e.target = Hv(e.props, p),
                    C = e.targetAnchor = b("");
                S ? (h(C, S), o = o || qw(S)) : m || re("Invalid Teleport target on mount:", S, `(${typeof S})`);
                const A = (T, E) => {
                    g & 16 && u(v, T, E, i, s, o, a, l)
                };
                m ? A(n, w) : S && A(S, C)
            } else {
                e.el = t.el;
                const x = e.anchor = t.anchor,
                    w = e.target = t.target,
                    S = e.targetAnchor = t.targetAnchor,
                    C = Ka(t.props),
                    A = C ? n : w,
                    T = C ? x : S;
                if (o = o || qw(w), _ ? (f(t.dynamicChildren, _, A, i, s, o, a), th(t, e, !0)) : l || d(t, e, A, T, i, s, o, a, !1), m) C || Sd(e, n, x, c, 1);
                else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
                    const E = e.target = Hv(e.props, p);
                    E ? Sd(e, E, null, c, 0) : re("Invalid Teleport target on update:", w, `(${typeof w})`)
                } else C && Sd(e, w, S, c, 1)
            }
            zA(e)
        },
        remove(t, e, n, r, {
            um: i,
            o: {
                remove: s
            }
        }, o) {
            const {
                shapeFlag: a,
                children: l,
                anchor: c,
                targetAnchor: u,
                target: d,
                props: f
            } = t;
            if (d && s(u), (o || !Ka(f)) && (s(c), a & 16))
                for (let h = 0; h < l.length; h++) {
                    const p = l[h];
                    i(p, e, n, !0, !!p.dynamicChildren)
                }
        },
        move: Sd,
        hydrate: b4
    };

function Sd(t, e, n, {
    o: {
        insert: r
    },
    m: i
}, s = 2) {
    s === 0 && r(t.targetAnchor, e, n);
    const {
        el: o,
        anchor: a,
        shapeFlag: l,
        children: c,
        props: u
    } = t, d = s === 2;
    if (d && r(o, e, n), (!d || Ka(u)) && l & 16)
        for (let f = 0; f < c.length; f++) i(c[f], e, n, 2);
    d && r(a, e, n)
}

function b4(t, e, n, r, i, s, {
    o: {
        nextSibling: o,
        parentNode: a,
        querySelector: l
    }
}, c) {
    const u = e.target = Hv(e.props, l);
    if (u) {
        const d = u._lpa || u.firstChild;
        if (e.shapeFlag & 16)
            if (Ka(e.props)) e.anchor = c(o(t), e, a(t), n, r, i, s), e.targetAnchor = d;
            else {
                e.anchor = o(t);
                let f = d;
                for (; f;)
                    if (f = o(f), f && f.nodeType === 8 && f.data === "teleport anchor") {
                        e.targetAnchor = f, u._lpa = e.targetAnchor && o(e.targetAnchor);
                        break
                    }
                c(d, e, u, n, r, i, s)
            }
        zA(e)
    }
    return e.anchor && o(e.anchor)
}
const S_ = _4;

function zA(t) {
    const e = t.ctx;
    if (e && e.ut) {
        let n = t.children[0].el;
        for (; n !== t.targetAnchor;) n.nodeType === 1 && n.setAttribute("data-v-owner", e.uid), n = n.nextSibling;
        e.ut()
    }
}
const gt = Symbol.for("v-fgt"),
    ii = Symbol.for("v-txt"),
    Ot = Symbol.for("v-cmt"),
    Ts = Symbol.for("v-stc"),
    Oc = [];
let Bn = null;

function Zh(t = !1) {
    Oc.push(Bn = t ? null : [])
}

function jA() {
    Oc.pop(), Bn = Oc[Oc.length - 1] || null
}
let Go = 1;

function zv(t) {
    Go += t
}

function VA(t) {
    return t.dynamicChildren = Go > 0 ? Bn || Wa : null, jA(), Go > 0 && Bn && Bn.push(t), t
}

function x4(t, e, n, r, i, s) {
    return VA(C_(t, e, n, r, i, s, !0))
}

function T_(t, e, n, r, i) {
    return VA(I(t, e, n, r, i, !0))
}

function si(t) {
    return t ? t.__v_isVNode === !0 : !1
}

function xr(t, e) {
    return e.shapeFlag & 6 && $a.has(e.type) ? (t.shapeFlag &= -257, e.shapeFlag &= -513, !1) : t.type === e.type && t.key === e.key
}
let jv;

function w4(t) {
    jv = t
}
const E4 = (...t) => S4(...jv ? jv(t, Bt) : t),
    Qh = "__vInternal",
    WA = ({
        key: t
    }) => t ? ? null,
    xf = ({
        ref: t,
        ref_key: e,
        ref_for: n
    }) => (typeof t == "number" && (t = "" + t), t != null ? It(t) || tt(t) || ke(t) ? {
        i: Bt,
        r: t,
        k: e,
        f: !!n
    } : t : null);

function C_(t, e = null, n = null, r = 0, i = null, s = t === gt ? 0 : 1, o = !1, a = !1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t,
        props: e,
        key: e && WA(e),
        ref: e && xf(e),
        scopeId: Xh,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: r,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null,
        ctx: Bt
    };
    return a ? (P_(l, n), s & 128 && t.normalize(l)) : n && (l.shapeFlag |= It(n) ? 8 : 16), l.key !== l.key && re("VNode created with invalid key (NaN). VNode type:", l.type), Go > 0 && !o && Bn && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && Bn.push(l), l
}
const I = E4;

function S4(t, e = null, n = null, r = 0, i = null, s = !1) {
    if ((!t || t === PA) && (t || re(`Invalid vnode type when creating vnode: ${t}.`), t = Ot), si(t)) {
        const a = hr(t, e, !0);
        return n && P_(a, n), Go > 0 && !s && Bn && (a.shapeFlag & 6 ? Bn[Bn.indexOf(t)] = a : Bn.push(a)), a.patchFlag |= -2, a
    }
    if (eO(t) && (t = t.__vccOpts), e) {
        e = YA(e);
        let {
            class: a,
            style: l
        } = e;
        a && !It(a) && (e.class = Gu(a)), ut(l) && (qc(l) && !Be(l) && (l = Et({}, l)), e.style = Uu(l))
    }
    const o = It(t) ? 1 : pA(t) ? 128 : y4(t) ? 64 : ut(t) ? 4 : ke(t) ? 2 : 0;
    return o & 4 && qc(t) && (t = Oe(t), re("Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", `
Component that was made reactive: `, t)), C_(t, e, n, r, i, o, s, !0)
}

function YA(t) {
    return t ? qc(t) || Qh in t ? Et({}, t) : t : null
}

function hr(t, e, n = !1) {
    const {
        props: r,
        ref: i,
        patchFlag: s,
        children: o
    } = t, a = e ? et(r || {}, e) : r;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t.type,
        props: a,
        key: a && WA(a),
        ref: e && e.ref ? n && i ? Be(i) ? i.concat(xf(e)) : [i, xf(e)] : xf(e) : i,
        scopeId: t.scopeId,
        slotScopeIds: t.slotScopeIds,
        children: s === -1 && Be(o) ? o.map(XA) : o,
        target: t.target,
        targetAnchor: t.targetAnchor,
        staticCount: t.staticCount,
        shapeFlag: t.shapeFlag,
        patchFlag: e && t.type !== gt ? s === -1 ? 16 : s | 16 : s,
        dynamicProps: t.dynamicProps,
        dynamicChildren: t.dynamicChildren,
        appContext: t.appContext,
        dirs: t.dirs,
        transition: t.transition,
        component: t.component,
        suspense: t.suspense,
        ssContent: t.ssContent && hr(t.ssContent),
        ssFallback: t.ssFallback && hr(t.ssFallback),
        el: t.el,
        anchor: t.anchor,
        ctx: t.ctx,
        ce: t.ce
    }
}

function XA(t) {
    const e = hr(t);
    return Be(t.children) && (e.children = t.children.map(XA)), e
}

function ep(t = " ", e = 0) {
    return I(ii, null, t, e)
}

function T4(t, e) {
    const n = I(Ts, null, t);
    return n.staticCount = e, n
}

function C4(t = "", e = !1) {
    return e ? (Zh(), T_(Ot, null, t)) : I(Ot, null, t)
}

function Rn(t) {
    return t == null || typeof t == "boolean" ? I(Ot) : Be(t) ? I(gt, null, t.slice()) : typeof t == "object" ? ls(t) : I(ii, null, String(t))
}

function ls(t) {
    return t.el === null && t.patchFlag !== -1 || t.memo ? t : hr(t)
}

function P_(t, e) {
    let n = 0;
    const {
        shapeFlag: r
    } = t;
    if (e == null) e = null;
    else if (Be(e)) n = 16;
    else if (typeof e == "object")
        if (r & 65) {
            const i = e.default;
            i && (i._c && (i._d = !1), P_(t, i()), i._c && (i._d = !0));
            return
        } else {
            n = 32;
            const i = e._;
            !i && !(Qh in e) ? e._ctx = Bt : i === 3 && Bt && (Bt.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024))
        }
    else ke(e) ? (e = {
        default: e,
        _ctx: Bt
    }, n = 32) : (e = String(e), r & 64 ? (n = 16, e = [ep(e)]) : n = 8);
    t.children = e, t.shapeFlag |= n
}

function et(...t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        for (const i in r)
            if (i === "class") e.class !== r.class && (e.class = Gu([e.class, r.class]));
            else if (i === "style") e.style = Uu([e.style, r.style]);
        else if (Lu(i)) {
            const s = e[i],
                o = r[i];
            o && s !== o && !(Be(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o)
        } else i !== "" && (e[i] = r[i])
    }
    return e
}

function An(t, e, n, r = null) {
    Wn(t, e, 7, [n, r])
}
const P4 = MA();
let A4 = 0;

function KA(t, e, n) {
    const r = t.type,
        i = (e ? e.appContext : t.appContext) || P4,
        s = {
            uid: A4++,
            vnode: t,
            type: r,
            parent: e,
            appContext: i,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new e_(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: e ? e.provides : Object.create(i.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: DA(r, i),
            emitsOptions: hA(r, i),
            emit: null,
            emitted: null,
            propsDefaults: st,
            inheritAttrs: r.inheritAttrs,
            ctx: st,
            data: st,
            props: st,
            attrs: st,
            slots: st,
            refs: st,
            setupState: st,
            setupContext: null,
            attrsProxy: null,
            slotsProxy: null,
            suspense: n,
            suspenseId: n ? n.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return s.ctx = kN(s), s.root = e ? e.root : s, s.emit = rN.bind(null, s), t.ce && t.ce(s), s
}
let kt = null;
const it = () => kt || Bt;
let A_, va, Jw = "__VUE_INSTANCE_SETTERS__";
(va = Xf()[Jw]) || (va = Xf()[Jw] = []), va.push(t => kt = t), A_ = t => {
    va.length > 1 ? va.forEach(e => e(t)) : va[0](t)
};
const Rs = t => {
        A_(t), t.scope.on()
    },
    Cs = () => {
        kt && kt.scope.off(), A_(null)
    },
    O4 = Fu("slot,component");

function Vv(t, e) {
    const n = e.isNativeTag || eA;
    (O4(t) || n(t)) && re("Do not use built-in or reserved HTML elements as component id: " + t)
}

function qA(t) {
    return t.vnode.shapeFlag & 4
}
let sl = !1;

function JA(t, e = !1) {
    sl = e;
    const {
        props: n,
        children: r
    } = t.vnode, i = qA(t);
    i4(t, n, i, e), h4(t, r);
    const s = i ? I4(t, e) : void 0;
    return sl = !1, s
}

function I4(t, e) {
    var n;
    const r = t.type; {
        if (r.name && Vv(r.name, t.appContext.config), r.components) {
            const s = Object.keys(r.components);
            for (let o = 0; o < s.length; o++) Vv(s[o], t.appContext.config)
        }
        if (r.directives) {
            const s = Object.keys(r.directives);
            for (let o = 0; o < s.length; o++) yA(s[o])
        }
        r.compilerOptions && O_() && re('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.')
    }
    t.accessCache = Object.create(null), t.proxy = Zr(new Proxy(t.ctx, Ac)), BN(t);
    const {
        setup: i
    } = r;
    if (i) {
        const s = t.setupContext = i.length > 1 ? QA(t) : null;
        Rs(t), ia();
        const o = ei(i, t, 0, [Ua(t.props), s]);
        if (sa(), Cs(), jh(o)) {
            if (o.then(Cs, Cs), e) return o.then(a => {
                Wv(t, a, e)
            }).catch(a => {
                aa(a, t, 0)
            });
            if (t.asyncDep = o, !t.suspense) {
                const a = (n = r.name) != null ? n : "Anonymous";
                re(`Component <${a}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`)
            }
        } else Wv(t, o, e)
    } else ZA(t, e)
}

function Wv(t, e, n) {
    ke(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : ut(e) ? (si(e) && re("setup() should not return VNodes directly - return a render function instead."), t.devtoolsRawSetupState = e, t.setupState = o_(e), DN(t)) : e !== void 0 && re(`setup() should return an object. Received: ${e===null?"null":typeof e}`), ZA(t, n)
}
let Ic, Yv;

function R4(t) {
    Ic = t, Yv = e => {
        e.render._rc && (e.withProxy = new Proxy(e.ctx, MN))
    }
}
const O_ = () => !Ic;

function ZA(t, e, n) {
    const r = t.type;
    if (!t.render) {
        if (!e && Ic && !r.render) {
            const i = r.template || w_(t).template;
            if (i) {
                yi(t, "compile");
                const {
                    isCustomElement: s,
                    compilerOptions: o
                } = t.appContext.config, {
                    delimiters: a,
                    compilerOptions: l
                } = r, c = Et(Et({
                    isCustomElement: s,
                    delimiters: a
                }, o), l);
                r.render = Ic(i, c), _i(t, "compile")
            }
        }
        t.render = r.render || kn, Yv && Yv(t)
    }
    Rs(t), ia(), JN(t), sa(), Cs(), !r.render && t.render === kn && !e && (!Ic && r.template ? re('Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".') : re("Component is missing template or render function."))
}

function M4(t) {
    return t.attrsProxy || (t.attrsProxy = new Proxy(t.attrs, {
        get(e, n) {
            return qf(), pn(t, "get", "$attrs"), e[n]
        },
        set() {
            return re("setupContext.attrs is readonly."), !1
        },
        deleteProperty() {
            return re("setupContext.attrs is readonly."), !1
        }
    }))
}

function k4(t) {
    return t.slotsProxy || (t.slotsProxy = new Proxy(t.slots, {
        get(e, n) {
            return pn(t, "get", "$slots"), e[n]
        }
    }))
}

function QA(t) {
    return Object.freeze({
        get attrs() {
            return M4(t)
        },
        get slots() {
            return k4(t)
        },
        get emit() {
            return (n, ...r) => t.emit(n, ...r)
        },
        expose: n => {
            if (t.exposed && re("expose() should be called only once per setup()."), n != null) {
                let r = typeof n;
                r === "object" && (Be(n) ? r = "array" : tt(n) && (r = "ref")), r !== "object" && re(`expose() should be passed a plain object, received ${r}.`)
            }
            t.exposed = n || {}
        }
    })
}

function tp(t) {
    if (t.exposed) return t.exposeProxy || (t.exposeProxy = new Proxy(o_(Zr(t.exposed)), {
        get(e, n) {
            if (n in e) return e[n];
            if (n in Mo) return Mo[n](t)
        },
        has(e, n) {
            return n in e || n in Mo
        }
    }))
}
const B4 = /(?:^|[-_])(\w)/g,
    D4 = t => t.replace(B4, e => e.toUpperCase()).replace(/[-_]/g, "");

function iu(t, e = !0) {
    return ke(t) ? t.displayName || t.name : t.name || e && t.__name
}

function np(t, e, n = !1) {
    let r = iu(e);
    if (!r && e.__file) {
        const i = e.__file.match(/([^/\\]+)\.\w+$/);
        i && (r = i[1])
    }
    if (!r && t && t.parent) {
        const i = s => {
            for (const o in s)
                if (s[o] === e) return o
        };
        r = i(t.components || t.parent.type.components) || i(t.appContext.components)
    }
    return r ? D4(r) : n ? "App" : "Anonymous"
}

function eO(t) {
    return ke(t) && "__vccOpts" in t
}
const ne = (t, e) => _L(t, e, sl);

function qt(t, e, n) {
    const r = arguments.length;
    return r === 2 ? ut(e) && !Be(e) ? si(e) ? I(t, null, [e]) : I(t, e) : I(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && si(n) && (n = [n]), I(t, e, n))
}
const tO = Symbol.for("v-scx"),
    nO = () => {
        {
            const t = Nt(tO);
            return t || re("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."), t
        }
    };

function pm(t) {
    return !!(t && t.__v_isShallow)
}

function rO() {
    if (typeof window > "u") return;
    const t = {
            style: "color:#3ba776"
        },
        e = {
            style: "color:#0b1bc9"
        },
        n = {
            style: "color:#b62e24"
        },
        r = {
            style: "color:#9d288c"
        },
        i = {
            header(d) {
                return ut(d) ? d.__isVue ? ["div", t, "VueInstance"] : tt(d) ? ["div", {},
                    ["span", t, u(d)], "<", a(d.value), ">"
                ] : Tr(d) ? ["div", {},
                    ["span", t, pm(d) ? "ShallowReactive" : "Reactive"], "<", a(d), `>${Ui(d)?" (readonly)":""}`
                ] : Ui(d) ? ["div", {},
                    ["span", t, pm(d) ? "ShallowReadonly" : "Readonly"], "<", a(d), ">"
                ] : null : null
            },
            hasBody(d) {
                return d && d.__isVue
            },
            body(d) {
                if (d && d.__isVue) return ["div", {}, ...s(d.$)]
            }
        };

    function s(d) {
        const f = [];
        d.type.props && d.props && f.push(o("props", Oe(d.props))), d.setupState !== st && f.push(o("setup", d.setupState)), d.data !== st && f.push(o("data", Oe(d.data)));
        const h = l(d, "computed");
        h && f.push(o("computed", h));
        const p = l(d, "inject");
        return p && f.push(o("injected", p)), f.push(["div", {},
            ["span", {
                style: r.style + ";opacity:0.66"
            }, "$ (internal): "],
            ["object", {
                object: d
            }]
        ]), f
    }

    function o(d, f) {
        return f = Et({}, f), Object.keys(f).length ? ["div", {
                style: "line-height:1.25em;margin-bottom:0.6em"
            },
            ["div", {
                style: "color:#476582"
            }, d],
            ["div", {
                style: "padding-left:1.25em"
            }, ...Object.keys(f).map(h => ["div", {},
                ["span", r, h + ": "], a(f[h], !1)
            ])]
        ] : ["span", {}]
    }

    function a(d, f = !0) {
        return typeof d == "number" ? ["span", e, d] : typeof d == "string" ? ["span", n, JSON.stringify(d)] : typeof d == "boolean" ? ["span", r, d] : ut(d) ? ["object", {
            object: f ? Oe(d) : d
        }] : ["span", n, String(d)]
    }

    function l(d, f) {
        const h = d.type;
        if (ke(h)) return;
        const p = {};
        for (const b in d.ctx) c(h, b, f) && (p[b] = d.ctx[b]);
        return p
    }

    function c(d, f, h) {
        const p = d[h];
        if (Be(p) && p.includes(f) || ut(p) && f in p || d.extends && c(d.extends, f, h) || d.mixins && d.mixins.some(b => c(b, f, h))) return !0
    }

    function u(d) {
        return pm(d) ? "ShallowRef" : d.effect ? "ComputedRef" : "Ref"
    }
    window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i]
}

function $4(t, e, n, r) {
    const i = n[r];
    if (i && iO(i, t)) return i;
    const s = e();
    return s.memo = t.slice(), n[r] = s
}

function iO(t, e) {
    const n = t.memo;
    if (n.length != e.length) return !1;
    for (let r = 0; r < n.length; r++)
        if (Rv(n[r], e[r])) return !1;
    return Go > 0 && Bn && Bn.push(t), !0
}
const Xv = "3.3.4",
    F4 = {
        createComponentInstance: KA,
        setupComponent: JA,
        renderComponentRoot: bf,
        setCurrentRenderingInstance: eu,
        isVNode: si,
        normalizeVNode: Rn
    },
    L4 = F4,
    N4 = null,
    U4 = null;

function I_(t, e) {
    const n = Object.create(null),
        r = t.split(",");
    for (let i = 0; i < r.length; i++) n[r[i]] = !0;
    return e ? i => !!n[i.toLowerCase()] : i => !!n[i]
}
const mm = Object.freeze({}),
    G4 = /^on[^a-z]/,
    H4 = t => G4.test(t),
    z4 = t => t.startsWith("onUpdate:"),
    Vu = Object.assign,
    $n = Array.isArray,
    Wu = t => oO(t) === "[object Set]",
    Zw = t => oO(t) === "[object Date]",
    sO = t => typeof t == "function",
    su = t => typeof t == "string",
    Qw = t => typeof t == "symbol",
    Kv = t => t !== null && typeof t == "object",
    j4 = Object.prototype.toString,
    oO = t => j4.call(t),
    R_ = t => {
        const e = Object.create(null);
        return n => e[n] || (e[n] = t(n))
    },
    V4 = /-(\w)/g,
    gm = R_(t => t.replace(V4, (e, n) => n ? n.toUpperCase() : "")),
    W4 = /\B([A-Z])/g,
    ds = R_(t => t.replace(W4, "-$1").toLowerCase()),
    Y4 = R_(t => t.charAt(0).toUpperCase() + t.slice(1)),
    X4 = (t, e) => {
        for (let n = 0; n < t.length; n++) t[n](e)
    },
    qv = t => {
        const e = parseFloat(t);
        return isNaN(e) ? t : e
    },
    Jv = t => {
        const e = su(t) ? Number(t) : NaN;
        return isNaN(e) ? t : e
    },
    K4 = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot",
    q4 = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view",
    J4 = I_(K4),
    Z4 = I_(q4),
    Q4 = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    eU = I_(Q4);

function aO(t) {
    return !!t || t === ""
}

function tU(t, e) {
    if (t.length !== e.length) return !1;
    let n = !0;
    for (let r = 0; n && r < t.length; r++) n = Ms(t[r], e[r]);
    return n
}

function Ms(t, e) {
    if (t === e) return !0;
    let n = Zw(t),
        r = Zw(e);
    if (n || r) return n && r ? t.getTime() === e.getTime() : !1;
    if (n = Qw(t), r = Qw(e), n || r) return t === e;
    if (n = $n(t), r = $n(e), n || r) return n && r ? tU(t, e) : !1;
    if (n = Kv(t), r = Kv(e), n || r) {
        if (!n || !r) return !1;
        const i = Object.keys(t).length,
            s = Object.keys(e).length;
        if (i !== s) return !1;
        for (const o in t) {
            const a = t.hasOwnProperty(o),
                l = e.hasOwnProperty(o);
            if (a && !l || !a && l || !Ms(t[o], e[o])) return !1
        }
    }
    return String(t) === String(e)
}

function rp(t, e) {
    return t.findIndex(n => Ms(n, e))
}
const nU = "http://www.w3.org/2000/svg",
    go = typeof document < "u" ? document : null,
    eE = go && go.createElement("template"),
    rU = {
        insert: (t, e, n) => {
            e.insertBefore(t, n || null)
        },
        remove: t => {
            const e = t.parentNode;
            e && e.removeChild(t)
        },
        createElement: (t, e, n, r) => {
            const i = e ? go.createElementNS(nU, t) : go.createElement(t, n ? {
                is: n
            } : void 0);
            return t === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple), i
        },
        createText: t => go.createTextNode(t),
        createComment: t => go.createComment(t),
        setText: (t, e) => {
            t.nodeValue = e
        },
        setElementText: (t, e) => {
            t.textContent = e
        },
        parentNode: t => t.parentNode,
        nextSibling: t => t.nextSibling,
        querySelector: t => go.querySelector(t),
        setScopeId(t, e) {
            t.setAttribute(e, "")
        },
        insertStaticContent(t, e, n, r, i, s) {
            const o = n ? n.previousSibling : e.lastChild;
            if (i && (i === s || i.nextSibling))
                for (; e.insertBefore(i.cloneNode(!0), n), !(i === s || !(i = i.nextSibling)););
            else {
                eE.innerHTML = r ? `<svg>${t}</svg>` : t;
                const a = eE.content;
                if (r) {
                    const l = a.firstChild;
                    for (; l.firstChild;) a.appendChild(l.firstChild);
                    a.removeChild(l)
                }
                e.insertBefore(a, n)
            }
            return [o ? o.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
        }
    };

function iU(t, e, n) {
    const r = t._vtc;
    r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e
}

function sU(t, e, n) {
    const r = t.style,
        i = su(n);
    if (n && !i) {
        if (e && !su(e))
            for (const s in e) n[s] == null && Zv(r, s, "");
        for (const s in n) Zv(r, s, n[s])
    } else {
        const s = r.display;
        i ? e !== n && (r.cssText = n) : e && t.removeAttribute("style"), "_vod" in t && (r.display = s)
    }
}
const oU = /[^\\];\s*$/,
    tE = /\s*!important$/;

function Zv(t, e, n) {
    if ($n(n)) n.forEach(r => Zv(t, e, r));
    else if (n == null && (n = ""), oU.test(n) && re(`Unexpected semicolon at the end of '${e}' style value: '${n}'`), e.startsWith("--")) t.setProperty(e, n);
    else {
        const r = aU(t, e);
        tE.test(n) ? t.setProperty(ds(r), n.replace(tE, ""), "important") : t[r] = n
    }
}
const nE = ["Webkit", "Moz", "ms"],
    vm = {};

function aU(t, e) {
    const n = vm[e];
    if (n) return n;
    let r = Rr(e);
    if (r !== "filter" && r in t) return vm[e] = r;
    r = Y4(r);
    for (let i = 0; i < nE.length; i++) {
        const s = nE[i] + r;
        if (s in t) return vm[e] = s
    }
    return e
}
const rE = "http://www.w3.org/1999/xlink";

function lU(t, e, n, r, i) {
    if (r && e.startsWith("xlink:")) n == null ? t.removeAttributeNS(rE, e.slice(6, e.length)) : t.setAttributeNS(rE, e, n);
    else {
        const s = eU(e);
        n == null || s && !aO(n) ? t.removeAttribute(e) : t.setAttribute(e, s ? "" : n)
    }
}

function cU(t, e, n, r, i, s, o) {
    if (e === "innerHTML" || e === "textContent") {
        r && o(r, i, s), t[e] = n ? ? "";
        return
    }
    const a = t.tagName;
    if (e === "value" && a !== "PROGRESS" && !a.includes("-")) {
        t._value = n;
        const c = a === "OPTION" ? t.getAttribute("value") : t.value,
            u = n ? ? "";
        c !== u && (t.value = u), n == null && t.removeAttribute(e);
        return
    }
    let l = !1;
    if (n === "" || n == null) {
        const c = typeof t[e];
        c === "boolean" ? n = aO(n) : n == null && c === "string" ? (n = "", l = !0) : c === "number" && (n = 0, l = !0)
    }
    try {
        t[e] = n
    } catch (c) {
        l || re(`Failed setting prop "${e}" on <${a.toLowerCase()}>: value ${n} is invalid.`, c)
    }
    l && t.removeAttribute(e)
}

function Pi(t, e, n, r) {
    t.addEventListener(e, n, r)
}

function uU(t, e, n, r) {
    t.removeEventListener(e, n, r)
}

function dU(t, e, n, r, i = null) {
    const s = t._vei || (t._vei = {}),
        o = s[e];
    if (r && o) o.value = r;
    else {
        const [a, l] = fU(e);
        if (r) {
            const c = s[e] = mU(r, i);
            Pi(t, a, c, l)
        } else o && (uU(t, a, o, l), s[e] = void 0)
    }
}
const iE = /(?:Once|Passive|Capture)$/;

function fU(t) {
    let e;
    if (iE.test(t)) {
        e = {};
        let r;
        for (; r = t.match(iE);) t = t.slice(0, t.length - r[0].length), e[r[0].toLowerCase()] = !0
    }
    return [t[2] === ":" ? t.slice(3) : ds(t.slice(2)), e]
}
let ym = 0;
const hU = Promise.resolve(),
    pU = () => ym || (hU.then(() => ym = 0), ym = Date.now());

function mU(t, e) {
    const n = r => {
        if (!r._vts) r._vts = Date.now();
        else if (r._vts <= n.attached) return;
        Wn(gU(r, n.value), e, 5, [r])
    };
    return n.value = t, n.attached = pU(), n
}

function gU(t, e) {
    if ($n(e)) {
        const n = t.stopImmediatePropagation;
        return t.stopImmediatePropagation = () => {
            n.call(t), t._stopped = !0
        }, e.map(r => i => !i._stopped && r && r(i))
    } else return e
}
const sE = /^on[a-z]/,
    vU = (t, e, n, r, i = !1, s, o, a, l) => {
        e === "class" ? iU(t, r, i) : e === "style" ? sU(t, n, r) : H4(e) ? z4(e) || dU(t, e, n, r, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : yU(t, e, r, i)) ? cU(t, e, r, s, o, a, l) : (e === "true-value" ? t._trueValue = r : e === "false-value" && (t._falseValue = r), lU(t, e, r, i))
    };

function yU(t, e, n, r) {
    return r ? !!(e === "innerHTML" || e === "textContent" || e in t && sE.test(e) && sO(n)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || sE.test(e) && su(n) ? !1 : e in t
}

function lO(t, e) {
    const n = ye(t);
    class r extends ip {
        constructor(s) {
            super(n, s, e)
        }
    }
    return r.def = n, r
}
const _U = t => lO(t, SO),
    bU = typeof HTMLElement < "u" ? HTMLElement : class {};
class ip extends bU {
    constructor(e, n = {}, r) {
        super(), this._def = e, this._props = n, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this.shadowRoot && r ? r(this._createVNode(), this.shadowRoot) : (this.shadowRoot && re("Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`."), this.attachShadow({
            mode: "open"
        }), this._def.__asyncLoader || this._resolveProps(this._def))
    }
    connectedCallback() {
        this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef())
    }
    disconnectedCallback() {
        this._connected = !1, Ue(() => {
            this._connected || (ty(null, this.shadowRoot), this._instance = null)
        })
    }
    _resolveDef() {
        this._resolved = !0;
        for (let r = 0; r < this.attributes.length; r++) this._setAttr(this.attributes[r].name);
        new MutationObserver(r => {
            for (const i of r) this._setAttr(i.attributeName)
        }).observe(this, {
            attributes: !0
        });
        const e = (r, i = !1) => {
                const {
                    props: s,
                    styles: o
                } = r;
                let a;
                if (s && !$n(s))
                    for (const l in s) {
                        const c = s[l];
                        (c === Number || c && c.type === Number) && (l in this._props && (this._props[l] = Jv(this._props[l])), (a || (a = Object.create(null)))[gm(l)] = !0)
                    }
                this._numberProps = a, i && this._resolveProps(r), this._applyStyles(o), this._update()
            },
            n = this._def.__asyncLoader;
        n ? n().then(r => e(r, !0)) : e(this._def)
    }
    _resolveProps(e) {
        const {
            props: n
        } = e, r = $n(n) ? n : Object.keys(n || {});
        for (const i of Object.keys(this)) i[0] !== "_" && r.includes(i) && this._setProp(i, this[i], !0, !1);
        for (const i of r.map(gm)) Object.defineProperty(this, i, {
            get() {
                return this._getProp(i)
            },
            set(s) {
                this._setProp(i, s)
            }
        })
    }
    _setAttr(e) {
        let n = this.getAttribute(e);
        const r = gm(e);
        this._numberProps && this._numberProps[r] && (n = Jv(n)), this._setProp(r, n, !1)
    }
    _getProp(e) {
        return this._props[e]
    }
    _setProp(e, n, r = !0, i = !0) {
        n !== this._props[e] && (this._props[e] = n, i && this._instance && this._update(), r && (n === !0 ? this.setAttribute(ds(e), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(ds(e), n + "") : n || this.removeAttribute(ds(e))))
    }
    _update() {
        ty(this._createVNode(), this.shadowRoot)
    }
    _createVNode() {
        const e = I(this._def, Vu({}, this._props));
        return this._instance || (e.ce = n => {
            this._instance = n, n.isCE = !0, n.ceReload = s => {
                this._styles && (this._styles.forEach(o => this.shadowRoot.removeChild(o)), this._styles.length = 0), this._applyStyles(s), this._instance = null, this._update()
            };
            const r = (s, o) => {
                this.dispatchEvent(new CustomEvent(s, {
                    detail: o
                }))
            };
            n.emit = (s, ...o) => {
                r(s, o), ds(s) !== s && r(ds(s), o)
            };
            let i = this;
            for (; i = i && (i.parentNode || i.host);)
                if (i instanceof ip) {
                    n.parent = i._instance, n.provides = i._instance.provides;
                    break
                }
        }), e
    }
    _applyStyles(e) {
        e && e.forEach(n => {
            const r = document.createElement("style");
            r.textContent = n, this.shadowRoot.appendChild(r), (this._styles || (this._styles = [])).push(r)
        })
    }
}

function xU(t = "$style") {
    {
        const e = it();
        if (!e) return re("useCssModule must be called inside setup()"), mm;
        const n = e.type.__cssModules;
        if (!n) return re("Current instance does not have CSS modules injected."), mm;
        const r = n[t];
        return r || (re(`Current instance does not have CSS module named "${t}".`), mm)
    }
}

function wU(t) {
    const e = it();
    if (!e) {
        re("useCssVars is called without current active component instance.");
        return
    }
    const n = e.ut = (i = t(e.proxy)) => {
            Array.from(document.querySelectorAll(`[data-v-owner="${e.uid}"]`)).forEach(s => ey(s, i))
        },
        r = () => {
            const i = t(e.proxy);
            Qv(e.subTree, i), n(i)
        };
    gA(r), St(() => {
        const i = new MutationObserver(r);
        i.observe(e.subTree.el.parentNode, {
            childList: !0
        }), Ki(() => i.disconnect())
    })
}

function Qv(t, e) {
    if (t.shapeFlag & 128) {
        const n = t.suspense;
        t = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push(() => {
            Qv(n.activeBranch, e)
        })
    }
    for (; t.component;) t = t.component.subTree;
    if (t.shapeFlag & 1 && t.el) ey(t.el, e);
    else if (t.type === gt) t.children.forEach(n => Qv(n, e));
    else if (t.type === Ts) {
        let {
            el: n,
            anchor: r
        } = t;
        for (; n && (ey(n, e), n !== r);) n = n.nextSibling
    }
}

function ey(t, e) {
    if (t.nodeType === 1) {
        const n = t.style;
        for (const r in e) n.setProperty(`--${r}`, e[r])
    }
}
const es = "transition",
    Xl = "animation",
    Yu = (t, {
        slots: e
    }) => qt(_A, uO(t), e);
Yu.displayName = "Transition";
const cO = {
        name: String,
        type: String,
        css: {
            type: Boolean,
            default: !0
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
    },
    EU = Yu.props = Vu({}, __, cO),
    no = (t, e = []) => {
        $n(t) ? t.forEach(n => n(...e)) : t && t(...e)
    },
    oE = t => t ? $n(t) ? t.some(e => e.length > 1) : t.length > 1 : !1;

function uO(t) {
    const e = {};
    for (const P in t) P in cO || (e[P] = t[P]);
    if (t.css === !1) return e;
    const {
        name: n = "v",
        type: r,
        duration: i,
        enterFromClass: s = `${n}-enter-from`,
        enterActiveClass: o = `${n}-enter-active`,
        enterToClass: a = `${n}-enter-to`,
        appearFromClass: l = s,
        appearActiveClass: c = o,
        appearToClass: u = a,
        leaveFromClass: d = `${n}-leave-from`,
        leaveActiveClass: f = `${n}-leave-active`,
        leaveToClass: h = `${n}-leave-to`
    } = t, p = SU(i), b = p && p[0], y = p && p[1], {
        onBeforeEnter: m,
        onEnter: g,
        onEnterCancelled: v,
        onLeave: _,
        onLeaveCancelled: x,
        onBeforeAppear: w = m,
        onAppear: S = g,
        onAppearCancelled: C = v
    } = e, A = (P, B, F) => {
        os(P, B ? u : a), os(P, B ? c : o), F && F()
    }, T = (P, B) => {
        P._isLeaving = !1, os(P, d), os(P, h), os(P, f), B && B()
    }, E = P => (B, F) => {
        const H = P ? S : g,
            k = () => A(B, P, F);
        no(H, [B, k]), aE(() => {
            os(B, P ? l : s), bi(B, P ? u : a), oE(H) || lE(B, r, b, k)
        })
    };
    return Vu(e, {
        onBeforeEnter(P) {
            no(m, [P]), bi(P, s), bi(P, o)
        },
        onBeforeAppear(P) {
            no(w, [P]), bi(P, l), bi(P, c)
        },
        onEnter: E(!1),
        onAppear: E(!0),
        onLeave(P, B) {
            P._isLeaving = !0;
            const F = () => T(P, B);
            bi(P, d), fO(), bi(P, f), aE(() => {
                P._isLeaving && (os(P, d), bi(P, h), oE(_) || lE(P, r, y, F))
            }), no(_, [P, F])
        },
        onEnterCancelled(P) {
            A(P, !1), no(v, [P])
        },
        onAppearCancelled(P) {
            A(P, !0), no(C, [P])
        },
        onLeaveCancelled(P) {
            T(P), no(x, [P])
        }
    })
}

function SU(t) {
    if (t == null) return null;
    if (Kv(t)) return [_m(t.enter), _m(t.leave)]; {
        const e = _m(t);
        return [e, e]
    }
}

function _m(t) {
    const e = Jv(t);
    return l_(e, "<transition> explicit duration"), e
}

function bi(t, e) {
    e.split(/\s+/).forEach(n => n && t.classList.add(n)), (t._vtc || (t._vtc = new Set)).add(e)
}

function os(t, e) {
    e.split(/\s+/).forEach(r => r && t.classList.remove(r));
    const {
        _vtc: n
    } = t;
    n && (n.delete(e), n.size || (t._vtc = void 0))
}

function aE(t) {
    requestAnimationFrame(() => {
        requestAnimationFrame(t)
    })
}
let TU = 0;

function lE(t, e, n, r) {
    const i = t._endId = ++TU,
        s = () => {
            i === t._endId && r()
        };
    if (n) return setTimeout(s, n);
    const {
        type: o,
        timeout: a,
        propCount: l
    } = dO(t, e);
    if (!o) return r();
    const c = o + "end";
    let u = 0;
    const d = () => {
            t.removeEventListener(c, f), s()
        },
        f = h => {
            h.target === t && ++u >= l && d()
        };
    setTimeout(() => {
        u < l && d()
    }, a + 1), t.addEventListener(c, f)
}

function dO(t, e) {
    const n = window.getComputedStyle(t),
        r = p => (n[p] || "").split(", "),
        i = r(`${es}Delay`),
        s = r(`${es}Duration`),
        o = cE(i, s),
        a = r(`${Xl}Delay`),
        l = r(`${Xl}Duration`),
        c = cE(a, l);
    let u = null,
        d = 0,
        f = 0;
    e === es ? o > 0 && (u = es, d = o, f = s.length) : e === Xl ? c > 0 && (u = Xl, d = c, f = l.length) : (d = Math.max(o, c), u = d > 0 ? o > c ? es : Xl : null, f = u ? u === es ? s.length : l.length : 0);
    const h = u === es && /\b(transform|all)(,|$)/.test(r(`${es}Property`).toString());
    return {
        type: u,
        timeout: d,
        propCount: f,
        hasTransform: h
    }
}

function cE(t, e) {
    for (; t.length < e.length;) t = t.concat(t);
    return Math.max(...e.map((n, r) => uE(n) + uE(t[r])))
}

function uE(t) {
    return Number(t.slice(0, -1).replace(",", ".")) * 1e3
}

function fO() {
    return document.body.offsetHeight
}
const hO = new WeakMap,
    pO = new WeakMap,
    mO = {
        name: "TransitionGroup",
        props: Vu({}, EU, {
            tag: String,
            moveClass: String
        }),
        setup(t, {
            slots: e
        }) {
            const n = it(),
                r = y_();
            let i, s;
            return la(() => {
                if (!i.length) return;
                const o = t.moveClass || `${t.name||"v"}-move`;
                if (!RU(i[0].el, n.vnode.el, o)) return;
                i.forEach(AU), i.forEach(OU);
                const a = i.filter(IU);
                fO(), a.forEach(l => {
                    const c = l.el,
                        u = c.style;
                    bi(c, o), u.transform = u.webkitTransform = u.transitionDuration = "";
                    const d = c._moveCb = f => {
                        f && f.target !== c || (!f || /transform$/.test(f.propertyName)) && (c.removeEventListener("transitionend", d), c._moveCb = null, os(c, o))
                    };
                    c.addEventListener("transitionend", d)
                })
            }), () => {
                const o = Oe(t),
                    a = uO(o);
                let l = o.tag || gt;
                i = s, s = e.default ? Kh(e.default()) : [];
                for (let c = 0; c < s.length; c++) {
                    const u = s[c];
                    u.key != null ? Uo(u, il(u, a, r, n)) : re("<TransitionGroup> children must be keyed.")
                }
                if (i)
                    for (let c = 0; c < i.length; c++) {
                        const u = i[c];
                        Uo(u, il(u, a, r, n)), hO.set(u, u.el.getBoundingClientRect())
                    }
                return I(l, null, s)
            }
        }
    },
    CU = t => delete t.mode;
mO.props;
const PU = mO;

function AU(t) {
    const e = t.el;
    e._moveCb && e._moveCb(), e._enterCb && e._enterCb()
}

function OU(t) {
    pO.set(t, t.el.getBoundingClientRect())
}

function IU(t) {
    const e = hO.get(t),
        n = pO.get(t),
        r = e.left - n.left,
        i = e.top - n.top;
    if (r || i) {
        const s = t.el.style;
        return s.transform = s.webkitTransform = `translate(${r}px,${i}px)`, s.transitionDuration = "0s", t
    }
}

function RU(t, e, n) {
    const r = t.cloneNode();
    t._vtc && t._vtc.forEach(o => {
        o.split(/\s+/).forEach(a => a && r.classList.remove(a))
    }), n.split(/\s+/).forEach(o => o && r.classList.add(o)), r.style.display = "none";
    const i = e.nodeType === 1 ? e : e.parentNode;
    i.appendChild(r);
    const {
        hasTransform: s
    } = dO(r);
    return i.removeChild(r), s
}
const ks = t => {
    const e = t.props["onUpdate:modelValue"] || !1;
    return $n(e) ? n => X4(e, n) : e
};

function MU(t) {
    t.target.composing = !0
}

function dE(t) {
    const e = t.target;
    e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")))
}
const nh = {
        created(t, {
            modifiers: {
                lazy: e,
                trim: n,
                number: r
            }
        }, i) {
            t._assign = ks(i);
            const s = r || i.props && i.props.type === "number";
            Pi(t, e ? "change" : "input", o => {
                if (o.target.composing) return;
                let a = t.value;
                n && (a = a.trim()), s && (a = qv(a)), t._assign(a)
            }), n && Pi(t, "change", () => {
                t.value = t.value.trim()
            }), e || (Pi(t, "compositionstart", MU), Pi(t, "compositionend", dE), Pi(t, "change", dE))
        },
        mounted(t, {
            value: e
        }) {
            t.value = e ? ? ""
        },
        beforeUpdate(t, {
            value: e,
            modifiers: {
                lazy: n,
                trim: r,
                number: i
            }
        }, s) {
            if (t._assign = ks(s), t.composing || document.activeElement === t && t.type !== "range" && (n || r && t.value.trim() === e || (i || t.type === "number") && qv(t.value) === e)) return;
            const o = e ? ? "";
            t.value !== o && (t.value = o)
        }
    },
    M_ = {
        deep: !0,
        created(t, e, n) {
            t._assign = ks(n), Pi(t, "change", () => {
                const r = t._modelValue,
                    i = ol(t),
                    s = t.checked,
                    o = t._assign;
                if ($n(r)) {
                    const a = rp(r, i),
                        l = a !== -1;
                    if (s && !l) o(r.concat(i));
                    else if (!s && l) {
                        const c = [...r];
                        c.splice(a, 1), o(c)
                    }
                } else if (Wu(r)) {
                    const a = new Set(r);
                    s ? a.add(i) : a.delete(i), o(a)
                } else o(vO(t, s))
            })
        },
        mounted: fE,
        beforeUpdate(t, e, n) {
            t._assign = ks(n), fE(t, e, n)
        }
    };

function fE(t, {
    value: e,
    oldValue: n
}, r) {
    t._modelValue = e, $n(e) ? t.checked = rp(e, r.props.value) > -1 : Wu(e) ? t.checked = e.has(r.props.value) : e !== n && (t.checked = Ms(e, vO(t, !0)))
}
const k_ = {
        created(t, {
            value: e
        }, n) {
            t.checked = Ms(e, n.props.value), t._assign = ks(n), Pi(t, "change", () => {
                t._assign(ol(t))
            })
        },
        beforeUpdate(t, {
            value: e,
            oldValue: n
        }, r) {
            t._assign = ks(r), e !== n && (t.checked = Ms(e, r.props.value))
        }
    },
    gO = {
        deep: !0,
        created(t, {
            value: e,
            modifiers: {
                number: n
            }
        }, r) {
            const i = Wu(e);
            Pi(t, "change", () => {
                const s = Array.prototype.filter.call(t.options, o => o.selected).map(o => n ? qv(ol(o)) : ol(o));
                t._assign(t.multiple ? i ? new Set(s) : s : s[0])
            }), t._assign = ks(r)
        },
        mounted(t, {
            value: e
        }) {
            hE(t, e)
        },
        beforeUpdate(t, e, n) {
            t._assign = ks(n)
        },
        updated(t, {
            value: e
        }) {
            hE(t, e)
        }
    };

function hE(t, e) {
    const n = t.multiple;
    if (n && !$n(e) && !Wu(e)) {
        re(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8,-1)}.`);
        return
    }
    for (let r = 0, i = t.options.length; r < i; r++) {
        const s = t.options[r],
            o = ol(s);
        if (n) $n(e) ? s.selected = rp(e, o) > -1 : s.selected = e.has(o);
        else if (Ms(ol(s), e)) {
            t.selectedIndex !== r && (t.selectedIndex = r);
            return
        }
    }!n && t.selectedIndex !== -1 && (t.selectedIndex = -1)
}

function ol(t) {
    return "_value" in t ? t._value : t.value
}

function vO(t, e) {
    const n = e ? "_trueValue" : "_falseValue";
    return n in t ? t[n] : e
}
const yO = {
    created(t, e, n) {
        Td(t, e, n, null, "created")
    },
    mounted(t, e, n) {
        Td(t, e, n, null, "mounted")
    },
    beforeUpdate(t, e, n, r) {
        Td(t, e, n, r, "beforeUpdate")
    },
    updated(t, e, n, r) {
        Td(t, e, n, r, "updated")
    }
};

function _O(t, e) {
    switch (t) {
        case "SELECT":
            return gO;
        case "TEXTAREA":
            return nh;
        default:
            switch (e) {
                case "checkbox":
                    return M_;
                case "radio":
                    return k_;
                default:
                    return nh
            }
    }
}

function Td(t, e, n, r, i) {
    const o = _O(t.tagName, n.props && n.props.type)[i];
    o && o(t, e, n, r)
}

function kU() {
    nh.getSSRProps = ({
        value: t
    }) => ({
        value: t
    }), k_.getSSRProps = ({
        value: t
    }, e) => {
        if (e.props && Ms(e.props.value, t)) return {
            checked: !0
        }
    }, M_.getSSRProps = ({
        value: t
    }, e) => {
        if ($n(t)) {
            if (e.props && rp(t, e.props.value) > -1) return {
                checked: !0
            }
        } else if (Wu(t)) {
            if (e.props && t.has(e.props.value)) return {
                checked: !0
            }
        } else if (t) return {
            checked: !0
        }
    }, yO.getSSRProps = (t, e) => {
        if (typeof e.type != "string") return;
        const n = _O(e.type.toUpperCase(), e.props && e.props.type);
        if (n.getSSRProps) return n.getSSRProps(t, e)
    }
}
const BU = ["ctrl", "shift", "alt", "meta"],
    DU = {
        stop: t => t.stopPropagation(),
        prevent: t => t.preventDefault(),
        self: t => t.target !== t.currentTarget,
        ctrl: t => !t.ctrlKey,
        shift: t => !t.shiftKey,
        alt: t => !t.altKey,
        meta: t => !t.metaKey,
        left: t => "button" in t && t.button !== 0,
        middle: t => "button" in t && t.button !== 1,
        right: t => "button" in t && t.button !== 2,
        exact: (t, e) => BU.some(n => t[`${n}Key`] && !e.includes(n))
    },
    $U = (t, e) => (n, ...r) => {
        for (let i = 0; i < e.length; i++) {
            const s = DU[e[i]];
            if (s && s(n, e)) return
        }
        return t(n, ...r)
    },
    FU = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
    },
    bO = (t, e) => n => {
        if (!("key" in n)) return;
        const r = ds(n.key);
        if (e.some(i => i === r || FU[i] === r)) return t(n)
    },
    Ar = {
        beforeMount(t, {
            value: e
        }, {
            transition: n
        }) {
            t._vod = t.style.display === "none" ? "" : t.style.display, n && e ? n.beforeEnter(t) : Kl(t, e)
        },
        mounted(t, {
            value: e
        }, {
            transition: n
        }) {
            n && e && n.enter(t)
        },
        updated(t, {
            value: e,
            oldValue: n
        }, {
            transition: r
        }) {
            !e != !n && (r ? e ? (r.beforeEnter(t), Kl(t, !0), r.enter(t)) : r.leave(t, () => {
                Kl(t, !1)
            }) : Kl(t, e))
        },
        beforeUnmount(t, {
            value: e
        }) {
            Kl(t, e)
        }
    };

function Kl(t, e) {
    t.style.display = e ? t._vod : "none"
}

function LU() {
    Ar.getSSRProps = ({
        value: t
    }) => {
        if (!t) return {
            style: {
                display: "none"
            }
        }
    }
}
const xO = Vu({
    patchProp: vU
}, rU);
let Rc, pE = !1;

function wO() {
    return Rc || (Rc = UA(xO))
}

function EO() {
    return Rc = pE ? Rc : GA(xO), pE = !0, Rc
}
const ty = (...t) => {
        wO().render(...t)
    },
    SO = (...t) => {
        EO().hydrate(...t)
    },
    TO = (...t) => {
        const e = wO().createApp(...t);
        CO(e), PO(e);
        const {
            mount: n
        } = e;
        return e.mount = r => {
            const i = AO(r);
            if (!i) return;
            const s = e._component;
            !sO(s) && !s.render && !s.template && (s.template = i.innerHTML), i.innerHTML = "";
            const o = n(i, !1, i instanceof SVGElement);
            return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), o
        }, e
    },
    NU = (...t) => {
        const e = EO().createApp(...t);
        CO(e), PO(e);
        const {
            mount: n
        } = e;
        return e.mount = r => {
            const i = AO(r);
            if (i) return n(i, !0, i instanceof SVGElement)
        }, e
    };

function CO(t) {
    Object.defineProperty(t.config, "isNativeTag", {
        value: e => J4(e) || Z4(e),
        writable: !1
    })
}

function PO(t) {
    if (O_()) {
        const e = t.config.isCustomElement;
        Object.defineProperty(t.config, "isCustomElement", {
            get() {
                return e
            },
            set() {
                re("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.")
            }
        });
        const n = t.config.compilerOptions,
            r = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
        Object.defineProperty(t.config, "compilerOptions", {
            get() {
                return re(r), n
            },
            set() {
                re(r)
            }
        })
    }
}

function AO(t) {
    if (su(t)) {
        const e = document.querySelector(t);
        return e || re(`Failed to mount app: mount target selector "${t}" returned null.`), e
    }
    return window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === "closed" && re('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'), t
}
let mE = !1;
const UU = () => {
    mE || (mE = !0, kU(), LU())
};

function GU() {
    rO()
}
GU();
const HU = () => {
        re('Runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".')
    },
    zU = Object.freeze(Object.defineProperty({
        __proto__: null,
        BaseTransition: _A,
        BaseTransitionPropsValidators: __,
        Comment: Ot,
        EffectScope: e_,
        Fragment: gt,
        KeepAlive: EN,
        ReactiveEffect: $u,
        Static: Ts,
        Suspense: fN,
        Teleport: S_,
        Text: ii,
        Transition: Yu,
        TransitionGroup: PU,
        VueElement: ip,
        assertNumber: l_,
        callWithAsyncErrorHandling: Wn,
        callWithErrorHandling: ei,
        camelize: Rr,
        capitalize: rl,
        cloneVNode: hr,
        compatUtils: U4,
        compile: HU,
        computed: ne,
        createApp: TO,
        createBlock: T_,
        createCommentVNode: C4,
        createElementBlock: x4,
        createElementVNode: C_,
        createHydrationRenderer: GA,
        createPropsRestProxy: XN,
        createRenderer: UA,
        createSSRApp: NU,
        createSlots: ON,
        createStaticVNode: T4,
        createTextVNode: ep,
        createVNode: I,
        customRef: ZP,
        defineAsyncComponent: xN,
        defineComponent: ye,
        defineCustomElement: lO,
        defineEmits: FN,
        defineExpose: LN,
        defineModel: GN,
        defineOptions: NN,
        defineProps: $N,
        defineSSRCustomElement: _U,
        defineSlots: UN,
        get devtools() {
            return br
        },
        effect: FF,
        effectScope: Bu,
        getCurrentInstance: it,
        getCurrentScope: Du,
        getTransitionRawChildren: Kh,
        guardReactiveProps: YA,
        h: qt,
        handleError: aa,
        hasInjectionContext: kA,
        hydrate: SO,
        initCustomFormatter: rO,
        initDirectivesForSSR: UU,
        inject: Nt,
        isMemoSame: iO,
        isProxy: qc,
        isReactive: Tr,
        isReadonly: Ui,
        isRef: tt,
        isRuntimeOnly: O_,
        isShallow: Kc,
        isVNode: si,
        markRaw: Zr,
        mergeDefaults: WN,
        mergeModels: YN,
        mergeProps: et,
        nextTick: Ue,
        normalizeClass: Gu,
        normalizeProps: DL,
        normalizeStyle: Uu,
        onActivated: zs,
        onBeforeMount: wA,
        onBeforeUnmount: er,
        onBeforeUpdate: Jh,
        onDeactivated: Yi,
        onErrorCaptured: CA,
        onMounted: St,
        onRenderTracked: TA,
        onRenderTriggered: SA,
        onScopeDispose: t_,
        onServerPrefetch: EA,
        onUnmounted: Ki,
        onUpdated: la,
        openBlock: Zh,
        popScopeId: sN,
        provide: Pr,
        proxyRefs: o_,
        pushScopeId: iN,
        queuePostFlushCb: Wh,
        reactive: ht,
        readonly: oa,
        ref: J,
        registerRuntimeCompiler: R4,
        render: ty,
        renderList: AN,
        renderSlot: IN,
        resolveComponent: CN,
        resolveDirective: AA,
        resolveDynamicComponent: PN,
        resolveFilter: N4,
        resolveTransitionHooks: il,
        setBlockTracking: zv,
        setDevtoolsHook: f_,
        setTransitionHooks: Uo,
        shallowReactive: qP,
        shallowReadonly: Ua,
        shallowRef: zh,
        ssrContextKey: tO,
        ssrUtils: L4,
        stop: LF,
        toDisplayString: $L,
        toHandlerKey: Si,
        toHandlers: RN,
        toRaw: Oe,
        toRef: Ec,
        toRefs: Ov,
        toValue: hL,
        transformVNodeArgs: w4,
        triggerRef: fL,
        unref: En,
        useAttrs: jN,
        useCssModule: xU,
        useCssVars: wU,
        useModel: VN,
        useSSRContext: nO,
        useSlots: zN,
        useTransitionState: y_,
        vModelCheckbox: M_,
        vModelDynamic: yO,
        vModelRadio: k_,
        vModelSelect: gO,
        vModelText: nh,
        vShow: Ar,
        version: Xv,
        warn: re,
        watch: pe,
        watchEffect: Il,
        watchPostEffect: gA,
        watchSyncEffect: yN,
        withAsyncContext: KN,
        withCtx: p_,
        withDefaults: HN,
        withDirectives: Cr,
        withKeys: bO,
        withMemo: $4,
        withModifiers: $U,
        withScopeId: oN
    }, Symbol.toStringTag, {
        value: "Module"
    }));
var jU = !1;

function Cd(t, e, n) {
    return Array.isArray(t) ? (t.length = Math.max(t.length, e), t.splice(e, 1, n), n) : (t[e] = n, n)
}

function bm(t, e) {
    if (Array.isArray(t)) {
        t.splice(e, 1);
        return
    }
    delete t[e]
}

function VU() {
    return OO().__VUE_DEVTOOLS_GLOBAL_HOOK__
}

function OO() {
    return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {}
}
const WU = typeof Proxy == "function",
    YU = "devtools-plugin:setup",
    XU = "plugin:settings:set";
let ya, ny;

function KU() {
    var t;
    return ya !== void 0 || (typeof window < "u" && window.performance ? (ya = !0, ny = window.performance) : typeof globalThis < "u" && (!((t = globalThis.perf_hooks) === null || t === void 0) && t.performance) ? (ya = !0, ny = globalThis.perf_hooks.performance) : ya = !1), ya
}

function qU() {
    return KU() ? ny.now() : Date.now()
}
class JU {
    constructor(e, n) {
        this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = e, this.hook = n;
        const r = {};
        if (e.settings)
            for (const o in e.settings) {
                const a = e.settings[o];
                r[o] = a.defaultValue
            }
        const i = `__vue-devtools-plugin-settings__${e.id}`;
        let s = Object.assign({}, r);
        try {
            const o = localStorage.getItem(i),
                a = JSON.parse(o);
            Object.assign(s, a)
        } catch {}
        this.fallbacks = {
            getSettings() {
                return s
            },
            setSettings(o) {
                try {
                    localStorage.setItem(i, JSON.stringify(o))
                } catch {}
                s = o
            },
            now() {
                return qU()
            }
        }, n && n.on(XU, (o, a) => {
            o === this.plugin.id && this.fallbacks.setSettings(a)
        }), this.proxiedOn = new Proxy({}, {
            get: (o, a) => this.target ? this.target.on[a] : (...l) => {
                this.onQueue.push({
                    method: a,
                    args: l
                })
            }
        }), this.proxiedTarget = new Proxy({}, {
            get: (o, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...l) => (this.targetQueue.push({
                method: a,
                args: l,
                resolve: () => {}
            }), this.fallbacks[a](...l)) : (...l) => new Promise(c => {
                this.targetQueue.push({
                    method: a,
                    args: l,
                    resolve: c
                })
            })
        })
    }
    async setRealTarget(e) {
        this.target = e;
        for (const n of this.onQueue) this.target.on[n.method](...n.args);
        for (const n of this.targetQueue) n.resolve(await this.target[n.method](...n.args))
    }
}

function sp(t, e) {
    const n = t,
        r = OO(),
        i = VU(),
        s = WU && n.enableEarlyProxy;
    if (i && (r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !s)) i.emit(YU, t, e);
    else {
        const o = s ? new JU(n, i) : null;
        (r.__VUE_DEVTOOLS_PLUGINS__ = r.__VUE_DEVTOOLS_PLUGINS__ || []).push({
            pluginDescriptor: n,
            setupFn: e,
            proxy: o
        }), o && e(o.proxiedTarget)
    }
}
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let ry;
const ou = t => ry = t,
    IO = Symbol("pinia");

function Ho(t) {
    return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function"
}
var ti;
(function(t) {
    t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function"
})(ti || (ti = {}));
const ko = typeof window < "u",
    gE = (() => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : {
        HTMLElement: null
    })();

function ZU(t, {
    autoBom: e = !1
} = {}) {
    return e && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t], {
        type: t.type
    }) : t
}

function B_(t, e, n) {
    const r = new XMLHttpRequest;
    r.open("GET", t), r.responseType = "blob", r.onload = function() {
        kO(r.response, e, n)
    }, r.onerror = function() {
        console.error("could not download file")
    }, r.send()
}

function RO(t) {
    const e = new XMLHttpRequest;
    e.open("HEAD", t, !1);
    try {
        e.send()
    } catch {}
    return e.status >= 200 && e.status <= 299
}

function wf(t) {
    try {
        t.dispatchEvent(new MouseEvent("click"))
    } catch {
        const n = document.createEvent("MouseEvents");
        n.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), t.dispatchEvent(n)
    }
}
const Ef = typeof navigator == "object" ? navigator : {
        userAgent: ""
    },
    MO = (() => /Macintosh/.test(Ef.userAgent) && /AppleWebKit/.test(Ef.userAgent) && !/Safari/.test(Ef.userAgent))(),
    kO = ko ? typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype && !MO ? QU : "msSaveOrOpenBlob" in Ef ? eG : tG : () => {};

function QU(t, e = "download", n) {
    const r = document.createElement("a");
    r.download = e, r.rel = "noopener", typeof t == "string" ? (r.href = t, r.origin !== location.origin ? RO(r.href) ? B_(t, e, n) : (r.target = "_blank", wf(r)) : wf(r)) : (r.href = URL.createObjectURL(t), setTimeout(function() {
        URL.revokeObjectURL(r.href)
    }, 4e4), setTimeout(function() {
        wf(r)
    }, 0))
}

function eG(t, e = "download", n) {
    if (typeof t == "string")
        if (RO(t)) B_(t, e, n);
        else {
            const r = document.createElement("a");
            r.href = t, r.target = "_blank", setTimeout(function() {
                wf(r)
            })
        }
    else navigator.msSaveOrOpenBlob(ZU(t, n), e)
}

function tG(t, e, n, r) {
    if (r = r || open("", "_blank"), r && (r.document.title = r.document.body.innerText = "downloading..."), typeof t == "string") return B_(t, e, n);
    const i = t.type === "application/octet-stream",
        s = /constructor/i.test(String(gE.HTMLElement)) || "safari" in gE,
        o = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((o || i && s || MO) && typeof FileReader < "u") {
        const a = new FileReader;
        a.onloadend = function() {
            let l = a.result;
            if (typeof l != "string") throw r = null, new Error("Wrong reader.result type");
            l = o ? l : l.replace(/^data:[^;]*;/, "data:attachment/file;"), r ? r.location.href = l : location.assign(l), r = null
        }, a.readAsDataURL(t)
    } else {
        const a = URL.createObjectURL(t);
        r ? r.location.assign(a) : location.href = a, r = null, setTimeout(function() {
            URL.revokeObjectURL(a)
        }, 4e4)
    }
}

function Kt(t, e) {
    const n = "🍍 " + t;
    typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(n, e) : e === "error" ? console.error(n) : e === "warn" ? console.warn(n) : console.log(n)
}

function D_(t) {
    return "_a" in t && "install" in t
}

function BO() {
    if (!("clipboard" in navigator)) return Kt("Your browser doesn't support the Clipboard API", "error"), !0
}

function DO(t) {
    return t instanceof Error && t.message.toLowerCase().includes("document is not focused") ? (Kt('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"), !0) : !1
}
async function nG(t) {
    if (!BO()) try {
        await navigator.clipboard.writeText(JSON.stringify(t.state.value)), Kt("Global state copied to clipboard.")
    } catch (e) {
        if (DO(e)) return;
        Kt("Failed to serialize the state. Check the console for more details.", "error"), console.error(e)
    }
}
async function rG(t) {
    if (!BO()) try {
        $O(t, JSON.parse(await navigator.clipboard.readText())), Kt("Global state pasted from clipboard.")
    } catch (e) {
        if (DO(e)) return;
        Kt("Failed to deserialize the state from clipboard. Check the console for more details.", "error"), console.error(e)
    }
}
async function iG(t) {
    try {
        kO(new Blob([JSON.stringify(t.state.value)], {
            type: "text/plain;charset=utf-8"
        }), "pinia-state.json")
    } catch (e) {
        Kt("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e)
    }
}
let di;

function sG() {
    di || (di = document.createElement("input"), di.type = "file", di.accept = ".json");

    function t() {
        return new Promise((e, n) => {
            di.onchange = async () => {
                const r = di.files;
                if (!r) return e(null);
                const i = r.item(0);
                return e(i ? {
                    text: await i.text(),
                    file: i
                } : null)
            }, di.oncancel = () => e(null), di.onerror = n, di.click()
        })
    }
    return t
}
async function oG(t) {
    try {
        const n = await sG()();
        if (!n) return;
        const {
            text: r,
            file: i
        } = n;
        $O(t, JSON.parse(r)), Kt(`Global state imported from "${i.name}".`)
    } catch (e) {
        Kt("Failed to import the state from JSON. Check the console for more details.", "error"), console.error(e)
    }
}

function $O(t, e) {
    for (const n in e) {
        const r = t.state.value[n];
        r ? Object.assign(r, e[n]) : t.state.value[n] = e[n]
    }
}

function _r(t) {
    return {
        _custom: {
            display: t
        }
    }
}
const FO = "🍍 Pinia (root)",
    Sf = "_root";

function aG(t) {
    return D_(t) ? {
        id: Sf,
        label: FO
    } : {
        id: t.$id,
        label: t.$id
    }
}

function lG(t) {
    if (D_(t)) {
        const n = Array.from(t._s.keys()),
            r = t._s;
        return {
            state: n.map(s => ({
                editable: !0,
                key: s,
                value: t.state.value[s]
            })),
            getters: n.filter(s => r.get(s)._getters).map(s => {
                const o = r.get(s);
                return {
                    editable: !1,
                    key: s,
                    value: o._getters.reduce((a, l) => (a[l] = o[l], a), {})
                }
            })
        }
    }
    const e = {
        state: Object.keys(t.$state).map(n => ({
            editable: !0,
            key: n,
            value: t.$state[n]
        }))
    };
    return t._getters && t._getters.length && (e.getters = t._getters.map(n => ({
        editable: !1,
        key: n,
        value: t[n]
    }))), t._customProperties.size && (e.customProperties = Array.from(t._customProperties).map(n => ({
        editable: !0,
        key: n,
        value: t[n]
    }))), e
}

function cG(t) {
    return t ? Array.isArray(t) ? t.reduce((e, n) => (e.keys.push(n.key), e.operations.push(n.type), e.oldValue[n.key] = n.oldValue, e.newValue[n.key] = n.newValue, e), {
        oldValue: {},
        keys: [],
        operations: [],
        newValue: {}
    }) : {
        operation: _r(t.type),
        key: _r(t.key),
        oldValue: t.oldValue,
        newValue: t.newValue
    } : {}
}

function uG(t) {
    switch (t) {
        case ti.direct:
            return "mutation";
        case ti.patchFunction:
            return "$patch";
        case ti.patchObject:
            return "$patch";
        default:
            return "unknown"
    }
}
let Ga = !0;
const Tf = [],
    lo = "pinia:mutations",
    an = "pinia",
    {
        assign: dG
    } = Object,
    rh = t => "🍍 " + t;

function fG(t, e) {
    sp({
        id: "dev.esm.pinia",
        label: "Pinia 🍍",
        logo: "https://pinia.vuejs.org/logo.svg",
        packageName: "pinia",
        homepage: "https://pinia.vuejs.org",
        componentStateTypes: Tf,
        app: t
    }, n => {
        typeof n.now != "function" && Kt("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), n.addTimelineLayer({
            id: lo,
            label: "Pinia 🍍",
            color: 15064968
        }), n.addInspector({
            id: an,
            label: "Pinia 🍍",
            icon: "storage",
            treeFilterPlaceholder: "Search stores",
            actions: [{
                icon: "content_copy",
                action: () => {
                    nG(e)
                },
                tooltip: "Serialize and copy the state"
            }, {
                icon: "content_paste",
                action: async () => {
                    await rG(e), n.sendInspectorTree(an), n.sendInspectorState(an)
                },
                tooltip: "Replace the state with the content of your clipboard"
            }, {
                icon: "save",
                action: () => {
                    iG(e)
                },
                tooltip: "Save the state as a JSON file"
            }, {
                icon: "folder_open",
                action: async () => {
                    await oG(e), n.sendInspectorTree(an), n.sendInspectorState(an)
                },
                tooltip: "Import the state from a JSON file"
            }],
            nodeActions: [{
                icon: "restore",
                tooltip: 'Reset the state (with "$reset")',
                action: r => {
                    const i = e._s.get(r);
                    i ? typeof i.$reset != "function" ? Kt(`Cannot reset "${r}" store because it doesn't have a "$reset" method implemented.`, "warn") : (i.$reset(), Kt(`Store "${r}" reset.`)) : Kt(`Cannot reset "${r}" store because it wasn't found.`, "warn")
                }
            }]
        }), n.on.inspectComponent((r, i) => {
            const s = r.componentInstance && r.componentInstance.proxy;
            if (s && s._pStores) {
                const o = r.componentInstance.proxy._pStores;
                Object.values(o).forEach(a => {
                    r.instanceData.state.push({
                        type: rh(a.$id),
                        key: "state",
                        editable: !0,
                        value: a._isOptionsAPI ? {
                            _custom: {
                                value: Oe(a.$state),
                                actions: [{
                                    icon: "restore",
                                    tooltip: "Reset the state of this store",
                                    action: () => a.$reset()
                                }]
                            }
                        } : Object.keys(a.$state).reduce((l, c) => (l[c] = a.$state[c], l), {})
                    }), a._getters && a._getters.length && r.instanceData.state.push({
                        type: rh(a.$id),
                        key: "getters",
                        editable: !1,
                        value: a._getters.reduce((l, c) => {
                            try {
                                l[c] = a[c]
                            } catch (u) {
                                l[c] = u
                            }
                            return l
                        }, {})
                    })
                })
            }
        }), n.on.getInspectorTree(r => {
            if (r.app === t && r.inspectorId === an) {
                let i = [e];
                i = i.concat(Array.from(e._s.values())), r.rootNodes = (r.filter ? i.filter(s => "$id" in s ? s.$id.toLowerCase().includes(r.filter.toLowerCase()) : FO.toLowerCase().includes(r.filter.toLowerCase())) : i).map(aG)
            }
        }), globalThis.$pinia = e, n.on.getInspectorState(r => {
            if (r.app === t && r.inspectorId === an) {
                const i = r.nodeId === Sf ? e : e._s.get(r.nodeId);
                if (!i) return;
                i && (r.nodeId !== Sf && (globalThis.$store = Oe(i)), r.state = lG(i))
            }
        }), n.on.editInspectorState((r, i) => {
            if (r.app === t && r.inspectorId === an) {
                const s = r.nodeId === Sf ? e : e._s.get(r.nodeId);
                if (!s) return Kt(`store "${r.nodeId}" not found`, "error");
                const {
                    path: o
                } = r;
                D_(s) ? o.unshift("state") : (o.length !== 1 || !s._customProperties.has(o[0]) || o[0] in s.$state) && o.unshift("$state"), Ga = !1, r.set(s, o, r.state.value), Ga = !0
            }
        }), n.on.editComponentState(r => {
            if (r.type.startsWith("🍍")) {
                const i = r.type.replace(/^🍍\s*/, ""),
                    s = e._s.get(i);
                if (!s) return Kt(`store "${i}" not found`, "error");
                const {
                    path: o
                } = r;
                if (o[0] !== "state") return Kt(`Invalid path for store "${i}":
${o}
Only state can be modified.`);
                o[0] = "$state", Ga = !1, r.set(s, o, r.state.value), Ga = !0
            }
        })
    })
}

function hG(t, e) {
    Tf.includes(rh(e.$id)) || Tf.push(rh(e.$id)), sp({
        id: "dev.esm.pinia",
        label: "Pinia 🍍",
        logo: "https://pinia.vuejs.org/logo.svg",
        packageName: "pinia",
        homepage: "https://pinia.vuejs.org",
        componentStateTypes: Tf,
        app: t,
        settings: {
            logStoreChanges: {
                label: "Notify about new/deleted stores",
                type: "boolean",
                defaultValue: !0
            }
        }
    }, n => {
        const r = typeof n.now == "function" ? n.now.bind(n) : Date.now;
        e.$onAction(({
            after: o,
            onError: a,
            name: l,
            args: c
        }) => {
            const u = LO++;
            n.addTimelineEvent({
                layerId: lo,
                event: {
                    time: r(),
                    title: "🛫 " + l,
                    subtitle: "start",
                    data: {
                        store: _r(e.$id),
                        action: _r(l),
                        args: c
                    },
                    groupId: u
                }
            }), o(d => {
                ps = void 0, n.addTimelineEvent({
                    layerId: lo,
                    event: {
                        time: r(),
                        title: "🛬 " + l,
                        subtitle: "end",
                        data: {
                            store: _r(e.$id),
                            action: _r(l),
                            args: c,
                            result: d
                        },
                        groupId: u
                    }
                })
            }), a(d => {
                ps = void 0, n.addTimelineEvent({
                    layerId: lo,
                    event: {
                        time: r(),
                        logType: "error",
                        title: "💥 " + l,
                        subtitle: "end",
                        data: {
                            store: _r(e.$id),
                            action: _r(l),
                            args: c,
                            error: d
                        },
                        groupId: u
                    }
                })
            })
        }, !0), e._customProperties.forEach(o => {
            pe(() => En(e[o]), (a, l) => {
                n.notifyComponentUpdate(), n.sendInspectorState(an), Ga && n.addTimelineEvent({
                    layerId: lo,
                    event: {
                        time: r(),
                        title: "Change",
                        subtitle: o,
                        data: {
                            newValue: a,
                            oldValue: l
                        },
                        groupId: ps
                    }
                })
            }, {
                deep: !0
            })
        }), e.$subscribe(({
            events: o,
            type: a
        }, l) => {
            if (n.notifyComponentUpdate(), n.sendInspectorState(an), !Ga) return;
            const c = {
                time: r(),
                title: uG(a),
                data: dG({
                    store: _r(e.$id)
                }, cG(o)),
                groupId: ps
            };
            a === ti.patchFunction ? c.subtitle = "⤵️" : a === ti.patchObject ? c.subtitle = "🧩" : o && !Array.isArray(o) && (c.subtitle = o.type), o && (c.data["rawEvent(s)"] = {
                _custom: {
                    display: "DebuggerEvent",
                    type: "object",
                    tooltip: "raw DebuggerEvent[]",
                    value: o
                }
            }), n.addTimelineEvent({
                layerId: lo,
                event: c
            })
        }, {
            detached: !0,
            flush: "sync"
        });
        const i = e._hotUpdate;
        e._hotUpdate = Zr(o => {
            i(o), n.addTimelineEvent({
                layerId: lo,
                event: {
                    time: r(),
                    title: "🔥 " + e.$id,
                    subtitle: "HMR update",
                    data: {
                        store: _r(e.$id),
                        info: _r("HMR update")
                    }
                }
            }), n.notifyComponentUpdate(), n.sendInspectorTree(an), n.sendInspectorState(an)
        });
        const {
            $dispose: s
        } = e;
        e.$dispose = () => {
            s(), n.notifyComponentUpdate(), n.sendInspectorTree(an), n.sendInspectorState(an), n.getSettings().logStoreChanges && Kt(`Disposed "${e.$id}" store 🗑`)
        }, n.notifyComponentUpdate(), n.sendInspectorTree(an), n.sendInspectorState(an), n.getSettings().logStoreChanges && Kt(`"${e.$id}" store installed 🆕`)
    })
}
let LO = 0,
    ps;

function vE(t, e, n) {
    const r = e.reduce((i, s) => (i[s] = Oe(t)[s], i), {});
    for (const i in r) t[i] = function() {
        const s = LO,
            o = n ? new Proxy(t, {
                get(...l) {
                    return ps = s, Reflect.get(...l)
                },
                set(...l) {
                    return ps = s, Reflect.set(...l)
                }
            }) : t;
        ps = s;
        const a = r[i].apply(o, arguments);
        return ps = void 0, a
    }
}

function pG({
    app: t,
    store: e,
    options: n
}) {
    if (!e.$id.startsWith("__hot:")) {
        if (e._isOptionsAPI = !!n.state, !e._p._testing) {
            vE(e, Object.keys(n.actions), e._isOptionsAPI);
            const r = e._hotUpdate;
            Oe(e)._hotUpdate = function(i) {
                r.apply(this, arguments), vE(e, Object.keys(i._hmrPayload.actions), !!e._isOptionsAPI)
            }
        }
        hG(t, e)
    }
}

function D0e() {
    const t = Bu(!0),
        e = t.run(() => J({}));
    let n = [],
        r = [];
    const i = Zr({
        install(s) {
            ou(i), i._a = s, s.provide(IO, i), s.config.globalProperties.$pinia = i, ko && fG(s, i), r.forEach(o => n.push(o)), r = []
        },
        use(s) {
            return !this._a && !jU ? r.push(s) : n.push(s), this
        },
        _p: n,
        _a: null,
        _e: t,
        _s: new Map,
        state: e
    });
    return ko && typeof Proxy < "u" && i.use(pG), i
}

function NO(t, e) {
    for (const n in e) {
        const r = e[n];
        if (!(n in t)) continue;
        const i = t[n];
        Ho(i) && Ho(r) && !tt(r) && !Tr(r) ? t[n] = NO(i, r) : t[n] = r
    }
    return t
}
const mG = () => {};

function yE(t, e, n, r = mG) {
    t.push(e);
    const i = () => {
        const s = t.indexOf(e);
        s > -1 && (t.splice(s, 1), r())
    };
    return !n && Du() && t_(i), i
}

function _a(t, ...e) {
    t.slice().forEach(n => {
        n(...e)
    })
}
const gG = t => t(),
    _E = Symbol(),
    xm = Symbol();

function iy(t, e) {
    t instanceof Map && e instanceof Map ? e.forEach((n, r) => t.set(r, n)) : t instanceof Set && e instanceof Set && e.forEach(t.add, t);
    for (const n in e) {
        if (!e.hasOwnProperty(n)) continue;
        const r = e[n],
            i = t[n];
        Ho(i) && Ho(r) && t.hasOwnProperty(n) && !tt(r) && !Tr(r) ? t[n] = iy(i, r) : t[n] = r
    }
    return t
}
const vG = Symbol("pinia:skipHydration");

function yG(t) {
    return !Ho(t) || !t.hasOwnProperty(vG)
}
const {
    assign: lr
} = Object;

function bE(t) {
    return !!(tt(t) && t.effect)
}

function xE(t, e, n, r) {
    const {
        state: i,
        actions: s,
        getters: o
    } = e, a = n.state.value[t];
    let l;

    function c() {
        !a && !r && (n.state.value[t] = i ? i() : {});
        const u = Ov(r ? J(i ? i() : {}).value : n.state.value[t]);
        return lr(u, s, Object.keys(o || {}).reduce((d, f) => (f in u && console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "${f}" in store "${t}".`), d[f] = Zr(ne(() => {
            ou(n);
            const h = n._s.get(t);
            return o[f].call(h, h)
        })), d), {}))
    }
    return l = sy(t, c, e, n, r, !0), l
}

function sy(t, e, n = {}, r, i, s) {
    let o;
    const a = lr({
        actions: {}
    }, n);
    if (!r._e.active) throw new Error("Pinia destroyed");
    const l = {
        deep: !0
    };
    l.onTrigger = T => {
        c ? h = T : c == !1 && !S._hotUpdating && (Array.isArray(h) ? h.push(T) : console.error("🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug."))
    };
    let c, u, d = [],
        f = [],
        h;
    const p = r.state.value[t];
    !s && !p && !i && (r.state.value[t] = {});
    const b = J({});
    let y;

    function m(T) {
        let E;
        c = u = !1, h = [], typeof T == "function" ? (T(r.state.value[t]), E = {
            type: ti.patchFunction,
            storeId: t,
            events: h
        }) : (iy(r.state.value[t], T), E = {
            type: ti.patchObject,
            payload: T,
            storeId: t,
            events: h
        });
        const P = y = Symbol();
        Ue().then(() => {
            y === P && (c = !0)
        }), u = !0, _a(d, E, r.state.value[t])
    }
    const g = s ? function() {
        const {
            state: E
        } = n, P = E ? E() : {};
        this.$patch(B => {
            lr(B, P)
        })
    } : () => {
        throw new Error(`🍍: Store "${t}" is built using the setup syntax and does not implement $reset().`)
    };

    function v() {
        o.stop(), d = [], f = [], r._s.delete(t)
    }
    const _ = (T, E = "") => {
            if (_E in T) return T[xm] = E, T;
            const P = function() {
                ou(r);
                const B = Array.from(arguments),
                    F = [],
                    H = [];

                function k(Y) {
                    F.push(Y)
                }

                function N(Y) {
                    H.push(Y)
                }
                _a(f, {
                    args: B,
                    name: P[xm],
                    store: S,
                    after: k,
                    onError: N
                });
                let V;
                try {
                    V = T.apply(this && this.$id === t ? this : S, B)
                } catch (Y) {
                    throw _a(H, Y), Y
                }
                return V instanceof Promise ? V.then(Y => (_a(F, Y), Y)).catch(Y => (_a(H, Y), Promise.reject(Y))) : (_a(F, V), V)
            };
            return P[_E] = !0, P[xm] = E, P
        },
        x = Zr({
            actions: {},
            getters: {},
            state: [],
            hotState: b
        }),
        w = {
            _p: r,
            $id: t,
            $onAction: yE.bind(null, f),
            $patch: m,
            $reset: g,
            $subscribe(T, E = {}) {
                const P = yE(d, T, E.detached, () => B()),
                    B = o.run(() => pe(() => r.state.value[t], F => {
                        (E.flush === "sync" ? u : c) && T({
                            storeId: t,
                            type: ti.direct,
                            events: h
                        }, F)
                    }, lr({}, l, E)));
                return P
            },
            $dispose: v
        },
        S = ht(lr({
            _hmrPayload: x,
            _customProperties: Zr(new Set)
        }, w));
    r._s.set(t, S);
    const A = (r._a && r._a.runWithContext || gG)(() => r._e.run(() => (o = Bu()).run(() => e({
        action: _
    }))));
    for (const T in A) {
        const E = A[T];
        if (tt(E) && !bE(E) || Tr(E)) i ? Cd(b.value, T, Ec(A, T)) : s || (p && yG(E) && (tt(E) ? E.value = p[T] : iy(E, p[T])), r.state.value[t][T] = E), x.state.push(T);
        else if (typeof E == "function") {
            const P = i ? E : _(E, T);
            A[T] = P, x.actions[T] = E, a.actions[T] = E
        } else bE(E) && (x.getters[T] = s ? n.getters[T] : E, ko && (A._getters || (A._getters = Zr([]))).push(T))
    }
    if (lr(S, A), lr(Oe(S), A), Object.defineProperty(S, "$state", {
            get: () => i ? b.value : r.state.value[t],
            set: T => {
                if (i) throw new Error("cannot set hotState");
                m(E => {
                    lr(E, T)
                })
            }
        }), S._hotUpdate = Zr(T => {
            S._hotUpdating = !0, T._hmrPayload.state.forEach(E => {
                if (E in S.$state) {
                    const P = T.$state[E],
                        B = S.$state[E];
                    typeof P == "object" && Ho(P) && Ho(B) ? NO(P, B) : T.$state[E] = B
                }
                Cd(S, E, Ec(T.$state, E))
            }), Object.keys(S.$state).forEach(E => {
                E in T.$state || bm(S, E)
            }), c = !1, u = !1, r.state.value[t] = Ec(T._hmrPayload, "hotState"), u = !0, Ue().then(() => {
                c = !0
            });
            for (const E in T._hmrPayload.actions) {
                const P = T[E];
                Cd(S, E, _(P, E))
            }
            for (const E in T._hmrPayload.getters) {
                const P = T._hmrPayload.getters[E],
                    B = s ? ne(() => (ou(r), P.call(S, S))) : P;
                Cd(S, E, B)
            }
            Object.keys(S._hmrPayload.getters).forEach(E => {
                E in T._hmrPayload.getters || bm(S, E)
            }), Object.keys(S._hmrPayload.actions).forEach(E => {
                E in T._hmrPayload.actions || bm(S, E)
            }), S._hmrPayload = T._hmrPayload, S._getters = T._getters, S._hotUpdating = !1
        }), ko) {
        const T = {
            writable: !0,
            configurable: !0,
            enumerable: !1
        };
        ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach(E => {
            Object.defineProperty(S, E, lr({
                value: S[E]
            }, T))
        })
    }
    return r._p.forEach(T => {
        if (ko) {
            const E = o.run(() => T({
                store: S,
                app: r._a,
                pinia: r,
                options: a
            }));
            Object.keys(E || {}).forEach(P => S._customProperties.add(P)), lr(S, E)
        } else lr(S, o.run(() => T({
            store: S,
            app: r._a,
            pinia: r,
            options: a
        })))
    }), S.$state && typeof S.$state == "object" && typeof S.$state.constructor == "function" && !S.$state.constructor.toString().includes("[native code]") && console.warn(`[🍍]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${S.$id}".`), p && s && n.hydrate && n.hydrate(S.$state, p), c = !0, u = !0, S
} /*! #__NO_SIDE_EFFECTS__ */
function $0e(t, e, n) {
    let r, i;
    const s = typeof e == "function";
    if (typeof t == "string") r = t, i = s ? n : e;
    else if (i = t, r = t.id, typeof r != "string") throw new Error('[🍍]: "defineStore()" must be passed a store id as its first argument.');

    function o(a, l) {
        const c = kA();
        if (a = a || (c ? Nt(IO, null) : null), a && ou(a), !ry) throw new Error(`[🍍]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
        a = ry, a._s.has(r) || (s ? sy(r, e, i, a) : xE(r, i, a), o._pinia = a);
        const u = a._s.get(r);
        if (l) {
            const d = "__hot:" + r,
                f = s ? sy(d, e, i, a, !0) : xE(d, lr({}, i), a, !0);
            l._hotUpdate(f), delete a.state.value[d], a._s.delete(d)
        }
        if (ko) {
            const d = it();
            if (d && d.proxy && !l) {
                const f = d.proxy,
                    h = "_pStores" in f ? f._pStores : f._pStores = {};
                h[r] = u
            }
        }
        return u
    }
    return o.$id = r, o
}(function(t, e) {
    var n = t.document,
        r = n.documentElement,
        i = n.querySelector('meta[name="viewport"]'),
        s = n.querySelector('meta[name="flexible"]'),
        o = 0,
        a = 0,
        l, c = e.flexible || (e.flexible = {});
    if (i) {
        console.warn("");
        var u = i.getAttribute("content").match(/initial\-scale=([\d\.]+)/);
        u && (a = parseFloat(u[1]), o = parseInt(1 / a))
    } else if (s) {
        var d = s.getAttribute("content");
        if (d) {
            var f = d.match(/initial\-dpr=([\d\.]+)/),
                h = d.match(/maximum\-dpr=([\d\.]+)/);
            f && (o = parseFloat(f[1]), a = parseFloat((1 / o).toFixed(2))), h && (o = parseFloat(h[1]), a = parseFloat((1 / o).toFixed(2)))
        }
    }
    if (!o && !a) {
        t.navigator.appVersion.match(/android/gi);
        var p = t.navigator.appVersion.match(/iphone/gi),
            b = t.devicePixelRatio;
        p ? b >= 3 && (!o || o >= 3) ? o = 3 : b >= 2 && (!o || o >= 2) ? o = 2 : o = 1 : o = 1, a = 1 / o
    }
    if (r.setAttribute("data-dpr", o), !i)
        if (i = n.createElement("meta"), i.setAttribute("name", "viewport"), i.setAttribute("content", "initial-scale=" + a + ", maximum-scale=" + a + ", minimum-scale=" + a + ", user-scalable=no"), r.firstElementChild) r.firstElementChild.appendChild(i);
        else {
            var y = n.createElement("div");
            y.appendChild(i), n.write(y.innerHTML)
        }
    function m() {
        var g = r.getBoundingClientRect().width;
        g / o > 540 && (g = 540 * o);
        var v = g / 10;
        r.style.fontSize = v + "px", c.rem = t.rem = v
    }
    t.addEventListener("resize", function() {
        clearTimeout(l), l = setTimeout(m, 300)
    }, !1), t.addEventListener("pageshow", function(g) {
        g.persisted && (clearTimeout(l), l = setTimeout(m, 300))
    }, !1), n.readyState === "complete" ? n.body.style.fontSize = 12 * o + "px" : n.addEventListener("DOMContentLoaded", function(g) {
        n.body.style.fontSize = 12 * o + "px"
    }, !1), m(), c.dpr = t.dpr = o, c.refreshRem = m, c.rem2px = function(g) {
        var v = parseFloat(g) * this.rem;
        return typeof g == "string" && g.match(/rem$/) && (v += "px"), v
    }, c.px2rem = function(g) {
        var v = parseFloat(g) / this.rem;
        return typeof g == "string" && g.match(/px$/) && (v += "rem"), v
    }
})(window, window.lib || (window.lib = {}));

function _G(t) {
    return typeof t == "object" && t !== null
}

function wE(t, e) {
    return t = _G(t) ? t : Object.create(null), new Proxy(t, {
        get(n, r, i) {
            return r === "key" ? Reflect.get(n, r, i) : Reflect.get(n, r, i) || Reflect.get(e, r, i)
        }
    })
}

function bG(t, e) {
    return e.reduce((n, r) => n == null ? void 0 : n[r], t)
}

function xG(t, e, n) {
    return e.slice(0, -1).reduce((r, i) => /^(__proto__)$/.test(i) ? {} : r[i] = r[i] || {}, t)[e[e.length - 1]] = n, t
}

function wG(t, e) {
    return e.reduce((n, r) => {
        const i = r.split(".");
        return xG(n, i, bG(t, i))
    }, {})
}

function EG(t, e) {
    return n => {
        var r;
        try {
            const {
                storage: i = localStorage,
                beforeRestore: s = void 0,
                afterRestore: o = void 0,
                serializer: a = {
                    serialize: JSON.stringify,
                    deserialize: JSON.parse
                },
                key: l = e.$id,
                paths: c = null,
                debug: u = !1
            } = n;
            return {
                storage: i,
                beforeRestore: s,
                afterRestore: o,
                serializer: a,
                key: ((r = t.key) != null ? r : d => d)(typeof l == "string" ? l : l(e.$id)),
                paths: c,
                debug: u
            }
        } catch (i) {
            return n.debug && console.error("[pinia-plugin-persistedstate]", i), null
        }
    }
}

function EE(t, {
    storage: e,
    serializer: n,
    key: r,
    debug: i
}) {
    try {
        const s = e == null ? void 0 : e.getItem(r);
        s && t.$patch(n == null ? void 0 : n.deserialize(s))
    } catch (s) {
        i && console.error("[pinia-plugin-persistedstate]", s)
    }
}

function SE(t, {
    storage: e,
    serializer: n,
    key: r,
    paths: i,
    debug: s
}) {
    try {
        const o = Array.isArray(i) ? wG(t, i) : t;
        e.setItem(r, n.serialize(o))
    } catch (o) {
        s && console.error("[pinia-plugin-persistedstate]", o)
    }
}

function SG(t = {}) {
    return e => {
        const {
            auto: n = !1
        } = t, {
            options: {
                persist: r = n
            },
            store: i,
            pinia: s
        } = e;
        if (!r) return;
        if (!(i.$id in s.state.value)) {
            const a = s._s.get(i.$id.replace("__hot:", ""));
            a && Promise.resolve().then(() => a.$persist());
            return
        }
        const o = (Array.isArray(r) ? r.map(a => wE(a, t)) : [wE(r, t)]).map(EG(t, i)).filter(Boolean);
        i.$persist = () => {
            o.forEach(a => {
                SE(i.$state, a)
            })
        }, i.$hydrate = ({
            runHooks: a = !0
        } = {}) => {
            o.forEach(l => {
                const {
                    beforeRestore: c,
                    afterRestore: u
                } = l;
                a && (c == null || c(e)), EE(i, l), a && (u == null || u(e))
            })
        }, o.forEach(a => {
            const {
                beforeRestore: l,
                afterRestore: c
            } = a;
            l == null || l(e), EE(i, a), c == null || c(e), i.$subscribe((u, d) => {
                SE(d, a)
            }, {
                detached: !0
            })
        })
    }
}
var F0e = SG(),
    zo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function ua(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}

function $_(t) {
    if (t.__esModule) return t;
    var e = t.default;
    if (typeof e == "function") {
        var n = function r() {
            return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        n.prototype = e.prototype
    } else n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }), Object.keys(t).forEach(function(r) {
        var i = Object.getOwnPropertyDescriptor(t, r);
        Object.defineProperty(n, r, i.get ? i : {
            enumerable: !0,
            get: function() {
                return t[r]
            }
        })
    }), n
}
const sn = $_(zU);
var UO = {
        exports: {}
    },
    F_ = Object.defineProperty,
    TG = Object.getOwnPropertyDescriptor,
    CG = Object.getOwnPropertyNames,
    PG = Object.prototype.hasOwnProperty,
    AG = (t, e) => {
        for (var n in e) F_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    OG = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of CG(e)) !PG.call(t, i) && i !== n && F_(t, i, {
                get: () => e[i],
                enumerable: !(r = TG(e, i)) || r.enumerable
            });
        return t
    },
    IG = t => OG(F_({}, "__esModule", {
        value: !0
    }), t),
    GO = {};
AG(GO, {
    extend: () => MG,
    flat: () => zG,
    get: () => NG,
    inBrowser: () => HO,
    isDate: () => DG,
    isDef: () => kG,
    isFunction: () => oy,
    isIOS: () => LG,
    isMobile: () => $G,
    isNumeric: () => FG,
    isObject: () => L_,
    isPromise: () => BG,
    isSameValue: () => GG,
    noop: () => RG,
    pick: () => UG,
    toArray: () => HG
});
var js = IG(GO);

function RG() {}
const MG = Object.assign,
    HO = typeof window < "u",
    L_ = t => t !== null && typeof t == "object",
    kG = t => t != null,
    oy = t => typeof t == "function",
    BG = t => L_(t) && oy(t.then) && oy(t.catch),
    DG = t => Object.prototype.toString.call(t) === "[object Date]" && !Number.isNaN(t.getTime());

function $G(t) {
    return t = t.replace(/[^-|\d]/g, ""), /^((\+86)|(86))?(1)\d{10}$/.test(t) || /^0[0-9-]{10,13}$/.test(t)
}
const FG = t => typeof t == "number" || /^\d+(\.\d+)?$/.test(t),
    LG = () => HO ? /ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()) : !1;

function NG(t, e) {
    const n = e.split(".");
    let r = t;
    return n.forEach(i => {
        var s;
        r = L_(r) && (s = r[i]) != null ? s : ""
    }), r
}

function UG(t, e, n) {
    return e.reduce((r, i) => ((!n || t[i] !== void 0) && (r[i] = t[i]), r), {})
}
const GG = (t, e) => JSON.stringify(t) === JSON.stringify(e),
    HG = t => Array.isArray(t) ? t : [t],
    zG = t => t.reduce((e, n) => e.concat(n), []);
var N_ = Object.defineProperty,
    jG = Object.getOwnPropertyDescriptor,
    VG = Object.getOwnPropertyNames,
    WG = Object.prototype.hasOwnProperty,
    YG = (t, e) => {
        for (var n in e) N_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    XG = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of VG(e)) !WG.call(t, i) && i !== n && N_(t, i, {
                get: () => e[i],
                enumerable: !(r = jG(e, i)) || r.enumerable
            });
        return t
    },
    KG = t => XG(N_({}, "__esModule", {
        value: !0
    }), t),
    zO = {};
YG(zO, {
    makeArrayProp: () => e6,
    makeNumberProp: () => t6,
    makeNumericProp: () => n6,
    makeRequiredProp: () => QG,
    makeStringProp: () => r6,
    numericProp: () => jO,
    truthProp: () => ZG,
    unknownProp: () => JG
});
var qG = KG(zO);
const JG = null,
    jO = [Number, String],
    ZG = {
        type: Boolean,
        default: !0
    },
    QG = t => ({
        type: t,
        required: !0
    }),
    e6 = () => ({
        type: Array,
        default: () => []
    }),
    t6 = t => ({
        type: Number,
        default: t
    }),
    n6 = t => ({
        type: jO,
        default: t
    }),
    r6 = t => ({
        type: String,
        default: t
    });
var li = typeof window < "u",
    i6 = !0;

function Sn(t) {
    return li ? requestAnimationFrame(t) : -1
}

function Xu(t) {
    li && cancelAnimationFrame(t)
}

function bo(t) {
    Sn(() => Sn(t))
}
var s6 = t => t === window,
    TE = (t, e) => ({
        top: 0,
        left: 0,
        right: t,
        bottom: e,
        width: t,
        height: e
    }),
    Jt = t => {
        const e = En(t);
        if (s6(e)) {
            const n = e.innerWidth,
                r = e.innerHeight;
            return TE(n, r)
        }
        return e != null && e.getBoundingClientRect ? e.getBoundingClientRect() : TE(0, 0)
    };

function VO(t = !1) {
    const e = J(t);
    return [e, (r = !e.value) => {
        e.value = r
    }]
}

function tr(t) {
    const e = Nt(t, null);
    if (e) {
        const n = it(),
            {
                link: r,
                unlink: i,
                internalChildren: s
            } = e;
        r(n), Ki(() => i(n));
        const o = ne(() => s.indexOf(n));
        return {
            parent: e,
            index: o
        }
    }
    return {
        parent: null,
        index: J(-1)
    }
}

function WO(t) {
    const e = [],
        n = r => {
            Array.isArray(r) && r.forEach(i => {
                var s;
                si(i) && (e.push(i), (s = i.component) != null && s.subTree && (e.push(i.component.subTree), n(i.component.subTree.children)), i.children && n(i.children))
            })
        };
    return n(t), e
}
var CE = (t, e) => {
    const n = t.indexOf(e);
    return n === -1 ? t.findIndex(r => e.key !== void 0 && e.key !== null && r.type === e.type && r.key === e.key) : n
};

function YO(t, e, n) {
    const r = WO(t.subTree.children);
    n.sort((s, o) => CE(r, s.vnode) - CE(r, o.vnode));
    const i = n.map(s => s.proxy);
    e.sort((s, o) => {
        const a = i.indexOf(s),
            l = i.indexOf(o);
        return a - l
    })
}

function Br(t) {
    const e = ht([]),
        n = ht([]),
        r = it();
    return {
        children: e,
        linkChildren: s => {
            Pr(t, Object.assign({
                link: l => {
                    l.proxy && (n.push(l), e.push(l.proxy), YO(r, e, n))
                },
                unlink: l => {
                    const c = n.indexOf(l);
                    e.splice(c, 1), n.splice(c, 1)
                },
                children: e,
                internalChildren: n
            }, s))
        }
    }
}
var ay = 1e3,
    ly = 60 * ay,
    cy = 60 * ly,
    PE = 24 * cy;

function o6(t) {
    const e = Math.floor(t / PE),
        n = Math.floor(t % PE / cy),
        r = Math.floor(t % cy / ly),
        i = Math.floor(t % ly / ay),
        s = Math.floor(t % ay);
    return {
        total: t,
        days: e,
        hours: n,
        minutes: r,
        seconds: i,
        milliseconds: s
    }
}

function a6(t, e) {
    return Math.floor(t / 1e3) === Math.floor(e / 1e3)
}

function XO(t) {
    let e, n, r, i;
    const s = J(t.time),
        o = ne(() => o6(s.value)),
        a = () => {
            r = !1, Xu(e)
        },
        l = () => Math.max(n - Date.now(), 0),
        c = b => {
            var y, m;
            s.value = b, (y = t.onChange) == null || y.call(t, o.value), b === 0 && (a(), (m = t.onFinish) == null || m.call(t))
        },
        u = () => {
            e = Sn(() => {
                r && (c(l()), s.value > 0 && u())
            })
        },
        d = () => {
            e = Sn(() => {
                if (r) {
                    const b = l();
                    (!a6(b, s.value) || b === 0) && c(b), s.value > 0 && d()
                }
            })
        },
        f = () => {
            li && (t.millisecond ? u() : d())
        },
        h = () => {
            r || (n = Date.now() + s.value, r = !0, f())
        },
        p = (b = t.time) => {
            a(), s.value = b
        };
    return er(a), zs(() => {
        i && (r = !0, i = !1, f())
    }), Yi(() => {
        r && (a(), i = !0)
    }), {
        start: h,
        pause: a,
        reset: p,
        current: o
    }
}

function Ml(t) {
    let e;
    St(() => {
        t(), Ue(() => {
            e = !0
        })
    }), zs(() => {
        e && t()
    })
}

function Nn(t, e, n = {}) {
    if (!li) return;
    const {
        target: r = window,
        passive: i = !1,
        capture: s = !1
    } = n;
    let o = !1,
        a;
    const l = d => {
            if (o) return;
            const f = En(d);
            f && !a && (f.addEventListener(t, e, {
                capture: s,
                passive: i
            }), a = !0)
        },
        c = d => {
            if (o) return;
            const f = En(d);
            f && a && (f.removeEventListener(t, e, s), a = !1)
        };
    Ki(() => c(r)), Yi(() => c(r)), Ml(() => l(r));
    let u;
    return tt(r) && (u = pe(r, (d, f) => {
        c(f), l(d)
    })), () => {
        u == null || u(), c(r), o = !0
    }
}

function KO(t, e, n = {}) {
    if (!li) return;
    const {
        eventName: r = "click"
    } = n;
    Nn(r, s => {
        (Array.isArray(t) ? t : [t]).every(l => {
            const c = En(l);
            return c && !c.contains(s.target)
        }) && e(s)
    }, {
        target: document
    })
}
var Pd, wm;

function qO() {
    if (!Pd && (Pd = J(0), wm = J(0), li)) {
        const t = () => {
            Pd.value = window.innerWidth, wm.value = window.innerHeight
        };
        t(), window.addEventListener("resize", t, {
            passive: !0
        }), window.addEventListener("orientationchange", t, {
            passive: !0
        })
    }
    return {
        width: Pd,
        height: wm
    }
}
var l6 = /scroll|auto|overlay/i,
    JO = li ? window : void 0;

function c6(t) {
    return t.tagName !== "HTML" && t.tagName !== "BODY" && t.nodeType === 1
}

function U_(t, e = JO) {
    let n = t;
    for (; n && n !== e && c6(n);) {
        const {
            overflowY: r
        } = window.getComputedStyle(n);
        if (l6.test(r)) return n;
        n = n.parentNode
    }
    return e
}

function Ku(t, e = JO) {
    const n = J();
    return St(() => {
        t.value && (n.value = U_(t.value, e))
    }), n
}
var Ad;

function ZO() {
    if (!Ad && (Ad = J("visible"), li)) {
        const t = () => {
            Ad.value = document.hidden ? "hidden" : "visible"
        };
        t(), window.addEventListener("visibilitychange", t)
    }
    return Ad
}
var G_ = Symbol("van-field");

function da(t) {
    const e = Nt(G_, null);
    e && !e.customValue.value && (e.customValue.value = t, pe(t, () => {
        e.resetValidation(), e.validateWithTrigger("onChange")
    }))
}

function u6(t, e) {
    if (li) {
        const {
            interval: n = 0,
            isLoop: r = !1
        } = e || {};
        let i, s = !1,
            o;
        const a = () => {
                s = !0, cancelAnimationFrame(o)
            },
            l = c => {
                if (!s) {
                    if (i === void 0) i = c;
                    else if (c - i > n && (t(c), i = c, !r)) {
                        a();
                        return
                    }
                    o = requestAnimationFrame(l)
                }
            };
        return o = requestAnimationFrame(l), a
    }
    return () => {}
}
const d6 = Object.freeze(Object.defineProperty({
        __proto__: null,
        CUSTOM_FIELD_INJECTION_KEY: G_,
        cancelRaf: Xu,
        doubleRaf: bo,
        flattenVNodes: WO,
        getScrollParent: U_,
        inBrowser: li,
        onMountedOrActivated: Ml,
        raf: Sn,
        sortChildren: YO,
        supportsPassive: i6,
        useChildren: Br,
        useClickAway: KO,
        useCountDown: XO,
        useCustomFieldValue: da,
        useEventListener: Nn,
        usePageVisibility: ZO,
        useParent: tr,
        useRaf: u6,
        useRect: Jt,
        useScrollParent: Ku,
        useToggle: VO,
        useWindowSize: qO
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    op = $_(d6);
var H_ = Object.defineProperty,
    f6 = Object.getOwnPropertyDescriptor,
    h6 = Object.getOwnPropertyNames,
    p6 = Object.prototype.hasOwnProperty,
    m6 = (t, e) => {
        for (var n in e) H_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    g6 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of h6(e)) !p6.call(t, i) && i !== n && H_(t, i, {
                get: () => e[i],
                enumerable: !(r = f6(e, i)) || r.enumerable
            });
        return t
    },
    v6 = t => g6(H_({}, "__esModule", {
        value: !0
    }), t),
    QO = {};
m6(QO, {
    getContainingBlock: () => A6,
    getElementTop: () => b6,
    getRootScrollTop: () => z_,
    getScrollTop: () => nI,
    isHidden: () => S6,
    preventDefault: () => E6,
    resetScroll: () => w6,
    setRootScrollTop: () => rI,
    setScrollTop: () => uy,
    stopPropagation: () => iI,
    windowHeight: () => C6,
    windowWidth: () => T6
});
var eI = v6(QO),
    tI = op,
    y6 = sn,
    _6 = js;

function nI(t) {
    const e = "scrollTop" in t ? t.scrollTop : t.pageYOffset;
    return Math.max(e, 0)
}

function uy(t, e) {
    "scrollTop" in t ? t.scrollTop = e : t.scrollTo(t.scrollX, e)
}

function z_() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
}

function rI(t) {
    uy(window, t), uy(document.body, t)
}

function b6(t, e) {
    if (t === window) return 0;
    const n = e ? nI(e) : z_();
    return (0, tI.useRect)(t).top + n
}
const x6 = (0, _6.isIOS)();

function w6() {
    x6 && rI(z_())
}
const iI = t => t.stopPropagation();

function E6(t, e) {
    (typeof t.cancelable != "boolean" || t.cancelable) && t.preventDefault(), e && iI(t)
}

function S6(t) {
    const e = (0, y6.unref)(t);
    if (!e) return !1;
    const n = window.getComputedStyle(e),
        r = n.display === "none",
        i = e.offsetParent === null && n.position !== "fixed";
    return r || i
}
const {
    width: T6,
    height: C6
} = (0, tI.useWindowSize)();

function P6(t) {
    const e = window.getComputedStyle(t);
    return e.transform !== "none" || e.perspective !== "none" || ["transform", "perspective", "filter"].some(n => (e.willChange || "").includes(n))
}

function A6(t) {
    let e = t.parentElement;
    for (; e;) {
        if (e && e.tagName !== "HTML" && e.tagName !== "BODY" && P6(e)) return e;
        e = e.parentElement
    }
    return null
}
var j_ = Object.defineProperty,
    O6 = Object.getOwnPropertyDescriptor,
    I6 = Object.getOwnPropertyNames,
    R6 = Object.prototype.hasOwnProperty,
    M6 = (t, e) => {
        for (var n in e) j_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    k6 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of I6(e)) !R6.call(t, i) && i !== n && j_(t, i, {
                get: () => e[i],
                enumerable: !(r = O6(e, i)) || r.enumerable
            });
        return t
    },
    B6 = t => k6(j_({}, "__esModule", {
        value: !0
    }), t),
    sI = {};
M6(sI, {
    addNumber: () => K6,
    addUnit: () => Cf,
    camelize: () => j6,
    clamp: () => Y6,
    formatNumber: () => X6,
    getSizeStyle: () => $6,
    getZIndexStyle: () => F6,
    kebabCase: () => V6,
    padZero: () => W6,
    unitToPx: () => H6
});
var V_ = B6(sI),
    D6 = js,
    oI = eI,
    dy = js;

function Cf(t) {
    if ((0, dy.isDef)(t)) return (0, dy.isNumeric)(t) ? `${t}px` : String(t)
}

function $6(t) {
    if ((0, dy.isDef)(t)) {
        if (Array.isArray(t)) return {
            width: Cf(t[0]),
            height: Cf(t[1])
        };
        const e = Cf(t);
        return {
            width: e,
            height: e
        }
    }
}

function F6(t) {
    const e = {};
    return t !== void 0 && (e.zIndex = +t), e
}
let Em;

function L6() {
    if (!Em) {
        const t = document.documentElement,
            e = t.style.fontSize || window.getComputedStyle(t).fontSize;
        Em = parseFloat(e)
    }
    return Em
}

function N6(t) {
    return t = t.replace(/rem/g, ""), +t * L6()
}

function U6(t) {
    return t = t.replace(/vw/g, ""), +t * oI.windowWidth.value / 100
}

function G6(t) {
    return t = t.replace(/vh/g, ""), +t * oI.windowHeight.value / 100
}

function H6(t) {
    if (typeof t == "number") return t;
    if (D6.inBrowser) {
        if (t.includes("rem")) return N6(t);
        if (t.includes("vw")) return U6(t);
        if (t.includes("vh")) return G6(t)
    }
    return parseFloat(t)
}
const z6 = /-(\w)/g,
    j6 = t => t.replace(z6, (e, n) => n.toUpperCase()),
    V6 = t => t.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");

function W6(t, e = 2) {
    let n = t + "";
    for (; n.length < e;) n = "0" + n;
    return n
}
const Y6 = (t, e, n) => Math.min(Math.max(t, e), n);

function AE(t, e, n) {
    const r = t.indexOf(e);
    return r === -1 ? t : e === "-" && r !== 0 ? t.slice(0, r) : t.slice(0, r + 1) + t.slice(r).replace(n, "")
}

function X6(t, e = !0, n = !0) {
    e ? t = AE(t, ".", /\./g) : t = t.split(".")[0], n ? t = AE(t, "-", /-/g) : t = t.replace(/-/, "");
    const r = e ? /[^-0-9.]/g : /[^-0-9]/g;
    return t.replace(r, "")
}

function K6(t, e) {
    return Math.round((t + e) * 1e10) / 1e10
}
var W_ = Object.defineProperty,
    q6 = Object.getOwnPropertyDescriptor,
    J6 = Object.getOwnPropertyNames,
    Z6 = Object.prototype.hasOwnProperty,
    Q6 = (t, e) => {
        for (var n in e) W_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    e9 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of J6(e)) !Z6.call(t, i) && i !== n && W_(t, i, {
                get: () => e[i],
                enumerable: !(r = q6(e, i)) || r.enumerable
            });
        return t
    },
    t9 = t => e9(W_({}, "__esModule", {
        value: !0
    }), t),
    aI = {};
Q6(aI, {
    deepAssign: () => lI
});
var n9 = t9(aI),
    OE = js;
const {
    hasOwnProperty: r9
} = Object.prototype;

function i9(t, e, n) {
    const r = e[n];
    (0, OE.isDef)(r) && (!r9.call(t, n) || !(0, OE.isObject)(r) ? t[n] = r : t[n] = lI(Object(t[n]), r))
}

function lI(t, e) {
    return Object.keys(e).forEach(n => {
        i9(t, e, n)
    }), t
}
var Y_ = Object.defineProperty,
    s9 = Object.getOwnPropertyDescriptor,
    o9 = Object.getOwnPropertyNames,
    a9 = Object.prototype.hasOwnProperty,
    l9 = (t, e) => {
        for (var n in e) Y_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    c9 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of o9(e)) !a9.call(t, i) && i !== n && Y_(t, i, {
                get: () => e[i],
                enumerable: !(r = s9(e, i)) || r.enumerable
            });
        return t
    },
    u9 = t => c9(Y_({}, "__esModule", {
        value: !0
    }), t),
    cI = {};
l9(cI, {
    default: () => f9
});
var d9 = u9(cI),
    f9 = {
        name: "姓名",
        tel: "电话",
        save: "保存",
        clear: "清空",
        cancel: "取消",
        confirm: "确认",
        delete: "删除",
        loading: "加载中...",
        noCoupon: "暂无优惠券",
        nameEmpty: "请填写姓名",
        addContact: "添加联系人",
        telInvalid: "请填写正确的电话",
        vanCalendar: {
            end: "结束",
            start: "开始",
            title: "日期选择",
            weekdays: ["日", "一", "二", "三", "四", "五", "六"],
            monthTitle: (t, e) => `${t}年${e}月`,
            rangePrompt: t => `最多选择 ${t} 天`
        },
        vanCascader: {
            select: "请选择"
        },
        vanPagination: {
            prev: "上一页",
            next: "下一页"
        },
        vanPullRefresh: {
            pulling: "下拉即可刷新...",
            loosing: "释放即可刷新..."
        },
        vanSubmitBar: {
            label: "合计:"
        },
        vanCoupon: {
            unlimited: "无门槛",
            discount: t => `${t}折`,
            condition: t => `满${t}元可用`
        },
        vanCouponCell: {
            title: "优惠券",
            count: t => `${t}张可用`
        },
        vanCouponList: {
            exchange: "兑换",
            close: "不使用",
            enable: "可用",
            disabled: "不可用",
            placeholder: "输入优惠码"
        },
        vanAddressEdit: {
            area: "地区",
            areaEmpty: "请选择地区",
            addressEmpty: "请填写详细地址",
            addressDetail: "详细地址",
            defaultAddress: "设为默认收货地址"
        },
        vanAddressList: {
            add: "新增地址"
        }
    },
    h9 = Object.create,
    ap = Object.defineProperty,
    p9 = Object.getOwnPropertyDescriptor,
    m9 = Object.getOwnPropertyNames,
    g9 = Object.getPrototypeOf,
    v9 = Object.prototype.hasOwnProperty,
    y9 = (t, e) => {
        for (var n in e) ap(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    uI = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of m9(e)) !v9.call(t, i) && i !== n && ap(t, i, {
                get: () => e[i],
                enumerable: !(r = p9(e, i)) || r.enumerable
            });
        return t
    },
    _9 = (t, e, n) => (n = t != null ? h9(g9(t)) : {}, uI(e || !t || !t.__esModule ? ap(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    b9 = t => uI(ap({}, "__esModule", {
        value: !0
    }), t),
    dI = {};
y9(dI, {
    Locale: () => hI,
    default: () => T9,
    useCurrentLang: () => S9
});
var x9 = b9(dI),
    fI = sn,
    w9 = n9,
    E9 = _9(d9);
const fy = (0, fI.ref)("zh-CN"),
    IE = (0, fI.reactive)({
        "zh-CN": E9.default
    }),
    hI = {
        messages() {
            return IE[fy.value]
        },
        use(t, e) {
            fy.value = t, this.add({
                [t]: e
            })
        },
        add(t = {}) {
            (0, w9.deepAssign)(IE, t)
        }
    },
    S9 = () => fy;
var T9 = hI,
    C9 = Object.create,
    lp = Object.defineProperty,
    P9 = Object.getOwnPropertyDescriptor,
    A9 = Object.getOwnPropertyNames,
    O9 = Object.getPrototypeOf,
    I9 = Object.prototype.hasOwnProperty,
    R9 = (t, e) => {
        for (var n in e) lp(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    pI = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of A9(e)) !I9.call(t, i) && i !== n && lp(t, i, {
                get: () => e[i],
                enumerable: !(r = P9(e, i)) || r.enumerable
            });
        return t
    },
    M9 = (t, e, n) => (n = t != null ? C9(O9(t)) : {}, pI(e || !t || !t.__esModule ? lp(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    k9 = t => pI(lp({}, "__esModule", {
        value: !0
    }), t),
    mI = {};
R9(mI, {
    createBEM: () => vI,
    createNamespace: () => F9,
    createTranslate: () => gI
});
var B9 = k9(mI),
    Sm = js,
    D9 = V_,
    $9 = M9(x9);

function gI(t) {
    const e = (0, D9.camelize)(t) + ".";
    return (n, ...r) => {
        const i = $9.default.messages(),
            s = (0, Sm.get)(i, e + n) || (0, Sm.get)(i, n);
        return (0, Sm.isFunction)(s) ? s(...r) : s
    }
}

function hy(t, e) {
    return e ? typeof e == "string" ? ` ${t}--${e}` : Array.isArray(e) ? e.reduce((n, r) => n + hy(t, r), "") : Object.keys(e).reduce((n, r) => n + (e[r] ? hy(t, r) : ""), "") : ""
}

function vI(t) {
    return (e, n) => (e && typeof e != "string" && (n = e, e = ""), e = e ? `${t}__${e}` : t, `${e}${hy(e,n)}`)
}

function F9(t) {
    const e = `van-${t}`;
    return [e, vI(e), gI(e)]
}
var X_ = Object.defineProperty,
    L9 = Object.getOwnPropertyDescriptor,
    N9 = Object.getOwnPropertyNames,
    U9 = Object.prototype.hasOwnProperty,
    G9 = (t, e) => {
        for (var n in e) X_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    H9 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of N9(e)) !U9.call(t, i) && i !== n && X_(t, i, {
                get: () => e[i],
                enumerable: !(r = L9(e, i)) || r.enumerable
            });
        return t
    },
    z9 = t => H9(X_({}, "__esModule", {
        value: !0
    }), t),
    yI = {};
G9(yI, {
    BORDER: () => Vs,
    BORDER_BOTTOM: () => X9,
    BORDER_LEFT: () => W9,
    BORDER_RIGHT: () => Y9,
    BORDER_SURROUND: () => K9,
    BORDER_TOP: () => V9,
    BORDER_TOP_BOTTOM: () => q9,
    BORDER_UNSET_TOP_BOTTOM: () => J9,
    FORM_KEY: () => Q9,
    HAPTICS_FEEDBACK: () => Z9,
    LONG_PRESS_START_TIME: () => eH,
    TAP_OFFSET: () => tH
});
var j9 = z9(yI);
const Vs = "van-hairline",
    V9 = `${Vs}--top`,
    W9 = `${Vs}--left`,
    Y9 = `${Vs}--right`,
    X9 = `${Vs}--bottom`,
    K9 = `${Vs}--surround`,
    q9 = `${Vs}--top-bottom`,
    J9 = `${Vs}-unset--top-bottom`,
    Z9 = "van-haptics-feedback",
    Q9 = Symbol("van-form"),
    eH = 500,
    tH = 5;
var K_ = Object.defineProperty,
    nH = Object.getOwnPropertyDescriptor,
    rH = Object.getOwnPropertyNames,
    iH = Object.prototype.hasOwnProperty,
    sH = (t, e) => {
        for (var n in e) K_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    oH = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of rH(e)) !iH.call(t, i) && i !== n && K_(t, i, {
                get: () => e[i],
                enumerable: !(r = nH(e, i)) || r.enumerable
            });
        return t
    },
    aH = t => oH(K_({}, "__esModule", {
        value: !0
    }), t),
    _I = {};
sH(_I, {
    callInterceptor: () => cH
});
var lH = aH(_I),
    RE = js;

function cH(t, {
    args: e = [],
    done: n,
    canceled: r,
    error: i
}) {
    if (t) {
        const s = t.apply(null, e);
        (0, RE.isPromise)(s) ? s.then(o => {
            o ? n() : r && r()
        }).catch(i || RE.noop): s ? n() : r && r()
    } else n()
}
var q_ = Object.defineProperty,
    uH = Object.getOwnPropertyDescriptor,
    dH = Object.getOwnPropertyNames,
    fH = Object.prototype.hasOwnProperty,
    hH = (t, e) => {
        for (var n in e) q_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    pH = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of dH(e)) !fH.call(t, i) && i !== n && q_(t, i, {
                get: () => e[i],
                enumerable: !(r = uH(e, i)) || r.enumerable
            });
        return t
    },
    mH = t => pH(q_({}, "__esModule", {
        value: !0
    }), t),
    bI = {};
hH(bI, {
    withInstall: () => yH
});
var gH = mH(bI),
    vH = V_;

function yH(t) {
    return t.install = e => {
        const {
            name: n
        } = t;
        n && (e.component(n, t), e.component((0, vH.camelize)(`-${n}`), t))
    }, t
}
var J_ = Object.defineProperty,
    _H = Object.getOwnPropertyDescriptor,
    bH = Object.getOwnPropertyNames,
    xH = Object.prototype.hasOwnProperty,
    wH = (t, e) => {
        for (var n in e) J_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    EH = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of bH(e)) !xH.call(t, i) && i !== n && J_(t, i, {
                get: () => e[i],
                enumerable: !(r = _H(e, i)) || r.enumerable
            });
        return t
    },
    SH = t => EH(J_({}, "__esModule", {
        value: !0
    }), t),
    xI = {};
wH(xI, {
    closest: () => CH
});
var TH = SH(xI);

function CH(t, e) {
    return t.reduce((n, r) => Math.abs(n - e) < Math.abs(r - e) ? n : r)
}(function(t) {
    var e = Object.defineProperty,
        n = Object.getOwnPropertyDescriptor,
        r = Object.getOwnPropertyNames,
        i = Object.prototype.hasOwnProperty,
        s = (c, u, d, f) => {
            if (u && typeof u == "object" || typeof u == "function")
                for (let h of r(u)) !i.call(c, h) && h !== d && e(c, h, {
                    get: () => u[h],
                    enumerable: !(f = n(u, h)) || f.enumerable
                });
            return c
        },
        o = (c, u, d) => (s(c, u, "default"), d && s(d, u, "default")),
        a = c => s(e({}, "__esModule", {
            value: !0
        }), c),
        l = {};
    t.exports = a(l), o(l, js, t.exports), o(l, qG, t.exports), o(l, eI, t.exports), o(l, B9, t.exports), o(l, V_, t.exports), o(l, j9, t.exports), o(l, lH, t.exports), o(l, gH, t.exports), o(l, TH, t.exports)
})(UO);
var on = UO.exports,
    Z_ = Object.defineProperty,
    PH = Object.getOwnPropertyDescriptor,
    AH = Object.getOwnPropertyNames,
    OH = Object.prototype.hasOwnProperty,
    IH = (t, e) => {
        for (var n in e) Z_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    RH = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of AH(e)) !OH.call(t, i) && i !== n && Z_(t, i, {
                get: () => e[i],
                enumerable: !(r = PH(e, i)) || r.enumerable
            });
        return t
    },
    MH = t => RH(Z_({}, "__esModule", {
        value: !0
    }), t),
    wI = {};
IH(wI, {
    useExpose: () => DH
});
var EI = MH(wI),
    kH = sn,
    BH = on;

function DH(t) {
    const e = (0, kH.getCurrentInstance)();
    e && (0, BH.extend)(e.proxy, t)
}
var Q_ = Object.defineProperty,
    $H = Object.getOwnPropertyDescriptor,
    FH = Object.getOwnPropertyNames,
    LH = Object.prototype.hasOwnProperty,
    NH = (t, e) => {
        for (var n in e) Q_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    UH = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of FH(e)) !LH.call(t, i) && i !== n && Q_(t, i, {
                get: () => e[i],
                enumerable: !(r = $H(e, i)) || r.enumerable
            });
        return t
    },
    GH = t => UH(Q_({}, "__esModule", {
        value: !0
    }), t),
    SI = {};
NH(SI, {
    mountComponent: () => WH,
    usePopupState: () => VH
});
var HH = GH(SI),
    TI = sn,
    zH = js,
    jH = EI;

function VH() {
    const t = (0, TI.reactive)({
            show: !1
        }),
        e = i => {
            t.show = i
        },
        n = i => {
            (0, zH.extend)(t, i, {
                transitionAppear: !0
            }), e(!0)
        },
        r = () => e(!1);
    return (0, jH.useExpose)({
        open: n,
        close: r,
        toggle: e
    }), {
        open: n,
        close: r,
        state: t,
        toggle: e
    }
}

function WH(t) {
    const e = (0, TI.createApp)(t),
        n = document.createElement("div");
    return document.body.appendChild(n), {
        instance: e.mount(n),
        unmount() {
            e.unmount(), document.body.removeChild(n)
        }
    }
}
var eb = Object.defineProperty,
    YH = Object.getOwnPropertyDescriptor,
    XH = Object.getOwnPropertyNames,
    KH = Object.prototype.hasOwnProperty,
    qH = (t, e) => {
        for (var n in e) eb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    JH = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of XH(e)) !KH.call(t, i) && i !== n && eb(t, i, {
                get: () => e[i],
                enumerable: !(r = YH(e, i)) || r.enumerable
            });
        return t
    },
    ZH = t => JH(eb({}, "__esModule", {
        value: !0
    }), t),
    CI = {};
qH(CI, {
    lockClick: () => e8
});
var QH = ZH(CI);
let ql = 0;

function e8(t) {
    t ? (ql || document.body.classList.add("van-toast--unclickable"), ql++) : ql && (ql--, ql || document.body.classList.remove("van-toast--unclickable"))
}
var tb = Object.defineProperty,
    t8 = Object.getOwnPropertyDescriptor,
    n8 = Object.getOwnPropertyNames,
    r8 = Object.prototype.hasOwnProperty,
    i8 = (t, e) => {
        for (var n in e) tb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    s8 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of n8(e)) !r8.call(t, i) && i !== n && tb(t, i, {
                get: () => e[i],
                enumerable: !(r = t8(e, i)) || r.enumerable
            });
        return t
    },
    o8 = t => s8(tb({}, "__esModule", {
        value: !0
    }), t),
    PI = {};
i8(PI, {
    badgeProps: () => OI,
    default: () => l8
});
var AI = o8(PI),
    Od = sn,
    yn = on;
const [a8, ME] = (0, yn.createNamespace)("badge"), OI = {
    dot: Boolean,
    max: yn.numericProp,
    tag: (0, yn.makeStringProp)("div"),
    color: String,
    offset: Array,
    content: yn.numericProp,
    showZero: yn.truthProp,
    position: (0, yn.makeStringProp)("top-right")
};
var l8 = (0, Od.defineComponent)({
        name: a8,
        props: OI,
        setup(t, {
            slots: e
        }) {
            const n = () => {
                    if (e.content) return !0;
                    const {
                        content: a,
                        showZero: l
                    } = t;
                    return (0, yn.isDef)(a) && a !== "" && (l || a !== 0 && a !== "0")
                },
                r = () => {
                    const {
                        dot: a,
                        max: l,
                        content: c
                    } = t;
                    if (!a && n()) return e.content ? e.content() : (0, yn.isDef)(l) && (0, yn.isNumeric)(c) && +c > +l ? `${l}+` : c
                },
                i = a => a.startsWith("-") ? a.replace("-", "") : `-${a}`,
                s = (0, Od.computed)(() => {
                    const a = {
                        background: t.color
                    };
                    if (t.offset) {
                        const [l, c] = t.offset, {
                            position: u
                        } = t, [d, f] = u.split("-");
                        e.default ? (typeof c == "number" ? a[d] = (0, yn.addUnit)(d === "top" ? c : -c) : a[d] = d === "top" ? (0, yn.addUnit)(c) : i(c), typeof l == "number" ? a[f] = (0, yn.addUnit)(f === "left" ? l : -l) : a[f] = f === "left" ? (0, yn.addUnit)(l) : i(l)) : (a.marginTop = (0, yn.addUnit)(c), a.marginLeft = (0, yn.addUnit)(l))
                    }
                    return a
                }),
                o = () => {
                    if (n() || t.dot) return (0, Od.createVNode)("div", {
                        class: ME([t.position, {
                            dot: t.dot,
                            fixed: !!e.default
                        }]),
                        style: s.value
                    }, [r()])
                };
            return () => {
                if (e.default) {
                    const {
                        tag: a
                    } = t;
                    return (0, Od.createVNode)(a, {
                        class: ME("wrapper")
                    }, {
                        default: () => [e.default(), o()]
                    })
                }
                return o()
            }
        }
    }),
    c8 = Object.create,
    cp = Object.defineProperty,
    u8 = Object.getOwnPropertyDescriptor,
    d8 = Object.getOwnPropertyNames,
    f8 = Object.getPrototypeOf,
    h8 = Object.prototype.hasOwnProperty,
    p8 = (t, e) => {
        for (var n in e) cp(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    II = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of d8(e)) !h8.call(t, i) && i !== n && cp(t, i, {
                get: () => e[i],
                enumerable: !(r = u8(e, i)) || r.enumerable
            });
        return t
    },
    m8 = (t, e, n) => (n = t != null ? c8(f8(t)) : {}, II(e || !t || !t.__esModule ? cp(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    g8 = t => II(cp({}, "__esModule", {
        value: !0
    }), t),
    RI = {};
p8(RI, {
    Badge: () => MI,
    badgeProps: () => b8.badgeProps,
    default: () => x8
});
var v8 = g8(RI),
    y8 = on,
    _8 = m8(AI),
    b8 = AI;
const MI = (0, y8.withInstall)(_8.default);
var x8 = MI,
    nb = Object.defineProperty,
    w8 = Object.getOwnPropertyDescriptor,
    E8 = Object.getOwnPropertyNames,
    S8 = Object.prototype.hasOwnProperty,
    T8 = (t, e) => {
        for (var n in e) nb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    C8 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of E8(e)) !S8.call(t, i) && i !== n && nb(t, i, {
                get: () => e[i],
                enumerable: !(r = w8(e, i)) || r.enumerable
            });
        return t
    },
    P8 = t => C8(nb({}, "__esModule", {
        value: !0
    }), t),
    kI = {};
T8(kI, {
    setGlobalZIndex: () => O8,
    useGlobalZIndex: () => A8
});
var BI = P8(kI);
let DI = 2e3;
const A8 = () => ++DI,
    O8 = t => {
        DI = t
    };
var rb = Object.defineProperty,
    I8 = Object.getOwnPropertyDescriptor,
    R8 = Object.getOwnPropertyNames,
    M8 = Object.prototype.hasOwnProperty,
    k8 = (t, e) => {
        for (var n in e) rb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    B8 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of R8(e)) !M8.call(t, i) && i !== n && rb(t, i, {
                get: () => e[i],
                enumerable: !(r = I8(e, i)) || r.enumerable
            });
        return t
    },
    D8 = t => B8(rb({}, "__esModule", {
        value: !0
    }), t),
    $I = {};
k8($I, {
    CONFIG_PROVIDER_KEY: () => LI,
    configProviderProps: () => NI,
    default: () => G8
});
var $8 = D8($I),
    mr = sn,
    Bo = on,
    F8 = BI;
const [FI, L8] = (0, Bo.createNamespace)("config-provider"), LI = Symbol(FI), NI = {
    tag: (0, Bo.makeStringProp)("div"),
    theme: (0, Bo.makeStringProp)("light"),
    zIndex: Number,
    themeVars: Object,
    themeVarsDark: Object,
    themeVarsLight: Object,
    themeVarsScope: (0, Bo.makeStringProp)("local"),
    iconPrefix: String
};

function N8(t) {
    return t.replace(/([a-zA-Z])(\d)/g, "$1-$2")
}

function U8(t) {
    const e = {};
    return Object.keys(t).forEach(n => {
        const r = N8((0, Bo.kebabCase)(n));
        e[`--van-${r}`] = t[n]
    }), e
}

function Id(t = {}, e = {}) {
    Object.keys(t).forEach(n => {
        t[n] !== e[n] && document.documentElement.style.setProperty(n, t[n])
    }), Object.keys(e).forEach(n => {
        t[n] || document.documentElement.style.removeProperty(n)
    })
}
var G8 = (0, mr.defineComponent)({
        name: FI,
        props: NI,
        setup(t, {
            slots: e
        }) {
            const n = (0, mr.computed)(() => U8((0, Bo.extend)({}, t.themeVars, t.theme === "dark" ? t.themeVarsDark : t.themeVarsLight)));
            if (Bo.inBrowser) {
                const r = () => {
                        document.documentElement.classList.add(`van-theme-${t.theme}`)
                    },
                    i = (s = t.theme) => {
                        document.documentElement.classList.remove(`van-theme-${s}`)
                    };
                (0, mr.watch)(() => t.theme, (s, o) => {
                    o && i(o), r()
                }, {
                    immediate: !0
                }), (0, mr.onActivated)(r), (0, mr.onDeactivated)(i), (0, mr.onBeforeUnmount)(i), (0, mr.watch)(n, (s, o) => {
                    t.themeVarsScope === "global" && Id(s, o)
                }), (0, mr.watch)(() => t.themeVarsScope, (s, o) => {
                    o === "global" && Id({}, n.value), s === "global" && Id(n.value, {})
                }), t.themeVarsScope === "global" && Id(n.value, {})
            }
            return (0, mr.provide)(LI, t), (0, mr.watchEffect)(() => {
                t.zIndex !== void 0 && (0, F8.setGlobalZIndex)(t.zIndex)
            }), () => (0, mr.createVNode)(t.tag, {
                class: L8(),
                style: t.themeVarsScope === "local" ? n.value : void 0
            }, {
                default: () => {
                    var r;
                    return [(r = e.default) == null ? void 0 : r.call(e)]
                }
            })
        }
    }),
    ib = Object.defineProperty,
    H8 = Object.getOwnPropertyDescriptor,
    z8 = Object.getOwnPropertyNames,
    j8 = Object.prototype.hasOwnProperty,
    V8 = (t, e) => {
        for (var n in e) ib(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    W8 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of z8(e)) !j8.call(t, i) && i !== n && ib(t, i, {
                get: () => e[i],
                enumerable: !(r = H8(e, i)) || r.enumerable
            });
        return t
    },
    Y8 = t => W8(ib({}, "__esModule", {
        value: !0
    }), t),
    UI = {};
V8(UI, {
    default: () => Z8,
    iconProps: () => HI
});
var GI = Y8(UI),
    ba = sn,
    Mc = on,
    X8 = v8,
    K8 = $8;
const [q8, kE] = (0, Mc.createNamespace)("icon"), J8 = t => t == null ? void 0 : t.includes("/"), HI = {
    dot: Boolean,
    tag: (0, Mc.makeStringProp)("i"),
    name: String,
    size: Mc.numericProp,
    badge: Mc.numericProp,
    color: String,
    badgeProps: Object,
    classPrefix: String
};
var Z8 = (0, ba.defineComponent)({
        name: q8,
        props: HI,
        setup(t, {
            slots: e
        }) {
            const n = (0, ba.inject)(K8.CONFIG_PROVIDER_KEY, null),
                r = (0, ba.computed)(() => t.classPrefix || (n == null ? void 0 : n.iconPrefix) || kE());
            return () => {
                const {
                    tag: i,
                    dot: s,
                    name: o,
                    size: a,
                    badge: l,
                    color: c
                } = t, u = J8(o);
                return (0, ba.createVNode)(X8.Badge, (0, ba.mergeProps)({
                    dot: s,
                    tag: i,
                    class: [r.value, u ? "" : `${r.value}-${o}`],
                    style: {
                        color: c,
                        fontSize: (0, Mc.addUnit)(a)
                    },
                    content: l
                }, t.badgeProps), {
                    default: () => {
                        var d;
                        return [(d = e.default) == null ? void 0 : d.call(e), u && (0, ba.createVNode)("img", {
                            class: kE("image"),
                            src: o
                        }, null)]
                    }
                })
            }
        }
    }),
    Q8 = Object.create,
    up = Object.defineProperty,
    ez = Object.getOwnPropertyDescriptor,
    tz = Object.getOwnPropertyNames,
    nz = Object.getPrototypeOf,
    rz = Object.prototype.hasOwnProperty,
    iz = (t, e) => {
        for (var n in e) up(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    zI = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of tz(e)) !rz.call(t, i) && i !== n && up(t, i, {
                get: () => e[i],
                enumerable: !(r = ez(e, i)) || r.enumerable
            });
        return t
    },
    sz = (t, e, n) => (n = t != null ? Q8(nz(t)) : {}, zI(e || !t || !t.__esModule ? up(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    oz = t => zI(up({}, "__esModule", {
        value: !0
    }), t),
    jI = {};
iz(jI, {
    Icon: () => WI,
    default: () => uz,
    iconProps: () => cz.iconProps
});
var VI = oz(jI),
    az = on,
    lz = sz(GI),
    cz = GI;
const WI = (0, az.withInstall)(lz.default);
var uz = WI,
    sb = Object.defineProperty,
    dz = Object.getOwnPropertyDescriptor,
    fz = Object.getOwnPropertyNames,
    hz = Object.prototype.hasOwnProperty,
    pz = (t, e) => {
        for (var n in e) sb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    mz = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of fz(e)) !hz.call(t, i) && i !== n && sb(t, i, {
                get: () => e[i],
                enumerable: !(r = dz(e, i)) || r.enumerable
            });
        return t
    },
    gz = t => mz(sb({}, "__esModule", {
        value: !0
    }), t),
    YI = {};
pz(YI, {
    popupSharedPropKeys: () => yz,
    popupSharedProps: () => XI
});
var vz = gz(YI),
    ro = on;
const XI = {
        show: Boolean,
        zIndex: ro.numericProp,
        overlay: ro.truthProp,
        duration: ro.numericProp,
        teleport: [String, Object],
        lockScroll: ro.truthProp,
        lazyRender: ro.truthProp,
        beforeClose: Function,
        overlayStyle: Object,
        overlayClass: ro.unknownProp,
        transitionAppear: Boolean,
        closeOnClickOverlay: ro.truthProp
    },
    yz = Object.keys(XI);
var ob = Object.defineProperty,
    _z = Object.getOwnPropertyDescriptor,
    bz = Object.getOwnPropertyNames,
    xz = Object.prototype.hasOwnProperty,
    wz = (t, e) => {
        for (var n in e) ob(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    Ez = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of bz(e)) !xz.call(t, i) && i !== n && ob(t, i, {
                get: () => e[i],
                enumerable: !(r = _z(e, i)) || r.enumerable
            });
        return t
    },
    Sz = t => Ez(ob({}, "__esModule", {
        value: !0
    }), t),
    KI = {};
wz(KI, {
    useTouch: () => Pz
});
var Tz = Sz(KI),
    ts = sn,
    BE = on;

function Cz(t, e) {
    return t > e ? "horizontal" : e > t ? "vertical" : ""
}

function Pz() {
    const t = (0, ts.ref)(0),
        e = (0, ts.ref)(0),
        n = (0, ts.ref)(0),
        r = (0, ts.ref)(0),
        i = (0, ts.ref)(0),
        s = (0, ts.ref)(0),
        o = (0, ts.ref)(""),
        a = (0, ts.ref)(!0),
        l = () => o.value === "vertical",
        c = () => o.value === "horizontal",
        u = () => {
            n.value = 0, r.value = 0, i.value = 0, s.value = 0, o.value = "", a.value = !0
        };
    return {
        move: h => {
            const p = h.touches[0];
            n.value = (p.clientX < 0 ? 0 : p.clientX) - t.value, r.value = p.clientY - e.value, i.value = Math.abs(n.value), s.value = Math.abs(r.value);
            const b = 10;
            (!o.value || i.value < b && s.value < b) && (o.value = Cz(i.value, s.value)), a.value && (i.value > BE.TAP_OFFSET || s.value > BE.TAP_OFFSET) && (a.value = !1)
        },
        start: h => {
            u(), t.value = h.touches[0].clientX, e.value = h.touches[0].clientY
        },
        reset: u,
        startX: t,
        startY: e,
        deltaX: n,
        deltaY: r,
        offsetX: i,
        offsetY: s,
        direction: o,
        isVertical: l,
        isHorizontal: c,
        isTap: a
    }
}
var ab = Object.defineProperty,
    Az = Object.getOwnPropertyDescriptor,
    Oz = Object.getOwnPropertyNames,
    Iz = Object.prototype.hasOwnProperty,
    Rz = (t, e) => {
        for (var n in e) ab(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    Mz = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Oz(e)) !Iz.call(t, i) && i !== n && ab(t, i, {
                get: () => e[i],
                enumerable: !(r = Az(e, i)) || r.enumerable
            });
        return t
    },
    kz = t => Mz(ab({}, "__esModule", {
        value: !0
    }), t),
    qI = {};
Rz(qI, {
    useLockScroll: () => Fz
});
var Bz = kz(qI),
    Tm = sn,
    DE = op,
    Dz = Tz,
    $z = on;
let Jl = 0;
const $E = "van-overflow-hidden";

function Fz(t, e) {
    const n = (0, Dz.useTouch)(),
        r = "01",
        i = "10",
        s = u => {
            n.move(u);
            const d = n.deltaY.value > 0 ? i : r,
                f = (0, DE.getScrollParent)(u.target, t.value),
                {
                    scrollHeight: h,
                    offsetHeight: p,
                    scrollTop: b
                } = f;
            let y = "11";
            b === 0 ? y = p >= h ? "00" : "01" : b + p >= h && (y = "10"), y !== "11" && n.isVertical() && !(parseInt(y, 2) & parseInt(d, 2)) && (0, $z.preventDefault)(u, !0)
        },
        o = () => {
            document.addEventListener("touchstart", n.start), document.addEventListener("touchmove", s, {
                passive: !1
            }), Jl || document.body.classList.add($E), Jl++
        },
        a = () => {
            Jl && (document.removeEventListener("touchstart", n.start), document.removeEventListener("touchmove", s), Jl--, Jl || document.body.classList.remove($E))
        },
        l = () => e() && o(),
        c = () => e() && a();
    (0, DE.onMountedOrActivated)(l), (0, Tm.onDeactivated)(c), (0, Tm.onBeforeUnmount)(c), (0, Tm.watch)(e, u => {
        u ? o() : a()
    })
}
var lb = Object.defineProperty,
    Lz = Object.getOwnPropertyDescriptor,
    Nz = Object.getOwnPropertyNames,
    Uz = Object.prototype.hasOwnProperty,
    Gz = (t, e) => {
        for (var n in e) lb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    Hz = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Nz(e)) !Uz.call(t, i) && i !== n && lb(t, i, {
                get: () => e[i],
                enumerable: !(r = Lz(e, i)) || r.enumerable
            });
        return t
    },
    zz = t => Hz(lb({}, "__esModule", {
        value: !0
    }), t),
    JI = {};
Gz(JI, {
    useLazyRender: () => jz
});
var ZI = zz(JI),
    FE = sn;

function jz(t) {
    const e = (0, FE.ref)(!1);
    return (0, FE.watch)(t, n => {
        n && (e.value = n)
    }, {
        immediate: !0
    }), n => () => e.value ? n() : null
}
var cb = Object.defineProperty,
    Vz = Object.getOwnPropertyDescriptor,
    Wz = Object.getOwnPropertyNames,
    Yz = Object.prototype.hasOwnProperty,
    Xz = (t, e) => {
        for (var n in e) cb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    Kz = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Wz(e)) !Yz.call(t, i) && i !== n && cb(t, i, {
                get: () => e[i],
                enumerable: !(r = Vz(e, i)) || r.enumerable
            });
        return t
    },
    qz = t => Kz(cb({}, "__esModule", {
        value: !0
    }), t),
    QI = {};
Xz(QI, {
    POPUP_TOGGLE_KEY: () => eR,
    onPopupReopen: () => Zz
});
var Jz = qz(QI),
    LE = sn;
const eR = Symbol();

function Zz(t) {
    const e = (0, LE.inject)(eR, null);
    e && (0, LE.watch)(e, n => {
        n && t()
    })
}
var ub = Object.defineProperty,
    Qz = Object.getOwnPropertyDescriptor,
    e5 = Object.getOwnPropertyNames,
    t5 = Object.prototype.hasOwnProperty,
    n5 = (t, e) => {
        for (var n in e) ub(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    r5 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of e5(e)) !t5.call(t, i) && i !== n && ub(t, i, {
                get: () => e[i],
                enumerable: !(r = Qz(e, i)) || r.enumerable
            });
        return t
    },
    i5 = t => r5(ub({}, "__esModule", {
        value: !0
    }), t),
    tR = {};
n5(tR, {
    useScopeId: () => a5
});
var s5 = i5(tR),
    o5 = sn;
const a5 = () => {
    var t;
    const {
        scopeId: e
    } = ((t = (0, o5.getCurrentInstance)()) == null ? void 0 : t.vnode) || {};
    return e ? {
        [e]: ""
    } : null
};
var db = Object.defineProperty,
    l5 = Object.getOwnPropertyDescriptor,
    c5 = Object.getOwnPropertyNames,
    u5 = Object.prototype.hasOwnProperty,
    d5 = (t, e) => {
        for (var n in e) db(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    f5 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of c5(e)) !u5.call(t, i) && i !== n && db(t, i, {
                get: () => e[i],
                enumerable: !(r = l5(e, i)) || r.enumerable
            });
        return t
    },
    h5 = t => f5(db({}, "__esModule", {
        value: !0
    }), t),
    nR = {};
d5(nR, {
    default: () => y5,
    overlayProps: () => iR
});
var rR = h5(nR),
    fi = sn,
    qr = on,
    p5 = op,
    m5 = ZI;
const [g5, v5] = (0, qr.createNamespace)("overlay"), iR = {
    show: Boolean,
    zIndex: qr.numericProp,
    duration: qr.numericProp,
    className: qr.unknownProp,
    lockScroll: qr.truthProp,
    lazyRender: qr.truthProp,
    customStyle: Object,
    teleport: [String, Object]
};
var y5 = (0, fi.defineComponent)({
        name: g5,
        props: iR,
        setup(t, {
            slots: e
        }) {
            const n = (0, fi.ref)(),
                r = (0, m5.useLazyRender)(() => t.show || !t.lazyRender),
                i = o => {
                    t.lockScroll && (0, qr.preventDefault)(o, !0)
                },
                s = r(() => {
                    var o;
                    const a = (0, qr.extend)((0, qr.getZIndexStyle)(t.zIndex), t.customStyle);
                    return (0, qr.isDef)(t.duration) && (a.animationDuration = `${t.duration}s`), (0, fi.withDirectives)((0, fi.createVNode)("div", {
                        ref: n,
                        style: a,
                        class: [v5(), t.className]
                    }, [(o = e.default) == null ? void 0 : o.call(e)]), [
                        [fi.vShow, t.show]
                    ])
                });
            return (0, p5.useEventListener)("touchmove", i, {
                target: n
            }), () => {
                const o = (0, fi.createVNode)(fi.Transition, {
                    name: "van-fade",
                    appear: !0
                }, {
                    default: s
                });
                return t.teleport ? (0, fi.createVNode)(fi.Teleport, {
                    to: t.teleport
                }, {
                    default: () => [o]
                }) : o
            }
        }
    }),
    _5 = Object.create,
    dp = Object.defineProperty,
    b5 = Object.getOwnPropertyDescriptor,
    x5 = Object.getOwnPropertyNames,
    w5 = Object.getPrototypeOf,
    E5 = Object.prototype.hasOwnProperty,
    S5 = (t, e) => {
        for (var n in e) dp(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    sR = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of x5(e)) !E5.call(t, i) && i !== n && dp(t, i, {
                get: () => e[i],
                enumerable: !(r = b5(e, i)) || r.enumerable
            });
        return t
    },
    T5 = (t, e, n) => (n = t != null ? _5(w5(t)) : {}, sR(e || !t || !t.__esModule ? dp(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    C5 = t => sR(dp({}, "__esModule", {
        value: !0
    }), t),
    oR = {};
S5(oR, {
    Overlay: () => aR,
    default: () => R5,
    overlayProps: () => I5.overlayProps
});
var P5 = C5(oR),
    A5 = on,
    O5 = T5(rR),
    I5 = rR;
const aR = (0, A5.withInstall)(O5.default);
var R5 = aR,
    fb = Object.defineProperty,
    M5 = Object.getOwnPropertyDescriptor,
    k5 = Object.getOwnPropertyNames,
    B5 = Object.prototype.hasOwnProperty,
    D5 = (t, e) => {
        for (var n in e) fb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    $5 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of k5(e)) !B5.call(t, i) && i !== n && fb(t, i, {
                get: () => e[i],
                enumerable: !(r = M5(e, i)) || r.enumerable
            });
        return t
    },
    F5 = t => $5(fb({}, "__esModule", {
        value: !0
    }), t),
    lR = {};
D5(lR, {
    default: () => X5,
    popupProps: () => uR
});
var cR = F5(lR),
    _t = sn,
    L5 = vz,
    ms = on,
    N5 = op,
    U5 = EI,
    G5 = Bz,
    H5 = ZI,
    z5 = Jz,
    j5 = BI,
    NE = s5,
    V5 = VI,
    W5 = P5;
const uR = (0, ms.extend)({}, L5.popupSharedProps, {
        round: Boolean,
        position: (0, ms.makeStringProp)("center"),
        closeIcon: (0, ms.makeStringProp)("cross"),
        closeable: Boolean,
        transition: String,
        iconPrefix: String,
        closeOnPopstate: Boolean,
        closeIconPosition: (0, ms.makeStringProp)("top-right"),
        destroyOnClose: Boolean,
        safeAreaInsetTop: Boolean,
        safeAreaInsetBottom: Boolean
    }),
    [Y5, UE] = (0, ms.createNamespace)("popup");
var X5 = (0, _t.defineComponent)({
        name: Y5,
        inheritAttrs: !1,
        props: uR,
        emits: ["open", "close", "opened", "closed", "keydown", "update:show", "clickOverlay", "clickCloseIcon"],
        setup(t, {
            emit: e,
            attrs: n,
            slots: r
        }) {
            let i, s;
            const o = (0, _t.ref)(),
                a = (0, _t.ref)(),
                l = (0, H5.useLazyRender)(() => t.show || !t.lazyRender),
                c = (0, _t.computed)(() => {
                    const w = {
                        zIndex: o.value
                    };
                    if ((0, ms.isDef)(t.duration)) {
                        const S = t.position === "center" ? "animationDuration" : "transitionDuration";
                        w[S] = `${t.duration}s`
                    }
                    return w
                }),
                u = () => {
                    i || (i = !0, o.value = t.zIndex !== void 0 ? +t.zIndex : (0, j5.useGlobalZIndex)(), e("open"))
                },
                d = () => {
                    i && (0, ms.callInterceptor)(t.beforeClose, {
                        done() {
                            i = !1, e("close"), e("update:show", !1)
                        }
                    })
                },
                f = w => {
                    e("clickOverlay", w), t.closeOnClickOverlay && d()
                },
                h = () => {
                    if (t.overlay) return (0, _t.createVNode)(W5.Overlay, (0, _t.mergeProps)({
                        show: t.show,
                        class: t.overlayClass,
                        zIndex: o.value,
                        duration: t.duration,
                        customStyle: t.overlayStyle,
                        role: t.closeOnClickOverlay ? "button" : void 0,
                        tabindex: t.closeOnClickOverlay ? 0 : void 0
                    }, (0, NE.useScopeId)(), {
                        onClick: f
                    }), {
                        default: r["overlay-content"]
                    })
                },
                p = w => {
                    e("clickCloseIcon", w), d()
                },
                b = () => {
                    if (t.closeable) return (0, _t.createVNode)(V5.Icon, {
                        role: "button",
                        tabindex: 0,
                        name: t.closeIcon,
                        class: [UE("close-icon", t.closeIconPosition), ms.HAPTICS_FEEDBACK],
                        classPrefix: t.iconPrefix,
                        onClick: p
                    }, null)
                };
            let y;
            const m = () => {
                    y && clearTimeout(y), y = setTimeout(() => {
                        e("opened")
                    })
                },
                g = () => e("closed"),
                v = w => e("keydown", w),
                _ = l(() => {
                    var w;
                    const {
                        destroyOnClose: S,
                        round: C,
                        position: A,
                        safeAreaInsetTop: T,
                        safeAreaInsetBottom: E,
                        show: P
                    } = t;
                    if (!(!P && S)) return (0, _t.withDirectives)((0, _t.createVNode)("div", (0, _t.mergeProps)({
                        ref: a,
                        style: c.value,
                        role: "dialog",
                        tabindex: 0,
                        class: [UE({
                            round: C,
                            [A]: A
                        }), {
                            "van-safe-area-top": T,
                            "van-safe-area-bottom": E
                        }],
                        onKeydown: v
                    }, n, (0, NE.useScopeId)()), [(w = r.default) == null ? void 0 : w.call(r), b()]), [
                        [_t.vShow, P]
                    ])
                }),
                x = () => {
                    const {
                        position: w,
                        transition: S,
                        transitionAppear: C
                    } = t, A = w === "center" ? "van-fade" : `van-popup-slide-${w}`;
                    return (0, _t.createVNode)(_t.Transition, {
                        name: S || A,
                        appear: C,
                        onAfterEnter: m,
                        onAfterLeave: g
                    }, {
                        default: _
                    })
                };
            return (0, _t.watch)(() => t.show, w => {
                w && !i && (u(), n.tabindex === 0 && (0, _t.nextTick)(() => {
                    var S;
                    (S = a.value) == null || S.focus()
                })), !w && i && (i = !1, e("close"))
            }), (0, U5.useExpose)({
                popupRef: a
            }), (0, G5.useLockScroll)(a, () => t.show && t.lockScroll), (0, N5.useEventListener)("popstate", () => {
                t.closeOnPopstate && (d(), s = !1)
            }), (0, _t.onMounted)(() => {
                t.show && u()
            }), (0, _t.onActivated)(() => {
                s && (e("update:show", !0), s = !1)
            }), (0, _t.onDeactivated)(() => {
                t.show && t.teleport && (d(), s = !0)
            }), (0, _t.provide)(z5.POPUP_TOGGLE_KEY, () => t.show), () => t.teleport ? (0, _t.createVNode)(_t.Teleport, {
                to: t.teleport
            }, {
                default: () => [h(), x()]
            }) : (0, _t.createVNode)(_t.Fragment, null, [h(), x()])
        }
    }),
    K5 = Object.create,
    fp = Object.defineProperty,
    q5 = Object.getOwnPropertyDescriptor,
    J5 = Object.getOwnPropertyNames,
    Z5 = Object.getPrototypeOf,
    Q5 = Object.prototype.hasOwnProperty,
    ej = (t, e) => {
        for (var n in e) fp(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    dR = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of J5(e)) !Q5.call(t, i) && i !== n && fp(t, i, {
                get: () => e[i],
                enumerable: !(r = q5(e, i)) || r.enumerable
            });
        return t
    },
    tj = (t, e, n) => (n = t != null ? K5(Z5(t)) : {}, dR(e || !t || !t.__esModule ? fp(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    nj = t => dR(fp({}, "__esModule", {
        value: !0
    }), t),
    fR = {};
ej(fR, {
    Popup: () => hR,
    default: () => aj,
    popupProps: () => oj.popupProps
});
var rj = nj(fR),
    ij = on,
    sj = tj(cR),
    oj = cR;
const hR = (0, ij.withInstall)(sj.default);
var aj = hR,
    hb = Object.defineProperty,
    lj = Object.getOwnPropertyDescriptor,
    cj = Object.getOwnPropertyNames,
    uj = Object.prototype.hasOwnProperty,
    dj = (t, e) => {
        for (var n in e) hb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    fj = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of cj(e)) !uj.call(t, i) && i !== n && hb(t, i, {
                get: () => e[i],
                enumerable: !(r = lj(e, i)) || r.enumerable
            });
        return t
    },
    hj = t => fj(hb({}, "__esModule", {
        value: !0
    }), t),
    pR = {};
dj(pR, {
    default: () => vj,
    loadingProps: () => gR
});
var mR = hj(pR),
    fs = sn,
    Do = on;
const [pj, kc] = (0, Do.createNamespace)("loading"), mj = Array(12).fill(null).map((t, e) => (0, fs.createVNode)("i", {
    class: kc("line", String(e + 1))
}, null)), gj = (0, fs.createVNode)("svg", {
    class: kc("circular"),
    viewBox: "25 25 50 50"
}, [(0, fs.createVNode)("circle", {
    cx: "50",
    cy: "50",
    r: "20",
    fill: "none"
}, null)]), gR = {
    size: Do.numericProp,
    type: (0, Do.makeStringProp)("circular"),
    color: String,
    vertical: Boolean,
    textSize: Do.numericProp,
    textColor: String
};
var vj = (0, fs.defineComponent)({
        name: pj,
        props: gR,
        setup(t, {
            slots: e
        }) {
            const n = (0, fs.computed)(() => (0, Do.extend)({
                    color: t.color
                }, (0, Do.getSizeStyle)(t.size))),
                r = () => {
                    const s = t.type === "spinner" ? mj : gj;
                    return (0, fs.createVNode)("span", {
                        class: kc("spinner", t.type),
                        style: n.value
                    }, [e.icon ? e.icon() : s])
                },
                i = () => {
                    var s;
                    if (e.default) return (0, fs.createVNode)("span", {
                        class: kc("text"),
                        style: {
                            fontSize: (0, Do.addUnit)(t.textSize),
                            color: (s = t.textColor) != null ? s : t.color
                        }
                    }, [e.default()])
                };
            return () => {
                const {
                    type: s,
                    vertical: o
                } = t;
                return (0, fs.createVNode)("div", {
                    class: kc([s, {
                        vertical: o
                    }]),
                    "aria-live": "polite",
                    "aria-busy": !0
                }, [r(), i()])
            }
        }
    }),
    yj = Object.create,
    hp = Object.defineProperty,
    _j = Object.getOwnPropertyDescriptor,
    bj = Object.getOwnPropertyNames,
    xj = Object.getPrototypeOf,
    wj = Object.prototype.hasOwnProperty,
    Ej = (t, e) => {
        for (var n in e) hp(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    vR = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of bj(e)) !wj.call(t, i) && i !== n && hp(t, i, {
                get: () => e[i],
                enumerable: !(r = _j(e, i)) || r.enumerable
            });
        return t
    },
    Sj = (t, e, n) => (n = t != null ? yj(xj(t)) : {}, vR(e || !t || !t.__esModule ? hp(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    Tj = t => vR(hp({}, "__esModule", {
        value: !0
    }), t),
    yR = {};
Ej(yR, {
    Loading: () => _R,
    default: () => Ij,
    loadingProps: () => Oj.loadingProps
});
var Cj = Tj(yR),
    Pj = on,
    Aj = Sj(mR),
    Oj = mR;
const _R = (0, Pj.withInstall)(Aj.default);
var Ij = _R,
    pb = Object.defineProperty,
    Rj = Object.getOwnPropertyDescriptor,
    Mj = Object.getOwnPropertyNames,
    kj = Object.prototype.hasOwnProperty,
    Bj = (t, e) => {
        for (var n in e) pb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    Dj = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Mj(e)) !kj.call(t, i) && i !== n && pb(t, i, {
                get: () => e[i],
                enumerable: !(r = Rj(e, i)) || r.enumerable
            });
        return t
    },
    $j = t => Dj(pb({}, "__esModule", {
        value: !0
    }), t),
    bR = {};
Bj(bR, {
    default: () => jj,
    toastProps: () => xR
});
var Fj = $j(bR),
    sr = sn,
    cr = on,
    Lj = QH,
    Nj = VI,
    Uj = rj,
    Gj = Cj;
const [Hj, xa] = (0, cr.createNamespace)("toast"), zj = ["show", "overlay", "teleport", "transition", "overlayClass", "overlayStyle", "closeOnClickOverlay", "zIndex"], xR = {
    icon: String,
    show: Boolean,
    type: (0, cr.makeStringProp)("text"),
    overlay: Boolean,
    message: cr.numericProp,
    iconSize: cr.numericProp,
    duration: (0, cr.makeNumberProp)(2e3),
    position: (0, cr.makeStringProp)("middle"),
    teleport: [String, Object],
    wordBreak: String,
    className: cr.unknownProp,
    iconPrefix: String,
    transition: (0, cr.makeStringProp)("van-fade"),
    loadingType: String,
    forbidClick: Boolean,
    overlayClass: cr.unknownProp,
    overlayStyle: Object,
    closeOnClick: Boolean,
    closeOnClickOverlay: Boolean,
    zIndex: cr.numericProp
};
var jj = (0, sr.defineComponent)({
        name: Hj,
        props: xR,
        emits: ["update:show"],
        setup(t, {
            emit: e,
            slots: n
        }) {
            let r, i = !1;
            const s = () => {
                    const d = t.show && t.forbidClick;
                    i !== d && (i = d, (0, Lj.lockClick)(i))
                },
                o = d => e("update:show", d),
                a = () => {
                    t.closeOnClick && o(!1)
                },
                l = () => clearTimeout(r),
                c = () => {
                    const {
                        icon: d,
                        type: f,
                        iconSize: h,
                        iconPrefix: p,
                        loadingType: b
                    } = t;
                    if (d || f === "success" || f === "fail") return (0, sr.createVNode)(Nj.Icon, {
                        name: d || f,
                        size: h,
                        class: xa("icon"),
                        classPrefix: p
                    }, null);
                    if (f === "loading") return (0, sr.createVNode)(Gj.Loading, {
                        class: xa("loading"),
                        size: h,
                        type: b
                    }, null)
                },
                u = () => {
                    const {
                        type: d,
                        message: f
                    } = t;
                    if (n.message) return (0, sr.createVNode)("div", {
                        class: xa("text")
                    }, [n.message()]);
                    if ((0, cr.isDef)(f) && f !== "") return d === "html" ? (0, sr.createVNode)("div", {
                        key: 0,
                        class: xa("text"),
                        innerHTML: String(f)
                    }, null) : (0, sr.createVNode)("div", {
                        class: xa("text")
                    }, [f])
                };
            return (0, sr.watch)(() => [t.show, t.forbidClick], s), (0, sr.watch)(() => [t.show, t.type, t.message, t.duration], () => {
                l(), t.show && t.duration > 0 && (r = setTimeout(() => {
                    o(!1)
                }, t.duration))
            }), (0, sr.onMounted)(s), (0, sr.onUnmounted)(s), () => (0, sr.createVNode)(Uj.Popup, (0, sr.mergeProps)({
                class: [xa([t.position, t.wordBreak === "normal" ? "break-normal" : t.wordBreak, {
                    [t.type]: !t.icon
                }]), t.className],
                lockScroll: !1,
                onClick: a,
                onClosed: l,
                "onUpdate:show": o
            }, (0, cr.pick)(t, zj)), {
                default: () => [c(), u()]
            })
        }
    }),
    Vj = Object.create,
    pp = Object.defineProperty,
    Wj = Object.getOwnPropertyDescriptor,
    Yj = Object.getOwnPropertyNames,
    Xj = Object.getPrototypeOf,
    Kj = Object.prototype.hasOwnProperty,
    qj = (t, e) => {
        for (var n in e) pp(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    wR = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Yj(e)) !Kj.call(t, i) && i !== n && pp(t, i, {
                get: () => e[i],
                enumerable: !(r = Wj(e, i)) || r.enumerable
            });
        return t
    },
    Jj = (t, e, n) => (n = t != null ? Vj(Xj(t)) : {}, wR(e || !t || !t.__esModule ? pp(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    Zj = t => wR(pp({}, "__esModule", {
        value: !0
    }), t),
    ER = {};
qj(ER, {
    allowMultipleToast: () => lV,
    closeToast: () => sV,
    resetToastDefaultOptions: () => aV,
    setToastDefaultOptions: () => oV,
    showFailToast: () => iV,
    showLoadingToast: () => nV,
    showSuccessToast: () => rV,
    showToast: () => CR
});
var L0e = Zj(ER),
    Zl = sn,
    jo = on,
    GE = HH,
    Qj = Jj(Fj);
const SR = {
    icon: "",
    type: "text",
    message: "",
    className: "",
    overlay: !1,
    onClose: void 0,
    onOpened: void 0,
    duration: 2e3,
    teleport: "body",
    iconSize: void 0,
    iconPrefix: void 0,
    position: "middle",
    transition: "van-fade",
    forbidClick: !1,
    loadingType: void 0,
    overlayClass: "",
    overlayStyle: void 0,
    closeOnClick: !1,
    closeOnClickOverlay: !1
};
let wr = [],
    mp = !1,
    ih = (0, jo.extend)({}, SR);
const sh = new Map;

function TR(t) {
    return (0, jo.isObject)(t) ? t : {
        message: t
    }
}

function eV() {
    const {
        instance: t,
        unmount: e
    } = (0, GE.mountComponent)({
        setup() {
            const n = (0, Zl.ref)(""),
                {
                    open: r,
                    state: i,
                    close: s,
                    toggle: o
                } = (0, GE.usePopupState)(),
                a = () => {
                    mp && (wr = wr.filter(c => c !== t), e())
                },
                l = () => {
                    const c = {
                        onClosed: a,
                        "onUpdate:show": o
                    };
                    return (0, Zl.createVNode)(Qj.default, (0, Zl.mergeProps)(i, c), null)
                };
            return (0, Zl.watch)(n, c => {
                i.message = c
            }), (0, Zl.getCurrentInstance)().render = l, {
                open: r,
                close: s,
                message: n
            }
        }
    });
    return t
}

function tV() {
    if (!wr.length || mp) {
        const t = eV();
        wr.push(t)
    }
    return wr[wr.length - 1]
}

function CR(t = {}) {
    if (!jo.inBrowser) return {};
    const e = tV(),
        n = TR(t);
    return e.open((0, jo.extend)({}, ih, sh.get(n.type || ih.type), n)), e
}
const mb = t => e => CR((0, jo.extend)({
        type: t
    }, TR(e))),
    nV = mb("loading"),
    rV = mb("success"),
    iV = mb("fail"),
    sV = t => {
        var e;
        wr.length && (t ? (wr.forEach(n => {
            n.close()
        }), wr = []) : mp ? (e = wr.shift()) == null || e.close() : wr[0].close())
    };

function oV(t, e) {
    typeof t == "string" ? sh.set(t, e) : (0, jo.extend)(ih, t)
}
const aV = t => {
        typeof t == "string" ? sh.delete(t) : (ih = (0, jo.extend)({}, SR), sh.clear())
    },
    lV = (t = !0) => {
        mp = t
    };
var PR = {
    exports: {}
};
(function(t, e) {
    (function(n) {
        t.exports = n()
    })(function(n) {
        var r = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];

        function i(m, g) {
            var v = m[0],
                _ = m[1],
                x = m[2],
                w = m[3];
            v += (_ & x | ~_ & w) + g[0] - 680876936 | 0, v = (v << 7 | v >>> 25) + _ | 0, w += (v & _ | ~v & x) + g[1] - 389564586 | 0, w = (w << 12 | w >>> 20) + v | 0, x += (w & v | ~w & _) + g[2] + 606105819 | 0, x = (x << 17 | x >>> 15) + w | 0, _ += (x & w | ~x & v) + g[3] - 1044525330 | 0, _ = (_ << 22 | _ >>> 10) + x | 0, v += (_ & x | ~_ & w) + g[4] - 176418897 | 0, v = (v << 7 | v >>> 25) + _ | 0, w += (v & _ | ~v & x) + g[5] + 1200080426 | 0, w = (w << 12 | w >>> 20) + v | 0, x += (w & v | ~w & _) + g[6] - 1473231341 | 0, x = (x << 17 | x >>> 15) + w | 0, _ += (x & w | ~x & v) + g[7] - 45705983 | 0, _ = (_ << 22 | _ >>> 10) + x | 0, v += (_ & x | ~_ & w) + g[8] + 1770035416 | 0, v = (v << 7 | v >>> 25) + _ | 0, w += (v & _ | ~v & x) + g[9] - 1958414417 | 0, w = (w << 12 | w >>> 20) + v | 0, x += (w & v | ~w & _) + g[10] - 42063 | 0, x = (x << 17 | x >>> 15) + w | 0, _ += (x & w | ~x & v) + g[11] - 1990404162 | 0, _ = (_ << 22 | _ >>> 10) + x | 0, v += (_ & x | ~_ & w) + g[12] + 1804603682 | 0, v = (v << 7 | v >>> 25) + _ | 0, w += (v & _ | ~v & x) + g[13] - 40341101 | 0, w = (w << 12 | w >>> 20) + v | 0, x += (w & v | ~w & _) + g[14] - 1502002290 | 0, x = (x << 17 | x >>> 15) + w | 0, _ += (x & w | ~x & v) + g[15] + 1236535329 | 0, _ = (_ << 22 | _ >>> 10) + x | 0, v += (_ & w | x & ~w) + g[1] - 165796510 | 0, v = (v << 5 | v >>> 27) + _ | 0, w += (v & x | _ & ~x) + g[6] - 1069501632 | 0, w = (w << 9 | w >>> 23) + v | 0, x += (w & _ | v & ~_) + g[11] + 643717713 | 0, x = (x << 14 | x >>> 18) + w | 0, _ += (x & v | w & ~v) + g[0] - 373897302 | 0, _ = (_ << 20 | _ >>> 12) + x | 0, v += (_ & w | x & ~w) + g[5] - 701558691 | 0, v = (v << 5 | v >>> 27) + _ | 0, w += (v & x | _ & ~x) + g[10] + 38016083 | 0, w = (w << 9 | w >>> 23) + v | 0, x += (w & _ | v & ~_) + g[15] - 660478335 | 0, x = (x << 14 | x >>> 18) + w | 0, _ += (x & v | w & ~v) + g[4] - 405537848 | 0, _ = (_ << 20 | _ >>> 12) + x | 0, v += (_ & w | x & ~w) + g[9] + 568446438 | 0, v = (v << 5 | v >>> 27) + _ | 0, w += (v & x | _ & ~x) + g[14] - 1019803690 | 0, w = (w << 9 | w >>> 23) + v | 0, x += (w & _ | v & ~_) + g[3] - 187363961 | 0, x = (x << 14 | x >>> 18) + w | 0, _ += (x & v | w & ~v) + g[8] + 1163531501 | 0, _ = (_ << 20 | _ >>> 12) + x | 0, v += (_ & w | x & ~w) + g[13] - 1444681467 | 0, v = (v << 5 | v >>> 27) + _ | 0, w += (v & x | _ & ~x) + g[2] - 51403784 | 0, w = (w << 9 | w >>> 23) + v | 0, x += (w & _ | v & ~_) + g[7] + 1735328473 | 0, x = (x << 14 | x >>> 18) + w | 0, _ += (x & v | w & ~v) + g[12] - 1926607734 | 0, _ = (_ << 20 | _ >>> 12) + x | 0, v += (_ ^ x ^ w) + g[5] - 378558 | 0, v = (v << 4 | v >>> 28) + _ | 0, w += (v ^ _ ^ x) + g[8] - 2022574463 | 0, w = (w << 11 | w >>> 21) + v | 0, x += (w ^ v ^ _) + g[11] + 1839030562 | 0, x = (x << 16 | x >>> 16) + w | 0, _ += (x ^ w ^ v) + g[14] - 35309556 | 0, _ = (_ << 23 | _ >>> 9) + x | 0, v += (_ ^ x ^ w) + g[1] - 1530992060 | 0, v = (v << 4 | v >>> 28) + _ | 0, w += (v ^ _ ^ x) + g[4] + 1272893353 | 0, w = (w << 11 | w >>> 21) + v | 0, x += (w ^ v ^ _) + g[7] - 155497632 | 0, x = (x << 16 | x >>> 16) + w | 0, _ += (x ^ w ^ v) + g[10] - 1094730640 | 0, _ = (_ << 23 | _ >>> 9) + x | 0, v += (_ ^ x ^ w) + g[13] + 681279174 | 0, v = (v << 4 | v >>> 28) + _ | 0, w += (v ^ _ ^ x) + g[0] - 358537222 | 0, w = (w << 11 | w >>> 21) + v | 0, x += (w ^ v ^ _) + g[3] - 722521979 | 0, x = (x << 16 | x >>> 16) + w | 0, _ += (x ^ w ^ v) + g[6] + 76029189 | 0, _ = (_ << 23 | _ >>> 9) + x | 0, v += (_ ^ x ^ w) + g[9] - 640364487 | 0, v = (v << 4 | v >>> 28) + _ | 0, w += (v ^ _ ^ x) + g[12] - 421815835 | 0, w = (w << 11 | w >>> 21) + v | 0, x += (w ^ v ^ _) + g[15] + 530742520 | 0, x = (x << 16 | x >>> 16) + w | 0, _ += (x ^ w ^ v) + g[2] - 995338651 | 0, _ = (_ << 23 | _ >>> 9) + x | 0, v += (x ^ (_ | ~w)) + g[0] - 198630844 | 0, v = (v << 6 | v >>> 26) + _ | 0, w += (_ ^ (v | ~x)) + g[7] + 1126891415 | 0, w = (w << 10 | w >>> 22) + v | 0, x += (v ^ (w | ~_)) + g[14] - 1416354905 | 0, x = (x << 15 | x >>> 17) + w | 0, _ += (w ^ (x | ~v)) + g[5] - 57434055 | 0, _ = (_ << 21 | _ >>> 11) + x | 0, v += (x ^ (_ | ~w)) + g[12] + 1700485571 | 0, v = (v << 6 | v >>> 26) + _ | 0, w += (_ ^ (v | ~x)) + g[3] - 1894986606 | 0, w = (w << 10 | w >>> 22) + v | 0, x += (v ^ (w | ~_)) + g[10] - 1051523 | 0, x = (x << 15 | x >>> 17) + w | 0, _ += (w ^ (x | ~v)) + g[1] - 2054922799 | 0, _ = (_ << 21 | _ >>> 11) + x | 0, v += (x ^ (_ | ~w)) + g[8] + 1873313359 | 0, v = (v << 6 | v >>> 26) + _ | 0, w += (_ ^ (v | ~x)) + g[15] - 30611744 | 0, w = (w << 10 | w >>> 22) + v | 0, x += (v ^ (w | ~_)) + g[6] - 1560198380 | 0, x = (x << 15 | x >>> 17) + w | 0, _ += (w ^ (x | ~v)) + g[13] + 1309151649 | 0, _ = (_ << 21 | _ >>> 11) + x | 0, v += (x ^ (_ | ~w)) + g[4] - 145523070 | 0, v = (v << 6 | v >>> 26) + _ | 0, w += (_ ^ (v | ~x)) + g[11] - 1120210379 | 0, w = (w << 10 | w >>> 22) + v | 0, x += (v ^ (w | ~_)) + g[2] + 718787259 | 0, x = (x << 15 | x >>> 17) + w | 0, _ += (w ^ (x | ~v)) + g[9] - 343485551 | 0, _ = (_ << 21 | _ >>> 11) + x | 0, m[0] = v + m[0] | 0, m[1] = _ + m[1] | 0, m[2] = x + m[2] | 0, m[3] = w + m[3] | 0
        }

        function s(m) {
            var g = [],
                v;
            for (v = 0; v < 64; v += 4) g[v >> 2] = m.charCodeAt(v) + (m.charCodeAt(v + 1) << 8) + (m.charCodeAt(v + 2) << 16) + (m.charCodeAt(v + 3) << 24);
            return g
        }

        function o(m) {
            var g = [],
                v;
            for (v = 0; v < 64; v += 4) g[v >> 2] = m[v] + (m[v + 1] << 8) + (m[v + 2] << 16) + (m[v + 3] << 24);
            return g
        }

        function a(m) {
            var g = m.length,
                v = [1732584193, -271733879, -1732584194, 271733878],
                _, x, w, S, C, A;
            for (_ = 64; _ <= g; _ += 64) i(v, s(m.substring(_ - 64, _)));
            for (m = m.substring(_ - 64), x = m.length, w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], _ = 0; _ < x; _ += 1) w[_ >> 2] |= m.charCodeAt(_) << (_ % 4 << 3);
            if (w[_ >> 2] |= 128 << (_ % 4 << 3), _ > 55)
                for (i(v, w), _ = 0; _ < 16; _ += 1) w[_] = 0;
            return S = g * 8, S = S.toString(16).match(/(.*?)(.{0,8})$/), C = parseInt(S[2], 16), A = parseInt(S[1], 16) || 0, w[14] = C, w[15] = A, i(v, w), v
        }

        function l(m) {
            var g = m.length,
                v = [1732584193, -271733879, -1732584194, 271733878],
                _, x, w, S, C, A;
            for (_ = 64; _ <= g; _ += 64) i(v, o(m.subarray(_ - 64, _)));
            for (m = _ - 64 < g ? m.subarray(_ - 64) : new Uint8Array(0), x = m.length, w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], _ = 0; _ < x; _ += 1) w[_ >> 2] |= m[_] << (_ % 4 << 3);
            if (w[_ >> 2] |= 128 << (_ % 4 << 3), _ > 55)
                for (i(v, w), _ = 0; _ < 16; _ += 1) w[_] = 0;
            return S = g * 8, S = S.toString(16).match(/(.*?)(.{0,8})$/), C = parseInt(S[2], 16), A = parseInt(S[1], 16) || 0, w[14] = C, w[15] = A, i(v, w), v
        }

        function c(m) {
            var g = "",
                v;
            for (v = 0; v < 4; v += 1) g += r[m >> v * 8 + 4 & 15] + r[m >> v * 8 & 15];
            return g
        }

        function u(m) {
            var g;
            for (g = 0; g < m.length; g += 1) m[g] = c(m[g]);
            return m.join("")
        }
        u(a("hello")), typeof ArrayBuffer < "u" && !ArrayBuffer.prototype.slice && function() {
            function m(g, v) {
                return g = g | 0 || 0, g < 0 ? Math.max(g + v, 0) : Math.min(g, v)
            }
            ArrayBuffer.prototype.slice = function(g, v) {
                var _ = this.byteLength,
                    x = m(g, _),
                    w = _,
                    S, C, A, T;
                return v !== n && (w = m(v, _)), x > w ? new ArrayBuffer(0) : (S = w - x, C = new ArrayBuffer(S), A = new Uint8Array(C), T = new Uint8Array(this, x, S), A.set(T), C)
            }
        }();

        function d(m) {
            return /[\u0080-\uFFFF]/.test(m) && (m = unescape(encodeURIComponent(m))), m
        }

        function f(m, g) {
            var v = m.length,
                _ = new ArrayBuffer(v),
                x = new Uint8Array(_),
                w;
            for (w = 0; w < v; w += 1) x[w] = m.charCodeAt(w);
            return g ? x : _
        }

        function h(m) {
            return String.fromCharCode.apply(null, new Uint8Array(m))
        }

        function p(m, g, v) {
            var _ = new Uint8Array(m.byteLength + g.byteLength);
            return _.set(new Uint8Array(m)), _.set(new Uint8Array(g), m.byteLength), v ? _ : _.buffer
        }

        function b(m) {
            var g = [],
                v = m.length,
                _;
            for (_ = 0; _ < v - 1; _ += 2) g.push(parseInt(m.substr(_, 2), 16));
            return String.fromCharCode.apply(String, g)
        }

        function y() {
            this.reset()
        }
        return y.prototype.append = function(m) {
            return this.appendBinary(d(m)), this
        }, y.prototype.appendBinary = function(m) {
            this._buff += m, this._length += m.length;
            var g = this._buff.length,
                v;
            for (v = 64; v <= g; v += 64) i(this._hash, s(this._buff.substring(v - 64, v)));
            return this._buff = this._buff.substring(v - 64), this
        }, y.prototype.end = function(m) {
            var g = this._buff,
                v = g.length,
                _, x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                w;
            for (_ = 0; _ < v; _ += 1) x[_ >> 2] |= g.charCodeAt(_) << (_ % 4 << 3);
            return this._finish(x, v), w = u(this._hash), m && (w = b(w)), this.reset(), w
        }, y.prototype.reset = function() {
            return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this
        }, y.prototype.getState = function() {
            return {
                buff: this._buff,
                length: this._length,
                hash: this._hash.slice()
            }
        }, y.prototype.setState = function(m) {
            return this._buff = m.buff, this._length = m.length, this._hash = m.hash, this
        }, y.prototype.destroy = function() {
            delete this._hash, delete this._buff, delete this._length
        }, y.prototype._finish = function(m, g) {
            var v = g,
                _, x, w;
            if (m[v >> 2] |= 128 << (v % 4 << 3), v > 55)
                for (i(this._hash, m), v = 0; v < 16; v += 1) m[v] = 0;
            _ = this._length * 8, _ = _.toString(16).match(/(.*?)(.{0,8})$/), x = parseInt(_[2], 16), w = parseInt(_[1], 16) || 0, m[14] = x, m[15] = w, i(this._hash, m)
        }, y.hash = function(m, g) {
            return y.hashBinary(d(m), g)
        }, y.hashBinary = function(m, g) {
            var v = a(m),
                _ = u(v);
            return g ? b(_) : _
        }, y.ArrayBuffer = function() {
            this.reset()
        }, y.ArrayBuffer.prototype.append = function(m) {
            var g = p(this._buff.buffer, m, !0),
                v = g.length,
                _;
            for (this._length += m.byteLength, _ = 64; _ <= v; _ += 64) i(this._hash, o(g.subarray(_ - 64, _)));
            return this._buff = _ - 64 < v ? new Uint8Array(g.buffer.slice(_ - 64)) : new Uint8Array(0), this
        }, y.ArrayBuffer.prototype.end = function(m) {
            var g = this._buff,
                v = g.length,
                _ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                x, w;
            for (x = 0; x < v; x += 1) _[x >> 2] |= g[x] << (x % 4 << 3);
            return this._finish(_, v), w = u(this._hash), m && (w = b(w)), this.reset(), w
        }, y.ArrayBuffer.prototype.reset = function() {
            return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this
        }, y.ArrayBuffer.prototype.getState = function() {
            var m = y.prototype.getState.call(this);
            return m.buff = h(m.buff), m
        }, y.ArrayBuffer.prototype.setState = function(m) {
            return m.buff = f(m.buff, !0), y.prototype.setState.call(this, m)
        }, y.ArrayBuffer.prototype.destroy = y.prototype.destroy, y.ArrayBuffer.prototype._finish = y.prototype._finish, y.ArrayBuffer.hash = function(m, g) {
            var v = l(new Uint8Array(m)),
                _ = u(v);
            return g ? b(_) : _
        }, y
    })
})(PR);
var cV = PR.exports;
const N0e = ua(cV);
var AR = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    })(zo, function() {
        var n = 1e3,
            r = 6e4,
            i = 36e5,
            s = "millisecond",
            o = "second",
            a = "minute",
            l = "hour",
            c = "day",
            u = "week",
            d = "month",
            f = "quarter",
            h = "year",
            p = "date",
            b = "Invalid Date",
            y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
            m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
            g = {
                name: "en",
                weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                ordinal: function(F) {
                    var H = ["th", "st", "nd", "rd"],
                        k = F % 100;
                    return "[" + F + (H[(k - 20) % 10] || H[k] || H[0]) + "]"
                }
            },
            v = function(F, H, k) {
                var N = String(F);
                return !N || N.length >= H ? F : "" + Array(H + 1 - N.length).join(k) + F
            },
            _ = {
                s: v,
                z: function(F) {
                    var H = -F.utcOffset(),
                        k = Math.abs(H),
                        N = Math.floor(k / 60),
                        V = k % 60;
                    return (H <= 0 ? "+" : "-") + v(N, 2, "0") + ":" + v(V, 2, "0")
                },
                m: function F(H, k) {
                    if (H.date() < k.date()) return -F(k, H);
                    var N = 12 * (k.year() - H.year()) + (k.month() - H.month()),
                        V = H.clone().add(N, d),
                        Y = k - V < 0,
                        le = H.clone().add(N + (Y ? -1 : 1), d);
                    return +(-(N + (k - V) / (Y ? V - le : le - V)) || 0)
                },
                a: function(F) {
                    return F < 0 ? Math.ceil(F) || 0 : Math.floor(F)
                },
                p: function(F) {
                    return {
                        M: d,
                        y: h,
                        w: u,
                        d: c,
                        D: p,
                        h: l,
                        m: a,
                        s: o,
                        ms: s,
                        Q: f
                    }[F] || String(F || "").toLowerCase().replace(/s$/, "")
                },
                u: function(F) {
                    return F === void 0
                }
            },
            x = "en",
            w = {};
        w[x] = g;
        var S = "$isDayjsObject",
            C = function(F) {
                return F instanceof P || !(!F || !F[S])
            },
            A = function F(H, k, N) {
                var V;
                if (!H) return x;
                if (typeof H == "string") {
                    var Y = H.toLowerCase();
                    w[Y] && (V = Y), k && (w[Y] = k, V = Y);
                    var le = H.split("-");
                    if (!V && le.length > 1) return F(le[0])
                } else {
                    var ae = H.name;
                    w[ae] = H, V = ae
                }
                return !N && V && (x = V), V || !N && x
            },
            T = function(F, H) {
                if (C(F)) return F.clone();
                var k = typeof H == "object" ? H : {};
                return k.date = F, k.args = arguments, new P(k)
            },
            E = _;
        E.l = A, E.i = C, E.w = function(F, H) {
            return T(F, {
                locale: H.$L,
                utc: H.$u,
                x: H.$x,
                $offset: H.$offset
            })
        };
        var P = function() {
                function F(k) {
                    this.$L = A(k.locale, null, !0), this.parse(k), this.$x = this.$x || k.x || {}, this[S] = !0
                }
                var H = F.prototype;
                return H.parse = function(k) {
                    this.$d = function(N) {
                        var V = N.date,
                            Y = N.utc;
                        if (V === null) return new Date(NaN);
                        if (E.u(V)) return new Date;
                        if (V instanceof Date) return new Date(V);
                        if (typeof V == "string" && !/Z$/i.test(V)) {
                            var le = V.match(y);
                            if (le) {
                                var ae = le[2] - 1 || 0,
                                    W = (le[7] || "0").substring(0, 3);
                                return Y ? new Date(Date.UTC(le[1], ae, le[3] || 1, le[4] || 0, le[5] || 0, le[6] || 0, W)) : new Date(le[1], ae, le[3] || 1, le[4] || 0, le[5] || 0, le[6] || 0, W)
                            }
                        }
                        return new Date(V)
                    }(k), this.init()
                }, H.init = function() {
                    var k = this.$d;
                    this.$y = k.getFullYear(), this.$M = k.getMonth(), this.$D = k.getDate(), this.$W = k.getDay(), this.$H = k.getHours(), this.$m = k.getMinutes(), this.$s = k.getSeconds(), this.$ms = k.getMilliseconds()
                }, H.$utils = function() {
                    return E
                }, H.isValid = function() {
                    return this.$d.toString() !== b
                }, H.isSame = function(k, N) {
                    var V = T(k);
                    return this.startOf(N) <= V && V <= this.endOf(N)
                }, H.isAfter = function(k, N) {
                    return T(k) < this.startOf(N)
                }, H.isBefore = function(k, N) {
                    return this.endOf(N) < T(k)
                }, H.$g = function(k, N, V) {
                    return E.u(k) ? this[N] : this.set(V, k)
                }, H.unix = function() {
                    return Math.floor(this.valueOf() / 1e3)
                }, H.valueOf = function() {
                    return this.$d.getTime()
                }, H.startOf = function(k, N) {
                    var V = this,
                        Y = !!E.u(N) || N,
                        le = E.p(k),
                        ae = function(K, ce) {
                            var de = E.w(V.$u ? Date.UTC(V.$y, ce, K) : new Date(V.$y, ce, K), V);
                            return Y ? de : de.endOf(c)
                        },
                        W = function(K, ce) {
                            return E.w(V.toDate()[K].apply(V.toDate("s"), (Y ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ce)), V)
                        },
                        Q = this.$W,
                        fe = this.$M,
                        D = this.$D,
                        X = "set" + (this.$u ? "UTC" : "");
                    switch (le) {
                        case h:
                            return Y ? ae(1, 0) : ae(31, 11);
                        case d:
                            return Y ? ae(1, fe) : ae(0, fe + 1);
                        case u:
                            var $ = this.$locale().weekStart || 0,
                                Z = (Q < $ ? Q + 7 : Q) - $;
                            return ae(Y ? D - Z : D + (6 - Z), fe);
                        case c:
                        case p:
                            return W(X + "Hours", 0);
                        case l:
                            return W(X + "Minutes", 1);
                        case a:
                            return W(X + "Seconds", 2);
                        case o:
                            return W(X + "Milliseconds", 3);
                        default:
                            return this.clone()
                    }
                }, H.endOf = function(k) {
                    return this.startOf(k, !1)
                }, H.$set = function(k, N) {
                    var V, Y = E.p(k),
                        le = "set" + (this.$u ? "UTC" : ""),
                        ae = (V = {}, V[c] = le + "Date", V[p] = le + "Date", V[d] = le + "Month", V[h] = le + "FullYear", V[l] = le + "Hours", V[a] = le + "Minutes", V[o] = le + "Seconds", V[s] = le + "Milliseconds", V)[Y],
                        W = Y === c ? this.$D + (N - this.$W) : N;
                    if (Y === d || Y === h) {
                        var Q = this.clone().set(p, 1);
                        Q.$d[ae](W), Q.init(), this.$d = Q.set(p, Math.min(this.$D, Q.daysInMonth())).$d
                    } else ae && this.$d[ae](W);
                    return this.init(), this
                }, H.set = function(k, N) {
                    return this.clone().$set(k, N)
                }, H.get = function(k) {
                    return this[E.p(k)]()
                }, H.add = function(k, N) {
                    var V, Y = this;
                    k = Number(k);
                    var le = E.p(N),
                        ae = function(fe) {
                            var D = T(Y);
                            return E.w(D.date(D.date() + Math.round(fe * k)), Y)
                        };
                    if (le === d) return this.set(d, this.$M + k);
                    if (le === h) return this.set(h, this.$y + k);
                    if (le === c) return ae(1);
                    if (le === u) return ae(7);
                    var W = (V = {}, V[a] = r, V[l] = i, V[o] = n, V)[le] || 1,
                        Q = this.$d.getTime() + k * W;
                    return E.w(Q, this)
                }, H.subtract = function(k, N) {
                    return this.add(-1 * k, N)
                }, H.format = function(k) {
                    var N = this,
                        V = this.$locale();
                    if (!this.isValid()) return V.invalidDate || b;
                    var Y = k || "YYYY-MM-DDTHH:mm:ssZ",
                        le = E.z(this),
                        ae = this.$H,
                        W = this.$m,
                        Q = this.$M,
                        fe = V.weekdays,
                        D = V.months,
                        X = V.meridiem,
                        $ = function(ce, de, ge, O) {
                            return ce && (ce[de] || ce(N, Y)) || ge[de].slice(0, O)
                        },
                        Z = function(ce) {
                            return E.s(ae % 12 || 12, ce, "0")
                        },
                        K = X || function(ce, de, ge) {
                            var O = ce < 12 ? "AM" : "PM";
                            return ge ? O.toLowerCase() : O
                        };
                    return Y.replace(m, function(ce, de) {
                        return de || function(ge) {
                            switch (ge) {
                                case "YY":
                                    return String(N.$y).slice(-2);
                                case "YYYY":
                                    return E.s(N.$y, 4, "0");
                                case "M":
                                    return Q + 1;
                                case "MM":
                                    return E.s(Q + 1, 2, "0");
                                case "MMM":
                                    return $(V.monthsShort, Q, D, 3);
                                case "MMMM":
                                    return $(D, Q);
                                case "D":
                                    return N.$D;
                                case "DD":
                                    return E.s(N.$D, 2, "0");
                                case "d":
                                    return String(N.$W);
                                case "dd":
                                    return $(V.weekdaysMin, N.$W, fe, 2);
                                case "ddd":
                                    return $(V.weekdaysShort, N.$W, fe, 3);
                                case "dddd":
                                    return fe[N.$W];
                                case "H":
                                    return String(ae);
                                case "HH":
                                    return E.s(ae, 2, "0");
                                case "h":
                                    return Z(1);
                                case "hh":
                                    return Z(2);
                                case "a":
                                    return K(ae, W, !0);
                                case "A":
                                    return K(ae, W, !1);
                                case "m":
                                    return String(W);
                                case "mm":
                                    return E.s(W, 2, "0");
                                case "s":
                                    return String(N.$s);
                                case "ss":
                                    return E.s(N.$s, 2, "0");
                                case "SSS":
                                    return E.s(N.$ms, 3, "0");
                                case "Z":
                                    return le
                            }
                            return null
                        }(ce) || le.replace(":", "")
                    })
                }, H.utcOffset = function() {
                    return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
                }, H.diff = function(k, N, V) {
                    var Y, le = this,
                        ae = E.p(N),
                        W = T(k),
                        Q = (W.utcOffset() - this.utcOffset()) * r,
                        fe = this - W,
                        D = function() {
                            return E.m(le, W)
                        };
                    switch (ae) {
                        case h:
                            Y = D() / 12;
                            break;
                        case d:
                            Y = D();
                            break;
                        case f:
                            Y = D() / 3;
                            break;
                        case u:
                            Y = (fe - Q) / 6048e5;
                            break;
                        case c:
                            Y = (fe - Q) / 864e5;
                            break;
                        case l:
                            Y = fe / i;
                            break;
                        case a:
                            Y = fe / r;
                            break;
                        case o:
                            Y = fe / n;
                            break;
                        default:
                            Y = fe
                    }
                    return V ? Y : E.a(Y)
                }, H.daysInMonth = function() {
                    return this.endOf(d).$D
                }, H.$locale = function() {
                    return w[this.$L]
                }, H.locale = function(k, N) {
                    if (!k) return this.$L;
                    var V = this.clone(),
                        Y = A(k, N, !0);
                    return Y && (V.$L = Y), V
                }, H.clone = function() {
                    return E.w(this.$d, this)
                }, H.toDate = function() {
                    return new Date(this.valueOf())
                }, H.toJSON = function() {
                    return this.isValid() ? this.toISOString() : null
                }, H.toISOString = function() {
                    return this.$d.toISOString()
                }, H.toString = function() {
                    return this.$d.toUTCString()
                }, F
            }(),
            B = P.prototype;
        return T.prototype = B, [
            ["$ms", s],
            ["$s", o],
            ["$m", a],
            ["$H", l],
            ["$W", c],
            ["$M", d],
            ["$y", h],
            ["$D", p]
        ].forEach(function(F) {
            B[F[1]] = function(H) {
                return this.$g(H, F[0], F[1])
            }
        }), T.extend = function(F, H) {
            return F.$i || (F(H, P, T), F.$i = !0), T
        }, T.locale = A, T.isDayjs = C, T.unix = function(F) {
            return T(1e3 * F)
        }, T.en = w[x], T.Ls = w, T.p = {}, T
    })
})(AR);
var gb = AR.exports;
const U0e = ua(gb);

function py() {}
const Ne = Object.assign,
    oi = typeof window < "u",
    Bs = t => t !== null && typeof t == "object",
    vt = t => t != null,
    al = t => typeof t == "function",
    vb = t => Bs(t) && al(t.then) && al(t.catch),
    au = t => Object.prototype.toString.call(t) === "[object Date]" && !Number.isNaN(t.getTime()),
    OR = t => typeof t == "number" || /^\d+(\.\d+)?$/.test(t),
    uV = () => oi ? /ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()) : !1;

function HE(t, e) {
    const n = e.split(".");
    let r = t;
    return n.forEach(i => {
        var s;
        r = Bs(r) && (s = r[i]) != null ? s : ""
    }), r
}

function wt(t, e, n) {
    return e.reduce((r, i) => ((!n || t[i] !== void 0) && (r[i] = t[i]), r), {})
}
const Ps = (t, e) => JSON.stringify(t) === JSON.stringify(e),
    oh = t => Array.isArray(t) ? t : [t],
    Ut = null,
    be = [Number, String],
    me = {
        type: Boolean,
        default: !0
    },
    xn = t => ({
        type: t,
        required: !0
    }),
    Gi = () => ({
        type: Array,
        default: () => []
    }),
    gp = t => ({
        type: Number,
        default: t
    }),
    Fe = t => ({
        type: be,
        default: t
    }),
    Pe = t => ({
        type: String,
        default: t
    });

function qu(t) {
    const e = "scrollTop" in t ? t.scrollTop : t.pageYOffset;
    return Math.max(e, 0)
}

function ah(t, e) {
    "scrollTop" in t ? t.scrollTop = e : t.scrollTo(t.scrollX, e)
}

function yb() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
}

function _b(t) {
    ah(window, t), ah(document.body, t)
}

function zE(t, e) {
    if (t === window) return 0;
    const n = e ? qu(e) : yb();
    return Jt(t).top + n
}
const dV = uV();

function IR() {
    dV && _b(yb())
}
const RR = t => t.stopPropagation();

function Zt(t, e) {
    (typeof t.cancelable != "boolean" || t.cancelable) && t.preventDefault(), e && RR(t)
}

function ll(t) {
    const e = En(t);
    if (!e) return !1;
    const n = window.getComputedStyle(e),
        r = n.display === "none",
        i = e.offsetParent === null && n.position !== "fixed";
    return r || i
}
const {
    width: kl,
    height: Ju
} = qO();

function Ze(t) {
    if (vt(t)) return OR(t) ? `${t}px` : String(t)
}

function fa(t) {
    if (vt(t)) {
        if (Array.isArray(t)) return {
            width: Ze(t[0]),
            height: Ze(t[1])
        };
        const e = Ze(t);
        return {
            width: e,
            height: e
        }
    }
}

function MR(t) {
    const e = {};
    return t !== void 0 && (e.zIndex = +t), e
}
let Cm;

function fV() {
    if (!Cm) {
        const t = document.documentElement,
            e = t.style.fontSize || window.getComputedStyle(t).fontSize;
        Cm = parseFloat(e)
    }
    return Cm
}

function hV(t) {
    return t = t.replace(/rem/g, ""), +t * fV()
}

function pV(t) {
    return t = t.replace(/vw/g, ""), +t * kl.value / 100
}

function mV(t) {
    return t = t.replace(/vh/g, ""), +t * Ju.value / 100
}

function bb(t) {
    if (typeof t == "number") return t;
    if (oi) {
        if (t.includes("rem")) return hV(t);
        if (t.includes("vw")) return pV(t);
        if (t.includes("vh")) return mV(t)
    }
    return parseFloat(t)
}
const gV = /-(\w)/g,
    kR = t => t.replace(gV, (e, n) => n.toUpperCase());

function vo(t, e = 2) {
    let n = t + "";
    for (; n.length < e;) n = "0" + n;
    return n
}
const nn = (t, e, n) => Math.min(Math.max(t, e), n);

function jE(t, e, n) {
    const r = t.indexOf(e);
    return r === -1 ? t : e === "-" && r !== 0 ? t.slice(0, r) : t.slice(0, r + 1) + t.slice(r).replace(n, "")
}

function my(t, e = !0, n = !0) {
    e ? t = jE(t, ".", /\./g) : t = t.split(".")[0], n ? t = jE(t, "-", /-/g) : t = t.replace(/-/, "");
    const r = e ? /[^-0-9.]/g : /[^-0-9]/g;
    return t.replace(r, "")
}

function BR(t, e) {
    return Math.round((t + e) * 1e10) / 1e10
}
const {
    hasOwnProperty: vV
} = Object.prototype;

function yV(t, e, n) {
    const r = e[n];
    vt(r) && (!vV.call(t, n) || !Bs(r) ? t[n] = r : t[n] = DR(Object(t[n]), r))
}

function DR(t, e) {
    return Object.keys(e).forEach(n => {
        yV(t, e, n)
    }), t
}
var _V = {
    name: "姓名",
    tel: "电话",
    save: "保存",
    clear: "清空",
    cancel: "取消",
    confirm: "确认",
    delete: "删除",
    loading: "加载中...",
    noCoupon: "暂无优惠券",
    nameEmpty: "请填写姓名",
    addContact: "添加联系人",
    telInvalid: "请填写正确的电话",
    vanCalendar: {
        end: "结束",
        start: "开始",
        title: "日期选择",
        weekdays: ["日", "一", "二", "三", "四", "五", "六"],
        monthTitle: (t, e) => `${t}年${e}月`,
        rangePrompt: t => `最多选择 ${t} 天`
    },
    vanCascader: {
        select: "请选择"
    },
    vanPagination: {
        prev: "上一页",
        next: "下一页"
    },
    vanPullRefresh: {
        pulling: "下拉即可刷新...",
        loosing: "释放即可刷新..."
    },
    vanSubmitBar: {
        label: "合计:"
    },
    vanCoupon: {
        unlimited: "无门槛",
        discount: t => `${t}折`,
        condition: t => `满${t}元可用`
    },
    vanCouponCell: {
        title: "优惠券",
        count: t => `${t}张可用`
    },
    vanCouponList: {
        exchange: "兑换",
        close: "不使用",
        enable: "可用",
        disabled: "不可用",
        placeholder: "输入优惠码"
    },
    vanAddressEdit: {
        area: "地区",
        areaEmpty: "请选择地区",
        addressEmpty: "请填写详细地址",
        addressDetail: "详细地址",
        defaultAddress: "设为默认收货地址"
    },
    vanAddressList: {
        add: "新增地址"
    }
};
const VE = J("zh-CN"),
    WE = ht({
        "zh-CN": _V
    }),
    bV = {
        messages() {
            return WE[VE.value]
        },
        use(t, e) {
            VE.value = t, this.add({
                [t]: e
            })
        },
        add(t = {}) {
            DR(WE, t)
        }
    };
var xV = bV;

function wV(t) {
    const e = kR(t) + ".";
    return (n, ...r) => {
        const i = xV.messages(),
            s = HE(i, e + n) || HE(i, n);
        return al(s) ? s(...r) : s
    }
}

function gy(t, e) {
    return e ? typeof e == "string" ? ` ${t}--${e}` : Array.isArray(e) ? e.reduce((n, r) => n + gy(t, r), "") : Object.keys(e).reduce((n, r) => n + (e[r] ? gy(t, r) : ""), "") : ""
}

function EV(t) {
    return (e, n) => (e && typeof e != "string" && (n = e, e = ""), e = e ? `${t}__${e}` : t, `${e}${gy(e,n)}`)
}

function Ee(t) {
    const e = `van-${t}`;
    return [e, EV(e), wV(e)]
}
const Ws = "van-hairline",
    $R = `${Ws}--top`,
    SV = `${Ws}--left`,
    TV = `${Ws}--right`,
    CV = `${Ws}--bottom`,
    Pf = `${Ws}--surround`,
    FR = `${Ws}--top-bottom`,
    PV = `${Ws}-unset--top-bottom`,
    Hi = "van-haptics-feedback",
    LR = Symbol("van-form"),
    NR = 500,
    YE = 5;

function Bl(t, {
    args: e = [],
    done: n,
    canceled: r,
    error: i
}) {
    if (t) {
        const s = t.apply(null, e);
        vb(s) ? s.then(o => {
            o ? n() : r && r()
        }).catch(i || py) : s ? n() : r && r()
    } else n()
}

function Ae(t) {
    return t.install = e => {
        const {
            name: n
        } = t;
        n && (e.component(n, t), e.component(kR(`-${n}`), t))
    }, t
}
const UR = Symbol();

function xb(t) {
    const e = Nt(UR, null);
    e && pe(e, n => {
        n && t()
    })
}
const GR = (t, e) => {
    const n = J(),
        r = () => {
            n.value = Jt(t).height
        };
    return St(() => {
        if (Ue(r), e)
            for (let i = 1; i <= 3; i++) setTimeout(r, 100 * i)
    }), xb(() => Ue(r)), pe([kl, Ju], r), n
};

function AV(t, e) {
    const n = GR(t, !0);
    return r => I("div", {
        class: e("placeholder"),
        style: {
            height: n.value ? `${n.value}px` : void 0
        }
    }, [r()])
}
const [HR, XE] = Ee("action-bar"), zR = Symbol(HR), OV = {
    placeholder: Boolean,
    safeAreaInsetBottom: me
};
var IV = ye({
    name: HR,
    props: OV,
    setup(t, {
        slots: e
    }) {
        const n = J(),
            r = AV(n, XE),
            {
                linkChildren: i
            } = Br(zR);
        i();
        const s = () => {
            var o;
            return I("div", {
                ref: n,
                class: [XE(), {
                    "van-safe-area-bottom": t.safeAreaInsetBottom
                }]
            }, [(o = e.default) == null ? void 0 : o.call(e)])
        };
        return () => t.placeholder ? r(s) : s()
    }
});
const RV = Ae(IV);

function Tt(t) {
    const e = it();
    e && Ne(e.proxy, t)
}
const Dl = {
    to: [String, Object],
    url: String,
    replace: Boolean
};

function jR({
    to: t,
    url: e,
    replace: n,
    $router: r
}) {
    t && r ? r[n ? "replace" : "push"](t) : e && (n ? location.replace(e) : location.href = e)
}

function Zu() {
    const t = it().proxy;
    return () => jR(t)
}
const [MV, KE] = Ee("badge"), kV = {
    dot: Boolean,
    max: be,
    tag: Pe("div"),
    color: String,
    offset: Array,
    content: be,
    showZero: me,
    position: Pe("top-right")
};
var BV = ye({
    name: MV,
    props: kV,
    setup(t, {
        slots: e
    }) {
        const n = () => {
                if (e.content) return !0;
                const {
                    content: a,
                    showZero: l
                } = t;
                return vt(a) && a !== "" && (l || a !== 0 && a !== "0")
            },
            r = () => {
                const {
                    dot: a,
                    max: l,
                    content: c
                } = t;
                if (!a && n()) return e.content ? e.content() : vt(l) && OR(c) && +c > +l ? `${l}+` : c
            },
            i = a => a.startsWith("-") ? a.replace("-", "") : `-${a}`,
            s = ne(() => {
                const a = {
                    background: t.color
                };
                if (t.offset) {
                    const [l, c] = t.offset, {
                        position: u
                    } = t, [d, f] = u.split("-");
                    e.default ? (typeof c == "number" ? a[d] = Ze(d === "top" ? c : -c) : a[d] = d === "top" ? Ze(c) : i(c), typeof l == "number" ? a[f] = Ze(f === "left" ? l : -l) : a[f] = f === "left" ? Ze(l) : i(l)) : (a.marginTop = Ze(c), a.marginLeft = Ze(l))
                }
                return a
            }),
            o = () => {
                if (n() || t.dot) return I("div", {
                    class: KE([t.position, {
                        dot: t.dot,
                        fixed: !!e.default
                    }]),
                    style: s.value
                }, [r()])
            };
        return () => {
            if (e.default) {
                const {
                    tag: a
                } = t;
                return I(a, {
                    class: KE("wrapper")
                }, {
                    default: () => [e.default(), o()]
                })
            }
            return o()
        }
    }
});
const vp = Ae(BV);
let DV = 2e3;
const $V = () => ++DV,
    [FV, G0e] = Ee("config-provider"),
    LV = Symbol(FV),
    [NV, qE] = Ee("icon"),
    UV = t => t == null ? void 0 : t.includes("/"),
    GV = {
        dot: Boolean,
        tag: Pe("i"),
        name: String,
        size: be,
        badge: be,
        color: String,
        badgeProps: Object,
        classPrefix: String
    };
var HV = ye({
    name: NV,
    props: GV,
    setup(t, {
        slots: e
    }) {
        const n = Nt(LV, null),
            r = ne(() => t.classPrefix || (n == null ? void 0 : n.iconPrefix) || qE());
        return () => {
            const {
                tag: i,
                dot: s,
                name: o,
                size: a,
                badge: l,
                color: c
            } = t, u = UV(o);
            return I(vp, et({
                dot: s,
                tag: i,
                class: [r.value, u ? "" : `${r.value}-${o}`],
                style: {
                    color: c,
                    fontSize: Ze(a)
                },
                content: l
            }, t.badgeProps), {
                default: () => {
                    var d;
                    return [(d = e.default) == null ? void 0 : d.call(e), u && I("img", {
                        class: qE("image"),
                        src: o
                    }, null)]
                }
            })
        }
    }
});
const $t = Ae(HV),
    [zV, Bc] = Ee("loading"),
    jV = Array(12).fill(null).map((t, e) => I("i", {
        class: Bc("line", String(e + 1))
    }, null)),
    VV = I("svg", {
        class: Bc("circular"),
        viewBox: "25 25 50 50"
    }, [I("circle", {
        cx: "50",
        cy: "50",
        r: "20",
        fill: "none"
    }, null)]),
    WV = {
        size: be,
        type: Pe("circular"),
        color: String,
        vertical: Boolean,
        textSize: be,
        textColor: String
    };
var YV = ye({
    name: zV,
    props: WV,
    setup(t, {
        slots: e
    }) {
        const n = ne(() => Ne({
                color: t.color
            }, fa(t.size))),
            r = () => {
                const s = t.type === "spinner" ? jV : VV;
                return I("span", {
                    class: Bc("spinner", t.type),
                    style: n.value
                }, [e.icon ? e.icon() : s])
            },
            i = () => {
                var s;
                if (e.default) return I("span", {
                    class: Bc("text"),
                    style: {
                        fontSize: Ze(t.textSize),
                        color: (s = t.textColor) != null ? s : t.color
                    }
                }, [e.default()])
            };
        return () => {
            const {
                type: s,
                vertical: o
            } = t;
            return I("div", {
                class: Bc([s, {
                    vertical: o
                }]),
                "aria-live": "polite",
                "aria-busy": !0
            }, [r(), i()])
        }
    }
});
const qi = Ae(YV),
    [XV, wa] = Ee("button"),
    KV = Ne({}, Dl, {
        tag: Pe("button"),
        text: String,
        icon: String,
        type: Pe("default"),
        size: Pe("normal"),
        color: String,
        block: Boolean,
        plain: Boolean,
        round: Boolean,
        square: Boolean,
        loading: Boolean,
        hairline: Boolean,
        disabled: Boolean,
        iconPrefix: String,
        nativeType: Pe("button"),
        loadingSize: be,
        loadingText: String,
        loadingType: String,
        iconPosition: Pe("left")
    });
var qV = ye({
    name: XV,
    props: KV,
    emits: ["click"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = Zu(),
            i = () => n.loading ? n.loading() : I(qi, {
                size: t.loadingSize,
                type: t.loadingType,
                class: wa("loading")
            }, null),
            s = () => {
                if (t.loading) return i();
                if (n.icon) return I("div", {
                    class: wa("icon")
                }, [n.icon()]);
                if (t.icon) return I($t, {
                    name: t.icon,
                    class: wa("icon"),
                    classPrefix: t.iconPrefix
                }, null)
            },
            o = () => {
                let c;
                if (t.loading ? c = t.loadingText : c = n.default ? n.default() : t.text, c) return I("span", {
                    class: wa("text")
                }, [c])
            },
            a = () => {
                const {
                    color: c,
                    plain: u
                } = t;
                if (c) {
                    const d = {
                        color: u ? c : "white"
                    };
                    return u || (d.background = c), c.includes("gradient") ? d.border = 0 : d.borderColor = c, d
                }
            },
            l = c => {
                t.loading ? Zt(c) : t.disabled || (e("click", c), r())
            };
        return () => {
            const {
                tag: c,
                type: u,
                size: d,
                block: f,
                round: h,
                plain: p,
                square: b,
                loading: y,
                disabled: m,
                hairline: g,
                nativeType: v,
                iconPosition: _
            } = t, x = [wa([u, d, {
                plain: p,
                block: f,
                round: h,
                square: b,
                loading: y,
                disabled: m,
                hairline: g
            }]), {
                [Pf]: g
            }];
            return I(c, {
                type: v,
                class: x,
                style: a(),
                disabled: m,
                onClick: l
            }, {
                default: () => [I("div", {
                    class: wa("content")
                }, [_ === "left" && s(), o(), _ === "right" && s()])]
            })
        }
    }
});
const lh = Ae(qV),
    [JV, ZV] = Ee("action-bar-button"),
    QV = Ne({}, Dl, {
        type: String,
        text: String,
        icon: String,
        color: String,
        loading: Boolean,
        disabled: Boolean
    });
var eW = ye({
    name: JV,
    props: QV,
    setup(t, {
        slots: e
    }) {
        const n = Zu(),
            {
                parent: r,
                index: i
            } = tr(zR),
            s = ne(() => {
                if (r) {
                    const a = r.children[i.value - 1];
                    return !(a && "isButton" in a)
                }
            }),
            o = ne(() => {
                if (r) {
                    const a = r.children[i.value + 1];
                    return !(a && "isButton" in a)
                }
            });
        return Tt({
            isButton: !0
        }), () => {
            const {
                type: a,
                icon: l,
                text: c,
                color: u,
                loading: d,
                disabled: f
            } = t;
            return I(lh, {
                class: ZV([a, {
                    last: o.value,
                    first: s.value
                }]),
                size: "large",
                type: a,
                icon: l,
                color: u,
                loading: d,
                disabled: f,
                onClick: n
            }, {
                default: () => [e.default ? e.default() : c]
            })
        }
    }
});
const JE = Ae(eW),
    Qu = {
        show: Boolean,
        zIndex: be,
        overlay: me,
        duration: be,
        teleport: [String, Object],
        lockScroll: me,
        lazyRender: me,
        beforeClose: Function,
        overlayStyle: Object,
        overlayClass: Ut,
        transitionAppear: Boolean,
        closeOnClickOverlay: me
    },
    VR = Object.keys(Qu);

function tW(t, e) {
    return t > e ? "horizontal" : e > t ? "vertical" : ""
}

function $l() {
    const t = J(0),
        e = J(0),
        n = J(0),
        r = J(0),
        i = J(0),
        s = J(0),
        o = J(""),
        a = J(!0),
        l = () => o.value === "vertical",
        c = () => o.value === "horizontal",
        u = () => {
            n.value = 0, r.value = 0, i.value = 0, s.value = 0, o.value = "", a.value = !0
        };
    return {
        move: h => {
            const p = h.touches[0];
            n.value = (p.clientX < 0 ? 0 : p.clientX) - t.value, r.value = p.clientY - e.value, i.value = Math.abs(n.value), s.value = Math.abs(r.value);
            const b = 10;
            (!o.value || i.value < b && s.value < b) && (o.value = tW(i.value, s.value)), a.value && (i.value > YE || s.value > YE) && (a.value = !1)
        },
        start: h => {
            u(), t.value = h.touches[0].clientX, e.value = h.touches[0].clientY
        },
        reset: u,
        startX: t,
        startY: e,
        deltaX: n,
        deltaY: r,
        offsetX: i,
        offsetY: s,
        direction: o,
        isVertical: l,
        isHorizontal: c,
        isTap: a
    }
}
let Ql = 0;
const ZE = "van-overflow-hidden";

function nW(t, e) {
    const n = $l(),
        r = "01",
        i = "10",
        s = u => {
            n.move(u);
            const d = n.deltaY.value > 0 ? i : r,
                f = U_(u.target, t.value),
                {
                    scrollHeight: h,
                    offsetHeight: p,
                    scrollTop: b
                } = f;
            let y = "11";
            b === 0 ? y = p >= h ? "00" : "01" : b + p >= h && (y = "10"), y !== "11" && n.isVertical() && !(parseInt(y, 2) & parseInt(d, 2)) && Zt(u, !0)
        },
        o = () => {
            document.addEventListener("touchstart", n.start), document.addEventListener("touchmove", s, {
                passive: !1
            }), Ql || document.body.classList.add(ZE), Ql++
        },
        a = () => {
            Ql && (document.removeEventListener("touchstart", n.start), document.removeEventListener("touchmove", s), Ql--, Ql || document.body.classList.remove(ZE))
        },
        l = () => e() && o(),
        c = () => e() && a();
    Ml(l), Yi(c), er(c), pe(e, u => {
        u ? o() : a()
    })
}

function wb(t) {
    const e = J(!1);
    return pe(t, n => {
        n && (e.value = n)
    }, {
        immediate: !0
    }), n => () => e.value ? n() : null
}
const vy = () => {
        var t;
        const {
            scopeId: e
        } = ((t = it()) == null ? void 0 : t.vnode) || {};
        return e ? {
            [e]: ""
        } : null
    },
    [rW, iW] = Ee("overlay"),
    sW = {
        show: Boolean,
        zIndex: be,
        duration: be,
        className: Ut,
        lockScroll: me,
        lazyRender: me,
        customStyle: Object,
        teleport: [String, Object]
    };
var oW = ye({
    name: rW,
    props: sW,
    setup(t, {
        slots: e
    }) {
        const n = J(),
            r = wb(() => t.show || !t.lazyRender),
            i = o => {
                t.lockScroll && Zt(o, !0)
            },
            s = r(() => {
                var o;
                const a = Ne(MR(t.zIndex), t.customStyle);
                return vt(t.duration) && (a.animationDuration = `${t.duration}s`), Cr(I("div", {
                    ref: n,
                    style: a,
                    class: [iW(), t.className]
                }, [(o = e.default) == null ? void 0 : o.call(e)]), [
                    [Ar, t.show]
                ])
            });
        return Nn("touchmove", i, {
            target: n
        }), () => {
            const o = I(Yu, {
                name: "van-fade",
                appear: !0
            }, {
                default: s
            });
            return t.teleport ? I(S_, {
                to: t.teleport
            }, {
                default: () => [o]
            }) : o
        }
    }
});
const aW = Ae(oW),
    lW = Ne({}, Qu, {
        round: Boolean,
        position: Pe("center"),
        closeIcon: Pe("cross"),
        closeable: Boolean,
        transition: String,
        iconPrefix: String,
        closeOnPopstate: Boolean,
        closeIconPosition: Pe("top-right"),
        destroyOnClose: Boolean,
        safeAreaInsetTop: Boolean,
        safeAreaInsetBottom: Boolean
    }),
    [cW, QE] = Ee("popup");
var uW = ye({
    name: cW,
    inheritAttrs: !1,
    props: lW,
    emits: ["open", "close", "opened", "closed", "keydown", "update:show", "clickOverlay", "clickCloseIcon"],
    setup(t, {
        emit: e,
        attrs: n,
        slots: r
    }) {
        let i, s;
        const o = J(),
            a = J(),
            l = wb(() => t.show || !t.lazyRender),
            c = ne(() => {
                const w = {
                    zIndex: o.value
                };
                if (vt(t.duration)) {
                    const S = t.position === "center" ? "animationDuration" : "transitionDuration";
                    w[S] = `${t.duration}s`
                }
                return w
            }),
            u = () => {
                i || (i = !0, o.value = t.zIndex !== void 0 ? +t.zIndex : $V(), e("open"))
            },
            d = () => {
                i && Bl(t.beforeClose, {
                    done() {
                        i = !1, e("close"), e("update:show", !1)
                    }
                })
            },
            f = w => {
                e("clickOverlay", w), t.closeOnClickOverlay && d()
            },
            h = () => {
                if (t.overlay) return I(aW, et({
                    show: t.show,
                    class: t.overlayClass,
                    zIndex: o.value,
                    duration: t.duration,
                    customStyle: t.overlayStyle,
                    role: t.closeOnClickOverlay ? "button" : void 0,
                    tabindex: t.closeOnClickOverlay ? 0 : void 0
                }, vy(), {
                    onClick: f
                }), {
                    default: r["overlay-content"]
                })
            },
            p = w => {
                e("clickCloseIcon", w), d()
            },
            b = () => {
                if (t.closeable) return I($t, {
                    role: "button",
                    tabindex: 0,
                    name: t.closeIcon,
                    class: [QE("close-icon", t.closeIconPosition), Hi],
                    classPrefix: t.iconPrefix,
                    onClick: p
                }, null)
            };
        let y;
        const m = () => {
                y && clearTimeout(y), y = setTimeout(() => {
                    e("opened")
                })
            },
            g = () => e("closed"),
            v = w => e("keydown", w),
            _ = l(() => {
                var w;
                const {
                    destroyOnClose: S,
                    round: C,
                    position: A,
                    safeAreaInsetTop: T,
                    safeAreaInsetBottom: E,
                    show: P
                } = t;
                if (!(!P && S)) return Cr(I("div", et({
                    ref: a,
                    style: c.value,
                    role: "dialog",
                    tabindex: 0,
                    class: [QE({
                        round: C,
                        [A]: A
                    }), {
                        "van-safe-area-top": T,
                        "van-safe-area-bottom": E
                    }],
                    onKeydown: v
                }, n, vy()), [(w = r.default) == null ? void 0 : w.call(r), b()]), [
                    [Ar, P]
                ])
            }),
            x = () => {
                const {
                    position: w,
                    transition: S,
                    transitionAppear: C
                } = t, A = w === "center" ? "van-fade" : `van-popup-slide-${w}`;
                return I(Yu, {
                    name: S || A,
                    appear: C,
                    onAfterEnter: m,
                    onAfterLeave: g
                }, {
                    default: _
                })
            };
        return pe(() => t.show, w => {
            w && !i && (u(), n.tabindex === 0 && Ue(() => {
                var S;
                (S = a.value) == null || S.focus()
            })), !w && i && (i = !1, e("close"))
        }), Tt({
            popupRef: a
        }), nW(a, () => t.show && t.lockScroll), Nn("popstate", () => {
            t.closeOnPopstate && (d(), s = !1)
        }), St(() => {
            t.show && u()
        }), zs(() => {
            s && (e("update:show", !0), s = !1)
        }), Yi(() => {
            t.show && t.teleport && (d(), s = !0)
        }), Pr(UR, () => t.show), () => t.teleport ? I(S_, {
            to: t.teleport
        }, {
            default: () => [h(), x()]
        }) : I(gt, null, [h(), x()])
    }
});
const ha = Ae(uW),
    [dW, or] = Ee("action-sheet"),
    fW = Ne({}, Qu, {
        title: String,
        round: me,
        actions: Gi(),
        closeIcon: Pe("cross"),
        closeable: me,
        cancelText: String,
        description: String,
        closeOnPopstate: me,
        closeOnClickAction: Boolean,
        safeAreaInsetBottom: me
    }),
    hW = [...VR, "round", "closeOnPopstate", "safeAreaInsetBottom"];
var pW = ye({
    name: dW,
    props: fW,
    emits: ["select", "cancel", "update:show"],
    setup(t, {
        slots: e,
        emit: n
    }) {
        const r = d => n("update:show", d),
            i = () => {
                r(!1), n("cancel")
            },
            s = () => {
                if (t.title) return I("div", {
                    class: or("header")
                }, [t.title, t.closeable && I($t, {
                    name: t.closeIcon,
                    class: [or("close"), Hi],
                    onClick: i
                }, null)])
            },
            o = () => {
                if (e.cancel || t.cancelText) return [I("div", {
                    class: or("gap")
                }, null), I("button", {
                    type: "button",
                    class: or("cancel"),
                    onClick: i
                }, [e.cancel ? e.cancel() : t.cancelText])]
            },
            a = d => {
                if (d.icon) return I($t, {
                    class: or("item-icon"),
                    name: d.icon
                }, null)
            },
            l = (d, f) => d.loading ? I(qi, {
                class: or("loading-icon")
            }, null) : e.action ? e.action({
                action: d,
                index: f
            }) : [I("span", {
                class: or("name")
            }, [d.name]), d.subname && I("div", {
                class: or("subname")
            }, [d.subname])],
            c = (d, f) => {
                const {
                    color: h,
                    loading: p,
                    callback: b,
                    disabled: y,
                    className: m
                } = d, g = () => {
                    y || p || (b && b(d), t.closeOnClickAction && r(!1), Ue(() => n("select", d, f)))
                };
                return I("button", {
                    type: "button",
                    style: {
                        color: h
                    },
                    class: [or("item", {
                        loading: p,
                        disabled: y
                    }), m],
                    onClick: g
                }, [a(d), l(d, f)])
            },
            u = () => {
                if (t.description || e.description) {
                    const d = e.description ? e.description() : t.description;
                    return I("div", {
                        class: or("description")
                    }, [d])
                }
            };
        return () => I(ha, et({
            class: or(),
            position: "bottom",
            "onUpdate:show": r
        }, wt(t, hW)), {
            default: () => {
                var d;
                return [s(), u(), I("div", {
                    class: or("content")
                }, [t.actions.map(c), (d = e.default) == null ? void 0 : d.call(e)]), o()]
            }
        })
    }
});
const H0e = Ae(pW),
    [mW, Ai, eS] = Ee("picker"),
    WR = t => t.find(e => !e.disabled) || t[0];

function gW(t, e) {
    const n = t[0];
    if (n) {
        if (Array.isArray(n)) return "multiple";
        if (e.children in n) return "cascade"
    }
    return "default"
}

function Af(t, e) {
    e = nn(e, 0, t.length);
    for (let n = e; n < t.length; n++)
        if (!t[n].disabled) return n;
    for (let n = e - 1; n >= 0; n--)
        if (!t[n].disabled) return n;
    return 0
}
const tS = (t, e, n) => e !== void 0 && !!t.find(r => r[n.value] === e);

function yy(t, e, n) {
    const r = t.findIndex(s => s[n.value] === e),
        i = Af(t, r);
    return t[i]
}

function vW(t, e, n) {
    const r = [];
    let i = {
            [e.children]: t
        },
        s = 0;
    for (; i && i[e.children];) {
        const o = i[e.children],
            a = n.value[s];
        if (i = vt(a) ? yy(o, a, e) : void 0, !i && o.length) {
            const l = WR(o)[e.value];
            i = yy(o, l, e)
        }
        s++, r.push(o)
    }
    return r
}

function yW(t) {
    const {
        transform: e
    } = window.getComputedStyle(t), n = e.slice(7, e.length - 1).split(", ")[5];
    return Number(n)
}

function _W(t) {
    return Ne({
        text: "text",
        value: "value",
        children: "children"
    }, t)
}
const nS = 200,
    rS = 300,
    bW = 15,
    [YR, Pm] = Ee("picker-column"),
    XR = Symbol(YR);
var xW = ye({
    name: YR,
    props: {
        value: be,
        fields: xn(Object),
        options: Gi(),
        readonly: Boolean,
        allowHtml: Boolean,
        optionHeight: xn(Number),
        swipeDuration: xn(be),
        visibleOptionNum: xn(be)
    },
    emits: ["change", "clickOption", "scrollInto"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        let r, i, s, o, a;
        const l = J(),
            c = J(),
            u = J(0),
            d = J(0),
            f = $l(),
            h = () => t.options.length,
            p = () => t.optionHeight * (+t.visibleOptionNum - 1) / 2,
            b = T => {
                let E = Af(t.options, T);
                const P = -E * t.optionHeight,
                    B = () => {
                        E > h() - 1 && (E = Af(t.options, T));
                        const F = t.options[E][t.fields.value];
                        F !== t.value && e("change", F)
                    };
                r && P !== u.value ? a = B : B(), u.value = P
            },
            y = () => t.readonly || !t.options.length,
            m = T => {
                r || y() || (a = null, d.value = nS, b(T), e("clickOption", t.options[T]))
            },
            g = T => nn(Math.round(-T / t.optionHeight), 0, h() - 1),
            v = ne(() => g(u.value)),
            _ = (T, E) => {
                const P = Math.abs(T / E);
                T = u.value + P / .003 * (T < 0 ? -1 : 1);
                const B = g(T);
                d.value = +t.swipeDuration, b(B)
            },
            x = () => {
                r = !1, d.value = 0, a && (a(), a = null)
            },
            w = T => {
                if (!y()) {
                    if (f.start(T), r) {
                        const E = yW(c.value);
                        u.value = Math.min(0, E - p())
                    }
                    d.value = 0, i = u.value, s = Date.now(), o = i, a = null
                }
            },
            S = T => {
                if (y()) return;
                f.move(T), f.isVertical() && (r = !0, Zt(T, !0));
                const E = nn(i + f.deltaY.value, -(h() * t.optionHeight), t.optionHeight),
                    P = g(E);
                P !== v.value && e("scrollInto", t.options[P]), u.value = E;
                const B = Date.now();
                B - s > rS && (s = B, o = E)
            },
            C = () => {
                if (y()) return;
                const T = u.value - o,
                    E = Date.now() - s;
                if (E < rS && Math.abs(T) > bW) {
                    _(T, E);
                    return
                }
                const B = g(u.value);
                d.value = nS, b(B), setTimeout(() => {
                    r = !1
                }, 0)
            },
            A = () => {
                const T = {
                    height: `${t.optionHeight}px`
                };
                return t.options.map((E, P) => {
                    const B = E[t.fields.text],
                        {
                            disabled: F
                        } = E,
                        H = E[t.fields.value],
                        k = {
                            role: "button",
                            style: T,
                            tabindex: F ? -1 : 0,
                            class: [Pm("item", {
                                disabled: F,
                                selected: H === t.value
                            }), E.className],
                            onClick: () => m(P)
                        },
                        N = {
                            class: "van-ellipsis",
                            [t.allowHtml ? "innerHTML" : "textContent"]: B
                        };
                    return I("li", k, [n.option ? n.option(E, P) : I("div", N, null)])
                })
            };
        return tr(XR), Tt({
            stopMomentum: x
        }), Il(() => {
            const T = r ? Math.floor(-u.value / t.optionHeight) : t.options.findIndex(B => B[t.fields.value] === t.value),
                E = Af(t.options, T),
                P = -E * t.optionHeight;
            r && E < T && x(), u.value = P
        }), Nn("touchmove", S, {
            target: l
        }), () => I("div", {
            ref: l,
            class: Pm(),
            onTouchstartPassive: w,
            onTouchend: C,
            onTouchcancel: C
        }, [I("ul", {
            ref: c,
            style: {
                transform: `translate3d(0, ${u.value+p()}px, 0)`,
                transitionDuration: `${d.value}ms`,
                transitionProperty: d.value ? "all" : "none"
            },
            class: Pm("wrapper"),
            onTransitionend: x
        }, [A()])])
    }
});
const [wW] = Ee("picker-toolbar"), yp = {
    title: String,
    cancelButtonText: String,
    confirmButtonText: String
}, EW = ["cancel", "confirm", "title", "toolbar"], SW = Object.keys(yp);
var TW = ye({
    name: wW,
    props: yp,
    emits: ["confirm", "cancel"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = () => {
                if (n.title) return n.title();
                if (t.title) return I("div", {
                    class: [Ai("title"), "van-ellipsis"]
                }, [t.title])
            },
            i = () => e("cancel"),
            s = () => e("confirm"),
            o = () => {
                var l;
                const c = (l = t.cancelButtonText) != null ? l : eS("cancel");
                if (!(!n.cancel && !c)) return I("button", {
                    type: "button",
                    class: [Ai("cancel"), Hi],
                    onClick: i
                }, [n.cancel ? n.cancel() : c])
            },
            a = () => {
                var l;
                const c = (l = t.confirmButtonText) != null ? l : eS("confirm");
                if (!(!n.confirm && !c)) return I("button", {
                    type: "button",
                    class: [Ai("confirm"), Hi],
                    onClick: s
                }, [n.confirm ? n.confirm() : c])
            };
        return () => I("div", {
            class: Ai("toolbar")
        }, [n.toolbar ? n.toolbar() : [o(), r(), a()]])
    }
});
const CW = (t, e) => {
    const n = J(t());
    return pe(t, r => {
        r !== n.value && (n.value = r)
    }), pe(n, r => {
        r !== t() && e(r)
    }), n
};
/**
 * @vue/shared v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const KR = Array.isArray,
    lu = t => typeof t == "string",
    qR = t => t !== null && typeof t == "object",
    PW = t => {
        const e = Object.create(null);
        return n => e[n] || (e[n] = t(n))
    },
    AW = /\B([A-Z])/g,
    OW = PW(t => t.replace(AW, "-$1").toLowerCase());

function JR(t) {
    if (KR(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const r = t[n],
                i = lu(r) ? kW(r) : JR(r);
            if (i)
                for (const s in i) e[s] = i[s]
        }
        return e
    } else if (lu(t) || qR(t)) return t
}
const IW = /;(?![^(]*\))/g,
    RW = /:([^]+)/,
    MW = /\/\*[^]*?\*\//g;

function kW(t) {
    const e = {};
    return t.replace(MW, "").split(IW).forEach(n => {
        if (n) {
            const r = n.split(RW);
            r.length > 1 && (e[r[0].trim()] = r[1].trim())
        }
    }), e
}

function BW(t) {
    if (!t) return "";
    if (lu(t)) return t;
    let e = "";
    for (const n in t) {
        const r = t[n];
        if (lu(r) || typeof r == "number") {
            const i = n.startsWith("--") ? n : OW(n);
            e += `${i}:${r};`
        }
    }
    return e
}

function ZR(t) {
    let e = "";
    if (lu(t)) e = t;
    else if (KR(t))
        for (let n = 0; n < t.length; n++) {
            const r = ZR(t[n]);
            r && (e += r + " ")
        } else if (qR(t))
            for (const n in t) t[n] && (e += n + " ");
    return e.trim()
}

function DW(t, e, n) {
    let r, i = 0;
    const s = t.scrollLeft,
        o = n === 0 ? 1 : Math.round(n * 1e3 / 16);
    let a = s;

    function l() {
        Xu(r)
    }

    function c() {
        a += (e - s) / o, t.scrollLeft = a, ++i < o && (r = Sn(c))
    }
    return c(), l
}

function $W(t, e, n, r) {
    let i, s = qu(t);
    const o = s < e,
        a = n === 0 ? 1 : Math.round(n * 1e3 / 16),
        l = (e - s) / a;

    function c() {
        Xu(i)
    }

    function u() {
        s += l, (o && s > e || !o && s < e) && (s = e), ah(t, s), o && s < e || !o && s > e ? i = Sn(u) : r && (i = Sn(r))
    }
    return u(), c
}
let FW = 0;

function Eb() {
    const t = it(),
        {
            name: e = "unknown"
        } = (t == null ? void 0 : t.type) || {};
    return `${e}-${++FW}`
}

function QR() {
    const t = J([]),
        e = [];
    return Jh(() => {
        t.value = []
    }), [t, r => (e[r] || (e[r] = i => {
        t.value[r] = i
    }), e[r])]
}

function e2(t, e) {
    if (!oi || !window.IntersectionObserver) return;
    const n = new IntersectionObserver(s => {
            e(s[0].intersectionRatio > 0)
        }, {
            root: document.body
        }),
        r = () => {
            t.value && n.observe(t.value)
        },
        i = () => {
            t.value && n.unobserve(t.value)
        };
    Yi(i), er(i), Ml(r)
}
const [LW, NW] = Ee("sticky"), UW = {
    zIndex: be,
    position: Pe("top"),
    container: Object,
    offsetTop: Fe(0),
    offsetBottom: Fe(0)
};
var GW = ye({
    name: LW,
    props: UW,
    emits: ["scroll", "change"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = J(),
            i = Ku(r),
            s = ht({
                fixed: !1,
                width: 0,
                height: 0,
                transform: 0
            }),
            o = J(!1),
            a = ne(() => bb(t.position === "top" ? t.offsetTop : t.offsetBottom)),
            l = ne(() => {
                if (o.value) return;
                const {
                    fixed: f,
                    height: h,
                    width: p
                } = s;
                if (f) return {
                    width: `${p}px`,
                    height: `${h}px`
                }
            }),
            c = ne(() => {
                if (!s.fixed || o.value) return;
                const f = Ne(MR(t.zIndex), {
                    width: `${s.width}px`,
                    height: `${s.height}px`,
                    [t.position]: `${a.value}px`
                });
                return s.transform && (f.transform = `translate3d(0, ${s.transform}px, 0)`), f
            }),
            u = f => e("scroll", {
                scrollTop: f,
                isFixed: s.fixed
            }),
            d = () => {
                if (!r.value || ll(r)) return;
                const {
                    container: f,
                    position: h
                } = t, p = Jt(r), b = qu(window);
                if (s.width = p.width, s.height = p.height, h === "top")
                    if (f) {
                        const y = Jt(f),
                            m = y.bottom - a.value - s.height;
                        s.fixed = a.value > p.top && y.bottom > 0, s.transform = m < 0 ? m : 0
                    } else s.fixed = a.value > p.top;
                else {
                    const {
                        clientHeight: y
                    } = document.documentElement;
                    if (f) {
                        const m = Jt(f),
                            g = y - m.top - a.value - s.height;
                        s.fixed = y - a.value < p.bottom && y > m.top, s.transform = g < 0 ? -g : 0
                    } else s.fixed = y - a.value < p.bottom
                }
                u(b)
            };
        return pe(() => s.fixed, f => e("change", f)), Nn("scroll", d, {
            target: i,
            passive: !0
        }), e2(r, d), pe([kl, Ju], () => {
            !r.value || ll(r) || !s.fixed || (o.value = !0, Ue(() => {
                const f = Jt(r);
                s.width = f.width, s.height = f.height, o.value = !1
            }))
        }), () => {
            var f;
            return I("div", {
                ref: r,
                style: l.value
            }, [I("div", {
                class: NW({
                    fixed: s.fixed && !o.value
                }),
                style: c.value
            }, [(f = n.default) == null ? void 0 : f.call(n)])])
        }
    }
});
const HW = Ae(GW),
    [t2, Rd] = Ee("swipe"),
    zW = {
        loop: me,
        width: be,
        height: be,
        vertical: Boolean,
        autoplay: Fe(0),
        duration: Fe(500),
        touchable: me,
        lazyRender: Boolean,
        initialSwipe: Fe(0),
        indicatorColor: String,
        showIndicators: me,
        stopPropagation: me
    },
    n2 = Symbol(t2);
var jW = ye({
    name: t2,
    props: zW,
    emits: ["change", "dragStart", "dragEnd"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = J(),
            i = J(),
            s = ht({
                rect: null,
                width: 0,
                height: 0,
                offset: 0,
                active: 0,
                swiping: !1
            });
        let o = !1;
        const a = $l(),
            {
                children: l,
                linkChildren: c
            } = Br(n2),
            u = ne(() => l.length),
            d = ne(() => s[t.vertical ? "height" : "width"]),
            f = ne(() => t.vertical ? a.deltaY.value : a.deltaX.value),
            h = ne(() => s.rect ? (t.vertical ? s.rect.height : s.rect.width) - d.value * u.value : 0),
            p = ne(() => d.value ? Math.ceil(Math.abs(h.value) / d.value) : u.value),
            b = ne(() => u.value * d.value),
            y = ne(() => (s.active + u.value) % u.value),
            m = ne(() => {
                const ae = t.vertical ? "vertical" : "horizontal";
                return a.direction.value === ae
            }),
            g = ne(() => {
                const ae = {
                    transitionDuration: `${s.swiping?0:t.duration}ms`,
                    transform: `translate${t.vertical?"Y":"X"}(${+s.offset.toFixed(2)}px)`
                };
                if (d.value) {
                    const W = t.vertical ? "height" : "width",
                        Q = t.vertical ? "width" : "height";
                    ae[W] = `${b.value}px`, ae[Q] = t[Q] ? `${t[Q]}px` : ""
                }
                return ae
            }),
            v = ae => {
                const {
                    active: W
                } = s;
                return ae ? t.loop ? nn(W + ae, -1, u.value) : nn(W + ae, 0, p.value) : W
            },
            _ = (ae, W = 0) => {
                let Q = ae * d.value;
                t.loop || (Q = Math.min(Q, -h.value));
                let fe = W - Q;
                return t.loop || (fe = nn(fe, h.value, 0)), fe
            },
            x = ({
                pace: ae = 0,
                offset: W = 0,
                emitChange: Q
            }) => {
                if (u.value <= 1) return;
                const {
                    active: fe
                } = s, D = v(ae), X = _(D, W);
                if (t.loop) {
                    if (l[0] && X !== h.value) {
                        const $ = X < h.value;
                        l[0].setOffset($ ? b.value : 0)
                    }
                    if (l[u.value - 1] && X !== 0) {
                        const $ = X > 0;
                        l[u.value - 1].setOffset($ ? -b.value : 0)
                    }
                }
                s.active = D, s.offset = X, Q && D !== fe && e("change", y.value)
            },
            w = () => {
                s.swiping = !0, s.active <= -1 ? x({
                    pace: u.value
                }) : s.active >= u.value && x({
                    pace: -u.value
                })
            },
            S = () => {
                w(), a.reset(), bo(() => {
                    s.swiping = !1, x({
                        pace: -1,
                        emitChange: !0
                    })
                })
            },
            C = () => {
                w(), a.reset(), bo(() => {
                    s.swiping = !1, x({
                        pace: 1,
                        emitChange: !0
                    })
                })
            };
        let A;
        const T = () => clearTimeout(A),
            E = () => {
                T(), +t.autoplay > 0 && u.value > 1 && (A = setTimeout(() => {
                    C(), E()
                }, +t.autoplay))
            },
            P = (ae = +t.initialSwipe) => {
                if (!r.value) return;
                const W = () => {
                    var Q, fe;
                    if (!ll(r)) {
                        const D = {
                            width: r.value.offsetWidth,
                            height: r.value.offsetHeight
                        };
                        s.rect = D, s.width = +((Q = t.width) != null ? Q : D.width), s.height = +((fe = t.height) != null ? fe : D.height)
                    }
                    u.value && (ae = Math.min(u.value - 1, ae), ae === -1 && (ae = u.value - 1)), s.active = ae, s.swiping = !0, s.offset = _(ae), l.forEach(D => {
                        D.setOffset(0)
                    }), E()
                };
                ll(r) ? Ue().then(W) : W()
            },
            B = () => P(s.active);
        let F;
        const H = ae => {
                !t.touchable || ae.touches.length > 1 || (a.start(ae), o = !1, F = Date.now(), T(), w())
            },
            k = ae => {
                t.touchable && s.swiping && (a.move(ae), m.value && (!t.loop && (s.active === 0 && f.value > 0 || s.active === u.value - 1 && f.value < 0) || (Zt(ae, t.stopPropagation), x({
                    offset: f.value
                }), o || (e("dragStart", {
                    index: y.value
                }), o = !0))))
            },
            N = () => {
                if (!t.touchable || !s.swiping) return;
                const ae = Date.now() - F,
                    W = f.value / ae;
                if ((Math.abs(W) > .25 || Math.abs(f.value) > d.value / 2) && m.value) {
                    const fe = t.vertical ? a.offsetY.value : a.offsetX.value;
                    let D = 0;
                    t.loop ? D = fe > 0 ? f.value > 0 ? -1 : 1 : 0 : D = -Math[f.value > 0 ? "ceil" : "floor"](f.value / d.value), x({
                        pace: D,
                        emitChange: !0
                    })
                } else f.value && x({
                    pace: 0
                });
                o = !1, s.swiping = !1, e("dragEnd", {
                    index: y.value
                }), E()
            },
            V = (ae, W = {}) => {
                w(), a.reset(), bo(() => {
                    let Q;
                    t.loop && ae === u.value ? Q = s.active === 0 ? 0 : ae : Q = ae % u.value, W.immediate ? bo(() => {
                        s.swiping = !1
                    }) : s.swiping = !1, x({
                        pace: Q - s.active,
                        emitChange: !0
                    })
                })
            },
            Y = (ae, W) => {
                const Q = W === y.value,
                    fe = Q ? {
                        backgroundColor: t.indicatorColor
                    } : void 0;
                return I("i", {
                    style: fe,
                    class: Rd("indicator", {
                        active: Q
                    })
                }, null)
            },
            le = () => {
                if (n.indicator) return n.indicator({
                    active: y.value,
                    total: u.value
                });
                if (t.showIndicators && u.value > 1) return I("div", {
                    class: Rd("indicators", {
                        vertical: t.vertical
                    })
                }, [Array(u.value).fill("").map(Y)])
            };
        return Tt({
            prev: S,
            next: C,
            state: s,
            resize: B,
            swipeTo: V
        }), c({
            size: d,
            props: t,
            count: u,
            activeIndicator: y
        }), pe(() => t.initialSwipe, ae => P(+ae)), pe(u, () => P(s.active)), pe(() => t.autoplay, E), pe([kl, Ju, () => t.width, () => t.height], B), pe(ZO(), ae => {
            ae === "visible" ? E() : T()
        }), St(P), zs(() => P(s.active)), xb(() => P(s.active)), Yi(T), er(T), Nn("touchmove", k, {
            target: i
        }), () => {
            var ae;
            return I("div", {
                ref: r,
                class: Rd()
            }, [I("div", {
                ref: i,
                style: g.value,
                class: Rd("track", {
                    vertical: t.vertical
                }),
                onTouchstartPassive: H,
                onTouchend: N,
                onTouchcancel: N
            }, [(ae = n.default) == null ? void 0 : ae.call(n)]), le()])
        }
    }
});
const r2 = Ae(jW),
    [VW, iS] = Ee("tabs");
var WW = ye({
    name: VW,
    props: {
        count: xn(Number),
        inited: Boolean,
        animated: Boolean,
        duration: xn(be),
        swipeable: Boolean,
        lazyRender: Boolean,
        currentIndex: xn(Number)
    },
    emits: ["change"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = J(),
            i = a => e("change", a),
            s = () => {
                var a;
                const l = (a = n.default) == null ? void 0 : a.call(n);
                return t.animated || t.swipeable ? I(r2, {
                    ref: r,
                    loop: !1,
                    class: iS("track"),
                    duration: +t.duration * 1e3,
                    touchable: t.swipeable,
                    lazyRender: t.lazyRender,
                    showIndicators: !1,
                    onChange: i
                }, {
                    default: () => [l]
                }) : l
            },
            o = a => {
                const l = r.value;
                l && l.state.active !== a && l.swipeTo(a, {
                    immediate: !t.inited
                })
            };
        return pe(() => t.currentIndex, o), St(() => {
            o(t.currentIndex)
        }), Tt({
            swipeRef: r
        }), () => I("div", {
            class: iS("content", {
                animated: t.animated || t.swipeable
            })
        }, [s()])
    }
});
const [i2, Md] = Ee("tabs"), YW = {
    type: Pe("line"),
    color: String,
    border: Boolean,
    sticky: Boolean,
    shrink: Boolean,
    active: Fe(0),
    duration: Fe(.3),
    animated: Boolean,
    ellipsis: me,
    swipeable: Boolean,
    scrollspy: Boolean,
    offsetTop: Fe(0),
    background: String,
    lazyRender: me,
    showHeader: me,
    lineWidth: be,
    lineHeight: be,
    beforeChange: Function,
    swipeThreshold: Fe(5),
    titleActiveColor: String,
    titleInactiveColor: String
}, s2 = Symbol(i2);
var XW = ye({
    name: i2,
    props: YW,
    emits: ["change", "scroll", "rendered", "clickTab", "update:active"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        let r, i, s, o, a;
        const l = J(),
            c = J(),
            u = J(),
            d = J(),
            f = Eb(),
            h = Ku(l),
            [p, b] = QR(),
            {
                children: y,
                linkChildren: m
            } = Br(s2),
            g = ht({
                inited: !1,
                position: "",
                lineStyle: {},
                currentIndex: -1
            }),
            v = ne(() => y.length > +t.swipeThreshold || !t.ellipsis || t.shrink),
            _ = ne(() => ({
                borderColor: t.color,
                background: t.background
            })),
            x = (D, X) => {
                var $;
                return ($ = D.name) != null ? $ : X
            },
            w = ne(() => {
                const D = y[g.currentIndex];
                if (D) return x(D, g.currentIndex)
            }),
            S = ne(() => bb(t.offsetTop)),
            C = ne(() => t.sticky ? S.value + r : 0),
            A = D => {
                const X = c.value,
                    $ = p.value;
                if (!v.value || !X || !$ || !$[g.currentIndex]) return;
                const Z = $[g.currentIndex].$el,
                    K = Z.offsetLeft - (X.offsetWidth - Z.offsetWidth) / 2;
                o && o(), o = DW(X, K, D ? 0 : +t.duration)
            },
            T = () => {
                const D = g.inited;
                Ue(() => {
                    const X = p.value;
                    if (!X || !X[g.currentIndex] || t.type !== "line" || ll(l.value)) return;
                    const $ = X[g.currentIndex].$el,
                        {
                            lineWidth: Z,
                            lineHeight: K
                        } = t,
                        ce = $.offsetLeft + $.offsetWidth / 2,
                        de = {
                            width: Ze(Z),
                            backgroundColor: t.color,
                            transform: `translateX(${ce}px) translateX(-50%)`
                        };
                    if (D && (de.transitionDuration = `${t.duration}s`), vt(K)) {
                        const ge = Ze(K);
                        de.height = ge, de.borderRadius = ge
                    }
                    g.lineStyle = de
                })
            },
            E = D => {
                const X = D < g.currentIndex ? -1 : 1;
                for (; D >= 0 && D < y.length;) {
                    if (!y[D].disabled) return D;
                    D += X
                }
            },
            P = (D, X) => {
                const $ = E(D);
                if (!vt($)) return;
                const Z = y[$],
                    K = x(Z, $),
                    ce = g.currentIndex !== null;
                g.currentIndex !== $ && (g.currentIndex = $, X || A(), T()), K !== t.active && (e("update:active", K), ce && e("change", K, Z.title)), s && !t.scrollspy && _b(Math.ceil(zE(l.value) - S.value))
            },
            B = (D, X) => {
                const $ = y.find((K, ce) => x(K, ce) === D),
                    Z = $ ? y.indexOf($) : 0;
                P(Z, X)
            },
            F = (D = !1) => {
                if (t.scrollspy) {
                    const X = y[g.currentIndex].$el;
                    if (X && h.value) {
                        const $ = zE(X, h.value) - C.value;
                        i = !0, a && a(), a = $W(h.value, $, D ? 0 : +t.duration, () => {
                            i = !1
                        })
                    }
                }
            },
            H = (D, X, $) => {
                const {
                    title: Z,
                    disabled: K
                } = y[X], ce = x(y[X], X);
                K || (Bl(t.beforeChange, {
                    args: [ce],
                    done: () => {
                        P(X), F()
                    }
                }), jR(D)), e("clickTab", {
                    name: ce,
                    title: Z,
                    event: $,
                    disabled: K
                })
            },
            k = D => {
                s = D.isFixed, e("scroll", D)
            },
            N = D => {
                Ue(() => {
                    B(D), F(!0)
                })
            },
            V = () => {
                for (let D = 0; D < y.length; D++) {
                    const {
                        top: X
                    } = Jt(y[D].$el);
                    if (X > C.value) return D === 0 ? 0 : D - 1
                }
                return y.length - 1
            },
            Y = () => {
                if (t.scrollspy && !i) {
                    const D = V();
                    P(D)
                }
            },
            le = () => {
                if (t.type === "line" && y.length) return I("div", {
                    class: Md("line"),
                    style: g.lineStyle
                }, null)
            },
            ae = () => {
                var D, X, $;
                const {
                    type: Z,
                    border: K,
                    sticky: ce
                } = t, de = [I("div", {
                    ref: ce ? void 0 : u,
                    class: [Md("wrap"), {
                        [FR]: Z === "line" && K
                    }]
                }, [I("div", {
                    ref: c,
                    role: "tablist",
                    class: Md("nav", [Z, {
                        shrink: t.shrink,
                        complete: v.value
                    }]),
                    style: _.value,
                    "aria-orientation": "horizontal"
                }, [(D = n["nav-left"]) == null ? void 0 : D.call(n), y.map(ge => ge.renderTitle(H)), le(), (X = n["nav-right"]) == null ? void 0 : X.call(n)])]), ($ = n["nav-bottom"]) == null ? void 0 : $.call(n)];
                return ce ? I("div", {
                    ref: u
                }, [de]) : de
            },
            W = () => {
                T(), Ue(() => {
                    var D, X;
                    A(!0), (X = (D = d.value) == null ? void 0 : D.swipeRef.value) == null || X.resize()
                })
            };
        pe(() => [t.color, t.duration, t.lineWidth, t.lineHeight], T), pe(kl, W), pe(() => t.active, D => {
            D !== w.value && B(D)
        }), pe(() => y.length, () => {
            g.inited && (B(t.active), T(), Ue(() => {
                A(!0)
            }))
        });
        const Q = () => {
                B(t.active, !0), Ue(() => {
                    g.inited = !0, u.value && (r = Jt(u.value).height), A(!0)
                })
            },
            fe = (D, X) => e("rendered", D, X);
        return Tt({
            resize: W,
            scrollTo: N
        }), zs(T), xb(T), Ml(Q), e2(l, T), Nn("scroll", Y, {
            target: h,
            passive: !0
        }), m({
            id: f,
            props: t,
            setLine: T,
            scrollable: v,
            onRendered: fe,
            currentName: w,
            setTitleRefs: b,
            scrollIntoView: A
        }), () => I("div", {
            ref: l,
            class: Md([t.type])
        }, [t.showHeader ? t.sticky ? I(HW, {
            container: l.value,
            offsetTop: S.value,
            onScroll: k
        }, {
            default: () => [ae()]
        }) : ae() : null, I(WW, {
            ref: d,
            count: y.length,
            inited: g.inited,
            animated: t.animated,
            duration: t.duration,
            swipeable: t.swipeable,
            lazyRender: t.lazyRender,
            currentIndex: g.currentIndex,
            onChange: P
        }, {
            default: () => {
                var D;
                return [(D = n.default) == null ? void 0 : D.call(n)]
            }
        })])
    }
});
const o2 = Symbol(),
    KW = () => Nt(o2, null),
    [qW, sS] = Ee("tab"),
    JW = ye({
        name: qW,
        props: {
            id: String,
            dot: Boolean,
            type: String,
            color: String,
            title: String,
            badge: be,
            shrink: Boolean,
            isActive: Boolean,
            disabled: Boolean,
            controls: String,
            scrollable: Boolean,
            activeColor: String,
            inactiveColor: String,
            showZeroBadge: me
        },
        setup(t, {
            slots: e
        }) {
            const n = ne(() => {
                    const i = {},
                        {
                            type: s,
                            color: o,
                            disabled: a,
                            isActive: l,
                            activeColor: c,
                            inactiveColor: u
                        } = t;
                    o && s === "card" && (i.borderColor = o, a || (l ? i.backgroundColor = o : i.color = o));
                    const f = l ? c : u;
                    return f && (i.color = f), i
                }),
                r = () => {
                    const i = I("span", {
                        class: sS("text", {
                            ellipsis: !t.scrollable
                        })
                    }, [e.title ? e.title() : t.title]);
                    return t.dot || vt(t.badge) && t.badge !== "" ? I(vp, {
                        dot: t.dot,
                        content: t.badge,
                        showZero: t.showZeroBadge
                    }, {
                        default: () => [i]
                    }) : i
                };
            return () => I("div", {
                id: t.id,
                role: "tab",
                class: [sS([t.type, {
                    grow: t.scrollable && !t.shrink,
                    shrink: t.shrink,
                    active: t.isActive,
                    disabled: t.disabled
                }])],
                style: n.value,
                tabindex: t.disabled ? void 0 : t.isActive ? 0 : -1,
                "aria-selected": t.isActive,
                "aria-disabled": t.disabled || void 0,
                "aria-controls": t.controls,
                "data-allow-mismatch": "attribute"
            }, [r()])
        }
    }),
    [ZW, QW] = Ee("swipe-item");
var e7 = ye({
    name: ZW,
    setup(t, {
        slots: e
    }) {
        let n;
        const r = ht({
                offset: 0,
                inited: !1,
                mounted: !1
            }),
            {
                parent: i,
                index: s
            } = tr(n2);
        if (!i) {
            console.error("[Vant] <SwipeItem> must be a child component of <Swipe>.");
            return
        }
        const o = ne(() => {
                const c = {},
                    {
                        vertical: u
                    } = i.props;
                return i.size.value && (c[u ? "height" : "width"] = `${i.size.value}px`), r.offset && (c.transform = `translate${u?"Y":"X"}(${r.offset}px)`), c
            }),
            a = ne(() => {
                const {
                    loop: c,
                    lazyRender: u
                } = i.props;
                if (!u || n) return !0;
                if (!r.mounted) return !1;
                const d = i.activeIndicator.value,
                    f = i.count.value - 1,
                    h = d === 0 && c ? f : d - 1,
                    p = d === f && c ? 0 : d + 1;
                return n = s.value === d || s.value === h || s.value === p, n
            }),
            l = c => {
                r.offset = c
            };
        return St(() => {
            Ue(() => {
                r.mounted = !0
            })
        }), Tt({
            setOffset: l
        }), () => {
            var c;
            return I("div", {
                class: QW(),
                style: o.value
            }, [a.value ? (c = e.default) == null ? void 0 : c.call(e) : null])
        }
    }
});
const a2 = Ae(e7),
    [t7, Am] = Ee("tab"),
    n7 = Ne({}, Dl, {
        dot: Boolean,
        name: be,
        badge: be,
        title: String,
        disabled: Boolean,
        titleClass: Ut,
        titleStyle: [String, Object],
        showZeroBadge: me
    });
var r7 = ye({
    name: t7,
    props: n7,
    setup(t, {
        slots: e
    }) {
        const n = Eb(),
            r = J(!1),
            i = it(),
            {
                parent: s,
                index: o
            } = tr(s2);
        if (!s) {
            console.error("[Vant] <Tab> must be a child component of <Tabs>.");
            return
        }
        const a = () => {
                var p;
                return (p = t.name) != null ? p : o.value
            },
            l = () => {
                r.value = !0, s.props.lazyRender && Ue(() => {
                    s.onRendered(a(), t.title)
                })
            },
            c = ne(() => {
                const p = a() === s.currentName.value;
                return p && !r.value && l(), p
            }),
            u = J(""),
            d = J("");
        Il(() => {
            const {
                titleClass: p,
                titleStyle: b
            } = t;
            u.value = p ? ZR(p) : "", d.value = b && typeof b != "string" ? BW(JR(b)) : b
        });
        const f = p => I(JW, et({
                key: n,
                id: `${s.id}-${o.value}`,
                ref: s.setTitleRefs(o.value),
                style: d.value,
                class: u.value,
                isActive: c.value,
                controls: n,
                scrollable: s.scrollable.value,
                activeColor: s.props.titleActiveColor,
                inactiveColor: s.props.titleInactiveColor,
                onClick: b => p(i.proxy, o.value, b)
            }, wt(s.props, ["type", "color", "shrink"]), wt(t, ["dot", "badge", "title", "disabled", "showZeroBadge"])), {
                title: e.title
            }),
            h = J(!c.value);
        return pe(c, p => {
            p ? h.value = !1 : bo(() => {
                h.value = !0
            })
        }), pe(() => t.title, () => {
            s.setLine(), s.scrollIntoView()
        }), Pr(o2, c), Tt({
            id: n,
            renderTitle: f
        }), () => {
            var p;
            const b = `${s.id}-${o.value}`,
                {
                    animated: y,
                    swipeable: m,
                    scrollspy: g,
                    lazyRender: v
                } = s.props;
            if (!e.default && !y) return;
            const _ = g || c.value;
            if (y || m) return I(a2, {
                id: n,
                role: "tabpanel",
                class: Am("panel-wrapper", {
                    inactive: h.value
                }),
                tabindex: c.value ? 0 : -1,
                "aria-hidden": !c.value,
                "aria-labelledby": b,
                "data-allow-mismatch": "attribute"
            }, {
                default: () => {
                    var S;
                    return [I("div", {
                        class: Am("panel")
                    }, [(S = e.default) == null ? void 0 : S.call(e)])]
                }
            });
            const w = r.value || g || !v ? (p = e.default) == null ? void 0 : p.call(e) : null;
            return Cr(I("div", {
                id: n,
                role: "tabpanel",
                class: Am("panel"),
                tabindex: _ ? 0 : -1,
                "aria-labelledby": b,
                "data-allow-mismatch": "attribute"
            }, [w]), [
                [Ar, _]
            ])
        }
    }
});
const z0e = Ae(r7),
    j0e = Ae(XW),
    [i7, V0e] = Ee("picker-group"),
    s7 = Symbol(i7);
Ne({
    tabs: Gi(),
    activeTab: Fe(0),
    nextStepText: String,
    showToolbar: me
}, yp);
const Sb = Ne({
        loading: Boolean,
        readonly: Boolean,
        allowHtml: Boolean,
        optionHeight: Fe(44),
        showToolbar: me,
        swipeDuration: Fe(1e3),
        visibleOptionNum: Fe(6)
    }, yp),
    o7 = Ne({}, Sb, {
        columns: Gi(),
        modelValue: Gi(),
        toolbarPosition: Pe("top"),
        columnsFieldNames: Object
    });
var a7 = ye({
    name: mW,
    props: o7,
    emits: ["confirm", "cancel", "change", "scrollInto", "clickOption", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = J(),
            i = J(t.modelValue.slice(0)),
            {
                parent: s
            } = tr(s7),
            {
                children: o,
                linkChildren: a
            } = Br(XR);
        a();
        const l = ne(() => _W(t.columnsFieldNames)),
            c = ne(() => bb(t.optionHeight)),
            u = ne(() => gW(t.columns, l.value)),
            d = ne(() => {
                const {
                    columns: E
                } = t;
                switch (u.value) {
                    case "multiple":
                        return E;
                    case "cascade":
                        return vW(E, l.value, i);
                    default:
                        return [E]
                }
            }),
            f = ne(() => d.value.some(E => E.length)),
            h = ne(() => d.value.map((E, P) => yy(E, i.value[P], l.value))),
            p = ne(() => d.value.map((E, P) => E.findIndex(B => B[l.value.value] === i.value[P]))),
            b = (E, P) => {
                if (i.value[E] !== P) {
                    const B = i.value.slice(0);
                    B[E] = P, i.value = B
                }
            },
            y = () => ({
                selectedValues: i.value.slice(0),
                selectedOptions: h.value,
                selectedIndexes: p.value
            }),
            m = (E, P) => {
                b(P, E), u.value === "cascade" && i.value.forEach((B, F) => {
                    const H = d.value[F];
                    tS(H, B, l.value) || b(F, H.length ? H[0][l.value.value] : void 0)
                }), Ue(() => {
                    e("change", Ne({
                        columnIndex: P
                    }, y()))
                })
            },
            g = (E, P) => {
                const B = {
                    columnIndex: P,
                    currentOption: E
                };
                e("clickOption", Ne(y(), B)), e("scrollInto", B)
            },
            v = () => {
                o.forEach(P => P.stopMomentum());
                const E = y();
                return Ue(() => {
                    e("confirm", E)
                }), E
            },
            _ = () => e("cancel", y()),
            x = () => d.value.map((E, P) => I(xW, {
                value: i.value[P],
                fields: l.value,
                options: E,
                readonly: t.readonly,
                allowHtml: t.allowHtml,
                optionHeight: c.value,
                swipeDuration: t.swipeDuration,
                visibleOptionNum: t.visibleOptionNum,
                onChange: B => m(B, P),
                onClickOption: B => g(B, P),
                onScrollInto: B => {
                    e("scrollInto", {
                        currentOption: B,
                        columnIndex: P
                    })
                }
            }, {
                option: n.option
            })),
            w = E => {
                if (f.value) {
                    const P = {
                            height: `${c.value}px`
                        },
                        B = {
                            backgroundSize: `100% ${(E-c.value)/2}px`
                        };
                    return [I("div", {
                        class: Ai("mask"),
                        style: B
                    }, null), I("div", {
                        class: [PV, Ai("frame")],
                        style: P
                    }, null)]
                }
            },
            S = () => {
                const E = c.value * +t.visibleOptionNum,
                    P = {
                        height: `${E}px`
                    };
                return !t.loading && !f.value && n.empty ? n.empty() : I("div", {
                    ref: r,
                    class: Ai("columns"),
                    style: P
                }, [x(), w(E)])
            },
            C = () => {
                if (t.showToolbar && !s) return I(TW, et(wt(t, SW), {
                    onConfirm: v,
                    onCancel: _
                }), wt(n, EW))
            };
        pe(d, E => {
            E.forEach((P, B) => {
                P.length && !tS(P, i.value[B], l.value) && b(B, WR(P)[l.value.value])
            })
        }, {
            immediate: !0
        });
        let A;
        return pe(() => t.modelValue, E => {
            !Ps(E, i.value) && !Ps(E, A) && (i.value = E.slice(0), A = E.slice(0))
        }, {
            deep: !0
        }), pe(i, E => {
            Ps(E, t.modelValue) || (A = E.slice(0), e("update:modelValue", A))
        }, {
            immediate: !0
        }), Nn("touchmove", Zt, {
            target: r
        }), Tt({
            confirm: v,
            getSelectedOptions: () => h.value
        }), () => {
            var E, P;
            return I("div", {
                class: Ai()
            }, [t.toolbarPosition === "top" ? C() : null, t.loading ? I(qi, {
                class: Ai("loading")
            }, null) : null, (E = n["columns-top"]) == null ? void 0 : E.call(n), S(), (P = n["columns-bottom"]) == null ? void 0 : P.call(n), t.toolbarPosition === "bottom" ? C() : null])
        }
    }
});
const l7 = Ae(a7),
    [c7, Ea] = Ee("cell"),
    _p = {
        tag: Pe("div"),
        icon: String,
        size: String,
        title: be,
        value: be,
        label: be,
        center: Boolean,
        isLink: Boolean,
        border: me,
        iconPrefix: String,
        valueClass: Ut,
        labelClass: Ut,
        titleClass: Ut,
        titleStyle: null,
        arrowDirection: String,
        required: {
            type: [Boolean, String],
            default: null
        },
        clickable: {
            type: Boolean,
            default: null
        }
    },
    u7 = Ne({}, _p, Dl);
var d7 = ye({
    name: c7,
    props: u7,
    setup(t, {
        slots: e
    }) {
        const n = Zu(),
            r = () => {
                if (e.label || vt(t.label)) return I("div", {
                    class: [Ea("label"), t.labelClass]
                }, [e.label ? e.label() : t.label])
            },
            i = () => {
                var l;
                if (e.title || vt(t.title)) {
                    const c = (l = e.title) == null ? void 0 : l.call(e);
                    return Array.isArray(c) && c.length === 0 ? void 0 : I("div", {
                        class: [Ea("title"), t.titleClass],
                        style: t.titleStyle
                    }, [c || I("span", null, [t.title]), r()])
                }
            },
            s = () => {
                const l = e.value || e.default;
                if (l || vt(t.value)) return I("div", {
                    class: [Ea("value"), t.valueClass]
                }, [l ? l() : I("span", null, [t.value])])
            },
            o = () => {
                if (e.icon) return e.icon();
                if (t.icon) return I($t, {
                    name: t.icon,
                    class: Ea("left-icon"),
                    classPrefix: t.iconPrefix
                }, null)
            },
            a = () => {
                if (e["right-icon"]) return e["right-icon"]();
                if (t.isLink) {
                    const l = t.arrowDirection && t.arrowDirection !== "right" ? `arrow-${t.arrowDirection}` : "arrow";
                    return I($t, {
                        name: l,
                        class: Ea("right-icon")
                    }, null)
                }
            };
        return () => {
            var l;
            const {
                tag: c,
                size: u,
                center: d,
                border: f,
                isLink: h,
                required: p
            } = t, b = (l = t.clickable) != null ? l : h, y = {
                center: d,
                required: !!p,
                clickable: b,
                borderless: !f
            };
            return u && (y[u] = !!u), I(c, {
                class: Ea(y),
                role: b ? "button" : void 0,
                tabindex: b ? 0 : void 0,
                onClick: n
            }, {
                default: () => {
                    var m;
                    return [o(), i(), s(), a(), (m = e.extra) == null ? void 0 : m.call(e)]
                }
            })
        }
    }
});
const l2 = Ae(d7),
    [f7, h7] = Ee("form"),
    p7 = {
        colon: Boolean,
        disabled: Boolean,
        readonly: Boolean,
        required: [Boolean, String],
        showError: Boolean,
        labelWidth: be,
        labelAlign: String,
        inputAlign: String,
        scrollToError: Boolean,
        scrollToErrorPosition: String,
        validateFirst: Boolean,
        submitOnEnter: me,
        showErrorMessage: me,
        errorMessageAlign: String,
        validateTrigger: {
            type: [String, Array],
            default: "onBlur"
        }
    };
var m7 = ye({
    name: f7,
    props: p7,
    emits: ["submit", "failed"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            children: r,
            linkChildren: i
        } = Br(LR), s = y => y ? r.filter(m => y.includes(m.name)) : r, o = y => new Promise((m, g) => {
            const v = [];
            s(y).reduce((x, w) => x.then(() => {
                if (!v.length) return w.validate().then(S => {
                    S && v.push(S)
                })
            }), Promise.resolve()).then(() => {
                v.length ? g(v) : m()
            })
        }), a = y => new Promise((m, g) => {
            const v = s(y);
            Promise.all(v.map(_ => _.validate())).then(_ => {
                _ = _.filter(Boolean), _.length ? g(_) : m()
            })
        }), l = y => {
            const m = r.find(g => g.name === y);
            return m ? new Promise((g, v) => {
                m.validate().then(_ => {
                    _ ? v(_) : g()
                })
            }) : Promise.reject()
        }, c = y => typeof y == "string" ? l(y) : t.validateFirst ? o(y) : a(y), u = y => {
            typeof y == "string" && (y = [y]), s(y).forEach(g => {
                g.resetValidation()
            })
        }, d = () => r.reduce((y, m) => (y[m.name] = m.getValidationStatus(), y), {}), f = (y, m) => {
            r.some(g => g.name === y ? (g.$el.scrollIntoView(m), !0) : !1)
        }, h = () => r.reduce((y, m) => (m.name !== void 0 && (y[m.name] = m.formValue.value), y), {}), p = () => {
            const y = h();
            c().then(() => e("submit", y)).catch(m => {
                e("failed", {
                    values: y,
                    errors: m
                });
                const {
                    scrollToError: g,
                    scrollToErrorPosition: v
                } = t;
                g && m[0].name && f(m[0].name, v ? {
                    block: v
                } : void 0)
            })
        }, b = y => {
            Zt(y), p()
        };
        return i({
            props: t
        }), Tt({
            submit: p,
            validate: c,
            getValues: h,
            scrollToField: f,
            resetValidation: u,
            getValidationStatus: d
        }), () => {
            var y;
            return I("form", {
                class: h7(),
                onSubmit: b
            }, [(y = n.default) == null ? void 0 : y.call(n)])
        }
    }
});
const W0e = Ae(m7);

function c2(t) {
    return Array.isArray(t) ? !t.length : t === 0 ? !1 : !t
}

function g7(t, e) {
    if (c2(t)) {
        if (e.required) return !1;
        if (e.validateEmpty === !1) return !0
    }
    return !(e.pattern && !e.pattern.test(String(t)))
}

function v7(t, e) {
    return new Promise(n => {
        const r = e.validator(t, e);
        if (vb(r)) {
            r.then(n);
            return
        }
        n(r)
    })
}

function oS(t, e) {
    const {
        message: n
    } = e;
    return al(n) ? n(t, e) : n || ""
}

function y7({
    target: t
}) {
    t.composing = !0
}

function aS({
    target: t
}) {
    t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")))
}

function _7(t, e) {
    const n = yb();
    t.style.height = "auto";
    let r = t.scrollHeight;
    if (Bs(e)) {
        const {
            maxHeight: i,
            minHeight: s
        } = e;
        i !== void 0 && (r = Math.min(r, i)), s !== void 0 && (r = Math.max(r, s))
    }
    r && (t.style.height = `${r}px`, _b(n))
}

function b7(t, e) {
    return t === "number" && (t = "text", e ? ? (e = "decimal")), t === "digit" && (t = "tel", e ? ? (e = "numeric")), {
        type: t,
        inputmode: e
    }
}

function hi(t) {
    return [...t].length
}

function Om(t, e) {
    return [...t].slice(0, e).join("")
}
const [x7, ar] = Ee("field"), w7 = {
    id: String,
    name: String,
    leftIcon: String,
    rightIcon: String,
    autofocus: Boolean,
    clearable: Boolean,
    maxlength: be,
    max: Number,
    min: Number,
    formatter: Function,
    clearIcon: Pe("clear"),
    modelValue: Fe(""),
    inputAlign: String,
    placeholder: String,
    autocomplete: String,
    autocapitalize: String,
    autocorrect: String,
    errorMessage: String,
    enterkeyhint: String,
    clearTrigger: Pe("focus"),
    formatTrigger: Pe("onChange"),
    spellcheck: {
        type: Boolean,
        default: null
    },
    error: {
        type: Boolean,
        default: null
    },
    disabled: {
        type: Boolean,
        default: null
    },
    readonly: {
        type: Boolean,
        default: null
    },
    inputmode: String
}, E7 = Ne({}, _p, w7, {
    rows: be,
    type: Pe("text"),
    rules: Array,
    autosize: [Boolean, Object],
    labelWidth: be,
    labelClass: Ut,
    labelAlign: String,
    showWordLimit: Boolean,
    errorMessageAlign: String,
    colon: {
        type: Boolean,
        default: null
    }
});
var S7 = ye({
    name: x7,
    props: E7,
    emits: ["blur", "focus", "clear", "keypress", "clickInput", "endValidate", "startValidate", "clickLeftIcon", "clickRightIcon", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = Eb(),
            i = ht({
                status: "unvalidated",
                focused: !1,
                validateMessage: ""
            }),
            s = J(),
            o = J(),
            a = J(),
            {
                parent: l
            } = tr(LR),
            c = () => {
                var $;
                return String(($ = t.modelValue) != null ? $ : "")
            },
            u = $ => {
                if (vt(t[$])) return t[$];
                if (l && vt(l.props[$])) return l.props[$]
            },
            d = ne(() => {
                const $ = u("readonly");
                if (t.clearable && !$) {
                    const Z = c() !== "",
                        K = t.clearTrigger === "always" || t.clearTrigger === "focus" && i.focused;
                    return Z && K
                }
                return !1
            }),
            f = ne(() => a.value && n.input ? a.value() : t.modelValue),
            h = ne(() => {
                var $;
                const Z = u("required");
                return Z === "auto" ? ($ = t.rules) == null ? void 0 : $.some(K => K.required) : Z
            }),
            p = $ => $.reduce((Z, K) => Z.then(() => {
                if (i.status === "failed") return;
                let {
                    value: ce
                } = f;
                if (K.formatter && (ce = K.formatter(ce, K)), !g7(ce, K)) {
                    i.status = "failed", i.validateMessage = oS(ce, K);
                    return
                }
                if (K.validator) return c2(ce) && K.validateEmpty === !1 ? void 0 : v7(ce, K).then(de => {
                    de && typeof de == "string" ? (i.status = "failed", i.validateMessage = de) : de === !1 && (i.status = "failed", i.validateMessage = oS(ce, K))
                })
            }), Promise.resolve()),
            b = () => {
                i.status = "unvalidated", i.validateMessage = ""
            },
            y = () => e("endValidate", {
                status: i.status,
                message: i.validateMessage
            }),
            m = ($ = t.rules) => new Promise(Z => {
                b(), $ ? (e("startValidate"), p($).then(() => {
                    i.status === "failed" ? (Z({
                        name: t.name,
                        message: i.validateMessage
                    }), y()) : (i.status = "passed", Z(), y())
                })) : Z()
            }),
            g = $ => {
                if (l && t.rules) {
                    const {
                        validateTrigger: Z
                    } = l.props, K = oh(Z).includes($), ce = t.rules.filter(de => de.trigger ? oh(de.trigger).includes($) : K);
                    ce.length && m(ce)
                }
            },
            v = $ => {
                var Z;
                const {
                    maxlength: K
                } = t;
                if (vt(K) && hi($) > +K) {
                    const ce = c();
                    if (ce && hi(ce) === +K) return ce;
                    const de = (Z = s.value) == null ? void 0 : Z.selectionEnd;
                    if (i.focused && de) {
                        const ge = [...$],
                            O = ge.length - +K;
                        return ge.splice(de - O, O), ge.join("")
                    }
                    return Om($, +K)
                }
                return $
            },
            _ = ($, Z = "onChange") => {
                var K, ce;
                const de = $;
                $ = v($);
                const ge = hi(de) - hi($);
                if (t.type === "number" || t.type === "digit") {
                    const L = t.type === "number";
                    if ($ = my($, L, L), Z === "onBlur" && $ !== "" && (t.min !== void 0 || t.max !== void 0)) {
                        const j = nn(+$, (K = t.min) != null ? K : -1 / 0, (ce = t.max) != null ? ce : 1 / 0); + $ !== j && ($ = j.toString())
                    }
                }
                let O = 0;
                if (t.formatter && Z === t.formatTrigger) {
                    const {
                        formatter: L,
                        maxlength: j
                    } = t;
                    if ($ = L($), vt(j) && hi($) > +j && ($ = Om($, +j)), s.value && i.focused) {
                        const {
                            selectionEnd: ie
                        } = s.value, oe = Om(de, ie);
                        O = hi(L(oe)) - hi(oe)
                    }
                }
                if (s.value && s.value.value !== $)
                    if (i.focused) {
                        let {
                            selectionStart: L,
                            selectionEnd: j
                        } = s.value;
                        if (s.value.value = $, vt(L) && vt(j)) {
                            const ie = hi($);
                            ge ? (L -= ge, j -= ge) : O && (L += O, j += O), s.value.setSelectionRange(Math.min(L, ie), Math.min(j, ie))
                        }
                    } else s.value.value = $;
                $ !== t.modelValue && e("update:modelValue", $)
            },
            x = $ => {
                $.target.composing || _($.target.value)
            },
            w = () => {
                var $;
                return ($ = s.value) == null ? void 0 : $.blur()
            },
            S = () => {
                var $;
                return ($ = s.value) == null ? void 0 : $.focus()
            },
            C = () => {
                const $ = s.value;
                t.type === "textarea" && t.autosize && $ && _7($, t.autosize)
            },
            A = $ => {
                i.focused = !0, e("focus", $), Ue(C), u("readonly") && w()
            },
            T = $ => {
                i.focused = !1, _(c(), "onBlur"), e("blur", $), !u("readonly") && (g("onBlur"), Ue(C), IR())
            },
            E = $ => e("clickInput", $),
            P = $ => e("clickLeftIcon", $),
            B = $ => e("clickRightIcon", $),
            F = $ => {
                Zt($), e("update:modelValue", ""), e("clear", $)
            },
            H = ne(() => {
                if (typeof t.error == "boolean") return t.error;
                if (l && l.props.showError && i.status === "failed") return !0
            }),
            k = ne(() => {
                const $ = u("labelWidth"),
                    Z = u("labelAlign");
                if ($ && Z !== "top") return {
                    width: Ze($)
                }
            }),
            N = $ => {
                $.keyCode === 13 && (!(l && l.props.submitOnEnter) && t.type !== "textarea" && Zt($), t.type === "search" && w()), e("keypress", $)
            },
            V = () => t.id || `${r}-input`,
            Y = () => i.status,
            le = () => {
                const $ = ar("control", [u("inputAlign"), {
                    error: H.value,
                    custom: !!n.input,
                    "min-height": t.type === "textarea" && !t.autosize
                }]);
                if (n.input) return I("div", {
                    class: $,
                    onClick: E
                }, [n.input()]);
                const Z = {
                    id: V(),
                    ref: s,
                    name: t.name,
                    rows: t.rows !== void 0 ? +t.rows : void 0,
                    class: $,
                    disabled: u("disabled"),
                    readonly: u("readonly"),
                    autofocus: t.autofocus,
                    placeholder: t.placeholder,
                    autocomplete: t.autocomplete,
                    autocapitalize: t.autocapitalize,
                    autocorrect: t.autocorrect,
                    enterkeyhint: t.enterkeyhint,
                    spellcheck: t.spellcheck,
                    "aria-labelledby": t.label ? `${r}-label` : void 0,
                    "data-allow-mismatch": "attribute",
                    onBlur: T,
                    onFocus: A,
                    onInput: x,
                    onClick: E,
                    onChange: aS,
                    onKeypress: N,
                    onCompositionend: aS,
                    onCompositionstart: y7
                };
                return t.type === "textarea" ? I("textarea", et(Z, {
                    inputmode: t.inputmode
                }), null) : I("input", et(b7(t.type, t.inputmode), Z), null)
            },
            ae = () => {
                const $ = n["left-icon"];
                if (t.leftIcon || $) return I("div", {
                    class: ar("left-icon"),
                    onClick: P
                }, [$ ? $() : I($t, {
                    name: t.leftIcon,
                    classPrefix: t.iconPrefix
                }, null)])
            },
            W = () => {
                const $ = n["right-icon"];
                if (t.rightIcon || $) return I("div", {
                    class: ar("right-icon"),
                    onClick: B
                }, [$ ? $() : I($t, {
                    name: t.rightIcon,
                    classPrefix: t.iconPrefix
                }, null)])
            },
            Q = () => {
                if (t.showWordLimit && t.maxlength) {
                    const $ = hi(c());
                    return I("div", {
                        class: ar("word-limit")
                    }, [I("span", {
                        class: ar("word-num")
                    }, [$]), ep("/"), t.maxlength])
                }
            },
            fe = () => {
                if (l && l.props.showErrorMessage === !1) return;
                const $ = t.errorMessage || i.validateMessage;
                if ($) {
                    const Z = n["error-message"],
                        K = u("errorMessageAlign");
                    return I("div", {
                        class: ar("error-message", K)
                    }, [Z ? Z({
                        message: $
                    }) : $])
                }
            },
            D = () => {
                const $ = u("labelWidth"),
                    Z = u("labelAlign"),
                    K = u("colon") ? ":" : "";
                if (n.label) return [n.label(), K];
                if (t.label) return I("label", {
                    id: `${r}-label`,
                    for: n.input ? void 0 : V(),
                    "data-allow-mismatch": "attribute",
                    onClick: ce => {
                        Zt(ce), S()
                    },
                    style: Z === "top" && $ ? {
                        width: Ze($)
                    } : void 0
                }, [t.label + K])
            },
            X = () => [I("div", {
                class: ar("body")
            }, [le(), d.value && I($t, {
                ref: o,
                name: t.clearIcon,
                class: ar("clear")
            }, null), W(), n.button && I("div", {
                class: ar("button")
            }, [n.button()])]), Q(), fe()];
        return Tt({
            blur: w,
            focus: S,
            validate: m,
            formValue: f,
            resetValidation: b,
            getValidationStatus: Y
        }), Pr(G_, {
            customValue: a,
            resetValidation: b,
            validateWithTrigger: g
        }), pe(() => t.modelValue, () => {
            _(c()), b(), g("onChange"), Ue(C)
        }), St(() => {
            _(c(), t.formatTrigger), Ue(C)
        }), Nn("touchstart", F, {
            target: ne(() => {
                var $;
                return ($ = o.value) == null ? void 0 : $.$el
            })
        }), () => {
            const $ = u("disabled"),
                Z = u("labelAlign"),
                K = ae(),
                ce = () => {
                    const de = D();
                    return Z === "top" ? [K, de].filter(Boolean) : de || []
                };
            return I(l2, {
                size: t.size,
                class: ar({
                    error: H.value,
                    disabled: $,
                    [`label-${Z}`]: Z
                }),
                center: t.center,
                border: t.border,
                isLink: t.isLink,
                clickable: t.clickable,
                titleStyle: k.value,
                valueClass: ar("value"),
                titleClass: [ar("label", [Z, {
                    required: h.value
                }]), t.labelClass],
                arrowDirection: t.arrowDirection
            }, {
                icon: K && Z !== "top" ? () => K : null,
                title: ce,
                value: X,
                extra: n.extra
            })
        }
    }
});
const Y0e = Ae(S7);
let ec = 0;

function T7(t) {
    t ? (ec || document.body.classList.add("van-toast--unclickable"), ec++) : ec && (ec--, ec || document.body.classList.remove("van-toast--unclickable"))
}
const [C7, Sa] = Ee("toast"), P7 = ["show", "overlay", "teleport", "transition", "overlayClass", "overlayStyle", "closeOnClickOverlay", "zIndex"], A7 = {
    icon: String,
    show: Boolean,
    type: Pe("text"),
    overlay: Boolean,
    message: be,
    iconSize: be,
    duration: gp(2e3),
    position: Pe("middle"),
    teleport: [String, Object],
    wordBreak: String,
    className: Ut,
    iconPrefix: String,
    transition: Pe("van-fade"),
    loadingType: String,
    forbidClick: Boolean,
    overlayClass: Ut,
    overlayStyle: Object,
    closeOnClick: Boolean,
    closeOnClickOverlay: Boolean,
    zIndex: be
};
var u2 = ye({
    name: C7,
    props: A7,
    emits: ["update:show"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        let r, i = !1;
        const s = () => {
                const d = t.show && t.forbidClick;
                i !== d && (i = d, T7(i))
            },
            o = d => e("update:show", d),
            a = () => {
                t.closeOnClick && o(!1)
            },
            l = () => clearTimeout(r),
            c = () => {
                const {
                    icon: d,
                    type: f,
                    iconSize: h,
                    iconPrefix: p,
                    loadingType: b
                } = t;
                if (d || f === "success" || f === "fail") return I($t, {
                    name: d || f,
                    size: h,
                    class: Sa("icon"),
                    classPrefix: p
                }, null);
                if (f === "loading") return I(qi, {
                    class: Sa("loading"),
                    size: h,
                    type: b
                }, null)
            },
            u = () => {
                const {
                    type: d,
                    message: f
                } = t;
                if (n.message) return I("div", {
                    class: Sa("text")
                }, [n.message()]);
                if (vt(f) && f !== "") return d === "html" ? I("div", {
                    key: 0,
                    class: Sa("text"),
                    innerHTML: String(f)
                }, null) : I("div", {
                    class: Sa("text")
                }, [f])
            };
        return pe(() => [t.show, t.forbidClick], s), pe(() => [t.show, t.type, t.message, t.duration], () => {
            l(), t.show && t.duration > 0 && (r = setTimeout(() => {
                o(!1)
            }, t.duration))
        }), St(s), Ki(s), () => I(ha, et({
            class: [Sa([t.position, t.wordBreak === "normal" ? "break-normal" : t.wordBreak, {
                [t.type]: !t.icon
            }]), t.className],
            lockScroll: !1,
            onClick: a,
            onClosed: l,
            "onUpdate:show": o
        }, wt(t, P7)), {
            default: () => [c(), u()]
        })
    }
});

function bp() {
    const t = ht({
            show: !1
        }),
        e = i => {
            t.show = i
        },
        n = i => {
            Ne(t, i, {
                transitionAppear: !0
            }), e(!0)
        },
        r = () => e(!1);
    return Tt({
        open: n,
        close: r,
        toggle: e
    }), {
        open: n,
        close: r,
        state: t,
        toggle: e
    }
}

function xp(t) {
    const e = TO(t),
        n = document.createElement("div");
    return document.body.appendChild(n), {
        instance: e.mount(n),
        unmount() {
            e.unmount(), document.body.removeChild(n)
        }
    }
}
const O7 = {
    icon: "",
    type: "text",
    message: "",
    className: "",
    overlay: !1,
    onClose: void 0,
    onOpened: void 0,
    duration: 2e3,
    teleport: "body",
    iconSize: void 0,
    iconPrefix: void 0,
    position: "middle",
    transition: "van-fade",
    forbidClick: !1,
    loadingType: void 0,
    overlayClass: "",
    overlayStyle: void 0,
    closeOnClick: !1,
    closeOnClickOverlay: !1
};
let gs = [],
    I7 = !1,
    _y = Ne({}, O7);
const d2 = new Map;

function f2(t) {
    return Bs(t) ? t : {
        message: t
    }
}

function R7() {
    const {
        instance: t,
        unmount: e
    } = xp({
        setup() {
            const n = J(""),
                {
                    open: r,
                    state: i,
                    close: s,
                    toggle: o
                } = bp(),
                a = () => {},
                l = () => I(u2, et(i, {
                    onClosed: a,
                    "onUpdate:show": o
                }), null);
            return pe(n, c => {
                i.message = c
            }), it().render = l, {
                open: r,
                close: s,
                message: n
            }
        }
    });
    return t
}

function M7() {
    if (!gs.length || I7) {
        const t = R7();
        gs.push(t)
    }
    return gs[gs.length - 1]
}

function by(t = {}) {
    if (!oi) return {};
    const e = M7(),
        n = f2(t);
    return e.open(Ne({}, _y, d2.get(n.type || _y.type), n)), e
}
const Tb = t => e => by(Ne({
        type: t
    }, f2(e))),
    X0e = Tb("loading"),
    K0e = Tb("success"),
    q0e = Tb("fail"),
    J0e = t => {
        gs.length && (t ? (gs.forEach(e => {
            e.close()
        }), gs = []) : gs[0].close())
    };

function Z0e(t, e) {
    typeof t == "string" ? d2.set(t, e) : Ne(_y, t)
}
const Q0e = Ae(u2),
    [k7, Im] = Ee("switch"),
    B7 = {
        size: be,
        loading: Boolean,
        disabled: Boolean,
        modelValue: Ut,
        activeColor: String,
        inactiveColor: String,
        activeValue: {
            type: Ut,
            default: !0
        },
        inactiveValue: {
            type: Ut,
            default: !1
        }
    };
var D7 = ye({
    name: k7,
    props: B7,
    emits: ["change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = () => t.modelValue === t.activeValue,
            i = () => {
                if (!t.disabled && !t.loading) {
                    const o = r() ? t.inactiveValue : t.activeValue;
                    e("update:modelValue", o), e("change", o)
                }
            },
            s = () => {
                if (t.loading) {
                    const o = r() ? t.activeColor : t.inactiveColor;
                    return I(qi, {
                        class: Im("loading"),
                        color: o
                    }, null)
                }
                if (n.node) return n.node()
            };
        return da(() => t.modelValue), () => {
            var o;
            const {
                size: a,
                loading: l,
                disabled: c,
                activeColor: u,
                inactiveColor: d
            } = t, f = r(), h = {
                fontSize: Ze(a),
                backgroundColor: f ? u : d
            };
            return I("div", {
                role: "switch",
                class: Im({
                    on: f,
                    loading: l,
                    disabled: c
                }),
                style: h,
                tabindex: c ? void 0 : 0,
                "aria-checked": f,
                onClick: i
            }, [I("div", {
                class: Im("node")
            }, [s()]), (o = n.background) == null ? void 0 : o.call(n)])
        }
    }
});
const e_e = Ae(D7),
    [h2, $7] = Ee("radio-group"),
    F7 = {
        shape: String,
        disabled: Boolean,
        iconSize: be,
        direction: String,
        modelValue: Ut,
        checkedColor: String
    },
    p2 = Symbol(h2);
var L7 = ye({
    name: h2,
    props: F7,
    emits: ["change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            linkChildren: r
        } = Br(p2), i = s => e("update:modelValue", s);
        return pe(() => t.modelValue, s => e("change", s)), r({
            props: t,
            updateValue: i
        }), da(() => t.modelValue), () => {
            var s;
            return I("div", {
                class: $7([t.direction]),
                role: "radiogroup"
            }, [(s = n.default) == null ? void 0 : s.call(n)])
        }
    }
});
const t_e = Ae(L7),
    [N7, n_e] = Ee("checkbox-group"),
    U7 = Symbol(N7),
    Cb = {
        name: Ut,
        disabled: Boolean,
        iconSize: be,
        modelValue: Ut,
        checkedColor: String,
        labelPosition: String,
        labelDisabled: Boolean
    };
var m2 = ye({
    props: Ne({}, Cb, {
        bem: xn(Function),
        role: String,
        shape: String,
        parent: Object,
        checked: Boolean,
        bindGroup: me,
        indeterminate: {
            type: Boolean,
            default: null
        }
    }),
    emits: ["click", "toggle"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = J(),
            i = f => {
                if (t.parent && t.bindGroup) return t.parent.props[f]
            },
            s = ne(() => {
                if (t.parent && t.bindGroup) {
                    const f = i("disabled") || t.disabled;
                    if (t.role === "checkbox") {
                        const h = i("modelValue").length,
                            p = i("max"),
                            b = p && h >= +p;
                        return f || b && !t.checked
                    }
                    return f
                }
                return t.disabled
            }),
            o = ne(() => i("direction")),
            a = ne(() => {
                const f = t.checkedColor || i("checkedColor");
                if (f && t.checked && !s.value) return {
                    borderColor: f,
                    backgroundColor: f
                }
            }),
            l = ne(() => t.shape || i("shape") || "round"),
            c = f => {
                const {
                    target: h
                } = f, p = r.value, b = p === h || (p == null ? void 0 : p.contains(h));
                !s.value && (b || !t.labelDisabled) && e("toggle"), e("click", f)
            },
            u = () => {
                var f, h;
                const {
                    bem: p,
                    checked: b,
                    indeterminate: y
                } = t, m = t.iconSize || i("iconSize");
                return I("div", {
                    ref: r,
                    class: p("icon", [l.value, {
                        disabled: s.value,
                        checked: b,
                        indeterminate: y
                    }]),
                    style: l.value !== "dot" ? {
                        fontSize: Ze(m)
                    } : {
                        width: Ze(m),
                        height: Ze(m),
                        borderColor: (f = a.value) == null ? void 0 : f.borderColor
                    }
                }, [n.icon ? n.icon({
                    checked: b,
                    disabled: s.value
                }) : l.value !== "dot" ? I($t, {
                    name: y ? "minus" : "success",
                    style: a.value
                }, null) : I("div", {
                    class: p("icon--dot__icon"),
                    style: {
                        backgroundColor: (h = a.value) == null ? void 0 : h.backgroundColor
                    }
                }, null)])
            },
            d = () => {
                const {
                    checked: f
                } = t;
                if (n.default) return I("span", {
                    class: t.bem("label", [t.labelPosition, {
                        disabled: s.value
                    }])
                }, [n.default({
                    checked: f,
                    disabled: s.value
                })])
            };
        return () => {
            const f = t.labelPosition === "left" ? [d(), u()] : [u(), d()];
            return I("div", {
                role: t.role,
                class: t.bem([{
                    disabled: s.value,
                    "label-disabled": t.labelDisabled
                }, o.value]),
                tabindex: s.value ? void 0 : 0,
                "aria-checked": t.checked,
                onClick: c
            }, [f])
        }
    }
});
const G7 = Ne({}, Cb, {
        shape: String
    }),
    [H7, z7] = Ee("radio");
var j7 = ye({
    name: H7,
    props: G7,
    emits: ["update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            parent: r
        } = tr(p2), i = () => (r ? r.props.modelValue : t.modelValue) === t.name, s = () => {
            r ? r.updateValue(t.name) : e("update:modelValue", t.name)
        };
        return () => I(m2, et({
            bem: z7,
            role: "radio",
            parent: r,
            checked: i(),
            onToggle: s
        }, t), wt(n, ["default", "icon"]))
    }
});
const r_e = Ae(j7),
    [V7, W7] = Ee("checkbox"),
    Y7 = Ne({}, Cb, {
        shape: String,
        bindGroup: me,
        indeterminate: {
            type: Boolean,
            default: null
        }
    });
var X7 = ye({
    name: V7,
    props: Y7,
    emits: ["change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            parent: r
        } = tr(U7), i = a => {
            const {
                name: l
            } = t, {
                max: c,
                modelValue: u
            } = r.props, d = u.slice();
            if (a) !(c && d.length >= +c) && !d.includes(l) && (d.push(l), t.bindGroup && r.updateValue(d));
            else {
                const f = d.indexOf(l);
                f !== -1 && (d.splice(f, 1), t.bindGroup && r.updateValue(d))
            }
        }, s = ne(() => r && t.bindGroup ? r.props.modelValue.indexOf(t.name) !== -1 : !!t.modelValue), o = (a = !s.value) => {
            r && t.bindGroup ? i(a) : e("update:modelValue", a), t.indeterminate !== null && e("change", a)
        };
        return pe(() => t.modelValue, a => {
            t.indeterminate === null && e("change", a)
        }), Tt({
            toggle: o,
            props: t,
            checked: s
        }), da(() => t.modelValue), () => I(m2, et({
            bem: W7,
            role: "checkbox",
            parent: r,
            checked: s.value,
            onToggle: o
        }, t), wt(n, ["default", "icon"]))
    }
});
const i_e = Ae(X7),
    [K7, At, Ri] = Ee("calendar"),
    q7 = t => Ri("monthTitle", t.getFullYear(), t.getMonth() + 1);

function xo(t, e) {
    const n = t.getFullYear(),
        r = e.getFullYear();
    if (n === r) {
        const i = t.getMonth(),
            s = e.getMonth();
        return i === s ? 0 : i > s ? 1 : -1
    }
    return n > r ? 1 : -1
}

function On(t, e) {
    const n = xo(t, e);
    if (n === 0) {
        const r = t.getDate(),
            i = e.getDate();
        return r === i ? 0 : r > i ? 1 : -1
    }
    return n
}
const cl = t => new Date(t),
    lS = t => Array.isArray(t) ? t.map(cl) : cl(t);

function Pb(t, e) {
    const n = cl(t);
    return n.setDate(n.getDate() + e), n
}

function Ab(t, e) {
    const n = cl(t);
    return n.setMonth(n.getMonth() + e), n.getDate() !== t.getDate() && n.setDate(0), n
}

function g2(t, e) {
    const n = cl(t);
    return n.setFullYear(n.getFullYear() + e), n.getDate() !== t.getDate() && n.setDate(0), n
}
const xy = t => Pb(t, -1),
    wy = t => Pb(t, 1),
    cS = t => Ab(t, -1),
    uS = t => Ab(t, 1),
    dS = t => g2(t, -1),
    fS = t => g2(t, 1),
    kd = () => {
        const t = new Date;
        return t.setHours(0, 0, 0, 0), t
    };

function J7(t) {
    const e = t[0].getTime();
    return (t[1].getTime() - e) / (1e3 * 60 * 60 * 24) + 1
}

function Z7(t, e = 0) {
    const n = new Date(t.getFullYear(), t.getMonth() + 1, 0),
        r = e + t.getDate() - 1,
        i = e + n.getDate() - 1;
    return Math.floor(r / 7) === Math.floor(i / 7)
}
const Q7 = Ne({}, Sb, {
        modelValue: Gi(),
        filter: Function,
        formatter: {
            type: Function,
            default: (t, e) => e
        }
    }),
    eY = Object.keys(Sb);

function tY(t, e) {
    if (t < 0) return [];
    const n = Array(t);
    let r = -1;
    for (; ++r < t;) n[r] = e(r);
    return n
}
const v2 = (t, e) => 32 - new Date(t, e - 1, 32).getDate(),
    Rm = (t, e, n, r, i, s) => {
        const o = tY(e - t + 1, a => {
            const l = vo(t + a);
            return r(n, {
                text: l,
                value: l
            })
        });
        return i ? i(n, o, s) : o
    },
    nY = (t, e) => t.map((n, r) => {
        const i = e[r];
        if (i.length) {
            const s = +i[0].value,
                o = +i[i.length - 1].value;
            return vo(nn(+n, s, o))
        }
        return n
    }),
    [rY] = Ee("calendar-day");
var iY = ye({
    name: rY,
    props: {
        item: xn(Object),
        color: String,
        index: Number,
        offset: gp(0),
        rowHeight: String
    },
    emits: ["click", "clickDisabledDate"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = ne(() => {
                const {
                    item: c,
                    index: u,
                    color: d,
                    offset: f,
                    rowHeight: h
                } = t, p = {
                    height: h
                };
                if (c.type === "placeholder") return p.width = "100%", p;
                if (u === 0 && (p.marginLeft = `${100*f/7}%`), d) switch (c.type) {
                    case "end":
                    case "start":
                    case "start-end":
                    case "multiple-middle":
                    case "multiple-selected":
                        p.background = d;
                        break;
                    case "middle":
                        p.color = d;
                        break
                }
                return c.date && Z7(c.date, f) && (p.marginBottom = 0), p
            }),
            i = () => {
                t.item.type !== "disabled" ? e("click", t.item) : e("clickDisabledDate", t.item)
            },
            s = () => {
                const {
                    topInfo: c
                } = t.item;
                if (c || n["top-info"]) return I("div", {
                    class: At("top-info")
                }, [n["top-info"] ? n["top-info"](t.item) : c])
            },
            o = () => {
                const {
                    bottomInfo: c
                } = t.item;
                if (c || n["bottom-info"]) return I("div", {
                    class: At("bottom-info")
                }, [n["bottom-info"] ? n["bottom-info"](t.item) : c])
            },
            a = () => n.text ? n.text(t.item) : t.item.text,
            l = () => {
                const {
                    item: c,
                    color: u,
                    rowHeight: d
                } = t, {
                    type: f
                } = c, h = [s(), a(), o()];
                return f === "selected" ? I("div", {
                    class: At("selected-day"),
                    style: {
                        width: d,
                        height: d,
                        background: u
                    }
                }, [h]) : h
            };
        return () => {
            const {
                type: c,
                className: u
            } = t.item;
            return c === "placeholder" ? I("div", {
                class: At("day"),
                style: r.value
            }, null) : I("div", {
                role: "gridcell",
                style: r.value,
                class: [At("day", c), u],
                tabindex: c === "disabled" ? void 0 : -1,
                onClick: i
            }, [l()])
        }
    }
});
const [sY] = Ee("calendar-month"), oY = {
    date: xn(Date),
    type: String,
    color: String,
    minDate: Date,
    maxDate: Date,
    showMark: Boolean,
    rowHeight: be,
    formatter: Function,
    lazyRender: Boolean,
    currentDate: [Date, Array],
    allowSameDay: Boolean,
    showSubtitle: Boolean,
    showMonthTitle: Boolean,
    firstDayOfWeek: Number
};
var aY = ye({
    name: sY,
    props: oY,
    emits: ["click", "clickDisabledDate"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const [r, i] = VO(), s = J(), o = J(), a = GR(o), l = ne(() => q7(t.date)), c = ne(() => Ze(t.rowHeight)), u = ne(() => {
            const T = t.date.getDate(),
                P = (t.date.getDay() - T % 7 + 8) % 7;
            return t.firstDayOfWeek ? (P + 7 - t.firstDayOfWeek) % 7 : P
        }), d = ne(() => v2(t.date.getFullYear(), t.date.getMonth() + 1)), f = ne(() => r.value || !t.lazyRender), h = () => l.value, p = T => {
            const E = P => t.currentDate.some(B => On(B, P) === 0);
            if (E(T)) {
                const P = xy(T),
                    B = wy(T),
                    F = E(P),
                    H = E(B);
                return F && H ? "multiple-middle" : F ? "end" : H ? "start" : "multiple-selected"
            }
            return ""
        }, b = T => {
            const [E, P] = t.currentDate;
            if (!E) return "";
            const B = On(T, E);
            if (!P) return B === 0 ? "start" : "";
            const F = On(T, P);
            return t.allowSameDay && B === 0 && F === 0 ? "start-end" : B === 0 ? "start" : F === 0 ? "end" : B > 0 && F < 0 ? "middle" : ""
        }, y = T => {
            const {
                type: E,
                minDate: P,
                maxDate: B,
                currentDate: F
            } = t;
            if (P && On(T, P) < 0 || B && On(T, B) > 0) return "disabled";
            if (F === null) return "";
            if (Array.isArray(F)) {
                if (E === "multiple") return p(T);
                if (E === "range") return b(T)
            } else if (E === "single") return On(T, F) === 0 ? "selected" : "";
            return ""
        }, m = T => {
            if (t.type === "range") {
                if (T === "start" || T === "end") return Ri(T);
                if (T === "start-end") return `${Ri("start")}/${Ri("end")}`
            }
        }, g = () => {
            if (t.showMonthTitle) return I("div", {
                class: At("month-title")
            }, [n["month-title"] ? n["month-title"]({
                date: t.date,
                text: l.value
            }) : l.value])
        }, v = () => {
            if (t.showMark && f.value) return I("div", {
                class: At("month-mark")
            }, [t.date.getMonth() + 1])
        }, _ = ne(() => {
            const T = Math.ceil((d.value + u.value) / 7);
            return Array(T).fill({
                type: "placeholder"
            })
        }), x = ne(() => {
            const T = [],
                E = t.date.getFullYear(),
                P = t.date.getMonth();
            for (let B = 1; B <= d.value; B++) {
                const F = new Date(E, P, B),
                    H = y(F);
                let k = {
                    date: F,
                    type: H,
                    text: B,
                    bottomInfo: m(H)
                };
                t.formatter && (k = t.formatter(k)), T.push(k)
            }
            return T
        }), w = ne(() => x.value.filter(T => T.type === "disabled")), S = (T, E) => {
            if (s.value) {
                const P = Jt(s.value),
                    B = _.value.length,
                    H = (Math.ceil((E.getDate() + u.value) / 7) - 1) * P.height / B;
                ah(T, P.top + H + T.scrollTop - Jt(T).top)
            }
        }, C = (T, E) => I(iY, {
            item: T,
            index: E,
            color: t.color,
            offset: u.value,
            rowHeight: c.value,
            onClick: P => e("click", P),
            onClickDisabledDate: P => e("clickDisabledDate", P)
        }, wt(n, ["top-info", "bottom-info", "text"])), A = () => I("div", {
            ref: s,
            role: "grid",
            class: At("days")
        }, [v(), (f.value ? x : _).value.map(C)]);
        return Tt({
            getTitle: h,
            getHeight: () => a.value,
            setVisible: i,
            scrollToDate: S,
            disabledDays: w
        }), () => I("div", {
            class: At("month"),
            ref: o
        }, [g(), A()])
    }
});
const [lY] = Ee("calendar-header");
var cY = ye({
    name: lY,
    props: {
        date: Date,
        minDate: Date,
        maxDate: Date,
        title: String,
        subtitle: String,
        showTitle: Boolean,
        showSubtitle: Boolean,
        firstDayOfWeek: Number,
        switchMode: Pe("none")
    },
    emits: ["clickSubtitle", "panelChange"],
    setup(t, {
        slots: e,
        emit: n
    }) {
        const r = ne(() => t.date && t.minDate && xo(cS(t.date), t.minDate) < 0),
            i = ne(() => t.date && t.minDate && xo(dS(t.date), t.minDate) < 0),
            s = ne(() => t.date && t.maxDate && xo(uS(t.date), t.maxDate) > 0),
            o = ne(() => t.date && t.maxDate && xo(fS(t.date), t.maxDate) > 0),
            a = () => {
                if (t.showTitle) {
                    const h = t.title || Ri("title"),
                        p = e.title ? e.title() : h;
                    return I("div", {
                        class: At("header-title")
                    }, [p])
                }
            },
            l = h => n("clickSubtitle", h),
            c = h => n("panelChange", h),
            u = h => {
                const p = t.switchMode === "year-month",
                    b = e[h ? "next-month" : "prev-month"],
                    y = e[h ? "next-year" : "prev-year"],
                    m = h ? s.value : r.value,
                    g = h ? o.value : i.value,
                    v = h ? "arrow" : "arrow-left",
                    _ = h ? "arrow-double-right" : "arrow-double-left",
                    x = () => c((h ? uS : cS)(t.date)),
                    w = () => c((h ? fS : dS)(t.date)),
                    S = I("view", {
                        class: At("header-action", {
                            disabled: m
                        }),
                        onClick: m ? void 0 : x
                    }, [b ? b({
                        disabled: m
                    }) : I($t, {
                        class: {
                            [Hi]: !m
                        },
                        name: v
                    }, null)]),
                    C = p && I("view", {
                        class: At("header-action", {
                            disabled: g
                        }),
                        onClick: g ? void 0 : w
                    }, [y ? y({
                        disabled: g
                    }) : I($t, {
                        class: {
                            [Hi]: !g
                        },
                        name: _
                    }, null)]);
                return h ? [S, C] : [C, S]
            },
            d = () => {
                if (t.showSubtitle) {
                    const h = e.subtitle ? e.subtitle({
                            date: t.date,
                            text: t.subtitle
                        }) : t.subtitle,
                        p = t.switchMode !== "none";
                    return I("div", {
                        class: At("header-subtitle", {
                            "with-switch": p
                        }),
                        onClick: l
                    }, [p ? [u(), I("div", {
                        class: At("header-subtitle-text")
                    }, [h]), u(!0)] : h])
                }
            },
            f = () => {
                const {
                    firstDayOfWeek: h
                } = t, p = Ri("weekdays"), b = [...p.slice(h, 7), ...p.slice(0, h)];
                return I("div", {
                    class: At("weekdays")
                }, [b.map(y => I("span", {
                    class: At("weekday")
                }, [y]))])
            };
        return () => I("div", {
            class: At("header")
        }, [a(), d(), f()])
    }
});
const uY = {
    show: Boolean,
    type: Pe("single"),
    switchMode: Pe("none"),
    title: String,
    color: String,
    round: me,
    readonly: Boolean,
    poppable: me,
    maxRange: Fe(null),
    position: Pe("bottom"),
    teleport: [String, Object],
    showMark: me,
    showTitle: me,
    formatter: Function,
    rowHeight: be,
    confirmText: String,
    rangePrompt: String,
    lazyRender: me,
    showConfirm: me,
    defaultDate: [Date, Array],
    allowSameDay: Boolean,
    showSubtitle: me,
    closeOnPopstate: me,
    showRangePrompt: me,
    confirmDisabledText: String,
    closeOnClickOverlay: me,
    safeAreaInsetTop: Boolean,
    safeAreaInsetBottom: me,
    minDate: {
        type: Date,
        validator: au
    },
    maxDate: {
        type: Date,
        validator: au
    },
    firstDayOfWeek: {
        type: be,
        default: 0,
        validator: t => t >= 0 && t <= 6
    }
};
var dY = ye({
    name: K7,
    props: uY,
    emits: ["select", "confirm", "unselect", "monthShow", "overRange", "update:show", "clickSubtitle", "clickDisabledDate", "clickOverlay", "panelChange"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = ne(() => t.switchMode !== "none"),
            i = ne(() => !t.minDate && !r.value ? kd() : t.minDate),
            s = ne(() => !t.maxDate && !r.value ? Ab(kd(), 6) : t.maxDate),
            o = (W, Q = i.value, fe = s.value) => Q && On(W, Q) === -1 ? Q : fe && On(W, fe) === 1 ? fe : W,
            a = (W = t.defaultDate) => {
                const {
                    type: Q,
                    allowSameDay: fe
                } = t;
                if (W === null) return W;
                const D = kd();
                if (Q === "range") {
                    Array.isArray(W) || (W = []), W.length === 1 && On(W[0], D) === 1 && (W = []);
                    const X = i.value,
                        $ = s.value,
                        Z = o(W[0] || D, X, $ ? fe ? $ : xy($) : void 0),
                        K = o(W[1] || (fe ? D : wy(D)), X ? fe ? X : wy(X) : void 0);
                    return [Z, K]
                }
                return Q === "multiple" ? Array.isArray(W) ? W.map(X => o(X)) : [o(D)] : ((!W || Array.isArray(W)) && (W = D), o(W))
            },
            l = () => {
                const W = Array.isArray(d.value) ? d.value[0] : d.value;
                return W || o(kd())
            };
        let c;
        const u = J(),
            d = J(a()),
            f = J(l()),
            h = J(),
            [p, b] = QR(),
            y = ne(() => t.firstDayOfWeek ? +t.firstDayOfWeek % 7 : 0),
            m = ne(() => {
                const W = [];
                if (!i.value || !s.value) return W;
                const Q = new Date(i.value);
                Q.setDate(1);
                do W.push(new Date(Q)), Q.setMonth(Q.getMonth() + 1); while (xo(Q, s.value) !== 1);
                return W
            }),
            g = ne(() => {
                if (d.value) {
                    if (t.type === "range") return !d.value[0] || !d.value[1];
                    if (t.type === "multiple") return !d.value.length
                }
                return !d.value
            }),
            v = () => d.value,
            _ = () => {
                const W = qu(u.value),
                    Q = W + c,
                    fe = m.value.map((K, ce) => p.value[ce].getHeight()),
                    D = fe.reduce((K, ce) => K + ce, 0);
                if (Q > D && W > 0) return;
                let X = 0,
                    $;
                const Z = [-1, -1];
                for (let K = 0; K < m.value.length; K++) {
                    const ce = p.value[K];
                    X <= Q && X + fe[K] >= W && (Z[1] = K, $ || ($ = ce, Z[0] = K), p.value[K].showed || (p.value[K].showed = !0, e("monthShow", {
                        date: ce.date,
                        title: ce.getTitle()
                    }))), X += fe[K]
                }
                m.value.forEach((K, ce) => {
                    const de = ce >= Z[0] - 1 && ce <= Z[1] + 1;
                    p.value[ce].setVisible(de)
                }), $ && (h.value = $)
            },
            x = W => {
                r.value ? f.value = W : Sn(() => {
                    m.value.some((Q, fe) => xo(Q, W) === 0 ? (u.value && p.value[fe].scrollToDate(u.value, W), !0) : !1), _()
                })
            },
            w = () => {
                if (!(t.poppable && !t.show))
                    if (d.value) {
                        const W = t.type === "single" ? d.value : d.value[0];
                        au(W) && x(W)
                    } else r.value || Sn(_)
            },
            S = () => {
                t.poppable && !t.show || (r.value || Sn(() => {
                    c = Math.floor(Jt(u).height)
                }), w())
            },
            C = (W = a()) => {
                d.value = W, w()
            },
            A = W => {
                const {
                    maxRange: Q,
                    rangePrompt: fe,
                    showRangePrompt: D
                } = t;
                return Q && J7(W) > +Q ? (D && by(fe || Ri("rangePrompt", Q)), e("overRange"), !1) : !0
            },
            T = W => {
                f.value = W, e("panelChange", {
                    date: W
                })
            },
            E = () => {
                var W;
                return e("confirm", (W = d.value) != null ? W : lS(d.value))
            },
            P = (W, Q) => {
                const fe = D => {
                    d.value = D, e("select", lS(D))
                };
                if (Q && t.type === "range" && !A(W)) {
                    fe([W[0], Pb(W[0], +t.maxRange - 1)]);
                    return
                }
                fe(W), Q && !t.showConfirm && E()
            },
            B = (W, Q, fe) => {
                var D;
                return (D = W.find(X => On(Q, X.date) === -1 && On(X.date, fe) === -1)) == null ? void 0 : D.date
            },
            F = ne(() => p.value.reduce((W, Q) => {
                var fe, D;
                return W.push(...(D = (fe = Q.disabledDays) == null ? void 0 : fe.value) != null ? D : []), W
            }, [])),
            H = W => {
                if (t.readonly || !W.date) return;
                const {
                    date: Q
                } = W, {
                    type: fe
                } = t;
                if (fe === "range") {
                    if (!d.value) {
                        P([Q]);
                        return
                    }
                    const [D, X] = d.value;
                    if (D && !X) {
                        const $ = On(Q, D);
                        if ($ === 1) {
                            const Z = B(F.value, D, Q);
                            if (Z) {
                                const K = xy(Z);
                                On(D, K) === -1 ? P([D, K]) : P([Q])
                            } else P([D, Q], !0)
                        } else $ === -1 ? P([Q]) : t.allowSameDay && P([Q, Q], !0)
                    } else P([Q])
                } else if (fe === "multiple") {
                    if (!d.value) {
                        P([Q]);
                        return
                    }
                    const D = d.value,
                        X = D.findIndex($ => On($, Q) === 0);
                    if (X !== -1) {
                        const [$] = D.splice(X, 1);
                        e("unselect", cl($))
                    } else t.maxRange && D.length >= +t.maxRange ? by(t.rangePrompt || Ri("rangePrompt", t.maxRange)) : P([...D, Q])
                } else P(Q, !0)
            },
            k = W => e("clickOverlay", W),
            N = W => e("update:show", W),
            V = (W, Q) => {
                const fe = Q !== 0 || !t.showSubtitle;
                return I(aY, et({
                    ref: r.value ? h : b(Q),
                    date: W,
                    currentDate: d.value,
                    showMonthTitle: fe,
                    firstDayOfWeek: y.value,
                    lazyRender: r.value ? !1 : t.lazyRender,
                    maxDate: s.value,
                    minDate: i.value
                }, wt(t, ["type", "color", "showMark", "formatter", "rowHeight", "showSubtitle", "allowSameDay"]), {
                    onClick: H,
                    onClickDisabledDate: D => e("clickDisabledDate", D)
                }), wt(n, ["top-info", "bottom-info", "month-title", "text"]))
            },
            Y = () => {
                if (n.footer) return n.footer();
                if (t.showConfirm) {
                    const W = n["confirm-text"],
                        Q = g.value,
                        fe = Q ? t.confirmDisabledText : t.confirmText;
                    return I(lh, {
                        round: !0,
                        block: !0,
                        type: "primary",
                        color: t.color,
                        class: At("confirm"),
                        disabled: Q,
                        nativeType: "button",
                        onClick: E
                    }, {
                        default: () => [W ? W({
                            disabled: Q
                        }) : fe || Ri("confirm")]
                    })
                }
            },
            le = () => I("div", {
                class: [At("footer"), {
                    "van-safe-area-bottom": t.safeAreaInsetBottom
                }]
            }, [Y()]),
            ae = () => {
                var W, Q;
                return I("div", {
                    class: At()
                }, [I(cY, {
                    date: (W = h.value) == null ? void 0 : W.date,
                    maxDate: s.value,
                    minDate: i.value,
                    title: t.title,
                    subtitle: (Q = h.value) == null ? void 0 : Q.getTitle(),
                    showTitle: t.showTitle,
                    showSubtitle: t.showSubtitle,
                    switchMode: t.switchMode,
                    firstDayOfWeek: y.value,
                    onClickSubtitle: fe => e("clickSubtitle", fe),
                    onPanelChange: T
                }, wt(n, ["title", "subtitle", "prev-month", "prev-year", "next-month", "next-year"])), I("div", {
                    ref: u,
                    class: At("body"),
                    onScroll: r.value ? void 0 : _
                }, [r.value ? V(f.value, 0) : m.value.map(V)]), le()])
            };
        return pe(() => t.show, S), pe(() => [t.type, t.minDate, t.maxDate, t.switchMode], () => C(a(d.value))), pe(() => t.defaultDate, W => {
            C(W)
        }), Tt({
            reset: C,
            scrollToDate: x,
            getSelectedDate: v
        }), Ml(S), () => t.poppable ? I(ha, {
            show: t.show,
            class: At("popup"),
            round: t.round,
            position: t.position,
            closeable: t.showTitle || t.showSubtitle,
            teleport: t.teleport,
            closeOnPopstate: t.closeOnPopstate,
            safeAreaInsetTop: t.safeAreaInsetTop,
            closeOnClickOverlay: t.closeOnClickOverlay,
            onClickOverlay: k,
            "onUpdate:show": N
        }, {
            default: ae
        }) : ae()
    }
});
const s_e = Ae(dY),
    [fY, Ta] = Ee("image"),
    hY = {
        src: String,
        alt: String,
        fit: String,
        position: String,
        round: Boolean,
        block: Boolean,
        width: be,
        height: be,
        radius: be,
        lazyLoad: Boolean,
        iconSize: be,
        showError: me,
        errorIcon: Pe("photo-fail"),
        iconPrefix: String,
        showLoading: me,
        loadingIcon: Pe("photo"),
        crossorigin: String,
        referrerpolicy: String
    };
var pY = ye({
    name: fY,
    props: hY,
    emits: ["load", "error"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = J(!1),
            i = J(!0),
            s = J(),
            {
                $Lazyload: o
            } = it().proxy,
            a = ne(() => {
                const y = {
                    width: Ze(t.width),
                    height: Ze(t.height)
                };
                return vt(t.radius) && (y.overflow = "hidden", y.borderRadius = Ze(t.radius)), y
            });
        pe(() => t.src, () => {
            r.value = !1, i.value = !0
        });
        const l = y => {
                i.value && (i.value = !1, e("load", y))
            },
            c = () => {
                const y = new Event("load");
                Object.defineProperty(y, "target", {
                    value: s.value,
                    enumerable: !0
                }), l(y)
            },
            u = y => {
                r.value = !0, i.value = !1, e("error", y)
            },
            d = (y, m, g) => g ? g() : I($t, {
                name: y,
                size: t.iconSize,
                class: m,
                classPrefix: t.iconPrefix
            }, null),
            f = () => {
                if (i.value && t.showLoading) return I("div", {
                    class: Ta("loading")
                }, [d(t.loadingIcon, Ta("loading-icon"), n.loading)]);
                if (r.value && t.showError) return I("div", {
                    class: Ta("error")
                }, [d(t.errorIcon, Ta("error-icon"), n.error)])
            },
            h = () => {
                if (r.value || !t.src) return;
                const y = {
                    alt: t.alt,
                    class: Ta("img"),
                    style: {
                        objectFit: t.fit,
                        objectPosition: t.position
                    },
                    crossorigin: t.crossorigin,
                    referrerpolicy: t.referrerpolicy
                };
                return t.lazyLoad ? Cr(I("img", et({
                    ref: s
                }, y), null), [
                    [AA("lazy"), t.src]
                ]) : I("img", et({
                    ref: s,
                    src: t.src,
                    onLoad: l,
                    onError: u
                }, y), null)
            },
            p = ({
                el: y
            }) => {
                const m = () => {
                    y === s.value && i.value && c()
                };
                s.value ? m() : Ue(m)
            },
            b = ({
                el: y
            }) => {
                y === s.value && !r.value && u()
            };
        return o && oi && (o.$on("loaded", p), o.$on("error", b), er(() => {
            o.$off("loaded", p), o.$off("error", b)
        })), St(() => {
            Ue(() => {
                var y;
                (y = s.value) != null && y.complete && !t.lazyLoad && c()
            })
        }), () => {
            var y;
            return I("div", {
                class: Ta({
                    round: t.round,
                    block: t.block
                }),
                style: a.value
            }, [h(), f(), (y = n.default) == null ? void 0 : y.call(n)])
        }
    }
});
const y2 = Ae(pY),
    [mY, Bd] = Ee("circle");
let gY = 0;
const hS = t => Math.min(Math.max(+t, 0), 100);

function vY(t, e) {
    const n = t ? 1 : 0;
    return `M ${e/2} ${e/2} m 0, -500 a 500, 500 0 1, ${n} 0, 1000 a 500, 500 0 1, ${n} 0, -1000`
}
const yY = {
    text: String,
    size: be,
    fill: Pe("none"),
    rate: Fe(100),
    speed: Fe(0),
    color: [String, Object],
    clockwise: me,
    layerColor: String,
    currentRate: gp(0),
    strokeWidth: Fe(40),
    strokeLinecap: String,
    startPosition: Pe("top")
};
var _Y = ye({
    name: mY,
    props: yY,
    emits: ["update:currentRate"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = `van-circle-${gY++}`,
            i = ne(() => +t.strokeWidth + 1e3),
            s = ne(() => vY(t.clockwise, i.value)),
            o = ne(() => {
                const f = {
                    top: 0,
                    right: 90,
                    bottom: 180,
                    left: 270
                }[t.startPosition];
                if (f) return {
                    transform: `rotate(${f}deg)`
                }
            });
        pe(() => t.rate, d => {
            let f;
            const h = Date.now(),
                p = t.currentRate,
                b = hS(d),
                y = Math.abs((p - b) * 1e3 / +t.speed),
                m = () => {
                    const g = Date.now(),
                        _ = Math.min((g - h) / y, 1) * (b - p) + p;
                    e("update:currentRate", hS(parseFloat(_.toFixed(1)))), (b > p ? _ < b : _ > b) && (f = Sn(m))
                };
            t.speed ? (f && Xu(f), f = Sn(m)) : e("update:currentRate", b)
        }, {
            immediate: !0
        });
        const a = () => {
                const {
                    strokeWidth: f,
                    currentRate: h,
                    strokeLinecap: p
                } = t, b = 3140 * h / 100, y = Bs(t.color) ? `url(#${r})` : t.color, m = {
                    stroke: y,
                    strokeWidth: `${+f+1}px`,
                    strokeLinecap: p,
                    strokeDasharray: `${b}px 3140px`
                };
                return I("path", {
                    d: s.value,
                    style: m,
                    class: Bd("hover"),
                    stroke: y
                }, null)
            },
            l = () => {
                const d = {
                    fill: t.fill,
                    stroke: t.layerColor,
                    strokeWidth: `${t.strokeWidth}px`
                };
                return I("path", {
                    class: Bd("layer"),
                    style: d,
                    d: s.value
                }, null)
            },
            c = () => {
                const {
                    color: d
                } = t;
                if (!Bs(d)) return;
                const f = Object.keys(d).sort((h, p) => parseFloat(h) - parseFloat(p)).map((h, p) => I("stop", {
                    key: p,
                    offset: h,
                    "stop-color": d[h]
                }, null));
                return I("defs", null, [I("linearGradient", {
                    id: r,
                    x1: "100%",
                    y1: "0%",
                    x2: "0%",
                    y2: "0%"
                }, [f])])
            },
            u = () => {
                if (n.default) return n.default();
                if (t.text) return I("div", {
                    class: Bd("text")
                }, [t.text])
            };
        return () => I("div", {
            class: Bd(),
            style: fa(t.size)
        }, [I("svg", {
            viewBox: `0 0 ${i.value} ${i.value}`,
            style: o.value
        }, [c(), l(), a()]), u()])
    }
});
const o_e = Ae(_Y),
    [_2, bY] = Ee("row"),
    b2 = Symbol(_2),
    xY = {
        tag: Pe("div"),
        wrap: me,
        align: String,
        gutter: {
            type: [String, Number, Array],
            default: 0
        },
        justify: String
    };
var wY = ye({
    name: _2,
    props: xY,
    setup(t, {
        slots: e
    }) {
        const {
            children: n,
            linkChildren: r
        } = Br(b2), i = ne(() => {
            const a = [
                []
            ];
            let l = 0;
            return n.forEach((c, u) => {
                l += Number(c.span), l > 24 ? (a.push([u]), l -= 24) : a[a.length - 1].push(u)
            }), a
        }), s = ne(() => {
            let a = 0;
            Array.isArray(t.gutter) ? a = Number(t.gutter[0]) || 0 : a = Number(t.gutter);
            const l = [];
            return a && i.value.forEach(c => {
                const u = a * (c.length - 1) / c.length;
                c.forEach((d, f) => {
                    if (f === 0) l.push({
                        right: u
                    });
                    else {
                        const h = a - l[d - 1].right,
                            p = u - h;
                        l.push({
                            left: h,
                            right: p
                        })
                    }
                })
            }), l
        }), o = ne(() => {
            const {
                gutter: a
            } = t, l = [];
            if (Array.isArray(a) && a.length > 1) {
                const c = Number(a[1]) || 0;
                if (c <= 0) return l;
                i.value.forEach((u, d) => {
                    d !== i.value.length - 1 && u.forEach(() => {
                        l.push({
                            bottom: c
                        })
                    })
                })
            }
            return l
        });
        return r({
            spaces: s,
            verticalSpaces: o
        }), () => {
            const {
                tag: a,
                wrap: l,
                align: c,
                justify: u
            } = t;
            return I(a, {
                class: bY({
                    [`align-${c}`]: c,
                    [`justify-${u}`]: u,
                    nowrap: !l
                })
            }, {
                default: () => {
                    var d;
                    return [(d = e.default) == null ? void 0 : d.call(e)]
                }
            })
        }
    }
});
const [EY, SY] = Ee("col"), TY = {
    tag: Pe("div"),
    span: Fe(0),
    offset: be
};
var CY = ye({
    name: EY,
    props: TY,
    setup(t, {
        slots: e
    }) {
        const {
            parent: n,
            index: r
        } = tr(b2), i = ne(() => {
            if (!n) return;
            const {
                spaces: s,
                verticalSpaces: o
            } = n;
            let a = {};
            if (s && s.value && s.value[r.value]) {
                const {
                    left: c,
                    right: u
                } = s.value[r.value];
                a = {
                    paddingLeft: c ? `${c}px` : null,
                    paddingRight: u ? `${u}px` : null
                }
            }
            const {
                bottom: l
            } = o.value[r.value] || {};
            return Ne(a, {
                marginBottom: l ? `${l}px` : null
            })
        });
        return () => {
            const {
                tag: s,
                span: o,
                offset: a
            } = t;
            return I(s, {
                style: i.value,
                class: SY({
                    [o]: o,
                    [`offset-${a}`]: a
                })
            }, {
                default: () => {
                    var l;
                    return [(l = e.default) == null ? void 0 : l.call(e)]
                }
            })
        }
    }
});
const a_e = Ae(CY),
    [x2, PY] = Ee("collapse"),
    w2 = Symbol(x2),
    AY = {
        border: me,
        accordion: Boolean,
        modelValue: {
            type: [String, Number, Array],
            default: ""
        }
    };

function OY(t, e) {
    return e && Array.isArray(t) ? (console.error('[Vant] Collapse: "v-model" should not be Array in accordion mode'), !1) : !e && !Array.isArray(t) ? (console.error('[Vant] Collapse: "v-model" should be Array in non-accordion mode'), !1) : !0
}
var IY = ye({
    name: x2,
    props: AY,
    emits: ["change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            linkChildren: r,
            children: i
        } = Br(w2), s = c => {
            e("change", c), e("update:modelValue", c)
        }, o = (c, u) => {
            const {
                accordion: d,
                modelValue: f
            } = t;
            s(d ? c === f ? "" : c : u ? f.concat(c) : f.filter(h => h !== c))
        }, a = (c = {}) => {
            if (t.accordion) return;
            typeof c == "boolean" && (c = {
                expanded: c
            });
            const {
                expanded: u,
                skipDisabled: d
            } = c, h = i.filter(p => p.disabled && d ? p.expanded.value : u ? ? !p.expanded.value).map(p => p.itemName.value);
            s(h)
        }, l = c => {
            const {
                accordion: u,
                modelValue: d
            } = t;
            return OY(d, u) ? u ? d === c : d.includes(c) : !1
        };
        return Tt({
            toggleAll: a
        }), r({
            toggle: o,
            isExpanded: l
        }), () => {
            var c;
            return I("div", {
                class: [PY(), {
                    [FR]: t.border
                }]
            }, [(c = n.default) == null ? void 0 : c.call(n)])
        }
    }
});
const l_e = Ae(IY),
    [RY, Dd] = Ee("collapse-item"),
    MY = ["icon", "title", "value", "label", "right-icon"],
    kY = Ne({}, _p, {
        name: be,
        isLink: me,
        disabled: Boolean,
        readonly: Boolean,
        lazyRender: me
    });
var BY = ye({
    name: RY,
    props: kY,
    setup(t, {
        slots: e
    }) {
        const n = J(),
            r = J(),
            {
                parent: i,
                index: s
            } = tr(w2);
        if (!i) {
            console.error("[Vant] <CollapseItem> must be a child component of <Collapse>.");
            return
        }
        const o = ne(() => {
                var b;
                return (b = t.name) != null ? b : s.value
            }),
            a = ne(() => i.isExpanded(o.value)),
            l = J(a.value),
            c = wb(() => l.value || !t.lazyRender),
            u = () => {
                a.value ? n.value && (n.value.style.height = "") : l.value = !1
            };
        pe(a, (b, y) => {
            if (y === null) return;
            b && (l.value = !0), (b ? Ue : Sn)(() => {
                if (!r.value || !n.value) return;
                const {
                    offsetHeight: g
                } = r.value;
                if (g) {
                    const v = `${g}px`;
                    n.value.style.height = b ? "0" : v, bo(() => {
                        n.value && (n.value.style.height = b ? v : "0")
                    })
                } else u()
            })
        });
        const d = (b = !a.value) => {
                i.toggle(o.value, b)
            },
            f = () => {
                !t.disabled && !t.readonly && d()
            },
            h = () => {
                const {
                    border: b,
                    disabled: y,
                    readonly: m
                } = t, g = wt(t, Object.keys(_p));
                return m && (g.isLink = !1), (y || m) && (g.clickable = !1), I(l2, et({
                    role: "button",
                    class: Dd("title", {
                        disabled: y,
                        expanded: a.value,
                        borderless: !b
                    }),
                    "aria-expanded": String(a.value),
                    onClick: f
                }, g), wt(e, MY))
            },
            p = c(() => {
                var b;
                return Cr(I("div", {
                    ref: n,
                    class: Dd("wrapper"),
                    onTransitionend: u
                }, [I("div", {
                    ref: r,
                    class: Dd("content")
                }, [(b = e.default) == null ? void 0 : b.call(e)])]), [
                    [Ar, l.value]
                ])
            });
        return Tt({
            toggle: d,
            expanded: a,
            itemName: o
        }), () => I("div", {
            class: [Dd({
                border: s.value && t.border
            })]
        }, [h(), p()])
    }
});
const c_e = Ae(BY);

function DY(t, e) {
    const {
        days: n
    } = e;
    let {
        hours: r,
        minutes: i,
        seconds: s,
        milliseconds: o
    } = e;
    if (t.includes("DD") ? t = t.replace("DD", vo(n)) : r += n * 24, t.includes("HH") ? t = t.replace("HH", vo(r)) : i += r * 60, t.includes("mm") ? t = t.replace("mm", vo(i)) : s += i * 60, t.includes("ss") ? t = t.replace("ss", vo(s)) : o += s * 1e3, t.includes("S")) {
        const a = vo(o, 3);
        t.includes("SSS") ? t = t.replace("SSS", a) : t.includes("SS") ? t = t.replace("SS", a.slice(0, 2)) : t = t.replace("S", a.charAt(0))
    }
    return t
}
const [$Y, FY] = Ee("count-down"), LY = {
    time: Fe(0),
    format: Pe("HH:mm:ss"),
    autoStart: me,
    millisecond: Boolean
};
var NY = ye({
    name: $Y,
    props: LY,
    emits: ["change", "finish"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            start: r,
            pause: i,
            reset: s,
            current: o
        } = XO({
            time: +t.time,
            millisecond: t.millisecond,
            onChange: c => e("change", c),
            onFinish: () => e("finish")
        }), a = ne(() => DY(t.format, o.value)), l = () => {
            s(+t.time), t.autoStart && r()
        };
        return pe(() => t.time, l, {
            immediate: !0
        }), Tt({
            start: r,
            pause: i,
            reset: l
        }), () => I("div", {
            role: "timer",
            class: FY()
        }, [n.default ? n.default(o.value) : a.value])
    }
});
const u_e = Ae(NY),
    pS = new Date().getFullYear(),
    [UY] = Ee("date-picker"),
    GY = Ne({}, Q7, {
        columnsType: {
            type: Array,
            default: () => ["year", "month", "day"]
        },
        minDate: {
            type: Date,
            default: () => new Date(pS - 10, 0, 1),
            validator: au
        },
        maxDate: {
            type: Date,
            default: () => new Date(pS + 10, 11, 31),
            validator: au
        }
    });
var HY = ye({
    name: UY,
    props: GY,
    emits: ["confirm", "cancel", "change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = J(t.modelValue),
            i = J(!1),
            s = J(),
            o = ne(() => i.value ? t.modelValue : r.value),
            a = x => x === t.minDate.getFullYear(),
            l = x => x === t.maxDate.getFullYear(),
            c = x => x === t.minDate.getMonth() + 1,
            u = x => x === t.maxDate.getMonth() + 1,
            d = x => {
                const {
                    minDate: w,
                    columnsType: S
                } = t, C = S.indexOf(x), A = o.value[C];
                if (A) return +A;
                switch (x) {
                    case "year":
                        return w.getFullYear();
                    case "month":
                        return w.getMonth() + 1;
                    case "day":
                        return w.getDate()
                }
            },
            f = () => {
                const x = t.minDate.getFullYear(),
                    w = t.maxDate.getFullYear();
                return Rm(x, w, "year", t.formatter, t.filter, o.value)
            },
            h = () => {
                const x = d("year"),
                    w = a(x) ? t.minDate.getMonth() + 1 : 1,
                    S = l(x) ? t.maxDate.getMonth() + 1 : 12;
                return Rm(w, S, "month", t.formatter, t.filter, o.value)
            },
            p = () => {
                const x = d("year"),
                    w = d("month"),
                    S = a(x) && c(w) ? t.minDate.getDate() : 1,
                    C = l(x) && u(w) ? t.maxDate.getDate() : v2(x, w);
                return Rm(S, C, "day", t.formatter, t.filter, o.value)
            },
            b = () => {
                var x;
                return (x = s.value) == null ? void 0 : x.confirm()
            },
            y = () => r.value,
            m = ne(() => t.columnsType.map(x => {
                switch (x) {
                    case "year":
                        return f();
                    case "month":
                        return h();
                    case "day":
                        return p();
                    default:
                        throw new Error(`[Vant] DatePicker: unsupported columns type: ${x}`)
                }
            }));
        pe(r, x => {
            Ps(x, t.modelValue) || e("update:modelValue", x)
        }), pe(() => t.modelValue, (x, w) => {
            i.value = Ps(w, r.value), x = nY(x, m.value), Ps(x, r.value) || (r.value = x), i.value = !1
        }, {
            immediate: !0
        });
        const g = (...x) => e("change", ...x),
            v = (...x) => e("cancel", ...x),
            _ = (...x) => e("confirm", ...x);
        return Tt({
            confirm: b,
            getSelectedDate: y
        }), () => I(l7, et({
            ref: s,
            modelValue: r.value,
            "onUpdate:modelValue": x => r.value = x,
            columns: m.value,
            onChange: g,
            onCancel: v,
            onConfirm: _
        }, wt(t, eY)), n)
    }
});
const d_e = Ae(HY),
    [zY, gr, $d] = Ee("dialog"),
    jY = Ne({}, Qu, {
        title: String,
        theme: String,
        width: be,
        message: [String, Function],
        callback: Function,
        allowHtml: Boolean,
        className: Ut,
        transition: Pe("van-dialog-bounce"),
        messageAlign: String,
        closeOnPopstate: me,
        showCancelButton: Boolean,
        cancelButtonText: String,
        cancelButtonColor: String,
        cancelButtonDisabled: Boolean,
        confirmButtonText: String,
        confirmButtonColor: String,
        confirmButtonDisabled: Boolean,
        showConfirmButton: me,
        closeOnClickOverlay: Boolean,
        keyboardEnabled: me,
        destroyOnClose: Boolean
    }),
    VY = [...VR, "transition", "closeOnPopstate", "destroyOnClose"];
var E2 = ye({
    name: zY,
    props: jY,
    emits: ["confirm", "cancel", "keydown", "update:show"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = J(),
            i = ht({
                confirm: !1,
                cancel: !1
            }),
            s = m => e("update:show", m),
            o = m => {
                var g;
                s(!1), (g = t.callback) == null || g.call(t, m)
            },
            a = m => () => {
                t.show && (e(m), t.beforeClose ? (i[m] = !0, Bl(t.beforeClose, {
                    args: [m],
                    done() {
                        o(m), i[m] = !1
                    },
                    canceled() {
                        i[m] = !1
                    }
                })) : o(m))
            },
            l = a("cancel"),
            c = a("confirm"),
            u = bO(m => {
                var g, v;
                if (!t.keyboardEnabled || m.target !== ((v = (g = r.value) == null ? void 0 : g.popupRef) == null ? void 0 : v.value)) return;
                ({
                    Enter: t.showConfirmButton ? c : py,
                    Escape: t.showCancelButton ? l : py
                })[m.key](), e("keydown", m)
            }, ["enter", "esc"]),
            d = () => {
                const m = n.title ? n.title() : t.title;
                if (m) return I("div", {
                    class: gr("header", {
                        isolated: !t.message && !n.default
                    })
                }, [m])
            },
            f = m => {
                const {
                    message: g,
                    allowHtml: v,
                    messageAlign: _
                } = t, x = gr("message", {
                    "has-title": m,
                    [_]: _
                }), w = al(g) ? g() : g;
                return v && typeof w == "string" ? I("div", {
                    class: x,
                    innerHTML: w
                }, null) : I("div", {
                    class: x
                }, [w])
            },
            h = () => {
                if (n.default) return I("div", {
                    class: gr("content")
                }, [n.default()]);
                const {
                    title: m,
                    message: g,
                    allowHtml: v
                } = t;
                if (g) {
                    const _ = !!(m || n.title);
                    return I("div", {
                        key: v ? 1 : 0,
                        class: gr("content", {
                            isolated: !_
                        })
                    }, [f(_)])
                }
            },
            p = () => I("div", {
                class: [$R, gr("footer")]
            }, [t.showCancelButton && I(lh, {
                size: "large",
                text: t.cancelButtonText || $d("cancel"),
                class: gr("cancel"),
                style: {
                    color: t.cancelButtonColor
                },
                loading: i.cancel,
                disabled: t.cancelButtonDisabled,
                onClick: l
            }, null), t.showConfirmButton && I(lh, {
                size: "large",
                text: t.confirmButtonText || $d("confirm"),
                class: [gr("confirm"), {
                    [SV]: t.showCancelButton
                }],
                style: {
                    color: t.confirmButtonColor
                },
                loading: i.confirm,
                disabled: t.confirmButtonDisabled,
                onClick: c
            }, null)]),
            b = () => I(RV, {
                class: gr("footer")
            }, {
                default: () => [t.showCancelButton && I(JE, {
                    type: "warning",
                    text: t.cancelButtonText || $d("cancel"),
                    class: gr("cancel"),
                    color: t.cancelButtonColor,
                    loading: i.cancel,
                    disabled: t.cancelButtonDisabled,
                    onClick: l
                }, null), t.showConfirmButton && I(JE, {
                    type: "danger",
                    text: t.confirmButtonText || $d("confirm"),
                    class: gr("confirm"),
                    color: t.confirmButtonColor,
                    loading: i.confirm,
                    disabled: t.confirmButtonDisabled,
                    onClick: c
                }, null)]
            }),
            y = () => n.footer ? n.footer() : t.theme === "round-button" ? b() : p();
        return () => {
            const {
                width: m,
                title: g,
                theme: v,
                message: _,
                className: x
            } = t;
            return I(ha, et({
                ref: r,
                role: "dialog",
                class: [gr([v]), x],
                style: {
                    width: Ze(m)
                },
                tabindex: 0,
                "aria-labelledby": g || _,
                onKeydown: u,
                "onUpdate:show": s
            }, wt(t, VY)), {
                default: () => [d(), h(), y()]
            })
        }
    }
});
let Ey;
const WY = {
    title: "",
    width: "",
    theme: null,
    message: "",
    overlay: !0,
    callback: null,
    teleport: "body",
    className: "",
    allowHtml: !1,
    lockScroll: !0,
    transition: void 0,
    beforeClose: null,
    overlayClass: "",
    overlayStyle: void 0,
    messageAlign: "",
    cancelButtonText: "",
    cancelButtonColor: null,
    cancelButtonDisabled: !1,
    confirmButtonText: "",
    confirmButtonColor: null,
    confirmButtonDisabled: !1,
    showConfirmButton: !0,
    showCancelButton: !1,
    closeOnPopstate: !0,
    closeOnClickOverlay: !1,
    destroyOnClose: !1
};
let YY = Ne({}, WY);

function XY() {
    ({
        instance: Ey
    } = xp({
        setup() {
            const {
                state: e,
                toggle: n
            } = bp();
            return () => I(E2, et(e, {
                "onUpdate:show": n
            }), null)
        }
    }))
}

function KY(t) {
    return oi ? new Promise((e, n) => {
        Ey || XY(), Ey.open(Ne({}, YY, t, {
            callback: r => {
                (r === "confirm" ? e : n)(r)
            }
        }))
    }) : Promise.resolve(void 0)
}
const f_e = t => KY(Ne({
        showCancelButton: !0
    }, t)),
    h_e = Ae(E2),
    [qY, JY] = Ee("divider"),
    ZY = {
        dashed: Boolean,
        hairline: me,
        vertical: Boolean,
        contentPosition: Pe("center")
    };
var QY = ye({
    name: qY,
    props: ZY,
    setup(t, {
        slots: e
    }) {
        return () => {
            var n;
            return I("div", {
                role: "separator",
                class: JY({
                    dashed: t.dashed,
                    hairline: t.hairline,
                    vertical: t.vertical,
                    [`content-${t.contentPosition}`]: !!e.default && !t.vertical
                })
            }, [!t.vertical && ((n = e.default) == null ? void 0 : n.call(e))])
        }
    }
});
const p_e = Ae(QY),
    [S2, eX] = Ee("grid"),
    tX = {
        square: Boolean,
        center: me,
        border: me,
        gutter: be,
        reverse: Boolean,
        iconSize: be,
        direction: String,
        clickable: Boolean,
        columnNum: Fe(4)
    },
    T2 = Symbol(S2);
var nX = ye({
    name: S2,
    props: tX,
    setup(t, {
        slots: e
    }) {
        const {
            linkChildren: n
        } = Br(T2);
        return n({
            props: t
        }), () => {
            var r;
            return I("div", {
                style: {
                    paddingLeft: Ze(t.gutter)
                },
                class: [eX(), {
                    [$R]: t.border && !t.gutter
                }]
            }, [(r = e.default) == null ? void 0 : r.call(e)])
        }
    }
});
const m_e = Ae(nX),
    [rX, Fd] = Ee("grid-item"),
    iX = Ne({}, Dl, {
        dot: Boolean,
        text: String,
        icon: String,
        badge: be,
        iconColor: String,
        iconPrefix: String,
        badgeProps: Object
    });
var sX = ye({
    name: rX,
    props: iX,
    setup(t, {
        slots: e
    }) {
        const {
            parent: n,
            index: r
        } = tr(T2), i = Zu();
        if (!n) {
            console.error("[Vant] <GridItem> must be a child component of <Grid>.");
            return
        }
        const s = ne(() => {
                const {
                    square: u,
                    gutter: d,
                    columnNum: f
                } = n.props, h = `${100/+f}%`, p = {
                    flexBasis: h
                };
                if (u) p.paddingTop = h;
                else if (d) {
                    const b = Ze(d);
                    p.paddingRight = b, r.value >= +f && (p.marginTop = b)
                }
                return p
            }),
            o = ne(() => {
                const {
                    square: u,
                    gutter: d
                } = n.props;
                if (u && d) {
                    const f = Ze(d);
                    return {
                        right: f,
                        bottom: f,
                        height: "auto"
                    }
                }
            }),
            a = () => {
                if (e.icon) return I(vp, et({
                    dot: t.dot,
                    content: t.badge
                }, t.badgeProps), {
                    default: e.icon
                });
                if (t.icon) return I($t, {
                    dot: t.dot,
                    name: t.icon,
                    size: n.props.iconSize,
                    badge: t.badge,
                    class: Fd("icon"),
                    color: t.iconColor,
                    badgeProps: t.badgeProps,
                    classPrefix: t.iconPrefix
                }, null)
            },
            l = () => {
                if (e.text) return e.text();
                if (t.text) return I("span", {
                    class: Fd("text")
                }, [t.text])
            },
            c = () => e.default ? e.default() : [a(), l()];
        return () => {
            const {
                center: u,
                border: d,
                square: f,
                gutter: h,
                reverse: p,
                direction: b,
                clickable: y
            } = n.props, m = [Fd("content", [b, {
                center: u,
                square: f,
                reverse: p,
                clickable: y,
                surround: d && h
            }]), {
                [Ws]: d
            }];
            return I("div", {
                class: [Fd({
                    square: f
                })],
                style: s.value
            }, [I("div", {
                role: y ? "button" : void 0,
                class: m,
                style: o.value,
                tabindex: y ? 0 : void 0,
                onClick: i
            }, [c()])])
        }
    }
});
const g_e = Ae(sX),
    mS = t => Math.sqrt((t[0].clientX - t[1].clientX) ** 2 + (t[0].clientY - t[1].clientY) ** 2),
    oX = t => ({
        x: (t[0].clientX + t[1].clientX) / 2,
        y: (t[0].clientY + t[1].clientY) / 2
    }),
    Mm = Ee("image-preview")[1],
    gS = 2.6,
    aX = {
        src: String,
        show: Boolean,
        active: Number,
        minZoom: xn(be),
        maxZoom: xn(be),
        rootWidth: xn(Number),
        rootHeight: xn(Number),
        disableZoom: Boolean,
        doubleScale: Boolean,
        closeOnClickImage: Boolean,
        closeOnClickOverlay: Boolean,
        vertical: Boolean
    };
var lX = ye({
    props: aX,
    emits: ["scale", "close", "longPress"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = ht({
                scale: 1,
                moveX: 0,
                moveY: 0,
                moving: !1,
                zooming: !1,
                initializing: !1,
                imageRatio: 0
            }),
            i = $l(),
            s = J(),
            o = J(),
            a = J(!1),
            l = J(!1);
        let c = 0;
        const u = ne(() => {
                const {
                    scale: k,
                    moveX: N,
                    moveY: V,
                    moving: Y,
                    zooming: le,
                    initializing: ae
                } = r, W = {
                    transitionDuration: le || Y || ae ? "0s" : ".3s"
                };
                return (k !== 1 || l.value) && (W.transform = `matrix(${k}, 0, 0, ${k}, ${N}, ${V})`), W
            }),
            d = ne(() => {
                if (r.imageRatio) {
                    const {
                        rootWidth: k,
                        rootHeight: N
                    } = t, V = a.value ? N / r.imageRatio : k;
                    return Math.max(0, (r.scale * V - k) / 2)
                }
                return 0
            }),
            f = ne(() => {
                if (r.imageRatio) {
                    const {
                        rootWidth: k,
                        rootHeight: N
                    } = t, V = a.value ? N : k * r.imageRatio;
                    return Math.max(0, (r.scale * V - N) / 2)
                }
                return 0
            }),
            h = (k, N) => {
                var V;
                if (k = nn(k, +t.minZoom, +t.maxZoom + 1), k !== r.scale) {
                    const Y = k / r.scale;
                    if (r.scale = k, N) {
                        const le = Jt((V = s.value) == null ? void 0 : V.$el),
                            ae = {
                                x: le.width * .5,
                                y: le.height * .5
                            },
                            W = r.moveX - (N.x - le.left - ae.x) * (Y - 1),
                            Q = r.moveY - (N.y - le.top - ae.y) * (Y - 1);
                        r.moveX = nn(W, -d.value, d.value), r.moveY = nn(Q, -f.value, f.value)
                    } else r.moveX = 0, r.moveY = l.value ? c : 0;
                    e("scale", {
                        scale: k,
                        index: t.active
                    })
                }
            },
            p = () => {
                h(1)
            },
            b = () => {
                const k = r.scale > 1 ? 1 : 2;
                h(k, k === 2 || l.value ? {
                    x: i.startX.value,
                    y: i.startY.value
                } : void 0)
            };
        let y, m, g, v, _, x, w, S, C = !1;
        const A = k => {
                const {
                    touches: N
                } = k;
                if (y = N.length, y === 2 && t.disableZoom) return;
                const {
                    offsetX: V
                } = i;
                i.start(k), m = r.moveX, g = r.moveY, S = Date.now(), C = !1, r.moving = y === 1 && (r.scale !== 1 || l.value), r.zooming = y === 2 && !V.value, r.zooming && (v = r.scale, _ = mS(N))
            },
            T = k => {
                const {
                    touches: N
                } = k;
                if (i.move(k), r.moving) {
                    const {
                        deltaX: V,
                        deltaY: Y
                    } = i, le = V.value + m, ae = Y.value + g;
                    if ((t.vertical ? i.isVertical() && Math.abs(ae) > f.value : i.isHorizontal() && Math.abs(le) > d.value) && !C) {
                        r.moving = !1;
                        return
                    }
                    C = !0, Zt(k, !0), r.moveX = nn(le, -d.value, d.value), r.moveY = nn(ae, -f.value, f.value)
                }
                if (r.zooming && (Zt(k, !0), N.length === 2)) {
                    const V = mS(N),
                        Y = v * V / _;
                    x = oX(N), h(Y, x)
                }
            },
            E = k => {
                var N;
                const V = (N = o.value) == null ? void 0 : N.$el;
                if (!V) return;
                const Y = V.firstElementChild,
                    le = k.target === V,
                    ae = Y == null ? void 0 : Y.contains(k.target);
                !t.closeOnClickImage && ae || !t.closeOnClickOverlay && le || e("close")
            },
            P = k => {
                if (y > 1) return;
                const N = Date.now() - S,
                    V = 250;
                i.isTap.value && (N < V ? t.doubleScale ? w ? (clearTimeout(w), w = null, b()) : w = setTimeout(() => {
                    E(k), w = null
                }, V) : E(k) : N > NR && e("longPress"))
            },
            B = k => {
                let N = !1;
                if ((r.moving || r.zooming) && (N = !0, r.moving && m === r.moveX && g === r.moveY && (N = !1), !k.touches.length)) {
                    r.zooming && (r.moveX = nn(r.moveX, -d.value, d.value), r.moveY = nn(r.moveY, -f.value, f.value), r.zooming = !1), r.moving = !1, m = 0, g = 0, v = 1, r.scale < 1 && p();
                    const V = +t.maxZoom;
                    r.scale > V && h(V, x)
                }
                Zt(k, N), P(k), i.reset()
            },
            F = () => {
                const {
                    rootWidth: k,
                    rootHeight: N
                } = t, V = N / k, {
                    imageRatio: Y
                } = r;
                a.value = r.imageRatio > V && Y < gS, l.value = r.imageRatio > V && Y >= gS, l.value && (c = (Y * k - N) / 2, r.moveY = c, r.initializing = !0, Sn(() => {
                    r.initializing = !1
                })), p()
            },
            H = k => {
                const {
                    naturalWidth: N,
                    naturalHeight: V
                } = k.target;
                r.imageRatio = V / N, F()
            };
        return pe(() => t.active, p), pe(() => t.show, k => {
            k || p()
        }), pe(() => [t.rootWidth, t.rootHeight], F), Nn("touchmove", T, {
            target: ne(() => {
                var k;
                return (k = o.value) == null ? void 0 : k.$el
            })
        }), Tt({
            resetScale: p
        }), () => {
            const k = {
                loading: () => I(qi, {
                    type: "spinner"
                }, null)
            };
            return I(a2, {
                ref: o,
                class: Mm("swipe-item"),
                onTouchstartPassive: A,
                onTouchend: B,
                onTouchcancel: B
            }, {
                default: () => [n.image ? I("div", {
                    class: Mm("image-wrap")
                }, [n.image({
                    src: t.src,
                    onLoad: H,
                    style: u.value
                })]) : I(y2, {
                    ref: s,
                    src: t.src,
                    fit: "contain",
                    class: Mm("image", {
                        vertical: a.value
                    }),
                    style: u.value,
                    onLoad: H
                }, k)]
            })
        }
    }
});
const [cX, Ca] = Ee("image-preview"), uX = ["show", "teleport", "transition", "overlayStyle", "closeOnPopstate"], dX = {
    show: Boolean,
    loop: me,
    images: Gi(),
    minZoom: Fe(1 / 3),
    maxZoom: Fe(3),
    overlay: me,
    vertical: Boolean,
    closeable: Boolean,
    showIndex: me,
    className: Ut,
    closeIcon: Pe("clear"),
    transition: String,
    beforeClose: Function,
    doubleScale: me,
    overlayClass: Ut,
    overlayStyle: Object,
    swipeDuration: Fe(300),
    startPosition: Fe(0),
    showIndicators: Boolean,
    closeOnPopstate: me,
    closeOnClickImage: me,
    closeOnClickOverlay: me,
    closeIconPosition: Pe("top-right"),
    teleport: [String, Object]
};
var C2 = ye({
    name: cX,
    props: dX,
    emits: ["scale", "close", "closed", "change", "longPress", "update:show"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = J(),
            i = J(),
            s = ht({
                active: 0,
                rootWidth: 0,
                rootHeight: 0,
                disableZoom: !1
            }),
            o = () => {
                if (r.value) {
                    const v = Jt(r.value.$el);
                    s.rootWidth = v.width, s.rootHeight = v.height, r.value.resize()
                }
            },
            a = v => e("scale", v),
            l = v => e("update:show", v),
            c = () => {
                Bl(t.beforeClose, {
                    args: [s.active],
                    done: () => l(!1)
                })
            },
            u = v => {
                v !== s.active && (s.active = v, e("change", v))
            },
            d = () => {
                if (t.showIndex) return I("div", {
                    class: Ca("index")
                }, [n.index ? n.index({
                    index: s.active
                }) : `${s.active+1} / ${t.images.length}`])
            },
            f = () => {
                if (n.cover) return I("div", {
                    class: Ca("cover")
                }, [n.cover()])
            },
            h = () => {
                s.disableZoom = !0
            },
            p = () => {
                s.disableZoom = !1
            },
            b = () => I(r2, {
                ref: r,
                lazyRender: !0,
                loop: t.loop,
                class: Ca("swipe"),
                vertical: t.vertical,
                duration: t.swipeDuration,
                initialSwipe: t.startPosition,
                showIndicators: t.showIndicators,
                indicatorColor: "white",
                onChange: u,
                onDragEnd: p,
                onDragStart: h
            }, {
                default: () => [t.images.map((v, _) => I(lX, {
                    ref: x => {
                        _ === s.active && (i.value = x)
                    },
                    src: v,
                    show: t.show,
                    active: s.active,
                    maxZoom: t.maxZoom,
                    minZoom: t.minZoom,
                    rootWidth: s.rootWidth,
                    rootHeight: s.rootHeight,
                    disableZoom: s.disableZoom,
                    doubleScale: t.doubleScale,
                    closeOnClickImage: t.closeOnClickImage,
                    closeOnClickOverlay: t.closeOnClickOverlay,
                    vertical: t.vertical,
                    onScale: a,
                    onClose: c,
                    onLongPress: () => e("longPress", {
                        index: _
                    })
                }, {
                    image: n.image
                }))]
            }),
            y = () => {
                if (t.closeable) return I($t, {
                    role: "button",
                    name: t.closeIcon,
                    class: [Ca("close-icon", t.closeIconPosition), Hi],
                    onClick: c
                }, null)
            },
            m = () => e("closed"),
            g = (v, _) => {
                var x;
                return (x = r.value) == null ? void 0 : x.swipeTo(v, _)
            };
        return Tt({
            resetScale: () => {
                var v;
                (v = i.value) == null || v.resetScale()
            },
            swipeTo: g
        }), St(o), pe([kl, Ju], o), pe(() => t.startPosition, v => u(+v)), pe(() => t.show, v => {
            const {
                images: _,
                startPosition: x
            } = t;
            v ? (u(+x), Ue(() => {
                o(), g(+x, {
                    immediate: !0
                })
            })) : e("close", {
                index: s.active,
                url: _[s.active]
            })
        }), () => I(ha, et({
            class: [Ca(), t.className],
            overlayClass: [Ca("overlay"), t.overlayClass],
            onClosed: m,
            "onUpdate:show": l
        }, wt(t, uX)), {
            default: () => [y(), b(), d(), f()]
        })
    }
});
let Of;
const fX = {
    loop: !0,
    images: [],
    maxZoom: 3,
    minZoom: 1 / 3,
    onScale: void 0,
    onClose: void 0,
    onChange: void 0,
    vertical: !1,
    teleport: "body",
    className: "",
    showIndex: !0,
    closeable: !1,
    closeIcon: "clear",
    transition: void 0,
    beforeClose: void 0,
    doubleScale: !0,
    overlayStyle: void 0,
    overlayClass: void 0,
    startPosition: 0,
    swipeDuration: 300,
    showIndicators: !1,
    closeOnPopstate: !0,
    closeOnClickOverlay: !0,
    closeIconPosition: "top-right"
};

function hX() {
    ({
        instance: Of
    } = xp({
        setup() {
            const {
                state: t,
                toggle: e
            } = bp(), n = () => {
                t.images = []
            };
            return () => I(C2, et(t, {
                onClosed: n,
                "onUpdate:show": e
            }), null)
        }
    }))
}
const pX = (t, e = 0) => {
    if (oi) return Of || hX(), t = Array.isArray(t) ? {
        images: t,
        startPosition: e
    } : t, Of.open(Ne({}, fX, t)), Of
};
Ae(C2);
const [mX, Pa, gX] = Ee("list"), vX = {
    error: Boolean,
    offset: Fe(300),
    loading: Boolean,
    disabled: Boolean,
    finished: Boolean,
    scroller: Object,
    errorText: String,
    direction: Pe("down"),
    loadingText: String,
    finishedText: String,
    immediateCheck: me
};
var yX = ye({
    name: mX,
    props: vX,
    emits: ["load", "update:error", "update:loading"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = J(t.loading),
            i = J(),
            s = J(),
            o = KW(),
            a = Ku(i),
            l = ne(() => t.scroller || a.value),
            c = () => {
                Ue(() => {
                    if (r.value || t.finished || t.disabled || t.error || (o == null ? void 0 : o.value) === !1) return;
                    const {
                        direction: p
                    } = t, b = +t.offset, y = Jt(l);
                    if (!y.height || ll(i)) return;
                    let m = !1;
                    const g = Jt(s);
                    p === "up" ? m = y.top - g.top <= b : m = g.bottom - y.bottom <= b, m && (r.value = !0, e("update:loading", !0), e("load"))
                })
            },
            u = () => {
                if (t.finished) {
                    const p = n.finished ? n.finished() : t.finishedText;
                    if (p) return I("div", {
                        class: Pa("finished-text")
                    }, [p])
                }
            },
            d = () => {
                e("update:error", !1), c()
            },
            f = () => {
                if (t.error) {
                    const p = n.error ? n.error() : t.errorText;
                    if (p) return I("div", {
                        role: "button",
                        class: Pa("error-text"),
                        tabindex: 0,
                        onClick: d
                    }, [p])
                }
            },
            h = () => {
                if (r.value && !t.finished && !t.disabled) return I("div", {
                    class: Pa("loading")
                }, [n.loading ? n.loading() : I(qi, {
                    class: Pa("loading-icon")
                }, {
                    default: () => [t.loadingText || gX("loading")]
                })])
            };
        return pe(() => [t.loading, t.finished, t.error], c), o && pe(o, p => {
            p && c()
        }), la(() => {
            r.value = t.loading
        }), St(() => {
            t.immediateCheck && c()
        }), Tt({
            check: c
        }), Nn("scroll", c, {
            target: l,
            passive: !0
        }), () => {
            var p;
            const b = (p = n.default) == null ? void 0 : p.call(n),
                y = I("div", {
                    ref: s,
                    class: Pa("placeholder")
                }, null);
            return I("div", {
                ref: i,
                role: "feed",
                class: Pa(),
                "aria-busy": r.value
            }, [t.direction === "down" ? b : y, h(), u(), f(), t.direction === "up" ? b : y])
        }
    }
});
const v_e = Ae(yX),
    [_X, bX] = Ee("notify"),
    xX = ["lockScroll", "position", "show", "teleport", "zIndex"],
    wX = Ne({}, Qu, {
        type: Pe("danger"),
        color: String,
        message: be,
        position: Pe("top"),
        className: Ut,
        background: String,
        lockScroll: Boolean
    });
var P2 = ye({
    name: _X,
    props: wX,
    emits: ["update:show"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = i => e("update:show", i);
        return () => I(ha, et({
            class: [bX([t.type]), t.className],
            style: {
                color: t.color,
                background: t.background
            },
            overlay: !1,
            duration: .2,
            "onUpdate:show": r
        }, wt(t, xX)), {
            default: () => [n.default ? n.default() : t.message]
        })
    }
});
let vS, qa;
const EX = t => Bs(t) ? t : {
    message: t
};

function SX() {
    ({
        instance: qa
    } = xp({
        setup() {
            const {
                state: t,
                toggle: e
            } = bp();
            return () => I(P2, et(t, {
                "onUpdate:show": e
            }), null)
        }
    }))
}
const TX = () => ({
    type: "danger",
    color: void 0,
    message: "",
    onClose: void 0,
    onClick: void 0,
    onOpened: void 0,
    duration: 3e3,
    position: void 0,
    className: "",
    lockScroll: !1,
    background: void 0
});
let CX = TX();
const PX = () => {
    qa && qa.toggle(!1)
};

function y_e(t) {
    if (oi) return qa || SX(), t = Ne({}, CX, EX(t)), qa.open(t), clearTimeout(vS), t.duration > 0 && (vS = setTimeout(PX, t.duration)), qa
}
Ae(P2);
const [AX, Aa, yS] = Ee("pagination"), km = (t, e, n) => ({
    number: t,
    text: e,
    active: n
}), OX = {
    mode: Pe("multi"),
    prevText: String,
    nextText: String,
    pageCount: Fe(0),
    modelValue: gp(0),
    totalItems: Fe(0),
    showPageSize: Fe(5),
    itemsPerPage: Fe(10),
    forceEllipses: Boolean,
    showPrevButton: me,
    showNextButton: me
};
var IX = ye({
    name: AX,
    props: OX,
    emits: ["change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = ne(() => {
                const {
                    pageCount: u,
                    totalItems: d,
                    itemsPerPage: f
                } = t, h = +u || Math.ceil(+d / +f);
                return Math.max(1, h)
            }),
            i = ne(() => {
                const u = [],
                    d = r.value,
                    f = +t.showPageSize,
                    {
                        modelValue: h,
                        forceEllipses: p
                    } = t;
                let b = 1,
                    y = d;
                const m = f < d;
                m && (b = Math.max(h - Math.floor(f / 2), 1), y = b + f - 1, y > d && (y = d, b = y - f + 1));
                for (let g = b; g <= y; g++) {
                    const v = km(g, g, g === h);
                    u.push(v)
                }
                if (m && f > 0 && p) {
                    if (b > 1) {
                        const g = km(b - 1, "...");
                        u.unshift(g)
                    }
                    if (y < d) {
                        const g = km(y + 1, "...");
                        u.push(g)
                    }
                }
                return u
            }),
            s = (u, d) => {
                u = nn(u, 1, r.value), t.modelValue !== u && (e("update:modelValue", u), d && e("change", u))
            };
        Il(() => s(t.modelValue));
        const o = () => I("li", {
                class: Aa("page-desc")
            }, [n.pageDesc ? n.pageDesc() : `${t.modelValue}/${r.value}`]),
            a = () => {
                const {
                    mode: u,
                    modelValue: d,
                    showPrevButton: f
                } = t;
                if (!f) return;
                const h = n["prev-text"],
                    p = d === 1;
                return I("li", {
                    class: [Aa("item", {
                        disabled: p,
                        border: u === "simple",
                        prev: !0
                    }), Pf]
                }, [I("button", {
                    type: "button",
                    disabled: p,
                    onClick: () => s(d - 1, !0)
                }, [h ? h() : t.prevText || yS("prev")])])
            },
            l = () => {
                const {
                    mode: u,
                    modelValue: d,
                    showNextButton: f
                } = t;
                if (!f) return;
                const h = n["next-text"],
                    p = d === r.value;
                return I("li", {
                    class: [Aa("item", {
                        disabled: p,
                        border: u === "simple",
                        next: !0
                    }), Pf]
                }, [I("button", {
                    type: "button",
                    disabled: p,
                    onClick: () => s(d + 1, !0)
                }, [h ? h() : t.nextText || yS("next")])])
            },
            c = () => i.value.map(u => I("li", {
                class: [Aa("item", {
                    active: u.active,
                    page: !0
                }), Pf]
            }, [I("button", {
                type: "button",
                "aria-current": u.active || void 0,
                onClick: () => s(u.number, !0)
            }, [n.page ? n.page(u) : u.text])]));
        return () => I("nav", {
            role: "navigation",
            class: Aa()
        }, [I("ul", {
            class: Aa("items")
        }, [a(), t.mode === "simple" ? o() : c(), l()])])
    }
});
const __e = Ae(IX);

function Dr(t) {
    if (t == null) return window;
    if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument;
        return e && e.defaultView || window
    }
    return t
}

function Ob(t) {
    var e = Dr(t).Element;
    return t instanceof e || t instanceof Element
}

function Or(t) {
    var e = Dr(t).HTMLElement;
    return t instanceof e || t instanceof HTMLElement
}

function A2(t) {
    if (typeof ShadowRoot > "u") return !1;
    var e = Dr(t).ShadowRoot;
    return t instanceof e || t instanceof ShadowRoot
}
var ul = Math.round;

function Sy() {
    var t = navigator.userAgentData;
    return t != null && t.brands ? t.brands.map(function(e) {
        return e.brand + "/" + e.version
    }).join(" ") : navigator.userAgent
}

function RX() {
    return !/^((?!chrome|android).)*safari/i.test(Sy())
}

function ch(t, e, n) {
    e === void 0 && (e = !1), n === void 0 && (n = !1);
    var r = t.getBoundingClientRect(),
        i = 1,
        s = 1;
    e && Or(t) && (i = t.offsetWidth > 0 && ul(r.width) / t.offsetWidth || 1, s = t.offsetHeight > 0 && ul(r.height) / t.offsetHeight || 1);
    var o = Ob(t) ? Dr(t) : window,
        a = o.visualViewport,
        l = !RX() && n,
        c = (r.left + (l && a ? a.offsetLeft : 0)) / i,
        u = (r.top + (l && a ? a.offsetTop : 0)) / s,
        d = r.width / i,
        f = r.height / s;
    return {
        width: d,
        height: f,
        top: u,
        right: c + d,
        bottom: u + f,
        left: c,
        x: c,
        y: u
    }
}

function O2(t) {
    var e = Dr(t),
        n = e.pageXOffset,
        r = e.pageYOffset;
    return {
        scrollLeft: n,
        scrollTop: r
    }
}

function MX(t) {
    return {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    }
}

function kX(t) {
    return t === Dr(t) || !Or(t) ? O2(t) : MX(t)
}

function zi(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
}

function wp(t) {
    return ((Ob(t) ? t.ownerDocument : t.document) || window.document).documentElement
}

function BX(t) {
    return ch(wp(t)).left + O2(t).scrollLeft
}

function ji(t) {
    return Dr(t).getComputedStyle(t)
}

function Ib(t) {
    var e = ji(t),
        n = e.overflow,
        r = e.overflowX,
        i = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + i + r)
}

function DX(t) {
    var e = t.getBoundingClientRect(),
        n = ul(e.width) / t.offsetWidth || 1,
        r = ul(e.height) / t.offsetHeight || 1;
    return n !== 1 || r !== 1
}

function $X(t, e, n) {
    n === void 0 && (n = !1);
    var r = Or(e),
        i = Or(e) && DX(e),
        s = wp(e),
        o = ch(t, i, n),
        a = {
            scrollLeft: 0,
            scrollTop: 0
        },
        l = {
            x: 0,
            y: 0
        };
    return (r || !r && !n) && ((zi(e) !== "body" || Ib(s)) && (a = kX(e)), Or(e) ? (l = ch(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = BX(s))), {
        x: o.left + a.scrollLeft - l.x,
        y: o.top + a.scrollTop - l.y,
        width: o.width,
        height: o.height
    }
}

function FX(t) {
    var e = ch(t),
        n = t.offsetWidth,
        r = t.offsetHeight;
    return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
        x: t.offsetLeft,
        y: t.offsetTop,
        width: n,
        height: r
    }
}

function Rb(t) {
    return zi(t) === "html" ? t : t.assignedSlot || t.parentNode || (A2(t) ? t.host : null) || wp(t)
}

function I2(t) {
    return ["html", "body", "#document"].indexOf(zi(t)) >= 0 ? t.ownerDocument.body : Or(t) && Ib(t) ? t : I2(Rb(t))
}

function If(t, e) {
    var n;
    e === void 0 && (e = []);
    var r = I2(t),
        i = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
        s = Dr(r),
        o = i ? [s].concat(s.visualViewport || [], Ib(r) ? r : []) : r,
        a = e.concat(o);
    return i ? a : a.concat(If(Rb(o)))
}

function LX(t) {
    return ["table", "td", "th"].indexOf(zi(t)) >= 0
}

function _S(t) {
    return !Or(t) || ji(t).position === "fixed" ? null : t.offsetParent
}

function NX(t) {
    var e = /firefox/i.test(Sy()),
        n = /Trident/i.test(Sy());
    if (n && Or(t)) {
        var r = ji(t);
        if (r.position === "fixed") return null
    }
    var i = Rb(t);
    for (A2(i) && (i = i.host); Or(i) && ["html", "body"].indexOf(zi(i)) < 0;) {
        var s = ji(i);
        if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none") return i;
        i = i.parentNode
    }
    return null
}

function R2(t) {
    for (var e = Dr(t), n = _S(t); n && LX(n) && ji(n).position === "static";) n = _S(n);
    return n && (zi(n) === "html" || zi(n) === "body" && ji(n).position === "static") ? e : n || NX(t) || e
}
var Ja = "top",
    uh = "bottom",
    cu = "right",
    $o = "left",
    M2 = "auto",
    UX = [Ja, uh, cu, $o],
    k2 = "start",
    dh = "end",
    GX = [].concat(UX, [M2]).reduce(function(t, e) {
        return t.concat([e, e + "-" + k2, e + "-" + dh])
    }, []),
    HX = "beforeRead",
    zX = "read",
    jX = "afterRead",
    VX = "beforeMain",
    WX = "main",
    YX = "afterMain",
    XX = "beforeWrite",
    KX = "write",
    qX = "afterWrite",
    Ty = [HX, zX, jX, VX, WX, YX, XX, KX, qX];

function JX(t) {
    var e = new Map,
        n = new Set,
        r = [];
    t.forEach(function(s) {
        e.set(s.name, s)
    });

    function i(s) {
        n.add(s.name);
        var o = [].concat(s.requires || [], s.requiresIfExists || []);
        o.forEach(function(a) {
            if (!n.has(a)) {
                var l = e.get(a);
                l && i(l)
            }
        }), r.push(s)
    }
    return t.forEach(function(s) {
        n.has(s.name) || i(s)
    }), r
}

function ZX(t) {
    var e = JX(t);
    return Ty.reduce(function(n, r) {
        return n.concat(e.filter(function(i) {
            return i.phase === r
        }))
    }, [])
}

function QX(t) {
    var e;
    return function() {
        return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
                e = void 0, n(t())
            })
        })), e
    }
}

function ns(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
    return [].concat(n).reduce(function(i, s) {
        return i.replace(/%s/, s)
    }, t)
}
var io = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s',
    eK = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available',
    bS = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];

function tK(t) {
    t.forEach(function(e) {
        [].concat(Object.keys(e), bS).filter(function(n, r, i) {
            return i.indexOf(n) === r
        }).forEach(function(n) {
            switch (n) {
                case "name":
                    typeof e.name != "string" && console.error(ns(io, String(e.name), '"name"', '"string"', '"' + String(e.name) + '"'));
                    break;
                case "enabled":
                    typeof e.enabled != "boolean" && console.error(ns(io, e.name, '"enabled"', '"boolean"', '"' + String(e.enabled) + '"'));
                    break;
                case "phase":
                    Ty.indexOf(e.phase) < 0 && console.error(ns(io, e.name, '"phase"', "either " + Ty.join(", "), '"' + String(e.phase) + '"'));
                    break;
                case "fn":
                    typeof e.fn != "function" && console.error(ns(io, e.name, '"fn"', '"function"', '"' + String(e.fn) + '"'));
                    break;
                case "effect":
                    e.effect != null && typeof e.effect != "function" && console.error(ns(io, e.name, '"effect"', '"function"', '"' + String(e.fn) + '"'));
                    break;
                case "requires":
                    e.requires != null && !Array.isArray(e.requires) && console.error(ns(io, e.name, '"requires"', '"array"', '"' + String(e.requires) + '"'));
                    break;
                case "requiresIfExists":
                    Array.isArray(e.requiresIfExists) || console.error(ns(io, e.name, '"requiresIfExists"', '"array"', '"' + String(e.requiresIfExists) + '"'));
                    break;
                case "options":
                case "data":
                    break;
                default:
                    console.error('PopperJS: an invalid property has been provided to the "' + e.name + '" modifier, valid properties are ' + bS.map(function(r) {
                        return '"' + r + '"'
                    }).join(", ") + '; but "' + n + '" was provided.')
            }
            e.requires && e.requires.forEach(function(r) {
                t.find(function(i) {
                    return i.name === r
                }) == null && console.error(ns(eK, String(e.name), r, r))
            })
        })
    })
}

function nK(t, e) {
    var n = new Set;
    return t.filter(function(r) {
        var i = e(r);
        if (!n.has(i)) return n.add(i), !0
    })
}

function Ep(t) {
    return t.split("-")[0]
}

function rK(t) {
    var e = t.reduce(function(n, r) {
        var i = n[r.name];
        return n[r.name] = i ? Object.assign({}, i, r, {
            options: Object.assign({}, i.options, r.options),
            data: Object.assign({}, i.data, r.data)
        }) : r, n
    }, {});
    return Object.keys(e).map(function(n) {
        return e[n]
    })
}

function B2(t) {
    return t.split("-")[1]
}

function iK(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
}

function sK(t) {
    var e = t.reference,
        n = t.element,
        r = t.placement,
        i = r ? Ep(r) : null,
        s = r ? B2(r) : null,
        o = e.x + e.width / 2 - n.width / 2,
        a = e.y + e.height / 2 - n.height / 2,
        l;
    switch (i) {
        case Ja:
            l = {
                x: o,
                y: e.y - n.height
            };
            break;
        case uh:
            l = {
                x: o,
                y: e.y + e.height
            };
            break;
        case cu:
            l = {
                x: e.x + e.width,
                y: a
            };
            break;
        case $o:
            l = {
                x: e.x - n.width,
                y: a
            };
            break;
        default:
            l = {
                x: e.x,
                y: e.y
            }
    }
    var c = i ? iK(i) : null;
    if (c != null) {
        var u = c === "y" ? "height" : "width";
        switch (s) {
            case k2:
                l[c] = l[c] - (e[u] / 2 - n[u] / 2);
                break;
            case dh:
                l[c] = l[c] + (e[u] / 2 - n[u] / 2);
                break
        }
    }
    return l
}
var xS = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.",
    oK = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.",
    wS = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
    };

function ES() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    return !e.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function")
    })
}

function aK(t) {
    t === void 0 && (t = {});
    var e = t,
        n = e.defaultModifiers,
        r = n === void 0 ? [] : n,
        i = e.defaultOptions,
        s = i === void 0 ? wS : i;
    return function(a, l, c) {
        c === void 0 && (c = s);
        var u = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, wS, s),
                modifiersData: {},
                elements: {
                    reference: a,
                    popper: l
                },
                attributes: {},
                styles: {}
            },
            d = [],
            f = !1,
            h = {
                state: u,
                setOptions: function(m) {
                    var g = typeof m == "function" ? m(u.options) : m;
                    b(), u.options = Object.assign({}, s, u.options, g), u.scrollParents = {
                        reference: Ob(a) ? If(a) : a.contextElement ? If(a.contextElement) : [],
                        popper: If(l)
                    };
                    var v = ZX(rK([].concat(r, u.options.modifiers)));
                    u.orderedModifiers = v.filter(function(E) {
                        return E.enabled
                    }); {
                        var _ = nK([].concat(v, u.options.modifiers), function(E) {
                            var P = E.name;
                            return P
                        });
                        if (tK(_), Ep(u.options.placement) === M2) {
                            var x = u.orderedModifiers.find(function(E) {
                                var P = E.name;
                                return P === "flip"
                            });
                            x || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "))
                        }
                        var w = ji(l),
                            S = w.marginTop,
                            C = w.marginRight,
                            A = w.marginBottom,
                            T = w.marginLeft;
                        [S, C, A, T].some(function(E) {
                            return parseFloat(E)
                        }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "))
                    }
                    return p(), h.update()
                },
                forceUpdate: function() {
                    if (!f) {
                        var m = u.elements,
                            g = m.reference,
                            v = m.popper;
                        if (!ES(g, v)) {
                            console.error(xS);
                            return
                        }
                        u.rects = {
                            reference: $X(g, R2(v), u.options.strategy === "fixed"),
                            popper: FX(v)
                        }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(E) {
                            return u.modifiersData[E.name] = Object.assign({}, E.data)
                        });
                        for (var _ = 0, x = 0; x < u.orderedModifiers.length; x++) {
                            if (_ += 1, _ > 100) {
                                console.error(oK);
                                break
                            }
                            if (u.reset === !0) {
                                u.reset = !1, x = -1;
                                continue
                            }
                            var w = u.orderedModifiers[x],
                                S = w.fn,
                                C = w.options,
                                A = C === void 0 ? {} : C,
                                T = w.name;
                            typeof S == "function" && (u = S({
                                state: u,
                                options: A,
                                name: T,
                                instance: h
                            }) || u)
                        }
                    }
                },
                update: QX(function() {
                    return new Promise(function(y) {
                        h.forceUpdate(), y(u)
                    })
                }),
                destroy: function() {
                    b(), f = !0
                }
            };
        if (!ES(a, l)) return console.error(xS), h;
        h.setOptions(c).then(function(y) {
            !f && c.onFirstUpdate && c.onFirstUpdate(y)
        });

        function p() {
            u.orderedModifiers.forEach(function(y) {
                var m = y.name,
                    g = y.options,
                    v = g === void 0 ? {} : g,
                    _ = y.effect;
                if (typeof _ == "function") {
                    var x = _({
                            state: u,
                            name: m,
                            instance: h,
                            options: v
                        }),
                        w = function() {};
                    d.push(x || w)
                }
            })
        }

        function b() {
            d.forEach(function(y) {
                return y()
            }), d = []
        }
        return h
    }
}
var Ld = {
    passive: !0
};

function lK(t) {
    var e = t.state,
        n = t.instance,
        r = t.options,
        i = r.scroll,
        s = i === void 0 ? !0 : i,
        o = r.resize,
        a = o === void 0 ? !0 : o,
        l = Dr(e.elements.popper),
        c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return s && c.forEach(function(u) {
            u.addEventListener("scroll", n.update, Ld)
        }), a && l.addEventListener("resize", n.update, Ld),
        function() {
            s && c.forEach(function(u) {
                u.removeEventListener("scroll", n.update, Ld)
            }), a && l.removeEventListener("resize", n.update, Ld)
        }
}
var cK = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {},
    effect: lK,
    data: {}
};

function uK(t) {
    var e = t.state,
        n = t.name;
    e.modifiersData[n] = sK({
        reference: e.rects.reference,
        element: e.rects.popper,
        strategy: "absolute",
        placement: e.placement
    })
}
var dK = {
        name: "popperOffsets",
        enabled: !0,
        phase: "read",
        fn: uK,
        data: {}
    },
    fK = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
    };

function hK(t) {
    var e = t.x,
        n = t.y,
        r = window,
        i = r.devicePixelRatio || 1;
    return {
        x: ul(e * i) / i || 0,
        y: ul(n * i) / i || 0
    }
}

function SS(t) {
    var e, n = t.popper,
        r = t.popperRect,
        i = t.placement,
        s = t.variation,
        o = t.offsets,
        a = t.position,
        l = t.gpuAcceleration,
        c = t.adaptive,
        u = t.roundOffsets,
        d = t.isFixed,
        f = o.x,
        h = f === void 0 ? 0 : f,
        p = o.y,
        b = p === void 0 ? 0 : p,
        y = typeof u == "function" ? u({
            x: h,
            y: b
        }) : {
            x: h,
            y: b
        };
    h = y.x, b = y.y;
    var m = o.hasOwnProperty("x"),
        g = o.hasOwnProperty("y"),
        v = $o,
        _ = Ja,
        x = window;
    if (c) {
        var w = R2(n),
            S = "clientHeight",
            C = "clientWidth";
        if (w === Dr(n) && (w = wp(n), ji(w).position !== "static" && a === "absolute" && (S = "scrollHeight", C = "scrollWidth")), w = w, i === Ja || (i === $o || i === cu) && s === dh) {
            _ = uh;
            var A = d && w === x && x.visualViewport ? x.visualViewport.height : w[S];
            b -= A - r.height, b *= l ? 1 : -1
        }
        if (i === $o || (i === Ja || i === uh) && s === dh) {
            v = cu;
            var T = d && w === x && x.visualViewport ? x.visualViewport.width : w[C];
            h -= T - r.width, h *= l ? 1 : -1
        }
    }
    var E = Object.assign({
            position: a
        }, c && fK),
        P = u === !0 ? hK({
            x: h,
            y: b
        }) : {
            x: h,
            y: b
        };
    if (h = P.x, b = P.y, l) {
        var B;
        return Object.assign({}, E, (B = {}, B[_] = g ? "0" : "", B[v] = m ? "0" : "", B.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + b + "px)" : "translate3d(" + h + "px, " + b + "px, 0)", B))
    }
    return Object.assign({}, E, (e = {}, e[_] = g ? b + "px" : "", e[v] = m ? h + "px" : "", e.transform = "", e))
}

function pK(t) {
    var e = t.state,
        n = t.options,
        r = n.gpuAcceleration,
        i = r === void 0 ? !0 : r,
        s = n.adaptive,
        o = s === void 0 ? !0 : s,
        a = n.roundOffsets,
        l = a === void 0 ? !0 : a; {
        var c = ji(e.elements.popper).transitionProperty || "";
        o && ["transform", "top", "right", "bottom", "left"].some(function(d) {
            return c.indexOf(d) >= 0
        }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "))
    }
    var u = {
        placement: Ep(e.placement),
        variation: B2(e.placement),
        popper: e.elements.popper,
        popperRect: e.rects.popper,
        gpuAcceleration: i,
        isFixed: e.options.strategy === "fixed"
    };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, SS(Object.assign({}, u, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: o,
        roundOffsets: l
    })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, SS(Object.assign({}, u, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
    })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
    })
}
var mK = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: pK,
    data: {}
};

function gK(t) {
    var e = t.state;
    Object.keys(e.elements).forEach(function(n) {
        var r = e.styles[n] || {},
            i = e.attributes[n] || {},
            s = e.elements[n];
        !Or(s) || !zi(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(o) {
            var a = i[o];
            a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a)
        }))
    })
}

function vK(t) {
    var e = t.state,
        n = {
            popper: {
                position: e.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
            },
            arrow: {
                position: "absolute"
            },
            reference: {}
        };
    return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
        function() {
            Object.keys(e.elements).forEach(function(r) {
                var i = e.elements[r],
                    s = e.attributes[r] || {},
                    o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]),
                    a = o.reduce(function(l, c) {
                        return l[c] = "", l
                    }, {});
                !Or(i) || !zi(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(l) {
                    i.removeAttribute(l)
                }))
            })
        }
}
var yK = {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: gK,
        effect: vK,
        requires: ["computeStyles"]
    },
    _K = [cK, dK, mK, yK],
    bK = aK({
        defaultModifiers: _K
    });

function xK(t, e, n) {
    var r = Ep(t),
        i = [$o, Ja].indexOf(r) >= 0 ? -1 : 1,
        s = typeof n == "function" ? n(Object.assign({}, e, {
            placement: t
        })) : n,
        o = s[0],
        a = s[1];
    return o = o || 0, a = (a || 0) * i, [$o, cu].indexOf(r) >= 0 ? {
        x: a,
        y: o
    } : {
        x: o,
        y: a
    }
}

function wK(t) {
    var e = t.state,
        n = t.options,
        r = t.name,
        i = n.offset,
        s = i === void 0 ? [0, 0] : i,
        o = GX.reduce(function(u, d) {
            return u[d] = xK(d, e.rects, s), u
        }, {}),
        a = o[e.placement],
        l = a.x,
        c = a.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = o
}
var EK = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: wK
};
const [SK, so] = Ee("popover"), TK = ["overlay", "duration", "teleport", "overlayStyle", "overlayClass", "closeOnClickOverlay"], CK = {
    show: Boolean,
    theme: Pe("light"),
    overlay: Boolean,
    actions: Gi(),
    actionsDirection: Pe("vertical"),
    trigger: Pe("click"),
    duration: be,
    showArrow: me,
    placement: Pe("bottom"),
    iconPrefix: String,
    overlayClass: Ut,
    overlayStyle: Object,
    closeOnClickAction: me,
    closeOnClickOverlay: me,
    closeOnClickOutside: me,
    offset: {
        type: Array,
        default: () => [0, 8]
    },
    teleport: {
        type: [String, Object],
        default: "body"
    }
};
var PK = ye({
    name: SK,
    props: CK,
    emits: ["select", "touchstart", "update:show"],
    setup(t, {
        emit: e,
        slots: n,
        attrs: r
    }) {
        let i;
        const s = J(),
            o = J(),
            a = J(),
            l = CW(() => t.show, g => e("update:show", g)),
            c = () => ({
                placement: t.placement,
                modifiers: [{
                    name: "computeStyles",
                    options: {
                        adaptive: !1,
                        gpuAcceleration: !1
                    }
                }, Ne({}, EK, {
                    options: {
                        offset: t.offset
                    }
                })]
            }),
            u = () => o.value && a.value ? bK(o.value, a.value.popupRef.value, c()) : null,
            d = () => {
                Ue(() => {
                    l.value && (i ? i.setOptions(c()) : (i = u(), oi && (window.addEventListener("animationend", d), window.addEventListener("transitionend", d))))
                })
            },
            f = g => {
                l.value = g
            },
            h = () => {
                t.trigger === "click" && (l.value = !l.value)
            },
            p = (g, v) => {
                g.disabled || (e("select", g, v), t.closeOnClickAction && (l.value = !1))
            },
            b = () => {
                l.value && t.closeOnClickOutside && (!t.overlay || t.closeOnClickOverlay) && (l.value = !1)
            },
            y = (g, v) => n.action ? n.action({
                action: g,
                index: v
            }) : [g.icon && I($t, {
                name: g.icon,
                classPrefix: t.iconPrefix,
                class: so("action-icon")
            }, null), I("div", {
                class: [so("action-text"), {
                    [CV]: t.actionsDirection === "vertical"
                }]
            }, [g.text])],
            m = (g, v) => {
                const {
                    icon: _,
                    color: x,
                    disabled: w,
                    className: S
                } = g;
                return I("div", {
                    role: "menuitem",
                    class: [so("action", {
                        disabled: w,
                        "with-icon": _
                    }), {
                        [TV]: t.actionsDirection === "horizontal"
                    }, S],
                    style: {
                        color: x
                    },
                    tabindex: w ? void 0 : 0,
                    "aria-disabled": w || void 0,
                    onClick: () => p(g, v)
                }, [y(g, v)])
            };
        return St(() => {
            d(), Il(() => {
                var g;
                s.value = (g = a.value) == null ? void 0 : g.popupRef.value
            })
        }), er(() => {
            i && (oi && (window.removeEventListener("animationend", d), window.removeEventListener("transitionend", d)), i.destroy(), i = null)
        }), pe(() => [l.value, t.offset, t.placement], d), KO([o, s], b, {
            eventName: "touchstart"
        }), () => {
            var g;
            return I(gt, null, [I("span", {
                ref: o,
                class: so("wrapper"),
                onClick: h
            }, [(g = n.reference) == null ? void 0 : g.call(n)]), I(ha, et({
                ref: a,
                show: l.value,
                class: so([t.theme]),
                position: "",
                transition: "van-popover-zoom",
                lockScroll: !1,
                "onUpdate:show": f
            }, r, vy(), wt(t, TK)), {
                default: () => [t.showArrow && I("div", {
                    class: so("arrow")
                }, null), I("div", {
                    role: "menu",
                    class: so("content", t.actionsDirection)
                }, [n.default ? n.default() : t.actions.map(m)])]
            })])
        }
    }
});
const b_e = Ae(PK),
    [AK, Bm] = Ee("progress"),
    OK = {
        color: String,
        inactive: Boolean,
        pivotText: String,
        textColor: String,
        showPivot: me,
        pivotColor: String,
        trackColor: String,
        strokeWidth: be,
        percentage: {
            type: be,
            default: 0,
            validator: t => +t >= 0 && +t <= 100
        }
    };
var IK = ye({
    name: AK,
    props: OK,
    setup(t) {
        const e = ne(() => t.inactive ? void 0 : t.color),
            n = () => {
                const {
                    textColor: r,
                    pivotText: i,
                    pivotColor: s,
                    percentage: o
                } = t, a = i ? ? `${o}%`;
                if (t.showPivot && a) {
                    const l = {
                        color: r,
                        left: `${+o}%`,
                        transform: `translate(-${+o}%,-50%)`,
                        background: s || e.value
                    };
                    return I("span", {
                        style: l,
                        class: Bm("pivot", {
                            inactive: t.inactive
                        })
                    }, [a])
                }
            };
        return () => {
            const {
                trackColor: r,
                percentage: i,
                strokeWidth: s
            } = t, o = {
                background: r,
                height: Ze(s)
            }, a = {
                width: `${i}%`,
                background: e.value
            };
            return I("div", {
                class: Bm(),
                style: o
            }, [I("span", {
                class: Bm("portion", {
                    inactive: t.inactive
                }),
                style: a
            }, null), n()])
        }
    }
});
const x_e = Ae(IK),
    [RK, tc, MK] = Ee("pull-refresh"),
    D2 = 50,
    kK = ["pulling", "loosing", "success"],
    BK = {
        disabled: Boolean,
        modelValue: Boolean,
        headHeight: Fe(D2),
        successText: String,
        pullingText: String,
        loosingText: String,
        loadingText: String,
        pullDistance: be,
        successDuration: Fe(500),
        animationDuration: Fe(300)
    };
var DK = ye({
    name: RK,
    props: BK,
    emits: ["change", "refresh", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        let r;
        const i = J(),
            s = J(),
            o = Ku(i),
            a = ht({
                status: "normal",
                distance: 0,
                duration: 0
            }),
            l = $l(),
            c = () => {
                if (t.headHeight !== D2) return {
                    height: `${t.headHeight}px`
                }
            },
            u = () => a.status !== "loading" && a.status !== "success" && !t.disabled,
            d = _ => {
                const x = +(t.pullDistance || t.headHeight);
                return _ > x && (_ < x * 2 ? _ = x + (_ - x) / 2 : _ = x * 1.5 + (_ - x * 2) / 4), Math.round(_)
            },
            f = (_, x) => {
                const w = +(t.pullDistance || t.headHeight);
                a.distance = _, x ? a.status = "loading" : _ === 0 ? a.status = "normal" : _ < w ? a.status = "pulling" : a.status = "loosing", e("change", {
                    status: a.status,
                    distance: _
                })
            },
            h = () => {
                const {
                    status: _
                } = a;
                return _ === "normal" ? "" : t[`${_}Text`] || MK(_)
            },
            p = () => {
                const {
                    status: _,
                    distance: x
                } = a;
                if (n[_]) return n[_]({
                    distance: x
                });
                const w = [];
                return kK.includes(_) && w.push(I("div", {
                    class: tc("text")
                }, [h()])), _ === "loading" && w.push(I(qi, {
                    class: tc("loading")
                }, {
                    default: h
                })), w
            },
            b = () => {
                a.status = "success", setTimeout(() => {
                    f(0)
                }, +t.successDuration)
            },
            y = _ => {
                r = qu(o.value) === 0, r && (a.duration = 0, l.start(_))
            },
            m = _ => {
                u() && y(_)
            },
            g = _ => {
                if (u()) {
                    r || y(_);
                    const {
                        deltaY: x
                    } = l;
                    l.move(_), r && x.value >= 0 && l.isVertical() && (Zt(_), f(d(x.value)))
                }
            },
            v = () => {
                r && l.deltaY.value && u() && (a.duration = +t.animationDuration, a.status === "loosing" ? (f(+t.headHeight, !0), e("update:modelValue", !0), Ue(() => e("refresh"))) : f(0))
            };
        return pe(() => t.modelValue, _ => {
            a.duration = +t.animationDuration, _ ? f(+t.headHeight, !0) : n.success || t.successText ? b() : f(0, !1)
        }), Nn("touchmove", g, {
            target: s
        }), () => {
            var _;
            const x = {
                transitionDuration: `${a.duration}ms`,
                transform: a.distance ? `translate3d(0,${a.distance}px, 0)` : ""
            };
            return I("div", {
                ref: i,
                class: tc()
            }, [I("div", {
                ref: s,
                class: tc("track"),
                style: x,
                onTouchstartPassive: m,
                onTouchend: v,
                onTouchcancel: v
            }, [I("div", {
                class: tc("head"),
                style: c()
            }, [p()]), (_ = n.default) == null ? void 0 : _.call(n)])])
        }
    }
});
const w_e = Ae(DK),
    E_e = Ae(wY),
    [$2, $K] = Ee("sidebar"),
    F2 = Symbol($2),
    FK = {
        modelValue: Fe(0)
    };
var LK = ye({
    name: $2,
    props: FK,
    emits: ["change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            linkChildren: r
        } = Br(F2), i = () => +t.modelValue;
        return r({
            getActive: i,
            setActive: o => {
                o !== i() && (e("update:modelValue", o), e("change", o))
            }
        }), () => {
            var o;
            return I("div", {
                role: "tablist",
                class: $K()
            }, [(o = n.default) == null ? void 0 : o.call(n)])
        }
    }
});
const S_e = Ae(LK),
    [NK, TS] = Ee("sidebar-item"),
    UK = Ne({}, Dl, {
        dot: Boolean,
        title: String,
        badge: be,
        disabled: Boolean,
        badgeProps: Object
    });
var GK = ye({
    name: NK,
    props: UK,
    emits: ["click"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = Zu(),
            {
                parent: i,
                index: s
            } = tr(F2);
        if (!i) {
            console.error("[Vant] <SidebarItem> must be a child component of <Sidebar>.");
            return
        }
        const o = () => {
            t.disabled || (e("click", s.value), i.setActive(s.value), r())
        };
        return () => {
            const {
                dot: a,
                badge: l,
                title: c,
                disabled: u
            } = t, d = s.value === i.getActive();
            return I("div", {
                role: "tab",
                class: TS({
                    select: d,
                    disabled: u
                }),
                tabindex: u ? void 0 : 0,
                "aria-selected": d,
                onClick: o
            }, [I(vp, et({
                dot: a,
                class: TS("text"),
                content: l
            }, t.badgeProps), {
                default: () => [n.title ? n.title() : c]
            })])
        }
    }
});
const T_e = Ae(GK),
    [HK, zK] = Ee("skeleton-title"),
    jK = {
        round: Boolean,
        titleWidth: be
    };
var VK = ye({
    name: HK,
    props: jK,
    setup(t) {
        return () => I("h3", {
            class: zK([{
                round: t.round
            }]),
            style: {
                width: Ze(t.titleWidth)
            }
        }, null)
    }
});
const WK = Ae(VK);
var YK = WK;
const [XK, KK] = Ee("skeleton-avatar"), qK = {
    avatarSize: be,
    avatarShape: Pe("round")
};
var JK = ye({
    name: XK,
    props: qK,
    setup(t) {
        return () => I("div", {
            class: KK([t.avatarShape]),
            style: fa(t.avatarSize)
        }, null)
    }
});
const ZK = Ae(JK);
var QK = ZK;
const Mb = "100%",
    eq = {
        round: Boolean,
        rowWidth: {
            type: be,
            default: Mb
        }
    },
    [tq, nq] = Ee("skeleton-paragraph");
var rq = ye({
    name: tq,
    props: eq,
    setup(t) {
        return () => I("div", {
            class: nq([{
                round: t.round
            }]),
            style: {
                width: t.rowWidth
            }
        }, null)
    }
});
const iq = Ae(rq);
var sq = iq;
const [oq, CS] = Ee("skeleton"), aq = "60%", lq = {
    row: Fe(0),
    round: Boolean,
    title: Boolean,
    titleWidth: be,
    avatar: Boolean,
    avatarSize: be,
    avatarShape: Pe("round"),
    loading: me,
    animate: me,
    rowWidth: {
        type: [Number, String, Array],
        default: Mb
    }
};
var cq = ye({
    name: oq,
    inheritAttrs: !1,
    props: lq,
    setup(t, {
        slots: e,
        attrs: n
    }) {
        const r = () => {
                if (t.avatar) return I(QK, {
                    avatarShape: t.avatarShape,
                    avatarSize: t.avatarSize
                }, null)
            },
            i = () => {
                if (t.title) return I(YK, {
                    round: t.round,
                    titleWidth: t.titleWidth
                }, null)
            },
            s = l => {
                const {
                    rowWidth: c
                } = t;
                return c === Mb && l === +t.row - 1 ? aq : Array.isArray(c) ? c[l] : c
            },
            o = () => Array(+t.row).fill("").map((l, c) => I(sq, {
                key: c,
                round: t.round,
                rowWidth: Ze(s(c))
            }, null)),
            a = () => e.template ? e.template() : I(gt, null, [r(), I("div", {
                class: CS("content")
            }, [i(), o()])]);
        return () => {
            var l;
            return t.loading ? I("div", et({
                class: CS({
                    animate: t.animate,
                    round: t.round
                })
            }, n), [a()]) : (l = e.default) == null ? void 0 : l.call(e)
        }
    }
});
const C_e = Ae(cq),
    [uq, nc] = Ee("slider"),
    dq = {
        min: Fe(0),
        max: Fe(100),
        step: Fe(1),
        range: Boolean,
        reverse: Boolean,
        disabled: Boolean,
        readonly: Boolean,
        vertical: Boolean,
        barHeight: be,
        buttonSize: be,
        activeColor: String,
        inactiveColor: String,
        modelValue: {
            type: [Number, Array],
            default: 0
        }
    };
var fq = ye({
    name: uq,
    props: dq,
    emits: ["change", "dragEnd", "dragStart", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        let r, i, s;
        const o = J(),
            a = [J(), J()],
            l = J(),
            c = $l(),
            u = ne(() => Number(t.max) - Number(t.min)),
            d = ne(() => {
                const E = t.vertical ? "width" : "height";
                return {
                    background: t.inactiveColor,
                    [E]: Ze(t.barHeight)
                }
            }),
            f = E => t.range && Array.isArray(E),
            h = () => {
                const {
                    modelValue: E,
                    min: P
                } = t;
                return f(E) ? `${(E[1]-E[0])*100/u.value}%` : `${(E-Number(P))*100/u.value}%`
            },
            p = () => {
                const {
                    modelValue: E,
                    min: P
                } = t;
                return f(E) ? `${(E[0]-Number(P))*100/u.value}%` : "0%"
            },
            b = ne(() => {
                const P = {
                    [t.vertical ? "height" : "width"]: h(),
                    background: t.activeColor
                };
                l.value && (P.transition = "none");
                const B = () => t.vertical ? t.reverse ? "bottom" : "top" : t.reverse ? "right" : "left";
                return P[B()] = p(), P
            }),
            y = E => {
                const P = +t.min,
                    B = +t.max,
                    F = +t.step;
                E = nn(E, P, B);
                const H = Math.round((E - P) / F) * F;
                return BR(P, H)
            },
            m = () => {
                const E = t.modelValue;
                f(E) ? s = E.map(y) : s = y(E)
            },
            g = E => {
                var P, B;
                const F = (P = E[0]) != null ? P : Number(t.min),
                    H = (B = E[1]) != null ? B : Number(t.max);
                return F > H ? [H, F] : [F, H]
            },
            v = (E, P) => {
                f(E) ? E = g(E).map(y) : E = y(E), Ps(E, t.modelValue) || e("update:modelValue", E), P && !Ps(E, s) && e("change", E)
            },
            _ = E => {
                if (E.stopPropagation(), t.disabled || t.readonly) return;
                m();
                const {
                    min: P,
                    reverse: B,
                    vertical: F,
                    modelValue: H
                } = t, k = Jt(o), N = () => F ? B ? k.bottom - E.clientY : E.clientY - k.top : B ? k.right - E.clientX : E.clientX - k.left, V = F ? k.height : k.width, Y = Number(P) + N() / V * u.value;
                if (f(H)) {
                    const [le, ae] = H, W = (le + ae) / 2;
                    Y <= W ? v([Y, ae], !0) : v([le, Y], !0)
                } else v(Y, !0)
            },
            x = E => {
                t.disabled || t.readonly || (c.start(E), i = t.modelValue, m(), l.value = "start")
            },
            w = E => {
                if (t.disabled || t.readonly) return;
                l.value === "start" && e("dragStart", E), Zt(E, !0), c.move(E), l.value = "dragging";
                const P = Jt(o),
                    B = t.vertical ? c.deltaY.value : c.deltaX.value,
                    F = t.vertical ? P.height : P.width;
                let H = B / F * u.value;
                if (t.reverse && (H = -H), f(s)) {
                    const k = t.reverse ? 1 - r : r;
                    i[k] = s[k] + H
                } else i = s + H;
                v(i)
            },
            S = E => {
                t.disabled || t.readonly || (l.value === "dragging" && (v(i, !0), e("dragEnd", E)), l.value = "")
            },
            C = E => typeof E == "number" ? nc("button-wrapper", ["left", "right"][E]) : nc("button-wrapper", t.reverse ? "left" : "right"),
            A = (E, P) => {
                const B = l.value === "dragging";
                if (typeof P == "number") {
                    const F = n[P === 0 ? "left-button" : "right-button"];
                    let H;
                    if (B && Array.isArray(i) && (H = i[0] > i[1] ? r ^ 1 : r), F) return F({
                        value: E,
                        dragging: B,
                        dragIndex: H
                    })
                }
                return n.button ? n.button({
                    value: E,
                    dragging: B
                }) : I("div", {
                    class: nc("button"),
                    style: fa(t.buttonSize)
                }, null)
            },
            T = E => {
                const P = typeof E == "number" ? t.modelValue[E] : t.modelValue;
                return I("div", {
                    ref: a[E ? ? 0],
                    role: "slider",
                    class: C(E),
                    tabindex: t.disabled ? void 0 : 0,
                    "aria-valuemin": t.min,
                    "aria-valuenow": P,
                    "aria-valuemax": t.max,
                    "aria-disabled": t.disabled || void 0,
                    "aria-readonly": t.readonly || void 0,
                    "aria-orientation": t.vertical ? "vertical" : "horizontal",
                    onTouchstartPassive: B => {
                        typeof E == "number" && (r = E), x(B)
                    },
                    onTouchend: S,
                    onTouchcancel: S,
                    onClick: RR
                }, [A(P, E)])
            };
        return v(t.modelValue), da(() => t.modelValue), a.forEach(E => {
            Nn("touchmove", w, {
                target: E
            })
        }), () => I("div", {
            ref: o,
            style: d.value,
            class: nc({
                vertical: t.vertical,
                disabled: t.disabled
            }),
            onClick: _
        }, [I("div", {
            class: nc("bar"),
            style: b.value
        }, [t.range ? [T(0), T(1)] : T()])])
    }
});
const P_e = Ae(fq),
    [PS, hq] = Ee("space"),
    pq = {
        align: String,
        direction: {
            type: String,
            default: "horizontal"
        },
        size: {
            type: [Number, String, Array],
            default: 8
        },
        wrap: Boolean,
        fill: Boolean
    };

function L2(t = []) {
    const e = [];
    return t.forEach(n => {
        Array.isArray(n) ? e.push(...n) : n.type === gt ? e.push(...L2(n.children)) : e.push(n)
    }), e.filter(n => {
        var r;
        return !(n && (n.type === Ot || n.type === gt && ((r = n.children) == null ? void 0 : r.length) === 0 || n.type === ii && n.children.trim() === ""))
    })
}
var mq = ye({
    name: PS,
    props: pq,
    setup(t, {
        slots: e
    }) {
        const n = ne(() => {
                var s;
                return (s = t.align) != null ? s : t.direction === "horizontal" ? "center" : ""
            }),
            r = s => typeof s == "number" ? s + "px" : s,
            i = s => {
                const o = {},
                    a = `${r(Array.isArray(t.size)?t.size[0]:t.size)}`,
                    l = `${r(Array.isArray(t.size)?t.size[1]:t.size)}`;
                return s ? t.wrap ? {
                    marginBottom: l
                } : {} : (t.direction === "horizontal" && (o.marginRight = a), (t.direction === "vertical" || t.wrap) && (o.marginBottom = l), o)
            };
        return () => {
            var s;
            const o = L2((s = e.default) == null ? void 0 : s.call(e));
            return I("div", {
                class: [hq({
                    [t.direction]: t.direction,
                    [`align-${n.value}`]: n.value,
                    wrap: t.wrap,
                    fill: t.fill
                })]
            }, [o.map((a, l) => I("div", {
                key: `item-${l}`,
                class: `${PS}-item`,
                style: i(l === o.length - 1)
            }, [a]))])
        }
    }
});
const A_e = Ae(mq),
    [gq, Nd] = Ee("stepper"),
    vq = 200,
    Ud = (t, e) => String(t) === String(e),
    yq = {
        min: Fe(1),
        max: Fe(1 / 0),
        name: Fe(""),
        step: Fe(1),
        theme: String,
        integer: Boolean,
        disabled: Boolean,
        showPlus: me,
        showMinus: me,
        showInput: me,
        longPress: me,
        autoFixed: me,
        allowEmpty: Boolean,
        modelValue: be,
        inputWidth: be,
        buttonSize: be,
        placeholder: String,
        disablePlus: Boolean,
        disableMinus: Boolean,
        disableInput: Boolean,
        beforeChange: Function,
        defaultValue: Fe(1),
        decimalLength: be
    };
var _q = ye({
    name: gq,
    props: yq,
    emits: ["plus", "blur", "minus", "focus", "change", "overlimit", "update:modelValue"],
    setup(t, {
        emit: e
    }) {
        const n = (C, A = !0) => {
                const {
                    min: T,
                    max: E,
                    allowEmpty: P,
                    decimalLength: B
                } = t;
                return P && C === "" || (C = my(String(C), !t.integer), C = C === "" ? 0 : +C, C = Number.isNaN(C) ? +T : C, C = A ? Math.max(Math.min(+E, C), +T) : C, vt(B) && (C = C.toFixed(+B))), C
            },
            r = () => {
                var C;
                const A = (C = t.modelValue) != null ? C : t.defaultValue,
                    T = n(A);
                return Ud(T, t.modelValue) || e("update:modelValue", T), T
            };
        let i;
        const s = J(),
            o = J(r()),
            a = ne(() => t.disabled || t.disableMinus || +o.value <= +t.min),
            l = ne(() => t.disabled || t.disablePlus || +o.value >= +t.max),
            c = ne(() => ({
                width: Ze(t.inputWidth),
                height: Ze(t.buttonSize)
            })),
            u = ne(() => fa(t.buttonSize)),
            d = () => {
                const C = n(o.value);
                Ud(C, o.value) || (o.value = C)
            },
            f = C => {
                t.beforeChange ? Bl(t.beforeChange, {
                    args: [C],
                    done() {
                        o.value = C
                    }
                }) : o.value = C
            },
            h = () => {
                if (i === "plus" && l.value || i === "minus" && a.value) {
                    e("overlimit", i);
                    return
                }
                const C = i === "minus" ? -t.step : +t.step,
                    A = n(BR(+o.value, C));
                f(A), e(i)
            },
            p = C => {
                const A = C.target,
                    {
                        value: T
                    } = A,
                    {
                        decimalLength: E
                    } = t;
                let P = my(String(T), !t.integer);
                if (vt(E) && P.includes(".")) {
                    const F = P.split(".");
                    P = `${F[0]}.${F[1].slice(0,+E)}`
                }
                t.beforeChange ? A.value = String(o.value) : Ud(T, P) || (A.value = P);
                const B = P === String(+P);
                f(B ? +P : P)
            },
            b = C => {
                var A;
                t.disableInput ? (A = s.value) == null || A.blur() : e("focus", C)
            },
            y = C => {
                const A = C.target,
                    T = n(A.value, t.autoFixed);
                A.value = String(T), o.value = T, Ue(() => {
                    e("blur", C), IR()
                })
            };
        let m, g;
        const v = () => {
                g = setTimeout(() => {
                    h(), v()
                }, vq)
            },
            _ = () => {
                t.longPress && (m = !1, clearTimeout(g), g = setTimeout(() => {
                    m = !0, h(), v()
                }, NR))
            },
            x = C => {
                t.longPress && (clearTimeout(g), m && Zt(C))
            },
            w = C => {
                t.disableInput && Zt(C)
            },
            S = C => ({
                onClick: A => {
                    Zt(A), i = C, h()
                },
                onTouchstartPassive: () => {
                    i = C, _()
                },
                onTouchend: x,
                onTouchcancel: x
            });
        return pe(() => [t.max, t.min, t.integer, t.decimalLength], d), pe(() => t.modelValue, C => {
            Ud(C, o.value) || (o.value = n(C))
        }), pe(o, C => {
            e("update:modelValue", C), e("change", C, {
                name: t.name
            })
        }), da(() => t.modelValue), () => I("div", {
            role: "group",
            class: Nd([t.theme])
        }, [Cr(I("button", et({
            type: "button",
            style: u.value,
            class: [Nd("minus", {
                disabled: a.value
            }), {
                [Hi]: !a.value
            }],
            "aria-disabled": a.value || void 0
        }, S("minus")), null), [
            [Ar, t.showMinus]
        ]), Cr(I("input", {
            ref: s,
            type: t.integer ? "tel" : "text",
            role: "spinbutton",
            class: Nd("input"),
            value: o.value,
            style: c.value,
            disabled: t.disabled,
            readonly: t.disableInput,
            inputmode: t.integer ? "numeric" : "decimal",
            placeholder: t.placeholder,
            autocomplete: "off",
            "aria-valuemax": t.max,
            "aria-valuemin": t.min,
            "aria-valuenow": o.value,
            onBlur: y,
            onInput: p,
            onFocus: b,
            onMousedown: w
        }, null), [
            [Ar, t.showInput]
        ]), Cr(I("button", et({
            type: "button",
            style: u.value,
            class: [Nd("plus", {
                disabled: l.value
            }), {
                [Hi]: !l.value
            }],
            "aria-disabled": l.value || void 0
        }, S("plus")), null), [
            [Ar, t.showPlus]
        ])])
    }
});
const O_e = Ae(_q),
    [bq, zt, xq] = Ee("uploader");

function AS(t, e) {
    return new Promise(n => {
        if (e === "file") {
            n();
            return
        }
        const r = new FileReader;
        r.onload = i => {
            n(i.target.result)
        }, e === "dataUrl" ? r.readAsDataURL(t) : e === "text" && r.readAsText(t)
    })
}

function N2(t, e) {
    return oh(t).some(n => n.file ? al(e) ? e(n.file) : n.file.size > +e : !1)
}

function wq(t, e) {
    const n = [],
        r = [];
    return t.forEach(i => {
        N2(i, e) ? r.push(i) : n.push(i)
    }), {
        valid: n,
        invalid: r
    }
}
const Eq = /\.(jpeg|jpg|gif|png|svg|webp|jfif|bmp|dpg|avif)/i,
    Sq = t => Eq.test(t);

function U2(t) {
    return t.isImage ? !0 : t.file && t.file.type ? t.file.type.indexOf("image") === 0 : t.url ? Sq(t.url) : typeof t.content == "string" ? t.content.indexOf("data:image") === 0 : !1
}
var Tq = ye({
    props: {
        name: be,
        item: xn(Object),
        index: Number,
        imageFit: String,
        lazyLoad: Boolean,
        deletable: Boolean,
        reupload: Boolean,
        previewSize: [Number, String, Array],
        beforeDelete: Function
    },
    emits: ["delete", "preview", "reupload"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = () => {
                const {
                    status: u,
                    message: d
                } = t.item;
                if (u === "uploading" || u === "failed") {
                    const f = u === "failed" ? I($t, {
                            name: "close",
                            class: zt("mask-icon")
                        }, null) : I(qi, {
                            class: zt("loading")
                        }, null),
                        h = vt(d) && d !== "";
                    return I("div", {
                        class: zt("mask")
                    }, [f, h && I("div", {
                        class: zt("mask-message")
                    }, [d])])
                }
            },
            i = u => {
                const {
                    name: d,
                    item: f,
                    index: h,
                    beforeDelete: p
                } = t;
                u.stopPropagation(), Bl(p, {
                    args: [f, {
                        name: d,
                        index: h
                    }],
                    done: () => e("delete")
                })
            },
            s = () => e("preview"),
            o = () => e("reupload"),
            a = () => {
                if (t.deletable && t.item.status !== "uploading") {
                    const u = n["preview-delete"];
                    return I("div", {
                        role: "button",
                        class: zt("preview-delete", {
                            shadow: !u
                        }),
                        tabindex: 0,
                        "aria-label": xq("delete"),
                        onClick: i
                    }, [u ? u() : I($t, {
                        name: "cross",
                        class: zt("preview-delete-icon")
                    }, null)])
                }
            },
            l = () => {
                if (n["preview-cover"]) {
                    const {
                        index: u,
                        item: d
                    } = t;
                    return I("div", {
                        class: zt("preview-cover")
                    }, [n["preview-cover"](Ne({
                        index: u
                    }, d))])
                }
            },
            c = () => {
                const {
                    item: u,
                    lazyLoad: d,
                    imageFit: f,
                    previewSize: h,
                    reupload: p
                } = t;
                return U2(u) ? I(y2, {
                    fit: f,
                    src: u.objectUrl || u.content || u.url,
                    class: zt("preview-image"),
                    width: Array.isArray(h) ? h[0] : h,
                    height: Array.isArray(h) ? h[1] : h,
                    lazyLoad: d,
                    onClick: p ? o : s
                }, {
                    default: l
                }) : I("div", {
                    class: zt("file"),
                    style: fa(t.previewSize)
                }, [I($t, {
                    class: zt("file-icon"),
                    name: "description"
                }, null), I("div", {
                    class: [zt("file-name"), "van-ellipsis"]
                }, [u.file ? u.file.name : u.url]), l()])
            };
        return () => I("div", {
            class: zt("preview")
        }, [c(), r(), a()])
    }
});
const Cq = {
    name: Fe(""),
    accept: Pe("image/*"),
    capture: String,
    multiple: Boolean,
    disabled: Boolean,
    readonly: Boolean,
    lazyLoad: Boolean,
    maxCount: Fe(1 / 0),
    imageFit: Pe("cover"),
    resultType: Pe("dataUrl"),
    uploadIcon: Pe("photograph"),
    uploadText: String,
    deletable: me,
    reupload: Boolean,
    afterRead: Function,
    showUpload: me,
    modelValue: Gi(),
    beforeRead: Function,
    beforeDelete: Function,
    previewSize: [Number, String, Array],
    previewImage: me,
    previewOptions: Object,
    previewFullImage: me,
    maxSize: {
        type: [Number, String, Function],
        default: 1 / 0
    }
};
var Pq = ye({
    name: bq,
    props: Cq,
    emits: ["delete", "oversize", "clickUpload", "closePreview", "clickPreview", "clickReupload", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = J(),
            i = [],
            s = J(-1),
            o = J(!1),
            a = (C = t.modelValue.length) => ({
                name: t.name,
                index: C
            }),
            l = () => {
                r.value && (r.value.value = "")
            },
            c = C => {
                if (l(), N2(C, t.maxSize))
                    if (Array.isArray(C)) {
                        const A = wq(C, t.maxSize);
                        if (C = A.valid, e("oversize", A.invalid, a()), !C.length) return
                    } else {
                        e("oversize", C, a());
                        return
                    }
                if (C = ht(C), s.value > -1) {
                    const A = [...t.modelValue];
                    A.splice(s.value, 1, C), e("update:modelValue", A), s.value = -1
                } else e("update:modelValue", [...t.modelValue, ...oh(C)]);
                t.afterRead && t.afterRead(C, a())
            },
            u = C => {
                const {
                    maxCount: A,
                    modelValue: T,
                    resultType: E
                } = t;
                if (Array.isArray(C)) {
                    const P = +A - T.length;
                    C.length > P && (C = C.slice(0, P)), Promise.all(C.map(B => AS(B, E))).then(B => {
                        const F = C.map((H, k) => {
                            const N = {
                                file: H,
                                status: "",
                                message: "",
                                objectUrl: URL.createObjectURL(H)
                            };
                            return B[k] && (N.content = B[k]), N
                        });
                        c(F)
                    })
                } else AS(C, E).then(P => {
                    const B = {
                        file: C,
                        status: "",
                        message: "",
                        objectUrl: URL.createObjectURL(C)
                    };
                    P && (B.content = P), c(B)
                })
            },
            d = C => {
                const {
                    files: A
                } = C.target;
                if (t.disabled || !A || !A.length) return;
                const T = A.length === 1 ? A[0] : [].slice.call(A);
                if (t.beforeRead) {
                    const E = t.beforeRead(T, a());
                    if (!E) {
                        l();
                        return
                    }
                    if (vb(E)) {
                        E.then(P => {
                            u(P || T)
                        }).catch(l);
                        return
                    }
                }
                u(T)
            };
        let f;
        const h = () => e("closePreview"),
            p = C => {
                if (t.previewFullImage) {
                    const A = t.modelValue.filter(U2),
                        T = A.map(E => (E.objectUrl && !E.url && E.status !== "failed" && (E.url = E.objectUrl, i.push(E.url)), E.url)).filter(Boolean);
                    f = pX(Ne({
                        images: T,
                        startPosition: A.indexOf(C),
                        onClose: h
                    }, t.previewOptions))
                }
            },
            b = () => {
                f && f.close()
            },
            y = (C, A) => {
                const T = t.modelValue.slice(0);
                T.splice(A, 1), e("update:modelValue", T), e("delete", C, a(A))
            },
            m = C => {
                o.value = !0, s.value = C, Ue(() => S())
            },
            g = () => {
                o.value || (s.value = -1), o.value = !1
            },
            v = (C, A) => {
                const T = ["imageFit", "deletable", "reupload", "previewSize", "beforeDelete"],
                    E = Ne(wt(t, T), wt(C, T, !0));
                return I(Tq, et({
                    item: C,
                    index: A,
                    onClick: () => e(t.reupload ? "clickReupload" : "clickPreview", C, a(A)),
                    onDelete: () => y(C, A),
                    onPreview: () => p(C),
                    onReupload: () => m(A)
                }, wt(t, ["name", "lazyLoad"]), E), wt(n, ["preview-cover", "preview-delete"]))
            },
            _ = () => {
                if (t.previewImage) return t.modelValue.map(v)
            },
            x = C => e("clickUpload", C),
            w = () => {
                const C = t.modelValue.length < +t.maxCount,
                    A = t.readonly ? null : I("input", {
                        ref: r,
                        type: "file",
                        class: zt("input"),
                        accept: t.accept,
                        capture: t.capture,
                        multiple: t.multiple && s.value === -1,
                        disabled: t.disabled,
                        onChange: d,
                        onClick: g
                    }, null);
                return n.default ? Cr(I("div", {
                    class: zt("input-wrapper"),
                    onClick: x
                }, [n.default(), A]), [
                    [Ar, C]
                ]) : Cr(I("div", {
                    class: zt("upload", {
                        readonly: t.readonly
                    }),
                    style: fa(t.previewSize),
                    onClick: x
                }, [I($t, {
                    name: t.uploadIcon,
                    class: zt("upload-icon")
                }, null), t.uploadText && I("span", {
                    class: zt("upload-text")
                }, [t.uploadText]), A]), [
                    [Ar, t.showUpload && C]
                ])
            },
            S = () => {
                r.value && !t.disabled && r.value.click()
            };
        return er(() => {
            i.forEach(C => URL.revokeObjectURL(C))
        }), Tt({
            chooseFile: S,
            reuploadFile: m,
            closeImagePreview: b
        }), da(() => t.modelValue), () => I("div", {
            class: zt()
        }, [I("div", {
            class: zt("wrapper", {
                disabled: t.disabled
            })
        }, [_(), w()])])
    }
});
const I_e = Ae(Pq);
/*!
 * shared v11.1.2
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
const Mr = typeof window < "u";
let Vn, Vo; {
    const t = Mr && window.performance;
    t && t.mark && t.measure && t.clearMarks && t.clearMeasures && (Vn = e => {
        t.mark(e)
    }, Vo = (e, n, r) => {
        t.measure(e, n, r), t.clearMarks(n), t.clearMarks(r)
    })
}
const Aq = /\{([0-9a-zA-Z]+)\}/g;

function Sp(t, ...e) {
    return e.length === 1 && Ke(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), t.replace(Aq, (n, r) => e.hasOwnProperty(r) ? e[r] : "")
}
const ci = (t, e = !1) => e ? Symbol.for(t) : Symbol(t),
    Oq = (t, e, n) => Iq({
        l: t,
        k: e,
        s: n
    }),
    Iq = t => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"),
    Lt = t => typeof t == "number" && isFinite(t),
    Rq = t => kb(t) === "[object Date]",
    dl = t => kb(t) === "[object RegExp]",
    Tp = t => Ge(t) && Object.keys(t).length === 0,
    Vt = Object.assign,
    Mq = Object.create,
    ot = (t = null) => Mq(t);
let OS;
const wo = () => OS || (OS = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : ot());

function IS(t) {
    return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
}
const kq = Object.prototype.hasOwnProperty;

function Sr(t, e) {
    return kq.call(t, e)
}
const Dt = Array.isArray,
    lt = t => typeof t == "function",
    _e = t => typeof t == "string",
    Je = t => typeof t == "boolean",
    Ke = t => t !== null && typeof t == "object",
    Bq = t => Ke(t) && lt(t.then) && lt(t.catch),
    G2 = Object.prototype.toString,
    kb = t => G2.call(t),
    Ge = t => kb(t) === "[object Object]",
    Dq = t => t == null ? "" : Dt(t) || Ge(t) && t.toString === G2 ? JSON.stringify(t, null, 2) : String(t);

function Bb(t, e = "") {
    return t.reduce((n, r, i) => i === 0 ? n + r : n + e + r, "")
}
const RS = 2;

function $q(t, e = 0, n = t.length) {
    const r = t.split(/\r?\n/);
    let i = 0;
    const s = [];
    for (let o = 0; o < r.length; o++)
        if (i += r[o].length + 1, i >= e) {
            for (let a = o - RS; a <= o + RS || n > i; a++) {
                if (a < 0 || a >= r.length) continue;
                const l = a + 1;
                s.push(`${l}${" ".repeat(3-String(l).length)}|  ${r[a]}`);
                const c = r[a].length;
                if (a === o) {
                    const u = e - (i - c) + 1,
                        d = Math.max(1, n > i ? c - u : n - e);
                    s.push("   |  " + " ".repeat(u) + "^".repeat(d))
                } else if (a > o) {
                    if (n > i) {
                        const u = Math.max(Math.min(n - i, c), 1);
                        s.push("   |  " + "^".repeat(u))
                    }
                    i += c + 1
                }
            }
            break
        }
    return s.join(`
`)
}

function Ys(t, e) {
    typeof console < "u" && (console.warn("[intlify] " + t), e && console.warn(e.stack))
}
const MS = {};

function Db(t) {
    MS[t] || (MS[t] = !0, Ys(t))
}

function $b() {
    const t = new Map;
    return {
        events: t,
        on(n, r) {
            const i = t.get(n);
            i && i.push(r) || t.set(n, [r])
        },
        off(n, r) {
            const i = t.get(n);
            i && i.splice(i.indexOf(r) >>> 0, 1)
        },
        emit(n, r) {
            (t.get(n) || []).slice().map(i => i(r)), (t.get("*") || []).slice().map(i => i(n, r))
        }
    }
}
const Gd = t => !Ke(t) || Dt(t);

function Rf(t, e) {
    if (Gd(t) || Gd(e)) throw new Error("Invalid value");
    const n = [{
        src: t,
        des: e
    }];
    for (; n.length;) {
        const {
            src: r,
            des: i
        } = n.pop();
        Object.keys(r).forEach(s => {
            s !== "__proto__" && (Ke(r[s]) && !Ke(i[s]) && (i[s] = Array.isArray(r[s]) ? [] : ot()), Gd(i[s]) || Gd(r[s]) ? i[s] = r[s] : n.push({
                src: r[s],
                des: i[s]
            }))
        })
    }
}
/*!
 * message-compiler v11.1.2
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
function Fq(t, e, n) {
    return {
        line: t,
        column: e,
        offset: n
    }
}

function Cy(t, e, n) {
    const r = {
        start: t,
        end: e
    };
    return n != null && (r.source = n), r
}
const De = {
        EXPECTED_TOKEN: 1,
        INVALID_TOKEN_IN_PLACEHOLDER: 2,
        UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
        UNKNOWN_ESCAPE_SEQUENCE: 4,
        INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
        UNBALANCED_CLOSING_BRACE: 6,
        UNTERMINATED_CLOSING_BRACE: 7,
        EMPTY_PLACEHOLDER: 8,
        NOT_ALLOW_NEST_PLACEHOLDER: 9,
        INVALID_LINKED_FORMAT: 10,
        MUST_HAVE_MESSAGES_IN_PLURAL: 11,
        UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
        UNEXPECTED_EMPTY_LINKED_KEY: 13,
        UNEXPECTED_LEXICAL_ANALYSIS: 14,
        UNHANDLED_CODEGEN_NODE_TYPE: 15,
        UNHANDLED_MINIFIER_NODE_TYPE: 16
    },
    Lq = 17,
    Nq = {
        [De.EXPECTED_TOKEN]: "Expected token: '{0}'",
        [De.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
        [De.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
        [De.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
        [De.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
        [De.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
        [De.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
        [De.EMPTY_PLACEHOLDER]: "Empty placeholder",
        [De.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
        [De.INVALID_LINKED_FORMAT]: "Invalid linked format",
        [De.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
        [De.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
        [De.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
        [De.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
        [De.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
        [De.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
    };

function Fl(t, e, n = {}) {
    const {
        domain: r,
        messages: i,
        args: s
    } = n, o = Sp((i || Nq)[t] || "", ...s || []), a = new SyntaxError(String(o));
    return a.code = t, e && (a.location = e), a.domain = r, a
}

function Uq(t) {
    throw t
}
const Gq = /<\/?[\w\s="/.':;#-\/]+>/,
    Hq = t => Gq.test(t),
    pi = " ",
    zq = "\r",
    vn = `
`,
    jq = String.fromCharCode(8232),
    Vq = String.fromCharCode(8233);

function Wq(t) {
    const e = t;
    let n = 0,
        r = 1,
        i = 1,
        s = 0;
    const o = S => e[S] === zq && e[S + 1] === vn,
        a = S => e[S] === vn,
        l = S => e[S] === Vq,
        c = S => e[S] === jq,
        u = S => o(S) || a(S) || l(S) || c(S),
        d = () => n,
        f = () => r,
        h = () => i,
        p = () => s,
        b = S => o(S) || l(S) || c(S) ? vn : e[S],
        y = () => b(n),
        m = () => b(n + s);

    function g() {
        return s = 0, u(n) && (r++, i = 0), o(n) && n++, n++, i++, e[n]
    }

    function v() {
        return o(n + s) && s++, s++, e[n + s]
    }

    function _() {
        n = 0, r = 1, i = 1, s = 0
    }

    function x(S = 0) {
        s = S
    }

    function w() {
        const S = n + s;
        for (; S !== n;) g();
        s = 0
    }
    return {
        index: d,
        line: f,
        column: h,
        peekOffset: p,
        charAt: b,
        currentChar: y,
        currentPeek: m,
        next: g,
        peek: v,
        reset: _,
        resetPeek: x,
        skipToPeek: w
    }
}
const rs = void 0,
    Yq = ".",
    kS = "'",
    Xq = "tokenizer";

function Kq(t, e = {}) {
    const n = e.location !== !1,
        r = Wq(t),
        i = () => r.index(),
        s = () => Fq(r.line(), r.column(), r.index()),
        o = s(),
        a = i(),
        l = {
            currentType: 13,
            offset: a,
            startLoc: o,
            endLoc: o,
            lastType: 13,
            lastOffset: a,
            lastStartLoc: o,
            lastEndLoc: o,
            braceNest: 0,
            inLinked: !1,
            text: ""
        },
        c = () => l,
        {
            onError: u
        } = e;

    function d(R, M, U, ...q) {
        const se = c();
        if (M.column += U, M.offset += U, u) {
            const he = n ? Cy(se.startLoc, M) : null,
                ue = Fl(R, he, {
                    domain: Xq,
                    args: q
                });
            u(ue)
        }
    }

    function f(R, M, U) {
        R.endLoc = s(), R.currentType = M;
        const q = {
            type: M
        };
        return n && (q.loc = Cy(R.startLoc, R.endLoc)), U != null && (q.value = U), q
    }
    const h = R => f(R, 13);

    function p(R, M) {
        return R.currentChar() === M ? (R.next(), M) : (d(De.EXPECTED_TOKEN, s(), 0, M), "")
    }

    function b(R) {
        let M = "";
        for (; R.currentPeek() === pi || R.currentPeek() === vn;) M += R.currentPeek(), R.peek();
        return M
    }

    function y(R) {
        const M = b(R);
        return R.skipToPeek(), M
    }

    function m(R) {
        if (R === rs) return !1;
        const M = R.charCodeAt(0);
        return M >= 97 && M <= 122 || M >= 65 && M <= 90 || M === 95
    }

    function g(R) {
        if (R === rs) return !1;
        const M = R.charCodeAt(0);
        return M >= 48 && M <= 57
    }

    function v(R, M) {
        const {
            currentType: U
        } = M;
        if (U !== 2) return !1;
        b(R);
        const q = m(R.currentPeek());
        return R.resetPeek(), q
    }

    function _(R, M) {
        const {
            currentType: U
        } = M;
        if (U !== 2) return !1;
        b(R);
        const q = R.currentPeek() === "-" ? R.peek() : R.currentPeek(),
            se = g(q);
        return R.resetPeek(), se
    }

    function x(R, M) {
        const {
            currentType: U
        } = M;
        if (U !== 2) return !1;
        b(R);
        const q = R.currentPeek() === kS;
        return R.resetPeek(), q
    }

    function w(R, M) {
        const {
            currentType: U
        } = M;
        if (U !== 7) return !1;
        b(R);
        const q = R.currentPeek() === ".";
        return R.resetPeek(), q
    }

    function S(R, M) {
        const {
            currentType: U
        } = M;
        if (U !== 8) return !1;
        b(R);
        const q = m(R.currentPeek());
        return R.resetPeek(), q
    }

    function C(R, M) {
        const {
            currentType: U
        } = M;
        if (!(U === 7 || U === 11)) return !1;
        b(R);
        const q = R.currentPeek() === ":";
        return R.resetPeek(), q
    }

    function A(R, M) {
        const {
            currentType: U
        } = M;
        if (U !== 9) return !1;
        const q = () => {
                const he = R.currentPeek();
                return he === "{" ? m(R.peek()) : he === "@" || he === "|" || he === ":" || he === "." || he === pi || !he ? !1 : he === vn ? (R.peek(), q()) : E(R, !1)
            },
            se = q();
        return R.resetPeek(), se
    }

    function T(R) {
        b(R);
        const M = R.currentPeek() === "|";
        return R.resetPeek(), M
    }

    function E(R, M = !0) {
        const U = (se = !1, he = "") => {
                const ue = R.currentPeek();
                return ue === "{" || ue === "@" || !ue ? se : ue === "|" ? !(he === pi || he === vn) : ue === pi ? (R.peek(), U(!0, pi)) : ue === vn ? (R.peek(), U(!0, vn)) : !0
            },
            q = U();
        return M && R.resetPeek(), q
    }

    function P(R, M) {
        const U = R.currentChar();
        return U === rs ? rs : M(U) ? (R.next(), U) : null
    }

    function B(R) {
        const M = R.charCodeAt(0);
        return M >= 97 && M <= 122 || M >= 65 && M <= 90 || M >= 48 && M <= 57 || M === 95 || M === 36
    }

    function F(R) {
        return P(R, B)
    }

    function H(R) {
        const M = R.charCodeAt(0);
        return M >= 97 && M <= 122 || M >= 65 && M <= 90 || M >= 48 && M <= 57 || M === 95 || M === 36 || M === 45
    }

    function k(R) {
        return P(R, H)
    }

    function N(R) {
        const M = R.charCodeAt(0);
        return M >= 48 && M <= 57
    }

    function V(R) {
        return P(R, N)
    }

    function Y(R) {
        const M = R.charCodeAt(0);
        return M >= 48 && M <= 57 || M >= 65 && M <= 70 || M >= 97 && M <= 102
    }

    function le(R) {
        return P(R, Y)
    }

    function ae(R) {
        let M = "",
            U = "";
        for (; M = V(R);) U += M;
        return U
    }

    function W(R) {
        let M = "";
        for (;;) {
            const U = R.currentChar();
            if (U === "{" || U === "}" || U === "@" || U === "|" || !U) break;
            if (U === pi || U === vn)
                if (E(R)) M += U, R.next();
                else {
                    if (T(R)) break;
                    M += U, R.next()
                }
            else M += U, R.next()
        }
        return M
    }

    function Q(R) {
        y(R);
        let M = "",
            U = "";
        for (; M = k(R);) U += M;
        return R.currentChar() === rs && d(De.UNTERMINATED_CLOSING_BRACE, s(), 0), U
    }

    function fe(R) {
        y(R);
        let M = "";
        return R.currentChar() === "-" ? (R.next(), M += `-${ae(R)}`) : M += ae(R), R.currentChar() === rs && d(De.UNTERMINATED_CLOSING_BRACE, s(), 0), M
    }

    function D(R) {
        return R !== kS && R !== vn
    }

    function X(R) {
        y(R), p(R, "'");
        let M = "",
            U = "";
        for (; M = P(R, D);) M === "\\" ? U += $(R) : U += M;
        const q = R.currentChar();
        return q === vn || q === rs ? (d(De.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, s(), 0), q === vn && (R.next(), p(R, "'")), U) : (p(R, "'"), U)
    }

    function $(R) {
        const M = R.currentChar();
        switch (M) {
            case "\\":
            case "'":
                return R.next(), `\\${M}`;
            case "u":
                return Z(R, M, 4);
            case "U":
                return Z(R, M, 6);
            default:
                return d(De.UNKNOWN_ESCAPE_SEQUENCE, s(), 0, M), ""
        }
    }

    function Z(R, M, U) {
        p(R, M);
        let q = "";
        for (let se = 0; se < U; se++) {
            const he = le(R);
            if (!he) {
                d(De.INVALID_UNICODE_ESCAPE_SEQUENCE, s(), 0, `\\${M}${q}${R.currentChar()}`);
                break
            }
            q += he
        }
        return `\\${M}${q}`
    }

    function K(R) {
        return R !== "{" && R !== "}" && R !== pi && R !== vn
    }

    function ce(R) {
        y(R);
        let M = "",
            U = "";
        for (; M = P(R, K);) U += M;
        return U
    }

    function de(R) {
        let M = "",
            U = "";
        for (; M = F(R);) U += M;
        return U
    }

    function ge(R) {
        const M = U => {
            const q = R.currentChar();
            return q === "{" || q === "@" || q === "|" || q === "(" || q === ")" || !q || q === pi ? U : (U += q, R.next(), M(U))
        };
        return M("")
    }

    function O(R) {
        y(R);
        const M = p(R, "|");
        return y(R), M
    }

    function L(R, M) {
        let U = null;
        switch (R.currentChar()) {
            case "{":
                return M.braceNest >= 1 && d(De.NOT_ALLOW_NEST_PLACEHOLDER, s(), 0), R.next(), U = f(M, 2, "{"), y(R), M.braceNest++, U;
            case "}":
                return M.braceNest > 0 && M.currentType === 2 && d(De.EMPTY_PLACEHOLDER, s(), 0), R.next(), U = f(M, 3, "}"), M.braceNest--, M.braceNest > 0 && y(R), M.inLinked && M.braceNest === 0 && (M.inLinked = !1), U;
            case "@":
                return M.braceNest > 0 && d(De.UNTERMINATED_CLOSING_BRACE, s(), 0), U = j(R, M) || h(M), M.braceNest = 0, U;
            default:
                {
                    let se = !0,
                        he = !0,
                        ue = !0;
                    if (T(R)) return M.braceNest > 0 && d(De.UNTERMINATED_CLOSING_BRACE, s(), 0), U = f(M, 1, O(R)), M.braceNest = 0, M.inLinked = !1, U;
                    if (M.braceNest > 0 && (M.currentType === 4 || M.currentType === 5 || M.currentType === 6)) return d(De.UNTERMINATED_CLOSING_BRACE, s(), 0), M.braceNest = 0, ie(R, M);
                    if (se = v(R, M)) return U = f(M, 4, Q(R)), y(R), U;
                    if (he = _(R, M)) return U = f(M, 5, fe(R)), y(R), U;
                    if (ue = x(R, M)) return U = f(M, 6, X(R)), y(R), U;
                    if (!se && !he && !ue) return U = f(M, 12, ce(R)), d(De.INVALID_TOKEN_IN_PLACEHOLDER, s(), 0, U.value), y(R), U;
                    break
                }
        }
        return U
    }

    function j(R, M) {
        const {
            currentType: U
        } = M;
        let q = null;
        const se = R.currentChar();
        switch ((U === 7 || U === 8 || U === 11 || U === 9) && (se === vn || se === pi) && d(De.INVALID_LINKED_FORMAT, s(), 0), se) {
            case "@":
                return R.next(), q = f(M, 7, "@"), M.inLinked = !0, q;
            case ".":
                return y(R), R.next(), f(M, 8, ".");
            case ":":
                return y(R), R.next(), f(M, 9, ":");
            default:
                return T(R) ? (q = f(M, 1, O(R)), M.braceNest = 0, M.inLinked = !1, q) : w(R, M) || C(R, M) ? (y(R), j(R, M)) : S(R, M) ? (y(R), f(M, 11, de(R))) : A(R, M) ? (y(R), se === "{" ? L(R, M) || q : f(M, 10, ge(R))) : (U === 7 && d(De.INVALID_LINKED_FORMAT, s(), 0), M.braceNest = 0, M.inLinked = !1, ie(R, M))
        }
    }

    function ie(R, M) {
        let U = {
            type: 13
        };
        if (M.braceNest > 0) return L(R, M) || h(M);
        if (M.inLinked) return j(R, M) || h(M);
        switch (R.currentChar()) {
            case "{":
                return L(R, M) || h(M);
            case "}":
                return d(De.UNBALANCED_CLOSING_BRACE, s(), 0), R.next(), f(M, 3, "}");
            case "@":
                return j(R, M) || h(M);
            default:
                {
                    if (T(R)) return U = f(M, 1, O(R)), M.braceNest = 0, M.inLinked = !1, U;
                    if (E(R)) return f(M, 0, W(R));
                    break
                }
        }
        return U
    }

    function oe() {
        const {
            currentType: R,
            offset: M,
            startLoc: U,
            endLoc: q
        } = l;
        return l.lastType = R, l.lastOffset = M, l.lastStartLoc = U, l.lastEndLoc = q, l.offset = i(), l.startLoc = s(), r.currentChar() === rs ? f(l, 13) : ie(r, l)
    }
    return {
        nextToken: oe,
        currentOffset: i,
        currentPosition: s,
        context: c
    }
}
const qq = "parser",
    Jq = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

function Zq(t, e, n) {
    switch (t) {
        case "\\\\":
            return "\\";
        case "\\'":
            return "'";
        default:
            {
                const r = parseInt(e || n, 16);
                return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : "�"
            }
    }
}

function Qq(t = {}) {
    const e = t.location !== !1,
        {
            onError: n
        } = t;

    function r(m, g, v, _, ...x) {
        const w = m.currentPosition();
        if (w.offset += _, w.column += _, n) {
            const S = e ? Cy(v, w) : null,
                C = Fl(g, S, {
                    domain: qq,
                    args: x
                });
            n(C)
        }
    }

    function i(m, g, v) {
        const _ = {
            type: m
        };
        return e && (_.start = g, _.end = g, _.loc = {
            start: v,
            end: v
        }), _
    }

    function s(m, g, v, _) {
        e && (m.end = g, m.loc && (m.loc.end = v))
    }

    function o(m, g) {
        const v = m.context(),
            _ = i(3, v.offset, v.startLoc);
        return _.value = g, s(_, m.currentOffset(), m.currentPosition()), _
    }

    function a(m, g) {
        const v = m.context(),
            {
                lastOffset: _,
                lastStartLoc: x
            } = v,
            w = i(5, _, x);
        return w.index = parseInt(g, 10), m.nextToken(), s(w, m.currentOffset(), m.currentPosition()), w
    }

    function l(m, g) {
        const v = m.context(),
            {
                lastOffset: _,
                lastStartLoc: x
            } = v,
            w = i(4, _, x);
        return w.key = g, m.nextToken(), s(w, m.currentOffset(), m.currentPosition()), w
    }

    function c(m, g) {
        const v = m.context(),
            {
                lastOffset: _,
                lastStartLoc: x
            } = v,
            w = i(9, _, x);
        return w.value = g.replace(Jq, Zq), m.nextToken(), s(w, m.currentOffset(), m.currentPosition()), w
    }

    function u(m) {
        const g = m.nextToken(),
            v = m.context(),
            {
                lastOffset: _,
                lastStartLoc: x
            } = v,
            w = i(8, _, x);
        return g.type !== 11 ? (r(m, De.UNEXPECTED_EMPTY_LINKED_MODIFIER, v.lastStartLoc, 0), w.value = "", s(w, _, x), {
            nextConsumeToken: g,
            node: w
        }) : (g.value == null && r(m, De.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, Nr(g)), w.value = g.value || "", s(w, m.currentOffset(), m.currentPosition()), {
            node: w
        })
    }

    function d(m, g) {
        const v = m.context(),
            _ = i(7, v.offset, v.startLoc);
        return _.value = g, s(_, m.currentOffset(), m.currentPosition()), _
    }

    function f(m) {
        const g = m.context(),
            v = i(6, g.offset, g.startLoc);
        let _ = m.nextToken();
        if (_.type === 8) {
            const x = u(m);
            v.modifier = x.node, _ = x.nextConsumeToken || m.nextToken()
        }
        switch (_.type !== 9 && r(m, De.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Nr(_)), _ = m.nextToken(), _.type === 2 && (_ = m.nextToken()), _.type) {
            case 10:
                _.value == null && r(m, De.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Nr(_)), v.key = d(m, _.value || "");
                break;
            case 4:
                _.value == null && r(m, De.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Nr(_)), v.key = l(m, _.value || "");
                break;
            case 5:
                _.value == null && r(m, De.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Nr(_)), v.key = a(m, _.value || "");
                break;
            case 6:
                _.value == null && r(m, De.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Nr(_)), v.key = c(m, _.value || "");
                break;
            default:
                {
                    r(m, De.UNEXPECTED_EMPTY_LINKED_KEY, g.lastStartLoc, 0);
                    const x = m.context(),
                        w = i(7, x.offset, x.startLoc);
                    return w.value = "",
                    s(w, x.offset, x.startLoc),
                    v.key = w,
                    s(v, x.offset, x.startLoc),
                    {
                        nextConsumeToken: _,
                        node: v
                    }
                }
        }
        return s(v, m.currentOffset(), m.currentPosition()), {
            node: v
        }
    }

    function h(m) {
        const g = m.context(),
            v = g.currentType === 1 ? m.currentOffset() : g.offset,
            _ = g.currentType === 1 ? g.endLoc : g.startLoc,
            x = i(2, v, _);
        x.items = [];
        let w = null;
        do {
            const A = w || m.nextToken();
            switch (w = null, A.type) {
                case 0:
                    A.value == null && r(m, De.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Nr(A)), x.items.push(o(m, A.value || ""));
                    break;
                case 5:
                    A.value == null && r(m, De.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Nr(A)), x.items.push(a(m, A.value || ""));
                    break;
                case 4:
                    A.value == null && r(m, De.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Nr(A)), x.items.push(l(m, A.value || ""));
                    break;
                case 6:
                    A.value == null && r(m, De.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, Nr(A)), x.items.push(c(m, A.value || ""));
                    break;
                case 7:
                    {
                        const T = f(m);x.items.push(T.node),
                        w = T.nextConsumeToken || null;
                        break
                    }
            }
        } while (g.currentType !== 13 && g.currentType !== 1);
        const S = g.currentType === 1 ? g.lastOffset : m.currentOffset(),
            C = g.currentType === 1 ? g.lastEndLoc : m.currentPosition();
        return s(x, S, C), x
    }

    function p(m, g, v, _) {
        const x = m.context();
        let w = _.items.length === 0;
        const S = i(1, g, v);
        S.cases = [], S.cases.push(_);
        do {
            const C = h(m);
            w || (w = C.items.length === 0), S.cases.push(C)
        } while (x.currentType !== 13);
        return w && r(m, De.MUST_HAVE_MESSAGES_IN_PLURAL, v, 0), s(S, m.currentOffset(), m.currentPosition()), S
    }

    function b(m) {
        const g = m.context(),
            {
                offset: v,
                startLoc: _
            } = g,
            x = h(m);
        return g.currentType === 13 ? x : p(m, v, _, x)
    }

    function y(m) {
        const g = Kq(m, Vt({}, t)),
            v = g.context(),
            _ = i(0, v.offset, v.startLoc);
        return e && _.loc && (_.loc.source = m), _.body = b(g), t.onCacheKey && (_.cacheKey = t.onCacheKey(m)), v.currentType !== 13 && r(g, De.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, m[v.offset] || ""), s(_, g.currentOffset(), g.currentPosition()), _
    }
    return {
        parse: y
    }
}

function Nr(t) {
    if (t.type === 13) return "EOF";
    const e = (t.value || "").replace(/\r?\n/gu, "\\n");
    return e.length > 10 ? e.slice(0, 9) + "…" : e
}

function eJ(t, e = {}) {
    const n = {
        ast: t,
        helpers: new Set
    };
    return {
        context: () => n,
        helper: s => (n.helpers.add(s), s)
    }
}

function BS(t, e) {
    for (let n = 0; n < t.length; n++) Fb(t[n], e)
}

function Fb(t, e) {
    switch (t.type) {
        case 1:
            BS(t.cases, e), e.helper("plural");
            break;
        case 2:
            BS(t.items, e);
            break;
        case 6:
            {
                Fb(t.key, e),
                e.helper("linked"),
                e.helper("type");
                break
            }
        case 5:
            e.helper("interpolate"), e.helper("list");
            break;
        case 4:
            e.helper("interpolate"), e.helper("named");
            break
    }
}

function tJ(t, e = {}) {
    const n = eJ(t);
    n.helper("normalize"), t.body && Fb(t.body, n);
    const r = n.context();
    t.helpers = Array.from(r.helpers)
}

function nJ(t) {
    const e = t.body;
    return e.type === 2 ? DS(e) : e.cases.forEach(n => DS(n)), t
}

function DS(t) {
    if (t.items.length === 1) {
        const e = t.items[0];
        (e.type === 3 || e.type === 9) && (t.static = e.value, delete e.value)
    } else {
        const e = [];
        for (let n = 0; n < t.items.length; n++) {
            const r = t.items[n];
            if (!(r.type === 3 || r.type === 9) || r.value == null) break;
            e.push(r.value)
        }
        if (e.length === t.items.length) {
            t.static = Bb(e);
            for (let n = 0; n < t.items.length; n++) {
                const r = t.items[n];
                (r.type === 3 || r.type === 9) && delete r.value
            }
        }
    }
}
const rJ = "minifier";

function Fa(t) {
    switch (t.t = t.type, t.type) {
        case 0:
            {
                const e = t;Fa(e.body),
                e.b = e.body,
                delete e.body;
                break
            }
        case 1:
            {
                const e = t,
                    n = e.cases;
                for (let r = 0; r < n.length; r++) Fa(n[r]);e.c = n,
                delete e.cases;
                break
            }
        case 2:
            {
                const e = t,
                    n = e.items;
                for (let r = 0; r < n.length; r++) Fa(n[r]);e.i = n,
                delete e.items,
                e.static && (e.s = e.static, delete e.static);
                break
            }
        case 3:
        case 9:
        case 8:
        case 7:
            {
                const e = t;e.value && (e.v = e.value, delete e.value);
                break
            }
        case 6:
            {
                const e = t;Fa(e.key),
                e.k = e.key,
                delete e.key,
                e.modifier && (Fa(e.modifier), e.m = e.modifier, delete e.modifier);
                break
            }
        case 5:
            {
                const e = t;e.i = e.index,
                delete e.index;
                break
            }
        case 4:
            {
                const e = t;e.k = e.key,
                delete e.key;
                break
            }
        default:
            throw Fl(De.UNHANDLED_MINIFIER_NODE_TYPE, null, {
                domain: rJ,
                args: [t.type]
            })
    }
    delete t.type
}
const iJ = "parser";

function sJ(t, e) {
    const {
        sourceMap: n,
        filename: r,
        breakLineCode: i,
        needIndent: s
    } = e, o = e.location !== !1, a = {
        filename: r,
        code: "",
        column: 1,
        line: 1,
        offset: 0,
        map: void 0,
        breakLineCode: i,
        needIndent: s,
        indentLevel: 0
    };
    o && t.loc && (a.source = t.loc.source);
    const l = () => a;

    function c(y, m) {
        a.code += y
    }

    function u(y, m = !0) {
        const g = m ? i : "";
        c(s ? g + "  ".repeat(y) : g)
    }

    function d(y = !0) {
        const m = ++a.indentLevel;
        y && u(m)
    }

    function f(y = !0) {
        const m = --a.indentLevel;
        y && u(m)
    }

    function h() {
        u(a.indentLevel)
    }
    return {
        context: l,
        push: c,
        indent: d,
        deindent: f,
        newline: h,
        helper: y => `_${y}`,
        needIndent: () => a.needIndent
    }
}

function oJ(t, e) {
    const {
        helper: n
    } = t;
    t.push(`${n("linked")}(`), fl(t, e.key), e.modifier ? (t.push(", "), fl(t, e.modifier), t.push(", _type")) : t.push(", undefined, _type"), t.push(")")
}

function aJ(t, e) {
    const {
        helper: n,
        needIndent: r
    } = t;
    t.push(`${n("normalize")}([`), t.indent(r());
    const i = e.items.length;
    for (let s = 0; s < i && (fl(t, e.items[s]), s !== i - 1); s++) t.push(", ");
    t.deindent(r()), t.push("])")
}

function lJ(t, e) {
    const {
        helper: n,
        needIndent: r
    } = t;
    if (e.cases.length > 1) {
        t.push(`${n("plural")}([`), t.indent(r());
        const i = e.cases.length;
        for (let s = 0; s < i && (fl(t, e.cases[s]), s !== i - 1); s++) t.push(", ");
        t.deindent(r()), t.push("])")
    }
}

function cJ(t, e) {
    e.body ? fl(t, e.body) : t.push("null")
}

function fl(t, e) {
    const {
        helper: n
    } = t;
    switch (e.type) {
        case 0:
            cJ(t, e);
            break;
        case 1:
            lJ(t, e);
            break;
        case 2:
            aJ(t, e);
            break;
        case 6:
            oJ(t, e);
            break;
        case 8:
            t.push(JSON.stringify(e.value), e);
            break;
        case 7:
            t.push(JSON.stringify(e.value), e);
            break;
        case 5:
            t.push(`${n("interpolate")}(${n("list")}(${e.index}))`, e);
            break;
        case 4:
            t.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(e.key)}))`, e);
            break;
        case 9:
            t.push(JSON.stringify(e.value), e);
            break;
        case 3:
            t.push(JSON.stringify(e.value), e);
            break;
        default:
            throw Fl(De.UNHANDLED_CODEGEN_NODE_TYPE, null, {
                domain: iJ,
                args: [e.type]
            })
    }
}
const uJ = (t, e = {}) => {
    const n = _e(e.mode) ? e.mode : "normal",
        r = _e(e.filename) ? e.filename : "message.intl",
        i = !!e.sourceMap,
        s = e.breakLineCode != null ? e.breakLineCode : n === "arrow" ? ";" : `
`,
        o = e.needIndent ? e.needIndent : n !== "arrow",
        a = t.helpers || [],
        l = sJ(t, {
            mode: n,
            filename: r,
            sourceMap: i,
            breakLineCode: s,
            needIndent: o
        });
    l.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), l.indent(o), a.length > 0 && (l.push(`const { ${Bb(a.map(d=>`${d}: _${d}`),", ")} } = ctx`), l.newline()), l.push("return "), fl(l, t), l.deindent(o), l.push("}"), delete t.helpers;
    const {
        code: c,
        map: u
    } = l.context();
    return {
        ast: t,
        code: c,
        map: u ? u.toJSON() : void 0
    }
};

function dJ(t, e = {}) {
    const n = Vt({}, e),
        r = !!n.jit,
        i = !!n.minify,
        s = n.optimize == null ? !0 : n.optimize,
        a = Qq(n).parse(t);
    return r ? (s && nJ(a), i && Fa(a), {
        ast: a,
        code: ""
    }) : (tJ(a, n), uJ(a, n))
}
/*!
 * core-base v11.1.2
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
function fJ() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (wo().__INTLIFY_PROD_DEVTOOLS__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (wo().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1)
}

function Dm(t) {
    return n => hJ(n, t)
}

function hJ(t, e) {
    const n = mJ(e);
    if (n == null) throw uu(0);
    if (Lb(n) === 1) {
        const s = vJ(n);
        return t.plural(s.reduce((o, a) => [...o, $S(t, a)], []))
    } else return $S(t, n)
}
const pJ = ["b", "body"];

function mJ(t) {
    return Xs(t, pJ)
}
const gJ = ["c", "cases"];

function vJ(t) {
    return Xs(t, gJ, [])
}

function $S(t, e) {
    const n = _J(e);
    if (n != null) return t.type === "text" ? n : t.normalize([n]); {
        const r = xJ(e).reduce((i, s) => [...i, Py(t, s)], []);
        return t.normalize(r)
    }
}
const yJ = ["s", "static"];

function _J(t) {
    return Xs(t, yJ)
}
const bJ = ["i", "items"];

function xJ(t) {
    return Xs(t, bJ, [])
}

function Py(t, e) {
    const n = Lb(e);
    switch (n) {
        case 3:
            return Hd(e, n);
        case 9:
            return Hd(e, n);
        case 4:
            {
                const r = e;
                if (Sr(r, "k") && r.k) return t.interpolate(t.named(r.k));
                if (Sr(r, "key") && r.key) return t.interpolate(t.named(r.key));
                throw uu(n)
            }
        case 5:
            {
                const r = e;
                if (Sr(r, "i") && Lt(r.i)) return t.interpolate(t.list(r.i));
                if (Sr(r, "index") && Lt(r.index)) return t.interpolate(t.list(r.index));
                throw uu(n)
            }
        case 6:
            {
                const r = e,
                    i = TJ(r),
                    s = PJ(r);
                return t.linked(Py(t, s), i ? Py(t, i) : void 0, t.type)
            }
        case 7:
            return Hd(e, n);
        case 8:
            return Hd(e, n);
        default:
            throw new Error(`unhandled node on format message part: ${n}`)
    }
}
const wJ = ["t", "type"];

function Lb(t) {
    return Xs(t, wJ)
}
const EJ = ["v", "value"];

function Hd(t, e) {
    const n = Xs(t, EJ);
    if (n) return n;
    throw uu(e)
}
const SJ = ["m", "modifier"];

function TJ(t) {
    return Xs(t, SJ)
}
const CJ = ["k", "key"];

function PJ(t) {
    const e = Xs(t, CJ);
    if (e) return e;
    throw uu(6)
}

function Xs(t, e, n) {
    for (let r = 0; r < e.length; r++) {
        const i = e[r];
        if (Sr(t, i) && t[i] != null) return t[i]
    }
    return n
}

function uu(t) {
    return new Error(`unhandled node type: ${t}`)
}
const AJ = "Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.";

function OJ(t, e) {
    e && Hq(t) && Ys(Sp(AJ, {
        source: t
    }))
}
const IJ = t => t;
let zd = ot();

function Ds(t) {
    return Ke(t) && Lb(t) === 0 && (Sr(t, "b") || Sr(t, "body"))
}

function RJ(t, e = {}) {
    let n = !1;
    const r = e.onError || Uq;
    return e.onError = i => {
        n = !0, r(i)
    }, { ...dJ(t, e),
        detectError: n
    }
}

function MJ(t, e) {
    if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && _e(t)) {
        const n = Je(e.warnHtmlMessage) ? e.warnHtmlMessage : !0;
        OJ(t, n);
        const i = (e.onCacheKey || IJ)(t),
            s = zd[i];
        if (s) return s;
        const {
            ast: o,
            detectError: a
        } = RJ(t, { ...e,
            location: !0,
            jit: !0
        }), l = Dm(o);
        return a ? l : zd[i] = l
    } else {
        if (!Ds(t)) return Ys(`the message that is resolve with key '${e.key}' is not supported for jit compilation`), () => t;
        const n = t.cacheKey;
        if (n) {
            const r = zd[n];
            return r || (zd[n] = Dm(t))
        } else return Dm(t)
    }
}
let du = null;

function kJ(t) {
    du = t
}

function BJ(t, e, n) {
    du && du.emit("i18n:init", {
        timestamp: Date.now(),
        i18n: t,
        version: e,
        meta: n
    })
}
const DJ = $J("function:translate");

function $J(t) {
    return e => du && du.emit(t, e)
}
const ln = {
        INVALID_ARGUMENT: Lq,
        INVALID_DATE_ARGUMENT: 18,
        INVALID_ISO_DATE_ARGUMENT: 19,
        NOT_SUPPORT_NON_STRING_MESSAGE: 20,
        NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
        NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
        NOT_SUPPORT_LOCALE_TYPE: 23
    },
    FJ = 24;

function Oi(t) {
    return Fl(t, null, {
        messages: LJ
    })
}
const LJ = {
    [ln.INVALID_ARGUMENT]: "Invalid arguments",
    [ln.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
    [ln.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
    [ln.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
    [ln.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
    [ln.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
    [ln.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};

function Nb(t, e) {
    return e.locale != null ? FS(e.locale) : FS(t.locale)
}
let $m;

function FS(t) {
    if (_e(t)) return t;
    if (lt(t)) {
        if (t.resolvedOnce && $m != null) return $m;
        if (t.constructor.name === "Function") {
            const e = t();
            if (Bq(e)) throw Oi(ln.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
            return $m = e
        } else throw Oi(ln.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION)
    } else throw Oi(ln.NOT_SUPPORT_LOCALE_TYPE)
}

function NJ(t, e, n) {
    return [...new Set([n, ...Dt(e) ? e : Ke(e) ? Object.keys(e) : _e(e) ? [e] : [n]])]
}

function H2(t, e, n) {
    const r = _e(n) ? n : fu,
        i = t;
    i.__localeChainCache || (i.__localeChainCache = new Map);
    let s = i.__localeChainCache.get(r);
    if (!s) {
        s = [];
        let o = [n];
        for (; Dt(o);) o = LS(s, o, e);
        const a = Dt(e) || !Ge(e) ? e : e.default ? e.default : null;
        o = _e(a) ? [a] : a, Dt(o) && LS(s, o, !1), i.__localeChainCache.set(r, s)
    }
    return s
}

function LS(t, e, n) {
    let r = !0;
    for (let i = 0; i < e.length && Je(r); i++) {
        const s = e[i];
        _e(s) && (r = UJ(t, e[i], n))
    }
    return r
}

function UJ(t, e, n) {
    let r;
    const i = e.split("-");
    do {
        const s = i.join("-");
        r = GJ(t, s, n), i.splice(-1, 1)
    } while (i.length && r === !0);
    return r
}

function GJ(t, e, n) {
    let r = !1;
    if (!t.includes(e) && (r = !0, e)) {
        r = e[e.length - 1] !== "!";
        const i = e.replace(/!/g, "");
        t.push(i), (Dt(n) || Ge(n)) && n[i] && (r = n[i])
    }
    return r
}
const Ks = [];
Ks[0] = {
    w: [0],
    i: [3, 0],
    "[": [4],
    o: [7]
};
Ks[1] = {
    w: [1],
    ".": [2],
    "[": [4],
    o: [7]
};
Ks[2] = {
    w: [2],
    i: [3, 0],
    0: [3, 0]
};
Ks[3] = {
    i: [3, 0],
    0: [3, 0],
    w: [1, 1],
    ".": [2, 1],
    "[": [4, 1],
    o: [7, 1]
};
Ks[4] = {
    "'": [5, 0],
    '"': [6, 0],
    "[": [4, 2],
    "]": [1, 3],
    o: 8,
    l: [4, 0]
};
Ks[5] = {
    "'": [4, 0],
    o: 8,
    l: [5, 0]
};
Ks[6] = {
    '"': [4, 0],
    o: 8,
    l: [6, 0]
};
const HJ = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

function zJ(t) {
    return HJ.test(t)
}

function jJ(t) {
    const e = t.charCodeAt(0),
        n = t.charCodeAt(t.length - 1);
    return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t
}

function VJ(t) {
    if (t == null) return "o";
    switch (t.charCodeAt(0)) {
        case 91:
        case 93:
        case 46:
        case 34:
        case 39:
            return t;
        case 95:
        case 36:
        case 45:
            return "i";
        case 9:
        case 10:
        case 13:
        case 160:
        case 65279:
        case 8232:
        case 8233:
            return "w"
    }
    return "i"
}

function WJ(t) {
    const e = t.trim();
    return t.charAt(0) === "0" && isNaN(parseInt(t)) ? !1 : zJ(e) ? jJ(e) : "*" + e
}

function YJ(t) {
    const e = [];
    let n = -1,
        r = 0,
        i = 0,
        s, o, a, l, c, u, d;
    const f = [];
    f[0] = () => {
        o === void 0 ? o = a : o += a
    }, f[1] = () => {
        o !== void 0 && (e.push(o), o = void 0)
    }, f[2] = () => {
        f[0](), i++
    }, f[3] = () => {
        if (i > 0) i--, r = 4, f[0]();
        else {
            if (i = 0, o === void 0 || (o = WJ(o), o === !1)) return !1;
            f[1]()
        }
    };

    function h() {
        const p = t[n + 1];
        if (r === 5 && p === "'" || r === 6 && p === '"') return n++, a = "\\" + p, f[0](), !0
    }
    for (; r !== null;)
        if (n++, s = t[n], !(s === "\\" && h())) {
            if (l = VJ(s), d = Ks[r], c = d[l] || d.l || 8, c === 8 || (r = c[0], c[1] !== void 0 && (u = f[c[1]], u && (a = s, u() === !1)))) return;
            if (r === 7) return e
        }
}
const NS = new Map;

function XJ(t, e) {
    return Ke(t) ? t[e] : null
}

function KJ(t, e) {
    if (!Ke(t)) return null;
    let n = NS.get(e);
    if (n || (n = YJ(e), n && NS.set(e, n)), !n) return null;
    const r = n.length;
    let i = t,
        s = 0;
    for (; s < r;) {
        const o = i[n[s]];
        if (o === void 0 || lt(i)) return null;
        i = o, s++
    }
    return i
}
const In = {
        NOT_FOUND_KEY: 1,
        FALLBACK_TO_TRANSLATE: 2,
        CANNOT_FORMAT_NUMBER: 3,
        FALLBACK_TO_NUMBER_FORMAT: 4,
        CANNOT_FORMAT_DATE: 5,
        FALLBACK_TO_DATE_FORMAT: 6,
        EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: 7
    },
    qJ = 8,
    JJ = {
        [In.NOT_FOUND_KEY]: "Not found '{key}' key in '{locale}' locale messages.",
        [In.FALLBACK_TO_TRANSLATE]: "Fall back to translate '{key}' key with '{target}' locale.",
        [In.CANNOT_FORMAT_NUMBER]: "Cannot format a number value due to not supported Intl.NumberFormat.",
        [In.FALLBACK_TO_NUMBER_FORMAT]: "Fall back to number format '{key}' key with '{target}' locale.",
        [In.CANNOT_FORMAT_DATE]: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
        [In.FALLBACK_TO_DATE_FORMAT]: "Fall back to datetime format '{key}' key with '{target}' locale.",
        [In.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: "This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future."
    };

function Wo(t, ...e) {
    return Sp(JJ[t], ...e)
}
const ZJ = "11.1.2",
    Cp = -1,
    fu = "en-US",
    fh = "",
    US = t => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;

function QJ() {
    return {
        upper: (t, e) => e === "text" && _e(t) ? t.toUpperCase() : e === "vnode" && Ke(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
        lower: (t, e) => e === "text" && _e(t) ? t.toLowerCase() : e === "vnode" && Ke(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
        capitalize: (t, e) => e === "text" && _e(t) ? US(t) : e === "vnode" && Ke(t) && "__v_isVNode" in t ? US(t.children) : t
    }
}
let z2;

function eZ(t) {
    z2 = t
}
let j2;

function tZ(t) {
    j2 = t
}
let V2;

function nZ(t) {
    V2 = t
}
let W2 = null;
const rZ = t => {
        W2 = t
    },
    iZ = () => W2;
let Y2 = null;
const GS = t => {
        Y2 = t
    },
    sZ = () => Y2;
let HS = 0;

function oZ(t = {}) {
    const e = lt(t.onWarn) ? t.onWarn : Ys,
        n = _e(t.version) ? t.version : ZJ,
        r = _e(t.locale) || lt(t.locale) ? t.locale : fu,
        i = lt(r) ? fu : r,
        s = Dt(t.fallbackLocale) || Ge(t.fallbackLocale) || _e(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : i,
        o = Ge(t.messages) ? t.messages : Fm(i),
        a = Ge(t.datetimeFormats) ? t.datetimeFormats : Fm(i),
        l = Ge(t.numberFormats) ? t.numberFormats : Fm(i),
        c = Vt(ot(), t.modifiers, QJ()),
        u = t.pluralRules || ot(),
        d = lt(t.missing) ? t.missing : null,
        f = Je(t.missingWarn) || dl(t.missingWarn) ? t.missingWarn : !0,
        h = Je(t.fallbackWarn) || dl(t.fallbackWarn) ? t.fallbackWarn : !0,
        p = !!t.fallbackFormat,
        b = !!t.unresolving,
        y = lt(t.postTranslation) ? t.postTranslation : null,
        m = Ge(t.processor) ? t.processor : null,
        g = Je(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
        v = !!t.escapeParameter,
        _ = lt(t.messageCompiler) ? t.messageCompiler : z2;
    lt(t.messageCompiler) && Db(Wo(In.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
    const x = lt(t.messageResolver) ? t.messageResolver : j2 || XJ,
        w = lt(t.localeFallbacker) ? t.localeFallbacker : V2 || NJ,
        S = Ke(t.fallbackContext) ? t.fallbackContext : void 0,
        C = t,
        A = Ke(C.__datetimeFormatters) ? C.__datetimeFormatters : new Map,
        T = Ke(C.__numberFormatters) ? C.__numberFormatters : new Map,
        E = Ke(C.__meta) ? C.__meta : {};
    HS++;
    const P = {
        version: n,
        cid: HS,
        locale: r,
        fallbackLocale: s,
        messages: o,
        modifiers: c,
        pluralRules: u,
        missing: d,
        missingWarn: f,
        fallbackWarn: h,
        fallbackFormat: p,
        unresolving: b,
        postTranslation: y,
        processor: m,
        warnHtmlMessage: g,
        escapeParameter: v,
        messageCompiler: _,
        messageResolver: x,
        localeFallbacker: w,
        fallbackContext: S,
        onWarn: e,
        __meta: E
    };
    return P.datetimeFormats = a, P.numberFormats = l, P.__datetimeFormatters = A, P.__numberFormatters = T, P.__v_emitter = C.__v_emitter != null ? C.__v_emitter : void 0, BJ(P, n, E), P
}
const Fm = t => ({
    [t]: ot()
});

function Pp(t, e) {
    return t instanceof RegExp ? t.test(e) : t
}

function X2(t, e) {
    return t instanceof RegExp ? t.test(e) : t
}

function Ub(t, e, n, r, i) {
    const {
        missing: s,
        onWarn: o
    } = t; {
        const a = t.__v_emitter;
        a && a.emit("missing", {
            locale: n,
            key: e,
            type: i,
            groupId: `${i}:${e}`
        })
    }
    if (s !== null) {
        const a = s(t, n, e, i);
        return _e(a) ? a : e
    } else return X2(r, e) && o(Wo(In.NOT_FOUND_KEY, {
        key: e,
        locale: n
    })), e
}

function rc(t, e, n) {
    const r = t;
    r.__localeChainCache = new Map, t.localeFallbacker(t, n, e)
}

function K2(t, e) {
    return t === e ? !1 : t.split("-")[0] === e.split("-")[0]
}

function aZ(t, e) {
    const n = e.indexOf(t);
    if (n === -1) return !1;
    for (let r = n + 1; r < e.length; r++)
        if (K2(t, e[r])) return !0;
    return !1
}
const zS = typeof Intl < "u",
    q2 = {
        dateTimeFormat: zS && typeof Intl.DateTimeFormat < "u",
        numberFormat: zS && typeof Intl.NumberFormat < "u"
    };

function jS(t, ...e) {
    const {
        datetimeFormats: n,
        unresolving: r,
        fallbackLocale: i,
        onWarn: s,
        localeFallbacker: o
    } = t, {
        __datetimeFormatters: a
    } = t;
    if (!q2.dateTimeFormat) return s(Wo(In.CANNOT_FORMAT_DATE)), fh;
    const [l, c, u, d] = Ay(...e), f = Je(u.missingWarn) ? u.missingWarn : t.missingWarn, h = Je(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn, p = !!u.part, b = Nb(t, u), y = o(t, i, b);
    if (!_e(l) || l === "") return new Intl.DateTimeFormat(b, d).format(c);
    let m = {},
        g, v = null,
        _ = b,
        x = null;
    const w = "datetime format";
    for (let A = 0; A < y.length; A++) {
        if (g = x = y[A], b !== g && Pp(h, l) && s(Wo(In.FALLBACK_TO_DATE_FORMAT, {
                key: l,
                target: g
            })), b !== g) {
            const T = t.__v_emitter;
            T && T.emit("fallback", {
                type: w,
                key: l,
                from: _,
                to: x,
                groupId: `${w}:${l}`
            })
        }
        if (m = n[g] || {}, v = m[l], Ge(v)) break;
        Ub(t, l, g, f, w), _ = x
    }
    if (!Ge(v) || !_e(g)) return r ? Cp : l;
    let S = `${g}__${l}`;
    Tp(d) || (S = `${S}__${JSON.stringify(d)}`);
    let C = a.get(S);
    return C || (C = new Intl.DateTimeFormat(g, Vt({}, v, d)), a.set(S, C)), p ? C.formatToParts(c) : C.format(c)
}
const J2 = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];

function Ay(...t) {
    const [e, n, r, i] = t, s = ot();
    let o = ot(),
        a;
    if (_e(e)) {
        const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
        if (!l) throw Oi(ln.INVALID_ISO_DATE_ARGUMENT);
        const c = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
        a = new Date(c);
        try {
            a.toISOString()
        } catch {
            throw Oi(ln.INVALID_ISO_DATE_ARGUMENT)
        }
    } else if (Rq(e)) {
        if (isNaN(e.getTime())) throw Oi(ln.INVALID_DATE_ARGUMENT);
        a = e
    } else if (Lt(e)) a = e;
    else throw Oi(ln.INVALID_ARGUMENT);
    return _e(n) ? s.key = n : Ge(n) && Object.keys(n).forEach(l => {
        J2.includes(l) ? o[l] = n[l] : s[l] = n[l]
    }), _e(r) ? s.locale = r : Ge(r) && (o = r), Ge(i) && (o = i), [s.key || "", a, s, o]
}

function VS(t, e, n) {
    const r = t;
    for (const i in n) {
        const s = `${e}__${i}`;
        r.__datetimeFormatters.has(s) && r.__datetimeFormatters.delete(s)
    }
}

function WS(t, ...e) {
    const {
        numberFormats: n,
        unresolving: r,
        fallbackLocale: i,
        onWarn: s,
        localeFallbacker: o
    } = t, {
        __numberFormatters: a
    } = t;
    if (!q2.numberFormat) return s(Wo(In.CANNOT_FORMAT_NUMBER)), fh;
    const [l, c, u, d] = Oy(...e), f = Je(u.missingWarn) ? u.missingWarn : t.missingWarn, h = Je(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn, p = !!u.part, b = Nb(t, u), y = o(t, i, b);
    if (!_e(l) || l === "") return new Intl.NumberFormat(b, d).format(c);
    let m = {},
        g, v = null,
        _ = b,
        x = null;
    const w = "number format";
    for (let A = 0; A < y.length; A++) {
        if (g = x = y[A], b !== g && Pp(h, l) && s(Wo(In.FALLBACK_TO_NUMBER_FORMAT, {
                key: l,
                target: g
            })), b !== g) {
            const T = t.__v_emitter;
            T && T.emit("fallback", {
                type: w,
                key: l,
                from: _,
                to: x,
                groupId: `${w}:${l}`
            })
        }
        if (m = n[g] || {}, v = m[l], Ge(v)) break;
        Ub(t, l, g, f, w), _ = x
    }
    if (!Ge(v) || !_e(g)) return r ? Cp : l;
    let S = `${g}__${l}`;
    Tp(d) || (S = `${S}__${JSON.stringify(d)}`);
    let C = a.get(S);
    return C || (C = new Intl.NumberFormat(g, Vt({}, v, d)), a.set(S, C)), p ? C.formatToParts(c) : C.format(c)
}
const Z2 = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];

function Oy(...t) {
    const [e, n, r, i] = t, s = ot();
    let o = ot();
    if (!Lt(e)) throw Oi(ln.INVALID_ARGUMENT);
    const a = e;
    return _e(n) ? s.key = n : Ge(n) && Object.keys(n).forEach(l => {
        Z2.includes(l) ? o[l] = n[l] : s[l] = n[l]
    }), _e(r) ? s.locale = r : Ge(r) && (o = r), Ge(i) && (o = i), [s.key || "", a, s, o]
}

function YS(t, e, n) {
    const r = t;
    for (const i in n) {
        const s = `${e}__${i}`;
        r.__numberFormatters.has(s) && r.__numberFormatters.delete(s)
    }
}
const lZ = t => t,
    cZ = t => "",
    uZ = "text",
    dZ = t => t.length === 0 ? "" : Bb(t),
    fZ = Dq;

function XS(t, e) {
    return t = Math.abs(t), e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0
}

function hZ(t) {
    const e = Lt(t.pluralIndex) ? t.pluralIndex : -1;
    return t.named && (Lt(t.named.count) || Lt(t.named.n)) ? Lt(t.named.count) ? t.named.count : Lt(t.named.n) ? t.named.n : e : e
}

function pZ(t, e) {
    e.count || (e.count = t), e.n || (e.n = t)
}

function mZ(t = {}) {
    const e = t.locale,
        n = hZ(t),
        r = Ke(t.pluralRules) && _e(e) && lt(t.pluralRules[e]) ? t.pluralRules[e] : XS,
        i = Ke(t.pluralRules) && _e(e) && lt(t.pluralRules[e]) ? XS : void 0,
        s = m => m[r(n, m.length, i)],
        o = t.list || [],
        a = m => o[m],
        l = t.named || ot();
    Lt(t.pluralIndex) && pZ(n, l);
    const c = m => l[m];

    function u(m, g) {
        const v = lt(t.messages) ? t.messages(m, !!g) : Ke(t.messages) ? t.messages[m] : !1;
        return v || (t.parent ? t.parent.message(m) : cZ)
    }
    const d = m => t.modifiers ? t.modifiers[m] : lZ,
        f = Ge(t.processor) && lt(t.processor.normalize) ? t.processor.normalize : dZ,
        h = Ge(t.processor) && lt(t.processor.interpolate) ? t.processor.interpolate : fZ,
        p = Ge(t.processor) && _e(t.processor.type) ? t.processor.type : uZ,
        y = {
            list: a,
            named: c,
            plural: s,
            linked: (m, ...g) => {
                const [v, _] = g;
                let x = "text",
                    w = "";
                g.length === 1 ? Ke(v) ? (w = v.modifier || w, x = v.type || x) : _e(v) && (w = v || w) : g.length === 2 && (_e(v) && (w = v || w), _e(_) && (x = _ || x));
                const S = u(m, !0)(y),
                    C = x === "vnode" && Dt(S) && w ? S[0] : S;
                return w ? d(w)(C, x) : C
            },
            message: u,
            type: p,
            interpolate: h,
            normalize: f,
            values: Vt(ot(), o, l)
        };
    return y
}
const KS = () => "",
    ur = t => lt(t);

function qS(t, ...e) {
    const {
        fallbackFormat: n,
        postTranslation: r,
        unresolving: i,
        messageCompiler: s,
        fallbackLocale: o,
        messages: a
    } = t, [l, c] = Iy(...e), u = Je(c.missingWarn) ? c.missingWarn : t.missingWarn, d = Je(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn, f = Je(c.escapeParameter) ? c.escapeParameter : t.escapeParameter, h = !!c.resolvedMessage, p = _e(c.default) || Je(c.default) ? Je(c.default) ? s ? l : () => l : c.default : n ? s ? l : () => l : null, b = n || p != null && (_e(p) || lt(p)), y = Nb(t, c);
    f && gZ(c);
    let [m, g, v] = h ? [l, y, a[y] || ot()] : Q2(t, l, y, o, d, u), _ = m, x = l;
    if (!h && !(_e(_) || Ds(_) || ur(_)) && b && (_ = p, x = _), !h && (!(_e(_) || Ds(_) || ur(_)) || !_e(g))) return i ? Cp : l;
    if (_e(_) && t.messageCompiler == null) return Ys(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${l}'.`), l;
    let w = !1;
    const S = () => {
            w = !0
        },
        C = ur(_) ? _ : eM(t, l, g, _, x, S);
    if (w) return _;
    const A = bZ(t, g, v, c),
        T = mZ(A),
        E = vZ(t, C, T),
        P = r ? r(E, l) : E; {
        const B = {
            timestamp: Date.now(),
            key: _e(l) ? l : ur(_) ? _.key : "",
            locale: g || (ur(_) ? _.locale : ""),
            format: _e(_) ? _ : ur(_) ? _.source : "",
            message: P
        };
        B.meta = Vt({}, t.__meta, iZ() || {}), DJ(B)
    }
    return P
}

function gZ(t) {
    Dt(t.list) ? t.list = t.list.map(e => _e(e) ? IS(e) : e) : Ke(t.named) && Object.keys(t.named).forEach(e => {
        _e(t.named[e]) && (t.named[e] = IS(t.named[e]))
    })
}

function Q2(t, e, n, r, i, s) {
    const {
        messages: o,
        onWarn: a,
        messageResolver: l,
        localeFallbacker: c
    } = t, u = c(t, r, n);
    let d = ot(),
        f, h = null,
        p = n,
        b = null;
    const y = "translate";
    for (let m = 0; m < u.length; m++) {
        if (f = b = u[m], n !== f && !K2(n, f) && Pp(i, e) && a(Wo(In.FALLBACK_TO_TRANSLATE, {
                key: e,
                target: f
            })), n !== f) {
            const x = t.__v_emitter;
            x && x.emit("fallback", {
                type: y,
                key: e,
                from: p,
                to: b,
                groupId: `${y}:${e}`
            })
        }
        d = o[f] || ot();
        let g = null,
            v, _;
        if (Mr && (g = window.performance.now(), v = "intlify-message-resolve-start", _ = "intlify-message-resolve-end", Vn && Vn(v)), (h = l(d, e)) === null && (h = d[e]), Mr) {
            const x = window.performance.now(),
                w = t.__v_emitter;
            w && g && h && w.emit("message-resolve", {
                type: "message-resolve",
                key: e,
                message: h,
                time: x - g,
                groupId: `${y}:${e}`
            }), v && _ && Vn && Vo && (Vn(_), Vo("intlify message resolve", v, _))
        }
        if (_e(h) || Ds(h) || ur(h)) break;
        if (!aZ(f, u)) {
            const x = Ub(t, e, f, s, y);
            x !== e && (h = x)
        }
        p = b
    }
    return [h, f, d]
}

function eM(t, e, n, r, i, s) {
    const {
        messageCompiler: o,
        warnHtmlMessage: a
    } = t;
    if (ur(r)) {
        const f = r;
        return f.locale = f.locale || n, f.key = f.key || e, f
    }
    if (o == null) {
        const f = () => r;
        return f.locale = n, f.key = e, f
    }
    let l = null,
        c, u;
    Mr && (l = window.performance.now(), c = "intlify-message-compilation-start", u = "intlify-message-compilation-end", Vn && Vn(c));
    const d = o(r, yZ(t, n, i, r, a, s));
    if (Mr) {
        const f = window.performance.now(),
            h = t.__v_emitter;
        h && l && h.emit("message-compilation", {
            type: "message-compilation",
            message: r,
            time: f - l,
            groupId: `translate:${e}`
        }), c && u && Vn && Vo && (Vn(u), Vo("intlify message compilation", c, u))
    }
    return d.locale = n, d.key = e, d.source = r, d
}

function vZ(t, e, n) {
    let r = null,
        i, s;
    Mr && (r = window.performance.now(), i = "intlify-message-evaluation-start", s = "intlify-message-evaluation-end", Vn && Vn(i));
    const o = e(n);
    if (Mr) {
        const a = window.performance.now(),
            l = t.__v_emitter;
        l && r && l.emit("message-evaluation", {
            type: "message-evaluation",
            value: o,
            time: a - r,
            groupId: `translate:${e.key}`
        }), i && s && Vn && Vo && (Vn(s), Vo("intlify message evaluation", i, s))
    }
    return o
}

function Iy(...t) {
    const [e, n, r] = t, i = ot();
    if (!_e(e) && !Lt(e) && !ur(e) && !Ds(e)) throw Oi(ln.INVALID_ARGUMENT);
    const s = Lt(e) ? String(e) : (ur(e), e);
    return Lt(n) ? i.plural = n : _e(n) ? i.default = n : Ge(n) && !Tp(n) ? i.named = n : Dt(n) && (i.list = n), Lt(r) ? i.plural = r : _e(r) ? i.default = r : Ge(r) && Vt(i, r), [s, i]
}

function yZ(t, e, n, r, i, s) {
    return {
        locale: e,
        key: n,
        warnHtmlMessage: i,
        onError: o => {
            s && s(o); {
                const a = _Z(r),
                    l = `Message compilation error: ${o.message}`,
                    c = o.location && a && $q(a, o.location.start.offset, o.location.end.offset),
                    u = t.__v_emitter;
                u && a && u.emit("compile-error", {
                    message: a,
                    error: o.message,
                    start: o.location && o.location.start.offset,
                    end: o.location && o.location.end.offset,
                    groupId: `translate:${n}`
                }), console.error(c ? `${l}
${c}` : l)
            }
        },
        onCacheKey: o => Oq(e, n, o)
    }
}

function _Z(t) {
    if (_e(t)) return t;
    if (t.loc && t.loc.source) return t.loc.source
}

function bZ(t, e, n, r) {
    const {
        modifiers: i,
        pluralRules: s,
        messageResolver: o,
        fallbackLocale: a,
        fallbackWarn: l,
        missingWarn: c,
        fallbackContext: u
    } = t, f = {
        locale: e,
        modifiers: i,
        pluralRules: s,
        messages: (h, p) => {
            let b = o(n, h);
            if (b == null && (u || p)) {
                const [, , y] = Q2(u || t, h, e, a, l, c);
                b = o(y, h)
            }
            if (_e(b) || Ds(b)) {
                let y = !1;
                const g = eM(t, h, e, b, h, () => {
                    y = !0
                });
                return y ? KS : g
            } else return ur(b) ? b : KS
        }
    };
    return t.processor && (f.processor = t.processor), r.list && (f.list = r.list), r.named && (f.named = r.named), Lt(r.plural) && (f.pluralIndex = r.plural), f
}
fJ();
/*!
 * vue-i18n v11.1.2
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
const xZ = "11.1.2";

function wZ() {
    typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (wo().__VUE_I18N_FULL_INSTALL__ = !0), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (wo().__VUE_I18N_LEGACY_API__ = !0), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (wo().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (wo().__INTLIFY_PROD_DEVTOOLS__ = !1)
}
const dt = {
    UNEXPECTED_RETURN_TYPE: FJ,
    INVALID_ARGUMENT: 25,
    MUST_BE_CALL_SETUP_TOP: 26,
    NOT_INSTALLED: 27,
    REQUIRED_VALUE: 28,
    INVALID_VALUE: 29,
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: 30,
    NOT_INSTALLED_WITH_PROVIDE: 31,
    UNEXPECTED_ERROR: 32,
    NOT_COMPATIBLE_LEGACY_VUE_I18N: 33,
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: 34
};

function Fn(t, ...e) {
    return Fl(t, null, {
        messages: EZ,
        args: e
    })
}
const EZ = {
        [dt.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
        [dt.INVALID_ARGUMENT]: "Invalid argument",
        [dt.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
        [dt.NOT_INSTALLED]: "Need to install with `app.use` function",
        [dt.UNEXPECTED_ERROR]: "Unexpected error",
        [dt.REQUIRED_VALUE]: "Required in value: {0}",
        [dt.INVALID_VALUE]: "Invalid value",
        [dt.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: "Cannot setup vue-devtools plugin",
        [dt.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
        [dt.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
        [dt.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
    },
    Ry = ci("__translateVNode"),
    My = ci("__datetimeParts"),
    ky = ci("__numberParts"),
    Yo = ci("__enableEmitter"),
    hu = ci("__disableEmitter"),
    tM = ci("__setPluralRules"),
    nM = ci("__injectWithOption"),
    By = ci("__dispose"),
    Jr = {
        FALLBACK_TO_ROOT: qJ,
        NOT_FOUND_PARENT_SCOPE: 9,
        IGNORE_OBJ_FLATTEN: 10,
        DEPRECATE_LEGACY_MODE: 11,
        DEPRECATE_TRANSLATE_CUSTOME_DIRECTIVE: 12
    },
    SZ = {
        [Jr.FALLBACK_TO_ROOT]: "Fall back to {type} '{key}' with root locale.",
        [Jr.NOT_FOUND_PARENT_SCOPE]: "Not found parent scope. use the global scope.",
        [Jr.IGNORE_OBJ_FLATTEN]: "Ignore object flatten: '{key}' key has an string value",
        [Jr.DEPRECATE_LEGACY_MODE]: `Legacy API mode has been deprecated in v11. Use Composition API mode instead.
About how to use the Composition API mode, see https://vue-i18n.intlify.dev/guide/advanced/composition.html`,
        [Jr.DEPRECATE_TRANSLATE_CUSTOME_DIRECTIVE]: "'v-t' has been deprecated in v11. Use translate APIs ('t' or '$t') instead."
    };

function ed(t, ...e) {
    return Sp(SZ[t], ...e)
}

function pu(t) {
    if (!Ke(t)) return t;
    for (const e in t)
        if (Sr(t, e))
            if (!e.includes(".")) Ke(t[e]) && pu(t[e]);
            else {
                const n = e.split("."),
                    r = n.length - 1;
                let i = t,
                    s = !1;
                for (let o = 0; o < r; o++) {
                    if (n[o] === "__proto__") throw new Error(`unsafe key: ${n[o]}`);
                    if (n[o] in i || (i[n[o]] = ot()), !Ke(i[n[o]])) {
                        Ys(ed(Jr.IGNORE_OBJ_FLATTEN, {
                            key: n[o]
                        })), s = !0;
                        break
                    }
                    i = i[n[o]]
                }
                s || (i[n[r]] = t[e], delete t[e]), Ke(i[n[r]]) && pu(i[n[r]])
            }
    return t
}

function Gb(t, e) {
    const {
        messages: n,
        __i18n: r,
        messageResolver: i,
        flatJson: s
    } = e, o = Ge(n) ? n : Dt(r) ? ot() : {
        [t]: ot()
    };
    if (Dt(r) && r.forEach(a => {
            if ("locale" in a && "resource" in a) {
                const {
                    locale: l,
                    resource: c
                } = a;
                l ? (o[l] = o[l] || ot(), Rf(c, o[l])) : Rf(c, o)
            } else _e(a) && Rf(JSON.parse(a), o)
        }), i == null && s)
        for (const a in o) Sr(o, a) && pu(o[a]);
    return o
}

function rM(t) {
    return t.type
}

function iM(t, e, n) {
    let r = Ke(e.messages) ? e.messages : ot();
    "__i18nGlobal" in n && (r = Gb(t.locale.value, {
        messages: r,
        __i18n: n.__i18nGlobal
    }));
    const i = Object.keys(r);
    i.length && i.forEach(s => {
        t.mergeLocaleMessage(s, r[s])
    }); {
        if (Ke(e.datetimeFormats)) {
            const s = Object.keys(e.datetimeFormats);
            s.length && s.forEach(o => {
                t.mergeDateTimeFormat(o, e.datetimeFormats[o])
            })
        }
        if (Ke(e.numberFormats)) {
            const s = Object.keys(e.numberFormats);
            s.length && s.forEach(o => {
                t.mergeNumberFormat(o, e.numberFormats[o])
            })
        }
    }
}

function JS(t) {
    return I(ii, null, t, 0)
}
const ZS = "__INTLIFY_META__",
    QS = () => [],
    TZ = () => !1;
let e1 = 0;

function t1(t) {
    return (e, n, r, i) => t(n, r, it() || void 0, i)
}
const CZ = () => {
    const t = it();
    let e = null;
    return t && (e = rM(t)[ZS]) ? {
        [ZS]: e
    } : null
};

function Hb(t = {}) {
    const {
        __root: e,
        __injectWithOption: n
    } = t, r = e === void 0, i = t.flatJson, s = Mr ? J : zh;
    let o = Je(t.inheritLocale) ? t.inheritLocale : !0;
    const a = s(e && o ? e.locale.value : _e(t.locale) ? t.locale : fu),
        l = s(e && o ? e.fallbackLocale.value : _e(t.fallbackLocale) || Dt(t.fallbackLocale) || Ge(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : a.value),
        c = s(Gb(a.value, t)),
        u = s(Ge(t.datetimeFormats) ? t.datetimeFormats : {
            [a.value]: {}
        }),
        d = s(Ge(t.numberFormats) ? t.numberFormats : {
            [a.value]: {}
        });
    let f = e ? e.missingWarn : Je(t.missingWarn) || dl(t.missingWarn) ? t.missingWarn : !0,
        h = e ? e.fallbackWarn : Je(t.fallbackWarn) || dl(t.fallbackWarn) ? t.fallbackWarn : !0,
        p = e ? e.fallbackRoot : Je(t.fallbackRoot) ? t.fallbackRoot : !0,
        b = !!t.fallbackFormat,
        y = lt(t.missing) ? t.missing : null,
        m = lt(t.missing) ? t1(t.missing) : null,
        g = lt(t.postTranslation) ? t.postTranslation : null,
        v = e ? e.warnHtmlMessage : Je(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
        _ = !!t.escapeParameter;
    const x = e ? e.modifiers : Ge(t.modifiers) ? t.modifiers : {};
    let w = t.pluralRules || e && e.pluralRules,
        S;
    S = (() => {
        r && GS(null);
        const z = {
            version: xZ,
            locale: a.value,
            fallbackLocale: l.value,
            messages: c.value,
            modifiers: x,
            pluralRules: w,
            missing: m === null ? void 0 : m,
            missingWarn: f,
            fallbackWarn: h,
            fallbackFormat: b,
            unresolving: !0,
            postTranslation: g === null ? void 0 : g,
            warnHtmlMessage: v,
            escapeParameter: _,
            messageResolver: t.messageResolver,
            messageCompiler: t.messageCompiler,
            __meta: {
                framework: "vue"
            }
        };
        z.datetimeFormats = u.value, z.numberFormats = d.value, z.__datetimeFormatters = Ge(S) ? S.__datetimeFormatters : void 0, z.__numberFormatters = Ge(S) ? S.__numberFormatters : void 0, z.__v_emitter = Ge(S) ? S.__v_emitter : void 0;
        const ee = oZ(z);
        return r && GS(ee), ee
    })(), rc(S, a.value, l.value);

    function A() {
        return [a.value, l.value, c.value, u.value, d.value]
    }
    const T = ne({
            get: () => a.value,
            set: z => {
                S.locale = z, a.value = z
            }
        }),
        E = ne({
            get: () => l.value,
            set: z => {
                S.fallbackLocale = z, l.value = z, rc(S, a.value, z)
            }
        }),
        P = ne(() => c.value),
        B = ne(() => u.value),
        F = ne(() => d.value);

    function H() {
        return lt(g) ? g : null
    }

    function k(z) {
        g = z, S.postTranslation = z
    }

    function N() {
        return y
    }

    function V(z) {
        z !== null && (m = t1(z)), y = z, S.missing = m
    }

    function Y(z, ee) {
        return z !== "translate" || !ee.resolvedMessage
    }
    const le = (z, ee, xe, Re, Ve, pt) => {
        A();
        let Wt;
        try {
            r || (S.fallbackContext = e ? sZ() : void 0), Wt = z(S)
        } finally {
            r || (S.fallbackContext = void 0)
        }
        if (xe !== "translate exists" && Lt(Wt) && Wt === Cp || xe === "translate exists" && !Wt) {
            const [Pn, gd] = ee();
            if (e && _e(Pn) && Y(xe, gd)) {
                p && (Pp(h, Pn) || X2(f, Pn)) && Ys(ed(Jr.FALLBACK_TO_ROOT, {
                    key: Pn,
                    type: xe
                })); {
                    const {
                        __v_emitter: Ji
                    } = S;
                    Ji && p && Ji.emit("fallback", {
                        type: xe,
                        key: Pn,
                        to: "global",
                        groupId: `${xe}:${Pn}`
                    })
                }
            }
            return e && p ? Re(e) : Ve(Pn)
        } else {
            if (pt(Wt)) return Wt;
            throw Fn(dt.UNEXPECTED_RETURN_TYPE)
        }
    };

    function ae(...z) {
        return le(ee => Reflect.apply(qS, null, [ee, ...z]), () => Iy(...z), "translate", ee => Reflect.apply(ee.t, ee, [...z]), ee => ee, ee => _e(ee))
    }

    function W(...z) {
        const [ee, xe, Re] = z;
        if (Re && !Ke(Re)) throw Fn(dt.INVALID_ARGUMENT);
        return ae(ee, xe, Vt({
            resolvedMessage: !0
        }, Re || {}))
    }

    function Q(...z) {
        return le(ee => Reflect.apply(jS, null, [ee, ...z]), () => Ay(...z), "datetime format", ee => Reflect.apply(ee.d, ee, [...z]), () => fh, ee => _e(ee))
    }

    function fe(...z) {
        return le(ee => Reflect.apply(WS, null, [ee, ...z]), () => Oy(...z), "number format", ee => Reflect.apply(ee.n, ee, [...z]), () => fh, ee => _e(ee))
    }

    function D(z) {
        return z.map(ee => _e(ee) || Lt(ee) || Je(ee) ? JS(String(ee)) : ee)
    }
    const $ = {
        normalize: D,
        interpolate: z => z,
        type: "vnode"
    };

    function Z(...z) {
        return le(ee => {
            let xe;
            const Re = ee;
            try {
                Re.processor = $, xe = Reflect.apply(qS, null, [Re, ...z])
            } finally {
                Re.processor = null
            }
            return xe
        }, () => Iy(...z), "translate", ee => ee[Ry](...z), ee => [JS(ee)], ee => Dt(ee))
    }

    function K(...z) {
        return le(ee => Reflect.apply(WS, null, [ee, ...z]), () => Oy(...z), "number format", ee => ee[ky](...z), QS, ee => _e(ee) || Dt(ee))
    }

    function ce(...z) {
        return le(ee => Reflect.apply(jS, null, [ee, ...z]), () => Ay(...z), "datetime format", ee => ee[My](...z), QS, ee => _e(ee) || Dt(ee))
    }

    function de(z) {
        w = z, S.pluralRules = w
    }

    function ge(z, ee) {
        return le(() => {
            if (!z) return !1;
            const xe = _e(ee) ? ee : a.value,
                Re = j(xe),
                Ve = S.messageResolver(Re, z);
            return Ds(Ve) || ur(Ve) || _e(Ve)
        }, () => [z], "translate exists", xe => Reflect.apply(xe.te, xe, [z, ee]), TZ, xe => Je(xe))
    }

    function O(z) {
        let ee = null;
        const xe = H2(S, l.value, a.value);
        for (let Re = 0; Re < xe.length; Re++) {
            const Ve = c.value[xe[Re]] || {},
                pt = S.messageResolver(Ve, z);
            if (pt != null) {
                ee = pt;
                break
            }
        }
        return ee
    }

    function L(z) {
        const ee = O(z);
        return ee ? ? (e ? e.tm(z) || {} : {})
    }

    function j(z) {
        return c.value[z] || {}
    }

    function ie(z, ee) {
        if (i) {
            const xe = {
                [z]: ee
            };
            for (const Re in xe) Sr(xe, Re) && pu(xe[Re]);
            ee = xe[z]
        }
        c.value[z] = ee, S.messages = c.value
    }

    function oe(z, ee) {
        c.value[z] = c.value[z] || {};
        const xe = {
            [z]: ee
        };
        if (i)
            for (const Re in xe) Sr(xe, Re) && pu(xe[Re]);
        ee = xe[z], Rf(ee, c.value[z]), S.messages = c.value
    }

    function R(z) {
        return u.value[z] || {}
    }

    function M(z, ee) {
        u.value[z] = ee, S.datetimeFormats = u.value, VS(S, z, ee)
    }

    function U(z, ee) {
        u.value[z] = Vt(u.value[z] || {}, ee), S.datetimeFormats = u.value, VS(S, z, ee)
    }

    function q(z) {
        return d.value[z] || {}
    }

    function se(z, ee) {
        d.value[z] = ee, S.numberFormats = d.value, YS(S, z, ee)
    }

    function he(z, ee) {
        d.value[z] = Vt(d.value[z] || {}, ee), S.numberFormats = d.value, YS(S, z, ee)
    }
    e1++, e && Mr && (pe(e.locale, z => {
        o && (a.value = z, S.locale = z, rc(S, a.value, l.value))
    }), pe(e.fallbackLocale, z => {
        o && (l.value = z, S.fallbackLocale = z, rc(S, a.value, l.value))
    }));
    const ue = {
        id: e1,
        locale: T,
        fallbackLocale: E,
        get inheritLocale() {
            return o
        },
        set inheritLocale(z) {
            o = z, z && e && (a.value = e.locale.value, l.value = e.fallbackLocale.value, rc(S, a.value, l.value))
        },
        get availableLocales() {
            return Object.keys(c.value).sort()
        },
        messages: P,
        get modifiers() {
            return x
        },
        get pluralRules() {
            return w || {}
        },
        get isGlobal() {
            return r
        },
        get missingWarn() {
            return f
        },
        set missingWarn(z) {
            f = z, S.missingWarn = f
        },
        get fallbackWarn() {
            return h
        },
        set fallbackWarn(z) {
            h = z, S.fallbackWarn = h
        },
        get fallbackRoot() {
            return p
        },
        set fallbackRoot(z) {
            p = z
        },
        get fallbackFormat() {
            return b
        },
        set fallbackFormat(z) {
            b = z, S.fallbackFormat = b
        },
        get warnHtmlMessage() {
            return v
        },
        set warnHtmlMessage(z) {
            v = z, S.warnHtmlMessage = z
        },
        get escapeParameter() {
            return _
        },
        set escapeParameter(z) {
            _ = z, S.escapeParameter = z
        },
        t: ae,
        getLocaleMessage: j,
        setLocaleMessage: ie,
        mergeLocaleMessage: oe,
        getPostTranslationHandler: H,
        setPostTranslationHandler: k,
        getMissingHandler: N,
        setMissingHandler: V,
        [tM]: de
    };
    return ue.datetimeFormats = B, ue.numberFormats = F, ue.rt = W, ue.te = ge, ue.tm = L, ue.d = Q, ue.n = fe, ue.getDateTimeFormat = R, ue.setDateTimeFormat = M, ue.mergeDateTimeFormat = U, ue.getNumberFormat = q, ue.setNumberFormat = se, ue.mergeNumberFormat = he, ue[nM] = n, ue[Ry] = Z, ue[My] = ce, ue[ky] = K, ue[Yo] = z => {
        S.__v_emitter = z
    }, ue[hu] = () => {
        S.__v_emitter = void 0
    }, ue
}
const sM = "vue-i18n: composer properties",
    Lm = {
        "vue-devtools-plugin-vue-i18n": "Vue I18n DevTools",
        "vue-i18n-resource-inspector": "Vue I18n DevTools",
        "vue-i18n-timeline": "Vue I18n"
    },
    PZ = {
        "vue-i18n-resource-inspector": "Search for scopes ..."
    },
    AZ = {
        "vue-i18n-timeline": 16764185
    };
let Dy;
async function OZ(t, e) {
    return new Promise((n, r) => {
        try {
            sp({
                id: "vue-devtools-plugin-vue-i18n",
                label: Lm["vue-devtools-plugin-vue-i18n"],
                packageName: "vue-i18n",
                homepage: "https://vue-i18n.intlify.dev",
                logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
                componentStateTypes: [sM],
                app: t
            }, i => {
                Dy = i, i.on.visitComponentTree(({
                    componentInstance: o,
                    treeNode: a
                }) => {
                    IZ(o, a, e)
                }), i.on.inspectComponent(({
                    componentInstance: o,
                    instanceData: a
                }) => {
                    o.vnode.el && o.vnode.el.__VUE_I18N__ && a && (e.mode === "legacy" ? o.vnode.el.__VUE_I18N__ !== e.global.__composer && n1(a, o.vnode.el.__VUE_I18N__) : n1(a, o.vnode.el.__VUE_I18N__))
                }), i.addInspector({
                    id: "vue-i18n-resource-inspector",
                    label: Lm["vue-i18n-resource-inspector"],
                    icon: "language",
                    treeFilterPlaceholder: PZ["vue-i18n-resource-inspector"]
                }), i.on.getInspectorTree(o => {
                    o.app === t && o.inspectorId === "vue-i18n-resource-inspector" && DZ(o, e)
                });
                const s = new Map;
                i.on.getInspectorState(async o => {
                    if (o.app === t && o.inspectorId === "vue-i18n-resource-inspector")
                        if (i.unhighlightElement(), FZ(o, e), o.nodeId === "global") {
                            if (!s.has(o.app)) {
                                const [a] = await i.getComponentInstances(o.app);
                                s.set(o.app, a)
                            }
                            i.highlightElement(s.get(o.app))
                        } else {
                            const a = $Z(o.nodeId, e);
                            a && i.highlightElement(a)
                        }
                }), i.on.editInspectorState(o => {
                    o.app === t && o.inspectorId === "vue-i18n-resource-inspector" && NZ(o, e)
                }), i.addTimelineLayer({
                    id: "vue-i18n-timeline",
                    label: Lm["vue-i18n-timeline"],
                    color: AZ["vue-i18n-timeline"]
                }), n(!0)
            })
        } catch (i) {
            console.error(i), r(!1)
        }
    })
}

function oM(t) {
    return t.type.name || t.type.displayName || t.type.__file || "Anonymous"
}

function IZ(t, e, n) {
    const r = n.mode === "composition" ? n.global : n.global.__composer;
    if (t && t.vnode.el && t.vnode.el.__VUE_I18N__ && t.vnode.el.__VUE_I18N__ !== r) {
        const i = {
            label: `i18n (${oM(t)} Scope)`,
            textColor: 0,
            backgroundColor: 16764185
        };
        e.tags.push(i)
    }
}

function n1(t, e) {
    const n = sM;
    t.state.push({
        type: n,
        key: "locale",
        editable: !0,
        value: e.locale.value
    }), t.state.push({
        type: n,
        key: "availableLocales",
        editable: !1,
        value: e.availableLocales
    }), t.state.push({
        type: n,
        key: "fallbackLocale",
        editable: !0,
        value: e.fallbackLocale.value
    }), t.state.push({
        type: n,
        key: "inheritLocale",
        editable: !0,
        value: e.inheritLocale
    }), t.state.push({
        type: n,
        key: "messages",
        editable: !1,
        value: zb(e.messages.value)
    }), t.state.push({
        type: n,
        key: "datetimeFormats",
        editable: !1,
        value: e.datetimeFormats.value
    }), t.state.push({
        type: n,
        key: "numberFormats",
        editable: !1,
        value: e.numberFormats.value
    })
}

function zb(t) {
    const e = {};
    return Object.keys(t).forEach(n => {
        const r = t[n];
        lt(r) && "source" in r ? e[n] = BZ(r) : Ds(r) && r.loc && r.loc.source ? e[n] = r.loc.source : Ke(r) ? e[n] = zb(r) : e[n] = r
    }), e
}
const RZ = {
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "&": "&amp;"
};

function MZ(t) {
    return t.replace(/[<>"&]/g, kZ)
}

function kZ(t) {
    return RZ[t] || t
}

function BZ(t) {
    return {
        _custom: {
            type: "function",
            display: `<span>ƒ</span> ${t.source?`("${MZ(t.source)}")`:"(?)"}`
        }
    }
}

function DZ(t, e) {
    t.rootNodes.push({
        id: "global",
        label: "Global Scope"
    });
    const n = e.mode === "composition" ? e.global : e.global.__composer;
    for (const [r, i] of e.__instances) {
        const s = e.mode === "composition" ? i : i.__composer;
        n !== s && t.rootNodes.push({
            id: s.id.toString(),
            label: `${oM(r)} Scope`
        })
    }
}

function $Z(t, e) {
    let n = null;
    if (t !== "global") {
        for (const [r, i] of e.__instances.entries())
            if (i.id.toString() === t) {
                n = r;
                break
            }
    }
    return n
}

function aM(t, e) {
    if (t === "global") return e.mode === "composition" ? e.global : e.global.__composer; {
        const n = Array.from(e.__instances.values()).find(r => r.id.toString() === t);
        return n ? e.mode === "composition" ? n : n.__composer : null
    }
}

function FZ(t, e) {
    const n = aM(t.nodeId, e);
    return n && (t.state = LZ(n)), null
}

function LZ(t) {
    const e = {},
        n = "Locale related info",
        r = [{
            type: n,
            key: "locale",
            editable: !0,
            value: t.locale.value
        }, {
            type: n,
            key: "fallbackLocale",
            editable: !0,
            value: t.fallbackLocale.value
        }, {
            type: n,
            key: "availableLocales",
            editable: !1,
            value: t.availableLocales
        }, {
            type: n,
            key: "inheritLocale",
            editable: !0,
            value: t.inheritLocale
        }];
    e[n] = r;
    const i = "Locale messages info",
        s = [{
            type: i,
            key: "messages",
            editable: !1,
            value: zb(t.messages.value)
        }];
    e[i] = s; {
        const o = "Datetime formats info",
            a = [{
                type: o,
                key: "datetimeFormats",
                editable: !1,
                value: t.datetimeFormats.value
            }];
        e[o] = a;
        const l = "Datetime formats info",
            c = [{
                type: l,
                key: "numberFormats",
                editable: !1,
                value: t.numberFormats.value
            }];
        e[l] = c
    }
    return e
}

function mu(t, e) {
    if (Dy) {
        let n;
        e && "groupId" in e && (n = e.groupId, delete e.groupId), Dy.addTimelineEvent({
            layerId: "vue-i18n-timeline",
            event: {
                title: t,
                groupId: n,
                time: Date.now(),
                meta: {},
                data: e || {},
                logType: t === "compile-error" ? "error" : t === "fallback" || t === "missing" ? "warning" : "default"
            }
        })
    }
}

function NZ(t, e) {
    const n = aM(t.nodeId, e);
    if (n) {
        const [r] = t.path;
        r === "locale" && _e(t.state.value) ? n.locale.value = t.state.value : r === "fallbackLocale" && (_e(t.state.value) || Dt(t.state.value) || Ke(t.state.value)) ? n.fallbackLocale.value = t.state.value : r === "inheritLocale" && Je(t.state.value) && (n.inheritLocale = t.state.value)
    }
}

function UZ(t) {
    const e = _e(t.locale) ? t.locale : fu,
        n = _e(t.fallbackLocale) || Dt(t.fallbackLocale) || Ge(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : e,
        r = lt(t.missing) ? t.missing : void 0,
        i = Je(t.silentTranslationWarn) || dl(t.silentTranslationWarn) ? !t.silentTranslationWarn : !0,
        s = Je(t.silentFallbackWarn) || dl(t.silentFallbackWarn) ? !t.silentFallbackWarn : !0,
        o = Je(t.fallbackRoot) ? t.fallbackRoot : !0,
        a = !!t.formatFallbackMessages,
        l = Ge(t.modifiers) ? t.modifiers : {},
        c = t.pluralizationRules,
        u = lt(t.postTranslation) ? t.postTranslation : void 0,
        d = _e(t.warnHtmlInMessage) ? t.warnHtmlInMessage !== "off" : !0,
        f = !!t.escapeParameterHtml,
        h = Je(t.sync) ? t.sync : !0;
    let p = t.messages;
    if (Ge(t.sharedMessages)) {
        const x = t.sharedMessages;
        p = Object.keys(x).reduce((S, C) => {
            const A = S[C] || (S[C] = {});
            return Vt(A, x[C]), S
        }, p || {})
    }
    const {
        __i18n: b,
        __root: y,
        __injectWithOption: m
    } = t, g = t.datetimeFormats, v = t.numberFormats, _ = t.flatJson;
    return {
        locale: e,
        fallbackLocale: n,
        messages: p,
        flatJson: _,
        datetimeFormats: g,
        numberFormats: v,
        missing: r,
        missingWarn: i,
        fallbackWarn: s,
        fallbackRoot: o,
        fallbackFormat: a,
        modifiers: l,
        pluralRules: c,
        postTranslation: u,
        warnHtmlMessage: d,
        escapeParameter: f,
        messageResolver: t.messageResolver,
        inheritLocale: h,
        __i18n: b,
        __root: y,
        __injectWithOption: m
    }
}

function $y(t = {}) {
    const e = Hb(UZ(t)),
        {
            __extender: n
        } = t,
        r = {
            id: e.id,
            get locale() {
                return e.locale.value
            },
            set locale(i) {
                e.locale.value = i
            },
            get fallbackLocale() {
                return e.fallbackLocale.value
            },
            set fallbackLocale(i) {
                e.fallbackLocale.value = i
            },
            get messages() {
                return e.messages.value
            },
            get datetimeFormats() {
                return e.datetimeFormats.value
            },
            get numberFormats() {
                return e.numberFormats.value
            },
            get availableLocales() {
                return e.availableLocales
            },
            get missing() {
                return e.getMissingHandler()
            },
            set missing(i) {
                e.setMissingHandler(i)
            },
            get silentTranslationWarn() {
                return Je(e.missingWarn) ? !e.missingWarn : e.missingWarn
            },
            set silentTranslationWarn(i) {
                e.missingWarn = Je(i) ? !i : i
            },
            get silentFallbackWarn() {
                return Je(e.fallbackWarn) ? !e.fallbackWarn : e.fallbackWarn
            },
            set silentFallbackWarn(i) {
                e.fallbackWarn = Je(i) ? !i : i
            },
            get modifiers() {
                return e.modifiers
            },
            get formatFallbackMessages() {
                return e.fallbackFormat
            },
            set formatFallbackMessages(i) {
                e.fallbackFormat = i
            },
            get postTranslation() {
                return e.getPostTranslationHandler()
            },
            set postTranslation(i) {
                e.setPostTranslationHandler(i)
            },
            get sync() {
                return e.inheritLocale
            },
            set sync(i) {
                e.inheritLocale = i
            },
            get warnHtmlInMessage() {
                return e.warnHtmlMessage ? "warn" : "off"
            },
            set warnHtmlInMessage(i) {
                e.warnHtmlMessage = i !== "off"
            },
            get escapeParameterHtml() {
                return e.escapeParameter
            },
            set escapeParameterHtml(i) {
                e.escapeParameter = i
            },
            get pluralizationRules() {
                return e.pluralRules || {}
            },
            __composer: e,
            t(...i) {
                return Reflect.apply(e.t, e, [...i])
            },
            rt(...i) {
                return Reflect.apply(e.rt, e, [...i])
            },
            te(i, s) {
                return e.te(i, s)
            },
            tm(i) {
                return e.tm(i)
            },
            getLocaleMessage(i) {
                return e.getLocaleMessage(i)
            },
            setLocaleMessage(i, s) {
                e.setLocaleMessage(i, s)
            },
            mergeLocaleMessage(i, s) {
                e.mergeLocaleMessage(i, s)
            },
            d(...i) {
                return Reflect.apply(e.d, e, [...i])
            },
            getDateTimeFormat(i) {
                return e.getDateTimeFormat(i)
            },
            setDateTimeFormat(i, s) {
                e.setDateTimeFormat(i, s)
            },
            mergeDateTimeFormat(i, s) {
                e.mergeDateTimeFormat(i, s)
            },
            n(...i) {
                return Reflect.apply(e.n, e, [...i])
            },
            getNumberFormat(i) {
                return e.getNumberFormat(i)
            },
            setNumberFormat(i, s) {
                e.setNumberFormat(i, s)
            },
            mergeNumberFormat(i, s) {
                e.mergeNumberFormat(i, s)
            }
        };
    return r.__extender = n, r.__enableEmitter = i => {
        const s = e;
        s[Yo] && s[Yo](i)
    }, r.__disableEmitter = () => {
        const i = e;
        i[hu] && i[hu]()
    }, r
}

function GZ(t, e, n) {
    return {
        beforeCreate() {
            const r = it();
            if (!r) throw Fn(dt.UNEXPECTED_ERROR);
            const i = this.$options;
            if (i.i18n) {
                const s = i.i18n;
                if (i.__i18n && (s.__i18n = i.__i18n), s.__root = e, this === this.$root) this.$i18n = r1(t, s);
                else {
                    s.__injectWithOption = !0, s.__extender = n.__vueI18nExtend, this.$i18n = $y(s);
                    const o = this.$i18n;
                    o.__extender && (o.__disposer = o.__extender(this.$i18n))
                }
            } else if (i.__i18n)
                if (this === this.$root) this.$i18n = r1(t, i);
                else {
                    this.$i18n = $y({
                        __i18n: i.__i18n,
                        __injectWithOption: !0,
                        __extender: n.__vueI18nExtend,
                        __root: e
                    });
                    const s = this.$i18n;
                    s.__extender && (s.__disposer = s.__extender(this.$i18n))
                }
            else this.$i18n = t;
            i.__i18nGlobal && iM(e, i, i), this.$t = (...s) => this.$i18n.t(...s), this.$rt = (...s) => this.$i18n.rt(...s), this.$te = (s, o) => this.$i18n.te(s, o), this.$d = (...s) => this.$i18n.d(...s), this.$n = (...s) => this.$i18n.n(...s), this.$tm = s => this.$i18n.tm(s), n.__setInstance(r, this.$i18n)
        },
        mounted() {
            if (this.$el && this.$i18n) {
                const r = this.$i18n;
                this.$el.__VUE_I18N__ = r.__composer;
                const i = this.__v_emitter = $b();
                r.__enableEmitter && r.__enableEmitter(i), i.on("*", mu)
            }
        },
        unmounted() {
            const r = it();
            if (!r) throw Fn(dt.UNEXPECTED_ERROR);
            const i = this.$i18n;
            this.$el && this.$el.__VUE_I18N__ && (this.__v_emitter && (this.__v_emitter.off("*", mu), delete this.__v_emitter), this.$i18n && (i.__disableEmitter && i.__disableEmitter(), delete this.$el.__VUE_I18N__)), delete this.$t, delete this.$rt, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, i.__disposer && (i.__disposer(), delete i.__disposer, delete i.__extender), n.__deleteInstance(r), delete this.$i18n
        }
    }
}

function r1(t, e) {
    t.locale = e.locale || t.locale, t.fallbackLocale = e.fallbackLocale || t.fallbackLocale, t.missing = e.missing || t.missing, t.silentTranslationWarn = e.silentTranslationWarn || t.silentFallbackWarn, t.silentFallbackWarn = e.silentFallbackWarn || t.silentFallbackWarn, t.formatFallbackMessages = e.formatFallbackMessages || t.formatFallbackMessages, t.postTranslation = e.postTranslation || t.postTranslation, t.warnHtmlInMessage = e.warnHtmlInMessage || t.warnHtmlInMessage, t.escapeParameterHtml = e.escapeParameterHtml || t.escapeParameterHtml, t.sync = e.sync || t.sync, t.__composer[tM](e.pluralizationRules || t.pluralizationRules);
    const n = Gb(t.locale, {
        messages: e.messages,
        __i18n: e.__i18n
    });
    return Object.keys(n).forEach(r => t.mergeLocaleMessage(r, n[r])), e.datetimeFormats && Object.keys(e.datetimeFormats).forEach(r => t.mergeDateTimeFormat(r, e.datetimeFormats[r])), e.numberFormats && Object.keys(e.numberFormats).forEach(r => t.mergeNumberFormat(r, e.numberFormats[r])), t
}
const jb = {
    tag: {
        type: [String, Object]
    },
    locale: {
        type: String
    },
    scope: {
        type: String,
        validator: t => t === "parent" || t === "global",
        default: "parent"
    },
    i18n: {
        type: Object
    }
};

function HZ({
    slots: t
}, e) {
    return e.length === 1 && e[0] === "default" ? (t.default ? t.default() : []).reduce((r, i) => [...r, ...i.type === gt ? i.children : [i]], []) : e.reduce((n, r) => {
        const i = t[r];
        return i && (n[r] = i()), n
    }, ot())
}

function lM() {
    return gt
}
const zZ = ye({
        name: "i18n-t",
        props: Vt({
            keypath: {
                type: String,
                required: !0
            },
            plural: {
                type: [Number, String],
                validator: t => Lt(t) || !isNaN(t)
            }
        }, jb),
        setup(t, e) {
            const {
                slots: n,
                attrs: r
            } = e, i = t.i18n || Vb({
                useScope: t.scope,
                __useComponent: !0
            });
            return () => {
                const s = Object.keys(n).filter(d => d !== "_"),
                    o = ot();
                t.locale && (o.locale = t.locale), t.plural !== void 0 && (o.plural = _e(t.plural) ? +t.plural : t.plural);
                const a = HZ(e, s),
                    l = i[Ry](t.keypath, a, o),
                    c = Vt(ot(), r),
                    u = _e(t.tag) || Ke(t.tag) ? t.tag : lM();
                return qt(u, c, l)
            }
        }
    }),
    i1 = zZ;

function jZ(t) {
    return Dt(t) && !_e(t[0])
}

function cM(t, e, n, r) {
    const {
        slots: i,
        attrs: s
    } = e;
    return () => {
        const o = {
            part: !0
        };
        let a = ot();
        t.locale && (o.locale = t.locale), _e(t.format) ? o.key = t.format : Ke(t.format) && (_e(t.format.key) && (o.key = t.format.key), a = Object.keys(t.format).reduce((f, h) => n.includes(h) ? Vt(ot(), f, {
            [h]: t.format[h]
        }) : f, ot()));
        const l = r(t.value, o, a);
        let c = [o.key];
        Dt(l) ? c = l.map((f, h) => {
            const p = i[f.type],
                b = p ? p({
                    [f.type]: f.value,
                    index: h,
                    parts: l
                }) : [f.value];
            return jZ(b) && (b[0].key = `${f.type}-${h}`), b
        }) : _e(l) && (c = [l]);
        const u = Vt(ot(), s),
            d = _e(t.tag) || Ke(t.tag) ? t.tag : lM();
        return qt(d, u, c)
    }
}
const VZ = ye({
        name: "i18n-n",
        props: Vt({
            value: {
                type: Number,
                required: !0
            },
            format: {
                type: [String, Object]
            }
        }, jb),
        setup(t, e) {
            const n = t.i18n || Vb({
                useScope: t.scope,
                __useComponent: !0
            });
            return cM(t, e, Z2, (...r) => n[ky](...r))
        }
    }),
    s1 = VZ;

function WZ(t, e) {
    const n = t;
    if (t.mode === "composition") return n.__getInstance(e) || t.global; {
        const r = n.__getInstance(e);
        return r != null ? r.__composer : t.global.__composer
    }
}

function YZ(t) {
    const e = o => {
        Db(ed(Jr.DEPRECATE_TRANSLATE_CUSTOME_DIRECTIVE));
        const {
            instance: a,
            value: l
        } = o;
        if (!a || !a.$) throw Fn(dt.UNEXPECTED_ERROR);
        const c = WZ(t, a.$),
            u = o1(l);
        return [Reflect.apply(c.t, c, [...a1(u)]), c]
    };
    return {
        created: (o, a) => {
            const [l, c] = e(a);
            Mr && t.global === c && (o.__i18nWatcher = pe(c.locale, () => {
                a.instance && a.instance.$forceUpdate()
            })), o.__composer = c, o.textContent = l
        },
        unmounted: o => {
            Mr && o.__i18nWatcher && (o.__i18nWatcher(), o.__i18nWatcher = void 0, delete o.__i18nWatcher), o.__composer && (o.__composer = void 0, delete o.__composer)
        },
        beforeUpdate: (o, {
            value: a
        }) => {
            if (o.__composer) {
                const l = o.__composer,
                    c = o1(a);
                o.textContent = Reflect.apply(l.t, l, [...a1(c)])
            }
        },
        getSSRProps: o => {
            const [a] = e(o);
            return {
                textContent: a
            }
        }
    }
}

function o1(t) {
    if (_e(t)) return {
        path: t
    };
    if (Ge(t)) {
        if (!("path" in t)) throw Fn(dt.REQUIRED_VALUE, "path");
        return t
    } else throw Fn(dt.INVALID_VALUE)
}

function a1(t) {
    const {
        path: e,
        locale: n,
        args: r,
        choice: i,
        plural: s
    } = t, o = {}, a = r || {};
    return _e(n) && (o.locale = n), Lt(i) && (o.plural = i), Lt(s) && (o.plural = s), [e, a, o]
}

function XZ(t, e, ...n) {
    const r = Ge(n[0]) ? n[0] : {};
    (Je(r.globalInstall) ? r.globalInstall : !0) && ([i1.name, "I18nT"].forEach(s => t.component(s, i1)), [s1.name, "I18nN"].forEach(s => t.component(s, s1)), [c1.name, "I18nD"].forEach(s => t.component(s, c1))), t.directive("t", YZ(e))
}
const KZ = ci("global-vue-i18n");

function R_e(t = {}) {
    const e = __VUE_I18N_LEGACY_API__ && Je(t.legacy) ? t.legacy : __VUE_I18N_LEGACY_API__;
    e && Db(ed(Jr.DEPRECATE_LEGACY_MODE));
    const n = Je(t.globalInjection) ? t.globalInjection : !0,
        r = new Map,
        [i, s] = qZ(t, e),
        o = ci("vue-i18n");

    function a(d) {
        return r.get(d) || null
    }

    function l(d, f) {
        r.set(d, f)
    }

    function c(d) {
        r.delete(d)
    }
    const u = {
        get mode() {
            return __VUE_I18N_LEGACY_API__ && e ? "legacy" : "composition"
        },
        async install(d, ...f) {
            if (d.__VUE_I18N__ = u, d.__VUE_I18N_SYMBOL__ = o, d.provide(d.__VUE_I18N_SYMBOL__, u), Ge(f[0])) {
                const b = f[0];
                u.__composerExtend = b.__composerExtend, u.__vueI18nExtend = b.__vueI18nExtend
            }
            let h = null;
            !e && n && (h = iQ(d, u.global)), __VUE_I18N_FULL_INSTALL__ && XZ(d, u, ...f), __VUE_I18N_LEGACY_API__ && e && d.mixin(GZ(s, s.__composer, u));
            const p = d.unmount;
            d.unmount = () => {
                h && h(), u.dispose(), p()
            }; {
                if (!await OZ(d, u)) throw Fn(dt.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
                const y = $b();
                if (e) {
                    const m = s;
                    m.__enableEmitter && m.__enableEmitter(y)
                } else {
                    const m = s;
                    m[Yo] && m[Yo](y)
                }
                y.on("*", mu)
            }
        },
        get global() {
            return s
        },
        dispose() {
            i.stop()
        },
        __instances: r,
        __getInstance: a,
        __setInstance: l,
        __deleteInstance: c
    };
    return u
}

function Vb(t = {}) {
    const e = it();
    if (e == null) throw Fn(dt.MUST_BE_CALL_SETUP_TOP);
    if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__) throw Fn(dt.NOT_INSTALLED);
    const n = JZ(e),
        r = QZ(n),
        i = rM(e),
        s = ZZ(t, i);
    if (s === "global") return iM(r, t, i), r;
    if (s === "parent") {
        let l = eQ(n, e, t.__useComponent);
        return l == null && (Ys(ed(Jr.NOT_FOUND_PARENT_SCOPE)), l = r), l
    }
    const o = n;
    let a = o.__getInstance(e);
    if (a == null) {
        const l = Vt({}, t);
        "__i18n" in i && (l.__i18n = i.__i18n), r && (l.__root = r), a = Hb(l), o.__composerExtend && (a[By] = o.__composerExtend(a)), nQ(o, e, a), o.__setInstance(e, a)
    }
    return a
}

function qZ(t, e) {
    const n = Bu(),
        r = __VUE_I18N_LEGACY_API__ && e ? n.run(() => $y(t)) : n.run(() => Hb(t));
    if (r == null) throw Fn(dt.UNEXPECTED_ERROR);
    return [n, r]
}

function JZ(t) {
    const e = Nt(t.isCE ? KZ : t.appContext.app.__VUE_I18N_SYMBOL__);
    if (!e) throw Fn(t.isCE ? dt.NOT_INSTALLED_WITH_PROVIDE : dt.UNEXPECTED_ERROR);
    return e
}

function ZZ(t, e) {
    return Tp(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local"
}

function QZ(t) {
    return t.mode === "composition" ? t.global : t.global.__composer
}

function eQ(t, e, n = !1) {
    let r = null;
    const i = e.root;
    let s = tQ(e, n);
    for (; s != null;) {
        const o = t;
        if (t.mode === "composition") r = o.__getInstance(s);
        else if (__VUE_I18N_LEGACY_API__) {
            const a = o.__getInstance(s);
            a != null && (r = a.__composer, n && r && !r[nM] && (r = null))
        }
        if (r != null || i === s) break;
        s = s.parent
    }
    return r
}

function tQ(t, e = !1) {
    return t == null ? null : e && t.vnode.ctx || t.parent
}

function nQ(t, e, n) {
    let r = null;
    St(() => {
        if (e.vnode.el) {
            e.vnode.el.__VUE_I18N__ = n, r = $b();
            const i = n;
            i[Yo] && i[Yo](r), r.on("*", mu)
        }
    }, e), Ki(() => {
        const i = n;
        e.vnode.el && e.vnode.el.__VUE_I18N__ && (r && r.off("*", mu), i[hu] && i[hu](), delete e.vnode.el.__VUE_I18N__), t.__deleteInstance(e);
        const s = i[By];
        s && (s(), delete i[By])
    }, e)
}
const rQ = ["locale", "fallbackLocale", "availableLocales"],
    l1 = ["t", "rt", "d", "n", "tm", "te"];

function iQ(t, e) {
    const n = Object.create(null);
    return rQ.forEach(i => {
        const s = Object.getOwnPropertyDescriptor(e, i);
        if (!s) throw Fn(dt.UNEXPECTED_ERROR);
        const o = tt(s.value) ? {
            get() {
                return s.value.value
            },
            set(a) {
                s.value.value = a
            }
        } : {
            get() {
                return s.get && s.get()
            }
        };
        Object.defineProperty(n, i, o)
    }), t.config.globalProperties.$i18n = n, l1.forEach(i => {
        const s = Object.getOwnPropertyDescriptor(e, i);
        if (!s || !s.value) throw Fn(dt.UNEXPECTED_ERROR);
        Object.defineProperty(t.config.globalProperties, `$${i}`, s)
    }), () => {
        delete t.config.globalProperties.$i18n, l1.forEach(i => {
            delete t.config.globalProperties[`$${i}`]
        })
    }
}
const sQ = ye({
        name: "i18n-d",
        props: Vt({
            value: {
                type: [Number, Date],
                required: !0
            },
            format: {
                type: [String, Object]
            }
        }, jb),
        setup(t, e) {
            const n = t.i18n || Vb({
                useScope: t.scope,
                __useComponent: !0
            });
            return cM(t, e, J2, (...r) => n[My](...r))
        }
    }),
    c1 = sQ;
wZ();
eZ(MJ);
tZ(KJ);
nZ(H2); {
    const t = wo();
    t.__INTLIFY__ = !0, kJ(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__)
}
var M_e = {
        name: "Name",
        tel: "Phone",
        save: "Save",
        clear: "Clear",
        cancel: "Cancel",
        confirm: "Confirm",
        delete: "Delete",
        loading: "Loading...",
        noCoupon: "No coupons",
        nameEmpty: "Please fill in the name",
        addContact: "Add contact",
        telInvalid: "Malformed phone number",
        vanCalendar: {
            end: "End",
            start: "Start",
            title: "Calendar",
            weekdays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `Choose no more than ${t} days`
        },
        vanCascader: {
            select: "Select"
        },
        vanPagination: {
            prev: "Previous",
            next: "Next"
        },
        vanPullRefresh: {
            pulling: "Pull to refresh...",
            loosing: "Loose to refresh..."
        },
        vanSubmitBar: {
            label: "Total:"
        },
        vanCoupon: {
            unlimited: "Unlimited",
            discount: t => `${t*10}% off`,
            condition: t => `At least ${t}`
        },
        vanCouponCell: {
            title: "Coupon",
            count: t => `You have ${t} coupons`
        },
        vanCouponList: {
            exchange: "Exchange",
            close: "Close",
            enable: "Available",
            disabled: "Unavailable",
            placeholder: "Coupon code"
        },
        vanAddressEdit: {
            area: "Area",
            areaEmpty: "Please select a receiving area",
            addressEmpty: "Address can not be empty",
            addressDetail: "Address",
            defaultAddress: "Set as the default address"
        },
        vanAddressList: {
            add: "Add new address"
        }
    },
    k_e = {
        name: "Имя",
        tel: "Телефон",
        save: "Сохранить",
        clear: "Прозрачный",
        cancel: "Отмена",
        confirm: "Подтвердить",
        delete: "Удалить",
        loading: "Загрузка...",
        noCoupon: "Нет купонов",
        nameEmpty: "Пожалуйста укажите имя",
        addContact: "Создать контакт",
        telInvalid: "Некорректный номер телефона",
        vanCalendar: {
            end: "Конец",
            start: "Начало",
            title: "Календарь",
            weekdays: ["ВС", "ПН", "ВТ", "СР", "ЧТ", "ПТ", "СБ"],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `Укажите более ${t} дней`
        },
        vanCascader: {
            select: "Выбрать"
        },
        vanPagination: {
            prev: "Назад",
            next: "Вперед"
        },
        vanPullRefresh: {
            pulling: "Потяните для обновления...",
            loosing: "Отпустите для обновления..."
        },
        vanSubmitBar: {
            label: "Всего:"
        },
        vanCoupon: {
            unlimited: "Безлимитный",
            discount: t => `${t*10}% скидка`,
            condition: t => `Как минимум ${t}`
        },
        vanCouponCell: {
            title: "Купон",
            count: t => `У вас есть ${t} купонов`
        },
        vanCouponList: {
            exchange: "Обмен",
            close: "Закрыть",
            enable: "Доступно",
            disabled: "Недоступно",
            placeholder: "Код купона"
        },
        vanAddressEdit: {
            area: "Область",
            areaEmpty: "Укажите зону доставки",
            addressEmpty: "Адрес не может быть пустым",
            addressDetail: "Адрес",
            defaultAddress: "Сделать адресом по умолчанию"
        },
        vanAddressList: {
            add: "Новый адрес"
        }
    },
    B_e = {
        name: "tên",
        tel: "Điện thoại",
        save: "Cứu",
        clear: "Thông thoáng",
        cancel: "Hủy bỏ",
        confirm: "Xác nhận",
        delete: "Xóa",
        loading: "Đang tải ...",
        noCoupon: "Không có phiếu giảm giá",
        nameEmpty: "Vui lòng điền vào tên",
        addContact: "Thêm liên hệ",
        telInvalid: "Số điện thoại không đúng định dạng",
        vanCalendar: {
            end: "Kết thúc",
            start: "Bắt ​​đầu",
            title: "Lịch",
            weekdays: ["chủ nhật", "thứ hai", "thứ ba", "Thứ Tư", "Thứ năm", "Thứ sáu", "thứ bảy"],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `Chọn không quá ${t} ngày`
        },
        vanCascader: {
            select: "Chọn"
        },
        vanPagination: {
            prev: "Trước đó",
            next: "Tiếp theo"
        },
        vanPullRefresh: {
            pulling: "Kéo để làm mới ...",
            loosing: "Loose để làm mới ..."
        },
        vanSubmitBar: {
            label: "Tổng:"
        },
        vanCoupon: {
            unlimited: "Không giới hạn",
            discount: t => `Chiết khấu ${t*10}%`,
            condition: t => `Ít nhất ${t}`
        },
        vanCouponCell: {
            title: "Phiếu giảm giá",
            count: t => `Bạn có ${t} phiếu giảm giá`
        },
        vanCouponList: {
            exchange: "Trao đổi",
            close: "Đóng",
            enable: "Có sẵn",
            disabled: "Không khả dụng",
            placeholder: "Mã phiếu thưởng"
        },
        vanAddressEdit: {
            area: "Khu vực",
            areaEmpty: "Vui lòng chọn khu vực nhận hàng",
            addressEmpty: "Địa chỉ không được để trống",
            addressDetail: "Địa chỉ",
            defaultAddress: "Đặt làm địa chỉ mặc định"
        },
        vanAddressList: {
            add: "Thêm địa chỉ mới"
        }
    },
    D_e = {
        name: "Nama",
        tel: "Telepon",
        save: "Simpan",
        clear: "Jernih",
        cancel: "Batal",
        confirm: "Konfirmasi",
        delete: "Hapus",
        loading: "Memuat...",
        noCoupon: "Tidak ada kupon",
        nameEmpty: "Silakan isi nama",
        addContact: "Tambahkan kontak",
        telInvalid: "Nomor telepon salah format",
        vanCalendar: {
            end: "Akhir",
            start: "Mulai",
            title: "Kalender",
            weekdays: ["minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `Pilih tidak lebih dari ${t} hari`
        },
        vanCascader: {
            select: "Pilih"
        },
        vanPagination: {
            prev: "Sebelumnya",
            next: "Selanjutnya"
        },
        vanPullRefresh: {
            pulling: "Tarik untuk menyegarkan...",
            loosing: "Loose untuk menyegarkan..."
        },
        vanSubmitBar: {
            label: "Jumlah:"
        },
        vanCoupon: {
            unlimited: "Tidak terbatas",
            discount: t => `${t*10}% off`,
            condition: t => `Setidaknya ${t}`
        },
        vanCouponCell: {
            title: "Kupon",
            count: t => `Anda memiliki kupon ${t}`
        },
        vanCouponList: {
            exchange: "Pertukaran",
            close: "Tutup",
            enable: "Tersedia",
            disabled: "Tidak tersedia",
            placeholder: "Kode kupon"
        },
        vanAddressEdit: {
            area: "Daerah",
            areaEmpty: "Silakan pilih area penerima",
            addressEmpty: "Alamat tidak boleh kosong",
            addressDetail: "Alamat",
            defaultAddress: "Tetapkan sebagai alamat default"
        },
        vanAddressList: {
            add: "Tambahkan alamat baru"
        }
    },
    $_e = {
        name: "नाम",
        tel: "फ़ोन",
        save: "सहेजें",
        clear: "साफ़",
        cancel: "रद्द करें",
        confirm: "पुष्टि करना",
        delete: "हटाएं",
        loading: "लोड हो रहा है...",
        noCoupon: "कोई कूपन नहीं",
        nameEmpty: "कृपया नाम भरें",
        addContact: "संपर्क जोड़ें",
        telInvalid: "विकृत फ़ोन नंबर",
        vanCalendar: {
            end: "समाप्त",
            start: "शुरू",
            title: "पंचांग",
            weekdays: ["रविवार", "सोमवार", "मंगलवार", "बुधवार", "गुरूवार", "शुक्रवार", "शनिवार"],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `${t} दिन से अधिक नहीं चुनें`
        },
        vanCascader: {
            select: "चुनते हैं"
        },
        vanPagination: {
            prev: "पहले का",
            next: "अगला"
        },
        vanPullRefresh: {
            pulling: "रीफ़्रेश करने के लिए खींचें...",
            loosing: "ताज़ा करने के लिए ढीला..."
        },
        vanSubmitBar: {
            label: "कुल:"
        },
        vanCoupon: {
            unlimited: "असीमित",
            discount: t => `${t*10}% छूट`,
            condition: t => `कम से कम ${t}`
        },
        vanCouponCell: {
            title: "कूपन",
            count: t => `आपके पास ${t} कूपन हैं`
        },
        vanCouponList: {
            exchange: "अदला बदली",
            close: "बंद करे",
            enable: "उपलब्ध",
            disabled: "अनुपलब्ध",
            placeholder: "कूपन कोड"
        },
        vanAddressEdit: {
            area: "क्षेत्र",
            areaEmpty: "कृपया एक क्षेत्र चुनें",
            addressEmpty: "पता खाली नहीं हो सकता",
            addressDetail: "पता",
            defaultAddress: "डिफ़ॉल्ट पते के रूप में सेट करें"
        },
        vanAddressList: {
            add: "नया पता जोड़ें"
        }
    },
    F_e = {
        name: "ชื่อ",
        tel: "โทรศัพท์",
        save: "บันทึก",
        clear: "ชัดเจน",
        cancel: "ยกเลิก",
        confirm: "ยืนยัน",
        delete: "ลบ",
        loading: "กำลังโหลด...",
        noCoupon: "ไม่มีคูปอง",
        nameEmpty: "กรุณากรอกชื่อของคุณ",
        addContact: "เพิ่มผู้ติดต่อ",
        telInvalid: "กรุณากรอกหมายเลขโทรศัพท์ที่ถูกต้อง",
        vanCalendar: {
            end: "จบ",
            start: "เริ่ม",
            title: "การเลือกวันที่",
            weekdays: ["อา", "จ", "อ", "พ", "พฤ", "ศ", "ส"],
            monthTitle: (t, e) => `${t}ปี${e}เดือน`,
            rangePrompt: t => `จำนวนวันที่เลือกต้องไม่เกิน ${t} วัน`
        },
        vanCascader: {
            select: "โปรดเลือก"
        },
        vanPagination: {
            prev: "หน้าที่แล้ว",
            next: "หน้าต่อไป"
        },
        vanPullRefresh: {
            pulling: "ดึงลงเพื่อรีเฟรช...",
            loosing: "ปล่อยเพื่อรีเฟรช..."
        },
        vanSubmitBar: {
            label: "รวม:"
        },
        vanCoupon: {
            unlimited: "ไม่ จำกัด",
            discount: t => `ลด${t}`,
            condition: t => `มีจำหน่ายในราคา ${t} กว่าหยวน`
        },
        vanCouponCell: {
            title: "คูปอง",
            count: t => `มีรูปภาพ ${t} รูป`
        },
        vanCouponList: {
            exchange: "แลกเปลี่ยน",
            close: "ไม่ได้ใช้",
            enable: "พร้อมใช้งาน",
            disabled: "ไม่พร้อมใช้งาน",
            placeholder: "กรุณากรอกรหัสคูปอง"
        },
        vanAddressEdit: {
            area: "พื้นที่",
            areaEmpty: "โปรดเลือกภูมิภาค",
            addressEmpty: "กรุณากรอกที่อยู่โดยละเอียด",
            addressDetail: "ที่อยู่",
            defaultAddress: "ตั้งเป็นที่อยู่จัดส่งเริ่มต้น"
        },
        vanAddressList: {
            add: "เพิ่มที่อยู่"
        }
    },
    L_e = {
        name: "Nome",
        tel: "Fone",
        save: "Salvar",
        clear: "Claro",
        cancel: "Cancelar",
        confirm: "Confirmar",
        delete: "Excluir",
        loading: "Carregando...",
        noCoupon: "Nenhum cupom",
        nameEmpty: "Por favor, preencha o nome",
        addContact: "Adicionar novo contato",
        telInvalid: "Telefone em formato inválido",
        vanCalendar: {
            end: "Fim",
            start: "Início",
            title: "Calendário",
            weekdays: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
            monthTitle: (t, e) => `${e}/${t}`,
            rangePrompt: t => `Escolha no máximo ${t} dias`
        },
        vanCascader: {
            select: "Selecione"
        },
        vanPagination: {
            prev: "Anterior",
            next: "Próximo"
        },
        vanPullRefresh: {
            pulling: "Puxe para atualizar...",
            loosing: "Solte para atualizar..."
        },
        vanSubmitBar: {
            label: "Total:"
        },
        vanCoupon: {
            unlimited: "Ilimitado",
            discount: t => `${t*10}% de desconto`,
            condition: t => `Pelo menos ${t}`
        },
        vanCouponCell: {
            title: "Cupom",
            count: t => `Você possui ${t} cupom(ns)`
        },
        vanCouponList: {
            exchange: "Usar",
            close: "Fechar",
            enable: "Disponível",
            disabled: "Indisponível",
            placeholder: "Código do cupom"
        },
        vanAddressEdit: {
            area: "Área",
            areaEmpty: "Por favor, selecione uma área de recebimento",
            addressEmpty: "Endereço não pode ser vazio",
            addressDetail: "Endereço",
            defaultAddress: "Usar como endereço padrão"
        },
        vanAddressList: {
            add: "Adicionar novo endereço"
        }
    },
    N_e = {
        name: "নাম",
        tel: "ফোন",
        save: "সংরক্ষণ করুন",
        clear: "পরিষ্কার",
        cancel: "বাতিল",
        confirm: "নিশ্চিত করুন",
        delete: "মুছুন",
        loading: "লোড হচ্ছে...",
        noCoupon: "কোন কুপন নেই",
        nameEmpty: "অনুগ্রহ করে নামটি পূরণ করুন",
        addContact: "যোগাযোগ যোগ করুন",
        telInvalid: "বিকৃত ফোন নম্বর",
        vanCalendar: {
            end: "শেষ",
            start: "শুরু",
            title: "ক্যালেন্ডার",
            weekdays: ["রবিবার", "সোমবার", "মঙ্গলবার", "বুধবার", "বৃহস্পতিবার", "শুক্রবার", "শনিবার"],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `${t} দিনের বেশি নির্বাচন করবেন না`
        },
        vanCascader: {
            select: "নির্বাচন"
        },
        vanPagination: {
            prev: "পূর্ববর্তী",
            next: "পরবর্তী"
        },
        vanPullRefresh: {
            pulling: "রিফ্রেশ করতে টানুন...",
            loosing: "রিফ্রেশ করতে আলগা..."
        },
        vanSubmitBar: {
            label: "মোট:"
        },
        vanCoupon: {
            unlimited: "আনলিমিটেড",
            discount: t => `${t*10}% ছাড়`,
            condition: t => `অন্তত ${t}`
        },
        vanCouponCell: {
            title: "কুপন",
            count: t => `আপনার ${t} কুপন আছে`
        },
        vanCouponList: {
            exchange: "বিনিময়",
            close: "বন্ধ",
            enable: "উপলভ্য",
            disabled: "অনুপলব্ধ",
            placeholder: "কুপন কোড"
        },
        vanAddressEdit: {
            area: "এরিয়া",
            areaEmpty: "অনুগ্রহ করে একটি রিসিভিং এলাকা নির্বাচন করুন",
            addressEmpty: "ঠিকানা খালি হতে পারে না",
            addressDetail: "ঠিকানা",
            defaultAddress: "ডিফল্ট ঠিকানা হিসাবে সেট করুন"
        },
        vanAddressList: {
            add: "নতুন ঠিকানা যোগ করুন"
        }
    },
    U_e = {
        name: "الاسم",
        tel: "الهاتف",
        save: "حفظ",
        clear: "مسح",
        cancel: "إلغاء",
        confirm: "تأكيد",
        delete: "حذف",
        loading: "جار التحميل...",
        noCoupon: "لا يوجد كوبونات",
        nameEmpty: "يرجى ملء الاسم",
        addContact: "إضافة جهة اتصال",
        telInvalid: "رقم الهاتف غير صحيح",
        vanCalendar: {
            end: "نهاية",
            start: "بداية",
            title: "التقويم",
            weekdays: ["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت"],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `اختر لا يزيد عن ${t} أيام`
        },
        vanCascader: {
            select: "اختر"
        },
        vanPagination: {
            prev: "السابق",
            next: "التالي"
        },
        vanPullRefresh: {
            pulling: "اسحب للتحديث...",
            loosing: "أفلت للتحديث..."
        },
        vanSubmitBar: {
            label: "المجموع:"
        },
        vanCoupon: {
            unlimited: "غير محدود",
            discount: t => `${t*10}% خصم`,
            condition: t => `على الأقل ${t}`
        },
        vanCouponCell: {
            title: "كوبون",
            count: t => `لديك ${t} كوبونات`
        },
        vanCouponList: {
            exchange: "استبدال",
            close: "إغلاق",
            enable: "متاح",
            disabled: "غير متاح",
            placeholder: "كود الكوبون"
        },
        vanAddressEdit: {
            area: "المنطقة",
            areaEmpty: "يرجى اختيار منطقة استقبال",
            addressEmpty: "العنوان لا يمكن أن يكون فارغًا",
            addressDetail: "العنوان",
            defaultAddress: "تعيين كعنوان افتراضي"
        },
        vanAddressList: {
            add: "إضافة عنوان جديد"
        }
    };

function $s(t) {
    return Du() ? (t_(t), !0) : !1
}

function G_e(t) {
    let e = !1,
        n;
    const r = Bu(!0);
    return (...i) => (e || (n = r.run(() => t(...i)), e = !0), n)
}

function Tn(t) {
    return typeof t == "function" ? t() : En(t)
}
const Fs = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const oQ = t => typeof t < "u",
    aQ = t => t != null,
    lQ = Object.prototype.toString,
    cQ = t => lQ.call(t) === "[object Object]",
    Yn = () => {},
    Fy = uQ();

function uQ() {
    var t, e;
    return Fs && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent))
}

function Wb(t, e) {
    function n(...r) {
        return new Promise((i, s) => {
            Promise.resolve(t(() => e.apply(this, r), {
                fn: e,
                thisArg: this,
                args: r
            })).then(i).catch(s)
        })
    }
    return n
}
const uM = t => t();

function dM(t, e = {}) {
    let n, r, i = Yn;
    const s = a => {
        clearTimeout(a), i(), i = Yn
    };
    return a => {
        const l = Tn(t),
            c = Tn(e.maxWait);
        return n && s(n), l <= 0 || c !== void 0 && c <= 0 ? (r && (s(r), r = null), Promise.resolve(a())) : new Promise((u, d) => {
            i = e.rejectOnCancel ? d : u, c && !r && (r = setTimeout(() => {
                n && s(n), r = null, u(a())
            }, c)), n = setTimeout(() => {
                r && s(r), r = null, u(a())
            }, l)
        })
    }
}

function dQ(...t) {
    let e = 0,
        n, r = !0,
        i = Yn,
        s, o, a, l, c;
    !tt(t[0]) && typeof t[0] == "object" ? {
        delay: o,
        trailing: a = !0,
        leading: l = !0,
        rejectOnCancel: c = !1
    } = t[0] : [o, a = !0, l = !0, c = !1] = t;
    const u = () => {
        n && (clearTimeout(n), n = void 0, i(), i = Yn)
    };
    return f => {
        const h = Tn(o),
            p = Date.now() - e,
            b = () => s = f();
        return u(), h <= 0 ? (e = Date.now(), b()) : (p > h && (l || !r) ? (e = Date.now(), b()) : a && (s = new Promise((y, m) => {
            i = c ? m : y, n = setTimeout(() => {
                e = Date.now(), r = !0, y(b()), u()
            }, Math.max(0, h - p))
        })), !l && !n && (n = setTimeout(() => r = !0, h)), r = !1, s)
    }
}

function fQ(t = uM) {
    const e = J(!0);

    function n() {
        e.value = !1
    }

    function r() {
        e.value = !0
    }
    const i = (...s) => {
        e.value && t(...s)
    };
    return {
        isActive: oa(e),
        pause: n,
        resume: r,
        eventFilter: i
    }
}

function hQ(t) {
    let e;

    function n() {
        return e || (e = t()), e
    }
    return n.reset = async () => {
        const r = e;
        e = void 0, r && await r
    }, n
}

function pQ(t) {
    return t || it()
}

function fM(...t) {
    if (t.length !== 1) return Ec(...t);
    const e = t[0];
    return typeof e == "function" ? oa(ZP(() => ({
        get: e,
        set: Yn
    }))) : J(e)
}

function H_e(t, e = 200, n = {}) {
    return Wb(dM(e, n), t)
}

function z_e(t, e = 200, n = !1, r = !0, i = !1) {
    return Wb(dQ(e, n, r, i), t)
}

function hM(t, e, n = {}) {
    const {
        eventFilter: r = uM,
        ...i
    } = n;
    return pe(t, Wb(r, e), i)
}

function pM(t, e, n = {}) {
    const {
        eventFilter: r,
        ...i
    } = n, {
        eventFilter: s,
        pause: o,
        resume: a,
        isActive: l
    } = fQ(r);
    return {
        stop: hM(t, e, { ...i,
            eventFilter: s
        }),
        pause: o,
        resume: a,
        isActive: l
    }
}

function Yb(t, e = !0, n) {
    pQ() ? St(t, n) : e ? t() : Ue(t)
}

function j_e(t, e) {
    return ne(() => Tn(t).map(n => Tn(n)).filter(e))
}

function V_e(t, e = 1e3, n = {}) {
    const {
        immediate: r = !0,
        immediateCallback: i = !1
    } = n;
    let s = null;
    const o = J(!1);

    function a() {
        s && (clearInterval(s), s = null)
    }

    function l() {
        o.value = !1, a()
    }

    function c() {
        const u = Tn(e);
        u <= 0 || (o.value = !0, i && t(), a(), s = setInterval(t, u))
    }
    if (r && Fs && c(), tt(e) || typeof e == "function") {
        const u = pe(e, () => {
            o.value && Fs && c()
        });
        $s(u)
    }
    return $s(l), {
        isActive: o,
        pause: l,
        resume: c
    }
}

function mQ(t, e, n = {}) {
    const {
        immediate: r = !0
    } = n, i = J(!1);
    let s = null;

    function o() {
        s && (clearTimeout(s), s = null)
    }

    function a() {
        i.value = !1, o()
    }

    function l(...c) {
        o(), i.value = !0, s = setTimeout(() => {
            i.value = !1, s = null, t(...c)
        }, Tn(e))
    }
    return r && (i.value = !0, Fs && l()), $s(a), {
        isPending: oa(i),
        start: l,
        stop: a
    }
}

function W_e(t, e, n = {}) {
    const {
        debounce: r = 0,
        maxWait: i = void 0,
        ...s
    } = n;
    return hM(t, e, { ...s,
        eventFilter: dM(r, {
            maxWait: i
        })
    })
}

function Qr(t) {
    var e;
    const n = Tn(t);
    return (e = n == null ? void 0 : n.$el) != null ? e : n
}
const ai = Fs ? window : void 0,
    mM = Fs ? window.document : void 0,
    gM = Fs ? window.navigator : void 0;

function dn(...t) {
    let e, n, r, i;
    if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([n, r, i] = t, e = ai) : [e, n, r, i] = t, !e) return Yn;
    Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
    const s = [],
        o = () => {
            s.forEach(u => u()), s.length = 0
        },
        a = (u, d, f, h) => (u.addEventListener(d, f, h), () => u.removeEventListener(d, f, h)),
        l = pe(() => [Qr(e), Tn(i)], ([u, d]) => {
            if (o(), !u) return;
            const f = cQ(d) ? { ...d
            } : d;
            s.push(...n.flatMap(h => r.map(p => a(u, h, p, f))))
        }, {
            immediate: !0,
            flush: "post"
        }),
        c = () => {
            l(), o()
        };
    return $s(c), c
}
let u1 = !1;

function Y_e(t, e, n = {}) {
    const {
        window: r = ai,
        ignore: i = [],
        capture: s = !0,
        detectIframe: o = !1
    } = n;
    if (!r) return Yn;
    Fy && !u1 && (u1 = !0, Array.from(r.document.body.children).forEach(f => f.addEventListener("click", Yn)), r.document.documentElement.addEventListener("click", Yn));
    let a = !0;
    const l = f => i.some(h => {
            if (typeof h == "string") return Array.from(r.document.querySelectorAll(h)).some(p => p === f.target || f.composedPath().includes(p)); {
                const p = Qr(h);
                return p && (f.target === p || f.composedPath().includes(p))
            }
        }),
        u = [dn(r, "click", f => {
            const h = Qr(t);
            if (!(!h || h === f.target || f.composedPath().includes(h))) {
                if (f.detail === 0 && (a = !l(f)), !a) {
                    a = !0;
                    return
                }
                e(f)
            }
        }, {
            passive: !0,
            capture: s
        }), dn(r, "pointerdown", f => {
            const h = Qr(t);
            a = !l(f) && !!(h && !f.composedPath().includes(h))
        }, {
            passive: !0
        }), o && dn(r, "blur", f => {
            setTimeout(() => {
                var h;
                const p = Qr(t);
                ((h = r.document.activeElement) == null ? void 0 : h.tagName) === "IFRAME" && !(p != null && p.contains(r.document.activeElement)) && e(f)
            }, 0)
        })].filter(Boolean);
    return () => u.forEach(f => f())
}

function gQ() {
    const t = J(!1),
        e = it();
    return e && St(() => {
        t.value = !0
    }, e), t
}

function Ap(t) {
    const e = gQ();
    return ne(() => (e.value, !!t()))
}

function vQ(t, e, n = {}) {
    const {
        window: r = ai,
        ...i
    } = n;
    let s;
    const o = Ap(() => r && "MutationObserver" in r),
        a = () => {
            s && (s.disconnect(), s = void 0)
        },
        l = ne(() => {
            const f = Tn(t),
                h = (Array.isArray(f) ? f : [f]).map(Qr).filter(aQ);
            return new Set(h)
        }),
        c = pe(() => l.value, f => {
            a(), o.value && f.size && (s = new MutationObserver(e), f.forEach(h => s.observe(h, i)))
        }, {
            immediate: !0,
            flush: "post"
        }),
        u = () => s == null ? void 0 : s.takeRecords(),
        d = () => {
            a(), c()
        };
    return $s(d), {
        isSupported: o,
        stop: d,
        takeRecords: u
    }
}

function X_e(t, e) {
    const {
        interrupt: n = !0,
        onError: r = Yn,
        onFinished: i = Yn,
        signal: s
    } = e || {}, o = {
        aborted: "aborted",
        fulfilled: "fulfilled",
        pending: "pending",
        rejected: "rejected"
    }, a = Array.from(Array.from({
        length: t.length
    }), () => ({
        state: o.pending,
        data: null
    })), l = ht(a), c = J(-1);
    if (!t || t.length === 0) return i(), {
        activeIndex: c,
        result: l
    };

    function u(d, f) {
        c.value++, l[c.value].data = f, l[c.value].state = d
    }
    return t.reduce((d, f) => d.then(h => {
        var p;
        if (s != null && s.aborted) {
            u(o.aborted, new Error("aborted"));
            return
        }
        if (((p = l[c.value]) == null ? void 0 : p.state) === o.rejected && n) {
            i();
            return
        }
        const b = f(h).then(y => (u(o.fulfilled, y), c.value === t.length - 1 && i(), y));
        return s ? Promise.race([b, yQ(s)]) : b
    }).catch(h => s != null && s.aborted ? (u(o.aborted, h), h) : (u(o.rejected, h), r(), h)), Promise.resolve()), {
        activeIndex: c,
        result: l
    }
}

function yQ(t) {
    return new Promise((e, n) => {
        const r = new Error("aborted");
        t.aborted ? n(r) : t.addEventListener("abort", () => n(r), {
            once: !0
        })
    })
}

function d1(t, e = {}) {
    const {
        controls: n = !1,
        navigator: r = gM
    } = e, i = Ap(() => r && "permissions" in r);
    let s;
    const o = typeof t == "string" ? {
            name: t
        } : t,
        a = J(),
        l = () => {
            s && (a.value = s.state)
        },
        c = hQ(async () => {
            if (i.value) {
                if (!s) try {
                    s = await r.permissions.query(o), dn(s, "change", l), l()
                } catch {
                    a.value = "prompt"
                }
                return s
            }
        });
    return c(), n ? {
        state: a,
        isSupported: i,
        query: c
    } : a
}

function K_e(t = {}) {
    const {
        navigator: e = gM,
        read: n = !1,
        source: r,
        copiedDuring: i = 1500,
        legacy: s = !1
    } = t, o = Ap(() => e && "clipboard" in e), a = d1("clipboard-read"), l = d1("clipboard-write"), c = ne(() => o.value || s), u = J(""), d = J(!1), f = mQ(() => d.value = !1, i);

    function h() {
        o.value && m(a.value) ? e.clipboard.readText().then(g => {
            u.value = g
        }) : u.value = y()
    }
    c.value && n && dn(["copy", "cut"], h);
    async function p(g = Tn(r)) {
        c.value && g != null && (o.value && m(l.value) ? await e.clipboard.writeText(g) : b(g), u.value = g, d.value = !0, f.start())
    }

    function b(g) {
        const v = document.createElement("textarea");
        v.value = g ? ? "", v.style.position = "absolute", v.style.opacity = "0", document.body.appendChild(v), v.select(), document.execCommand("copy"), v.remove()
    }

    function y() {
        var g, v, _;
        return (_ = (v = (g = document == null ? void 0 : document.getSelection) == null ? void 0 : g.call(document)) == null ? void 0 : v.toString()) != null ? _ : ""
    }

    function m(g) {
        return g === "granted" || g === "prompt"
    }
    return {
        isSupported: c,
        text: u,
        copied: d,
        copy: p
    }
}

function _Q(t) {
    return JSON.parse(JSON.stringify(t))
}
const jd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
    Vd = "__vueuse_ssr_handlers__",
    bQ = xQ();

function xQ() {
    return Vd in jd || (jd[Vd] = jd[Vd] || {}), jd[Vd]
}

function wQ(t, e) {
    return bQ[t] || e
}

function EQ(t) {
    return t == null ? "any" : t instanceof Set ? "set" : t instanceof Map ? "map" : t instanceof Date ? "date" : typeof t == "boolean" ? "boolean" : typeof t == "string" ? "string" : typeof t == "object" ? "object" : Number.isNaN(t) ? "any" : "number"
}
const SQ = {
        boolean: {
            read: t => t === "true",
            write: t => String(t)
        },
        object: {
            read: t => JSON.parse(t),
            write: t => JSON.stringify(t)
        },
        number: {
            read: t => Number.parseFloat(t),
            write: t => String(t)
        },
        any: {
            read: t => t,
            write: t => String(t)
        },
        string: {
            read: t => t,
            write: t => String(t)
        },
        map: {
            read: t => new Map(JSON.parse(t)),
            write: t => JSON.stringify(Array.from(t.entries()))
        },
        set: {
            read: t => new Set(JSON.parse(t)),
            write: t => JSON.stringify(Array.from(t))
        },
        date: {
            read: t => new Date(t),
            write: t => t.toISOString()
        }
    },
    f1 = "vueuse-storage";

function vM(t, e, n, r = {}) {
    var i;
    const {
        flush: s = "pre",
        deep: o = !0,
        listenToStorageChanges: a = !0,
        writeDefaults: l = !0,
        mergeDefaults: c = !1,
        shallow: u,
        window: d = ai,
        eventFilter: f,
        onError: h = T => {
            console.error(T)
        },
        initOnMounted: p
    } = r, b = (u ? zh : J)(typeof e == "function" ? e() : e);
    if (!n) try {
        n = wQ("getDefaultStorage", () => {
            var T;
            return (T = ai) == null ? void 0 : T.localStorage
        })()
    } catch (T) {
        h(T)
    }
    if (!n) return b;
    const y = Tn(e),
        m = EQ(y),
        g = (i = r.serializer) != null ? i : SQ[m],
        {
            pause: v,
            resume: _
        } = pM(b, () => w(b.value), {
            flush: s,
            deep: o,
            eventFilter: f
        });
    d && a && Yb(() => {
        dn(d, "storage", C), dn(d, f1, A), p && C()
    }), p || C();

    function x(T, E) {
        d && d.dispatchEvent(new CustomEvent(f1, {
            detail: {
                key: t,
                oldValue: T,
                newValue: E,
                storageArea: n
            }
        }))
    }

    function w(T) {
        try {
            const E = n.getItem(t);
            if (T == null) x(E, null), n.removeItem(t);
            else {
                const P = g.write(T);
                E !== P && (n.setItem(t, P), x(E, P))
            }
        } catch (E) {
            h(E)
        }
    }

    function S(T) {
        const E = T ? T.newValue : n.getItem(t);
        if (E == null) return l && y != null && n.setItem(t, g.write(y)), y;
        if (!T && c) {
            const P = g.read(E);
            return typeof c == "function" ? c(P, y) : m === "object" && !Array.isArray(P) ? { ...y,
                ...P
            } : P
        } else return typeof E != "string" ? E : g.read(E)
    }

    function C(T) {
        if (!(T && T.storageArea !== n)) {
            if (T && T.key == null) {
                b.value = y;
                return
            }
            if (!(T && T.key !== t)) {
                v();
                try {
                    (T == null ? void 0 : T.newValue) !== g.write(b.value) && (b.value = S(T))
                } catch (E) {
                    h(E)
                } finally {
                    T ? Ue(_) : _()
                }
            }
        }
    }

    function A(T) {
        C(T.detail)
    }
    return b
}

function q_e(t = {}) {
    const {
        document: e = mM
    } = t;
    if (!e) return J("visible");
    const n = J(e.visibilityState);
    return dn(e, "visibilitychange", () => {
        n.value = e.visibilityState
    }), n
}

function TQ(t, e, n = {}) {
    const {
        window: r = ai,
        ...i
    } = n;
    let s;
    const o = Ap(() => r && "ResizeObserver" in r),
        a = () => {
            s && (s.disconnect(), s = void 0)
        },
        l = ne(() => Array.isArray(t) ? t.map(d => Qr(d)) : [Qr(t)]),
        c = pe(l, d => {
            if (a(), o.value && r) {
                s = new ResizeObserver(e);
                for (const f of d) f && s.observe(f, i)
            }
        }, {
            immediate: !0,
            flush: "post"
        }),
        u = () => {
            a(), c()
        };
    return $s(u), {
        isSupported: o,
        stop: u
    }
}

function J_e(t, e = {}) {
    const {
        reset: n = !0,
        windowResize: r = !0,
        windowScroll: i = !0,
        immediate: s = !0
    } = e, o = J(0), a = J(0), l = J(0), c = J(0), u = J(0), d = J(0), f = J(0), h = J(0);

    function p() {
        const b = Qr(t);
        if (!b) {
            n && (o.value = 0, a.value = 0, l.value = 0, c.value = 0, u.value = 0, d.value = 0, f.value = 0, h.value = 0);
            return
        }
        const y = b.getBoundingClientRect();
        o.value = y.height, a.value = y.bottom, l.value = y.left, c.value = y.right, u.value = y.top, d.value = y.width, f.value = y.x, h.value = y.y
    }
    return TQ(t, p), pe(() => Qr(t), b => !b && p()), vQ(t, p, {
        attributeFilter: ["style", "class"]
    }), i && dn("scroll", p, {
        capture: !0,
        passive: !0
    }), r && dn("resize", p, {
        passive: !0
    }), Yb(() => {
        s && p()
    }), {
        height: o,
        bottom: a,
        left: l,
        right: c,
        top: u,
        width: d,
        x: f,
        y: h,
        update: p
    }
}
const ic = new Map;

function Z_e(t) {
    const e = Du();

    function n(a) {
        var l;
        const c = ic.get(t) || new Set;
        c.add(a), ic.set(t, c);
        const u = () => i(a);
        return (l = e == null ? void 0 : e.cleanups) == null || l.push(u), u
    }

    function r(a) {
        function l(...c) {
            i(l), a(...c)
        }
        return n(l)
    }

    function i(a) {
        const l = ic.get(t);
        l && (l.delete(a), l.size || s())
    }

    function s() {
        ic.delete(t)
    }

    function o(a, l) {
        var c;
        (c = ic.get(t)) == null || c.forEach(u => u(a, l))
    }
    return {
        on: n,
        once: r,
        off: i,
        emit: o,
        reset: s
    }
}

function Nm(t) {
    return typeof Window < "u" && t instanceof Window ? t.document.documentElement : typeof Document < "u" && t instanceof Document ? t.documentElement : t
}

function Q_e(t, e, n = {}) {
    const {
        window: r = ai
    } = n;
    return vM(t, e, r == null ? void 0 : r.localStorage, n)
}

function yM(t) {
    const e = window.getComputedStyle(t);
    if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && t.clientWidth < t.scrollWidth || e.overflowY === "auto" && t.clientHeight < t.scrollHeight) return !0; {
        const n = t.parentNode;
        return !n || n.tagName === "BODY" ? !1 : yM(n)
    }
}

function CQ(t) {
    const e = t || window.event,
        n = e.target;
    return yM(n) ? !1 : e.touches.length > 1 ? !0 : (e.preventDefault && e.preventDefault(), !1)
}
const Um = new WeakMap;

function ebe(t, e = !1) {
    const n = J(e);
    let r = null,
        i = "";
    pe(fM(t), a => {
        const l = Nm(Tn(a));
        if (l) {
            const c = l;
            if (Um.get(c) || Um.set(c, c.style.overflow), c.style.overflow !== "hidden" && (i = c.style.overflow), c.style.overflow === "hidden") return n.value = !0;
            if (n.value) return c.style.overflow = "hidden"
        }
    }, {
        immediate: !0
    });
    const s = () => {
            const a = Nm(Tn(t));
            !a || n.value || (Fy && (r = dn(a, "touchmove", l => {
                CQ(l)
            }, {
                passive: !1
            })), a.style.overflow = "hidden", n.value = !0)
        },
        o = () => {
            const a = Nm(Tn(t));
            !a || !n.value || (Fy && (r == null || r()), a.style.overflow = i, Um.delete(a), n.value = !1)
        };
    return $s(o), ne({
        get() {
            return n.value
        },
        set(a) {
            a ? s() : o()
        }
    })
}

function tbe(t, e, n = {}) {
    const {
        window: r = ai
    } = n;
    return vM(t, e, r == null ? void 0 : r.sessionStorage, n)
}
let PQ = 0;

function nbe(t, e = {}) {
    const n = J(!1),
        {
            document: r = mM,
            immediate: i = !0,
            manual: s = !1,
            id: o = `vueuse_styletag_${++PQ}`
        } = e,
        a = J(t);
    let l = () => {};
    const c = () => {
            if (!r) return;
            const d = r.getElementById(o) || r.createElement("style");
            d.isConnected || (d.id = o, e.media && (d.media = e.media), r.head.appendChild(d)), !n.value && (l = pe(a, f => {
                d.textContent = f
            }, {
                immediate: !0
            }), n.value = !0)
        },
        u = () => {
            !r || !n.value || (l(), r.head.removeChild(r.getElementById(o)), n.value = !1)
        };
    return i && !s && Yb(c), s || $s(u), {
        id: o,
        css: a,
        unload: u,
        load: c,
        isLoaded: oa(n)
    }
}

function rbe(t, e = {}) {
    const {
        threshold: n = 50,
        onSwipe: r,
        onSwipeEnd: i,
        onSwipeStart: s,
        passive: o = !0,
        window: a = ai
    } = e, l = ht({
        x: 0,
        y: 0
    }), c = ht({
        x: 0,
        y: 0
    }), u = ne(() => l.x - c.x), d = ne(() => l.y - c.y), {
        max: f,
        abs: h
    } = Math, p = ne(() => f(h(u.value), h(d.value)) >= n), b = J(!1), y = ne(() => p.value ? h(u.value) > h(d.value) ? u.value > 0 ? "left" : "right" : d.value > 0 ? "up" : "down" : "none"), m = A => [A.touches[0].clientX, A.touches[0].clientY], g = (A, T) => {
        l.x = A, l.y = T
    }, v = (A, T) => {
        c.x = A, c.y = T
    };
    let _;
    const x = AQ(a == null ? void 0 : a.document);
    o ? _ = x ? {
        passive: !0
    } : {
        capture: !1
    } : _ = x ? {
        passive: !1,
        capture: !0
    } : {
        capture: !0
    };
    const w = A => {
            b.value && (i == null || i(A, y.value)), b.value = !1
        },
        S = [dn(t, "touchstart", A => {
            if (A.touches.length !== 1) return;
            _.capture && !_.passive && A.preventDefault();
            const [T, E] = m(A);
            g(T, E), v(T, E), s == null || s(A)
        }, _), dn(t, "touchmove", A => {
            if (A.touches.length !== 1) return;
            const [T, E] = m(A);
            v(T, E), !b.value && p.value && (b.value = !0), b.value && (r == null || r(A))
        }, _), dn(t, ["touchend", "touchcancel"], w, _)];
    return {
        isPassiveEventSupported: x,
        isSwiping: b,
        direction: y,
        coordsStart: l,
        coordsEnd: c,
        lengthX: u,
        lengthY: d,
        stop: () => S.forEach(A => A())
    }
}

function AQ(t) {
    if (!t) return !1;
    let e = !1;
    const n = {
        get passive() {
            return e = !0, !1
        }
    };
    return t.addEventListener("x", Yn, n), t.removeEventListener("x", Yn), e
}

function ibe(t = "history", e = {}) {
    const {
        initialValue: n = {},
        removeNullishValues: r = !0,
        removeFalsyValues: i = !1,
        write: s = !0,
        window: o = ai
    } = e;
    if (!o) return ht(n);
    const a = ht({});

    function l() {
        if (t === "history") return o.location.search || "";
        if (t === "hash") {
            const m = o.location.hash || "",
                g = m.indexOf("?");
            return g > 0 ? m.slice(g) : ""
        } else return (o.location.hash || "").replace(/^#/, "")
    }

    function c(m) {
        const g = m.toString();
        if (t === "history") return `${g?`?${g}`:""}${o.location.hash||""}`;
        if (t === "hash-params") return `${o.location.search||""}${g?`#${g}`:""}`;
        const v = o.location.hash || "#",
            _ = v.indexOf("?");
        return _ > 0 ? `${v.slice(0,_)}${g?`?${g}`:""}` : `${v}${g?`?${g}`:""}`
    }

    function u() {
        return new URLSearchParams(l())
    }

    function d(m) {
        const g = new Set(Object.keys(a));
        for (const v of m.keys()) {
            const _ = m.getAll(v);
            a[v] = _.length > 1 ? _ : m.get(v) || "", g.delete(v)
        }
        Array.from(g).forEach(v => delete a[v])
    }
    const {
        pause: f,
        resume: h
    } = pM(a, () => {
        const m = new URLSearchParams("");
        Object.keys(a).forEach(g => {
            const v = a[g];
            Array.isArray(v) ? v.forEach(_ => m.append(g, _)) : r && v == null || i && !v ? m.delete(g) : m.set(g, v)
        }), p(m)
    }, {
        deep: !0
    });

    function p(m, g) {
        f(), g && d(m), o.history.replaceState(o.history.state, o.document.title, o.location.pathname + c(m)), h()
    }

    function b() {
        s && p(u(), !0)
    }
    dn(o, "popstate", b, !1), t !== "history" && dn(o, "hashchange", b, !1);
    const y = u();
    return y.keys().next().value ? d(y) : Object.assign(a, n), a
}

function OQ(t, e, n, r = {}) {
    var i, s, o;
    const {
        clone: a = !1,
        passive: l = !1,
        eventName: c,
        deep: u = !1,
        defaultValue: d,
        shouldEmit: f
    } = r, h = it(), p = n || (h == null ? void 0 : h.emit) || ((i = h == null ? void 0 : h.$emit) == null ? void 0 : i.bind(h)) || ((o = (s = h == null ? void 0 : h.proxy) == null ? void 0 : s.$emit) == null ? void 0 : o.bind(h == null ? void 0 : h.proxy));
    let b = c;
    e || (e = "modelValue"), b = b || `update:${e.toString()}`;
    const y = v => a ? typeof a == "function" ? a(v) : _Q(v) : v,
        m = () => oQ(t[e]) ? y(t[e]) : d,
        g = v => {
            f ? f(v) && p(b, v) : p(b, v)
        };
    if (l) {
        const v = m(),
            _ = J(v);
        let x = !1;
        return pe(() => t[e], w => {
            x || (x = !0, _.value = y(w), Ue(() => x = !1))
        }), pe(_, w => {
            !x && (w !== t[e] || u) && g(w)
        }, {
            deep: u
        }), _
    } else return ne({
        get() {
            return m()
        },
        set(v) {
            g(v)
        }
    })
}

function sbe(t, e, n = {}) {
    const r = {};
    for (const i in t) r[i] = OQ(t, i, e, n);
    return r
}
var _M = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    })(zo, function() {
        return function(n, r, i) {
            n = n || {};
            var s = r.prototype,
                o = {
                    future: "in %s",
                    past: "%s ago",
                    s: "a few seconds",
                    m: "a minute",
                    mm: "%d minutes",
                    h: "an hour",
                    hh: "%d hours",
                    d: "a day",
                    dd: "%d days",
                    M: "a month",
                    MM: "%d months",
                    y: "a year",
                    yy: "%d years"
                };

            function a(c, u, d, f) {
                return s.fromToBase(c, u, d, f)
            }
            i.en.relativeTime = o, s.fromToBase = function(c, u, d, f, h) {
                for (var p, b, y, m = d.$locale().relativeTime || o, g = n.thresholds || [{
                        l: "s",
                        r: 44,
                        d: "second"
                    }, {
                        l: "m",
                        r: 89
                    }, {
                        l: "mm",
                        r: 44,
                        d: "minute"
                    }, {
                        l: "h",
                        r: 89
                    }, {
                        l: "hh",
                        r: 21,
                        d: "hour"
                    }, {
                        l: "d",
                        r: 35
                    }, {
                        l: "dd",
                        r: 25,
                        d: "day"
                    }, {
                        l: "M",
                        r: 45
                    }, {
                        l: "MM",
                        r: 10,
                        d: "month"
                    }, {
                        l: "y",
                        r: 17
                    }, {
                        l: "yy",
                        d: "year"
                    }], v = g.length, _ = 0; _ < v; _ += 1) {
                    var x = g[_];
                    x.d && (p = f ? i(c).diff(d, x.d, !0) : d.diff(c, x.d, !0));
                    var w = (n.rounding || Math.round)(Math.abs(p));
                    if (y = p > 0, w <= x.r || !x.r) {
                        w <= 1 && _ > 0 && (x = g[_ - 1]);
                        var S = m[x.l];
                        h && (w = h("" + w)), b = typeof S == "string" ? S.replace("%d", w) : S(w, u, x.l, y);
                        break
                    }
                }
                if (u) return b;
                var C = y ? m.future : m.past;
                return typeof C == "function" ? C(b) : C.replace("%s", b)
            }, s.to = function(c, u) {
                return a(c, u, this, !0)
            }, s.from = function(c, u) {
                return a(c, u, this)
            };
            var l = function(c) {
                return c.$u ? i.utc() : i()
            };
            s.toNow = function(c) {
                return this.to(l(this), c)
            }, s.fromNow = function(c) {
                return this.from(l(this), c)
            }
        }
    })
})(_M);
var IQ = _M.exports;
const obe = ua(IQ);
var RQ = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r(gb)
    })(zo, function(n) {
        function r(o) {
            return o && typeof o == "object" && "default" in o ? o : {
                default: o
            }
        }
        var i = r(n),
            s = {
                name: "zh-cn",
                weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
                weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"),
                weekdaysMin: "日_一_二_三_四_五_六".split("_"),
                months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
                monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
                ordinal: function(o, a) {
                    return a === "W" ? o + "周" : o + "日"
                },
                weekStart: 1,
                yearStart: 4,
                formats: {
                    LT: "HH:mm",
                    LTS: "HH:mm:ss",
                    L: "YYYY/MM/DD",
                    LL: "YYYY年M月D日",
                    LLL: "YYYY年M月D日Ah点mm分",
                    LLLL: "YYYY年M月D日ddddAh点mm分",
                    l: "YYYY/M/D",
                    ll: "YYYY年M月D日",
                    lll: "YYYY年M月D日 HH:mm",
                    llll: "YYYY年M月D日dddd HH:mm"
                },
                relativeTime: {
                    future: "%s内",
                    past: "%s前",
                    s: "几秒",
                    m: "1 分钟",
                    mm: "%d 分钟",
                    h: "1 小时",
                    hh: "%d 小时",
                    d: "1 天",
                    dd: "%d 天",
                    M: "1 个月",
                    MM: "%d 个月",
                    y: "1 年",
                    yy: "%d 年"
                },
                meridiem: function(o, a) {
                    var l = 100 * o + a;
                    return l < 600 ? "凌晨" : l < 900 ? "早上" : l < 1100 ? "上午" : l < 1300 ? "中午" : l < 1800 ? "下午" : "晚上"
                }
            };
        return i.default.locale(s, null, !0), s
    })
})(RQ);
var MQ = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r(gb)
    })(zo, function(n) {
        function r(o) {
            return o && typeof o == "object" && "default" in o ? o : {
                default: o
            }
        }
        var i = r(n),
            s = {
                name: "zh-tw",
                weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
                weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"),
                weekdaysMin: "日_一_二_三_四_五_六".split("_"),
                months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
                monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
                ordinal: function(o, a) {
                    return a === "W" ? o + "週" : o + "日"
                },
                formats: {
                    LT: "HH:mm",
                    LTS: "HH:mm:ss",
                    L: "YYYY/MM/DD",
                    LL: "YYYY年M月D日",
                    LLL: "YYYY年M月D日 HH:mm",
                    LLLL: "YYYY年M月D日dddd HH:mm",
                    l: "YYYY/M/D",
                    ll: "YYYY年M月D日",
                    lll: "YYYY年M月D日 HH:mm",
                    llll: "YYYY年M月D日dddd HH:mm"
                },
                relativeTime: {
                    future: "%s內",
                    past: "%s前",
                    s: "幾秒",
                    m: "1 分鐘",
                    mm: "%d 分鐘",
                    h: "1 小時",
                    hh: "%d 小時",
                    d: "1 天",
                    dd: "%d 天",
                    M: "1 個月",
                    MM: "%d 個月",
                    y: "1 年",
                    yy: "%d 年"
                },
                meridiem: function(o, a) {
                    var l = 100 * o + a;
                    return l < 600 ? "凌晨" : l < 900 ? "早上" : l < 1100 ? "上午" : l < 1300 ? "中午" : l < 1800 ? "下午" : "晚上"
                }
            };
        return i.default.locale(s, null, !0), s
    })
})(MQ);
var kQ = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    })(zo, function() {
        return {
            name: "en",
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            ordinal: function(n) {
                var r = ["th", "st", "nd", "rd"],
                    i = n % 100;
                return "[" + n + (r[(i - 20) % 10] || r[i] || r[0]) + "]"
            }
        }
    })
})(kQ);
/*!
 * vue-router v4.1.6
 * (c) 2022 Eduardo San Martin Morote
 * @license MIT
 */
const Ti = typeof window < "u";

function BQ(t) {
    return t.__esModule || t[Symbol.toStringTag] === "Module"
}
const nt = Object.assign;

function Gm(t, e) {
    const n = {};
    for (const r in e) {
        const i = e[r];
        n[r] = Jn(i) ? i.map(t) : t(i)
    }
    return n
}
const Dc = () => {},
    Jn = Array.isArray;

function je(t) {
    const e = Array.from(arguments).slice(1);
    console.warn.apply(console, ["[Vue Router warn]: " + t].concat(e))
}
const DQ = /\/$/,
    $Q = t => t.replace(DQ, "");

function Hm(t, e, n = "/") {
    let r, i = {},
        s = "",
        o = "";
    const a = e.indexOf("#");
    let l = e.indexOf("?");
    return a < l && a >= 0 && (l = -1), l > -1 && (r = e.slice(0, l), s = e.slice(l + 1, a > -1 ? a : e.length), i = t(s)), a > -1 && (r = r || e.slice(0, a), o = e.slice(a, e.length)), r = NQ(r ? ? e, n), {
        fullPath: r + (s && "?") + s + o,
        path: r,
        query: i,
        hash: o
    }
}

function FQ(t, e) {
    const n = e.query ? t(e.query) : "";
    return e.path + (n && "?") + n + (e.hash || "")
}

function h1(t, e) {
    return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || "/"
}

function p1(t, e, n) {
    const r = e.matched.length - 1,
        i = n.matched.length - 1;
    return r > -1 && r === i && Ls(e.matched[r], n.matched[i]) && bM(e.params, n.params) && t(e.query) === t(n.query) && e.hash === n.hash
}

function Ls(t, e) {
    return (t.aliasOf || t) === (e.aliasOf || e)
}

function bM(t, e) {
    if (Object.keys(t).length !== Object.keys(e).length) return !1;
    for (const n in t)
        if (!LQ(t[n], e[n])) return !1;
    return !0
}

function LQ(t, e) {
    return Jn(t) ? m1(t, e) : Jn(e) ? m1(e, t) : t === e
}

function m1(t, e) {
    return Jn(e) ? t.length === e.length && t.every((n, r) => n === e[r]) : t.length === 1 && t[0] === e
}

function NQ(t, e) {
    if (t.startsWith("/")) return t;
    if (!e.startsWith("/")) return je(`Cannot resolve a relative location without an absolute path. Trying to resolve "${t}" from "${e}". It should look like "/${e}".`), t;
    if (!t) return e;
    const n = e.split("/"),
        r = t.split("/");
    let i = n.length - 1,
        s, o;
    for (s = 0; s < r.length; s++)
        if (o = r[s], o !== ".")
            if (o === "..") i > 1 && i--;
            else break;
    return n.slice(0, i).join("/") + "/" + r.slice(s - (s === r.length ? 1 : 0)).join("/")
}
var gu;
(function(t) {
    t.pop = "pop", t.push = "push"
})(gu || (gu = {}));
var $c;
(function(t) {
    t.back = "back", t.forward = "forward", t.unknown = ""
})($c || ($c = {}));

function UQ(t) {
    if (!t)
        if (Ti) {
            const e = document.querySelector("base");
            t = e && e.getAttribute("href") || "/", t = t.replace(/^\w+:\/\/[^\/]+/, "")
        } else t = "/";
    return t[0] !== "/" && t[0] !== "#" && (t = "/" + t), $Q(t)
}
const GQ = /^[^#]+#/;

function HQ(t, e) {
    return t.replace(GQ, "#") + e
}

function zQ(t, e) {
    const n = document.documentElement.getBoundingClientRect(),
        r = t.getBoundingClientRect();
    return {
        behavior: e.behavior,
        left: r.left - n.left - (e.left || 0),
        top: r.top - n.top - (e.top || 0)
    }
}
const Op = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset
});

function jQ(t) {
    let e;
    if ("el" in t) {
        const n = t.el,
            r = typeof n == "string" && n.startsWith("#");
        if (typeof t.el == "string" && (!r || !document.getElementById(t.el.slice(1)))) try {
            const s = document.querySelector(t.el);
            if (r && s) {
                je(`The selector "${t.el}" should be passed as "el: document.querySelector('${t.el}')" because it starts with "#".`);
                return
            }
        } catch {
            je(`The selector "${t.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
            return
        }
        const i = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!i) {
            je(`Couldn't find element using selector "${t.el}" returned by scrollBehavior.`);
            return
        }
        e = zQ(i, t)
    } else e = t;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.pageXOffset, e.top != null ? e.top : window.pageYOffset)
}

function g1(t, e) {
    return (history.state ? history.state.position - e : -1) + t
}
const Ly = new Map;

function VQ(t, e) {
    Ly.set(t, e)
}

function WQ(t) {
    const e = Ly.get(t);
    return Ly.delete(t), e
}
let YQ = () => location.protocol + "//" + location.host;

function xM(t, e) {
    const {
        pathname: n,
        search: r,
        hash: i
    } = e, s = t.indexOf("#");
    if (s > -1) {
        let a = i.includes(t.slice(s)) ? t.slice(s).length : 1,
            l = i.slice(a);
        return l[0] !== "/" && (l = "/" + l), h1(l, "")
    }
    return h1(n, t) + r + i
}

function XQ(t, e, n, r) {
    let i = [],
        s = [],
        o = null;
    const a = ({
        state: f
    }) => {
        const h = xM(t, location),
            p = n.value,
            b = e.value;
        let y = 0;
        if (f) {
            if (n.value = h, e.value = f, o && o === p) {
                o = null;
                return
            }
            y = b ? f.position - b.position : 0
        } else r(h);
        i.forEach(m => {
            m(n.value, p, {
                delta: y,
                type: gu.pop,
                direction: y ? y > 0 ? $c.forward : $c.back : $c.unknown
            })
        })
    };

    function l() {
        o = n.value
    }

    function c(f) {
        i.push(f);
        const h = () => {
            const p = i.indexOf(f);
            p > -1 && i.splice(p, 1)
        };
        return s.push(h), h
    }

    function u() {
        const {
            history: f
        } = window;
        f.state && f.replaceState(nt({}, f.state, {
            scroll: Op()
        }), "")
    }

    function d() {
        for (const f of s) f();
        s = [], window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", u)
    }
    return window.addEventListener("popstate", a), window.addEventListener("beforeunload", u), {
        pauseListeners: l,
        listen: c,
        destroy: d
    }
}

function v1(t, e, n, r = !1, i = !1) {
    return {
        back: t,
        current: e,
        forward: n,
        replaced: r,
        position: window.history.length,
        scroll: i ? Op() : null
    }
}

function KQ(t) {
    const {
        history: e,
        location: n
    } = window, r = {
        value: xM(t, n)
    }, i = {
        value: e.state
    };
    i.value || s(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null
    }, !0);

    function s(l, c, u) {
        const d = t.indexOf("#"),
            f = d > -1 ? (n.host && document.querySelector("base") ? t : t.slice(d)) + l : YQ() + t + l;
        try {
            e[u ? "replaceState" : "pushState"](c, "", f), i.value = c
        } catch (h) {
            je("Error with push/replace State", h), n[u ? "replace" : "assign"](f)
        }
    }

    function o(l, c) {
        const u = nt({}, e.state, v1(i.value.back, l, i.value.forward, !0), c, {
            position: i.value.position
        });
        s(l, u, !0), r.value = l
    }

    function a(l, c) {
        const u = nt({}, i.value, e.state, {
            forward: l,
            scroll: Op()
        });
        e.state || je(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`), s(u.current, u, !0);
        const d = nt({}, v1(r.value, l, null), {
            position: u.position + 1
        }, c);
        s(l, d, !1), r.value = l
    }
    return {
        location: r,
        state: i,
        push: a,
        replace: o
    }
}

function qQ(t) {
    t = UQ(t);
    const e = KQ(t),
        n = XQ(t, e.state, e.location, e.replace);

    function r(s, o = !0) {
        o || n.pauseListeners(), history.go(s)
    }
    const i = nt({
        location: "",
        base: t,
        go: r,
        createHref: HQ.bind(null, t)
    }, e, n);
    return Object.defineProperty(i, "location", {
        enumerable: !0,
        get: () => e.location.value
    }), Object.defineProperty(i, "state", {
        enumerable: !0,
        get: () => e.state.value
    }), i
}

function abe(t) {
    return t = location.host ? t || location.pathname + location.search : "", t.includes("#") || (t += "#"), !t.endsWith("#/") && !t.endsWith("#") && je(`A hash base must end with a "#":
"${t}" should be "${t.replace(/#.*$/,"#")}".`), qQ(t)
}

function JQ(t) {
    return typeof t == "string" || t && typeof t == "object"
}

function wM(t) {
    return typeof t == "string" || typeof t == "symbol"
}
const is = {
        path: "/",
        name: void 0,
        params: {},
        query: {},
        hash: "",
        fullPath: "/",
        matched: [],
        meta: {},
        redirectedFrom: void 0
    },
    EM = Symbol("navigation failure");
var y1;
(function(t) {
    t[t.aborted = 4] = "aborted", t[t.cancelled = 8] = "cancelled", t[t.duplicated = 16] = "duplicated"
})(y1 || (y1 = {}));
const ZQ = {
    1({
        location: t,
        currentLocation: e
    }) {
        return `No match for
 ${JSON.stringify(t)}${e?`
while being at
`+JSON.stringify(e):""}`
    },
    2({
        from: t,
        to: e
    }) {
        return `Redirected from "${t.fullPath}" to "${eee(e)}" via a navigation guard.`
    },
    4({
        from: t,
        to: e
    }) {
        return `Navigation aborted from "${t.fullPath}" to "${e.fullPath}" via a navigation guard.`
    },
    8({
        from: t,
        to: e
    }) {
        return `Navigation cancelled from "${t.fullPath}" to "${e.fullPath}" with a new navigation.`
    },
    16({
        from: t,
        to: e
    }) {
        return `Avoided redundant navigation to current location: "${t.fullPath}".`
    }
};

function hl(t, e) {
    return nt(new Error(ZQ[t](e)), {
        type: t,
        [EM]: !0
    }, e)
}

function mi(t, e) {
    return t instanceof Error && EM in t && (e == null || !!(t.type & e))
}
const QQ = ["params", "query", "hash"];

function eee(t) {
    if (typeof t == "string") return t;
    if ("path" in t) return t.path;
    const e = {};
    for (const n of QQ) n in t && (e[n] = t[n]);
    return JSON.stringify(e, null, 2)
}
const _1 = "[^/]+?",
    tee = {
        sensitive: !1,
        strict: !1,
        start: !0,
        end: !0
    },
    nee = /[.+*?^${}()[\]/\\]/g;

function ree(t, e) {
    const n = nt({}, tee, e),
        r = [];
    let i = n.start ? "^" : "";
    const s = [];
    for (const c of t) {
        const u = c.length ? [] : [90];
        n.strict && !c.length && (i += "/");
        for (let d = 0; d < c.length; d++) {
            const f = c[d];
            let h = 40 + (n.sensitive ? .25 : 0);
            if (f.type === 0) d || (i += "/"), i += f.value.replace(nee, "\\$&"), h += 40;
            else if (f.type === 1) {
                const {
                    value: p,
                    repeatable: b,
                    optional: y,
                    regexp: m
                } = f;
                s.push({
                    name: p,
                    repeatable: b,
                    optional: y
                });
                const g = m || _1;
                if (g !== _1) {
                    h += 10;
                    try {
                        new RegExp(`(${g})`)
                    } catch (_) {
                        throw new Error(`Invalid custom RegExp for param "${p}" (${g}): ` + _.message)
                    }
                }
                let v = b ? `((?:${g})(?:/(?:${g}))*)` : `(${g})`;
                d || (v = y && c.length < 2 ? `(?:/${v})` : "/" + v), y && (v += "?"), i += v, h += 20, y && (h += -8), b && (h += -20), g === ".*" && (h += -50)
            }
            u.push(h)
        }
        r.push(u)
    }
    if (n.strict && n.end) {
        const c = r.length - 1;
        r[c][r[c].length - 1] += .7000000000000001
    }
    n.strict || (i += "/?"), n.end ? i += "$" : n.strict && (i += "(?:/|$)");
    const o = new RegExp(i, n.sensitive ? "" : "i");

    function a(c) {
        const u = c.match(o),
            d = {};
        if (!u) return null;
        for (let f = 1; f < u.length; f++) {
            const h = u[f] || "",
                p = s[f - 1];
            d[p.name] = h && p.repeatable ? h.split("/") : h
        }
        return d
    }

    function l(c) {
        let u = "",
            d = !1;
        for (const f of t) {
            (!d || !u.endsWith("/")) && (u += "/"), d = !1;
            for (const h of f)
                if (h.type === 0) u += h.value;
                else if (h.type === 1) {
                const {
                    value: p,
                    repeatable: b,
                    optional: y
                } = h, m = p in c ? c[p] : "";
                if (Jn(m) && !b) throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`);
                const g = Jn(m) ? m.join("/") : m;
                if (!g)
                    if (y) f.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : d = !0);
                    else throw new Error(`Missing required param "${p}"`);
                u += g
            }
        }
        return u || "/"
    }
    return {
        re: o,
        score: r,
        keys: s,
        parse: a,
        stringify: l
    }
}

function iee(t, e) {
    let n = 0;
    for (; n < t.length && n < e.length;) {
        const r = e[n] - t[n];
        if (r) return r;
        n++
    }
    return t.length < e.length ? t.length === 1 && t[0] === 40 + 40 ? -1 : 1 : t.length > e.length ? e.length === 1 && e[0] === 40 + 40 ? 1 : -1 : 0
}

function see(t, e) {
    let n = 0;
    const r = t.score,
        i = e.score;
    for (; n < r.length && n < i.length;) {
        const s = iee(r[n], i[n]);
        if (s) return s;
        n++
    }
    if (Math.abs(i.length - r.length) === 1) {
        if (b1(r)) return 1;
        if (b1(i)) return -1
    }
    return i.length - r.length
}

function b1(t) {
    const e = t[t.length - 1];
    return t.length > 0 && e[e.length - 1] < 0
}
const oee = {
        type: 0,
        value: ""
    },
    aee = /[a-zA-Z0-9_]/;

function lee(t) {
    if (!t) return [
        []
    ];
    if (t === "/") return [
        [oee]
    ];
    if (!t.startsWith("/")) throw new Error(`Route paths should start with a "/": "${t}" should be "/${t}".`);

    function e(h) {
        throw new Error(`ERR (${n})/"${c}": ${h}`)
    }
    let n = 0,
        r = n;
    const i = [];
    let s;

    function o() {
        s && i.push(s), s = []
    }
    let a = 0,
        l, c = "",
        u = "";

    function d() {
        c && (n === 0 ? s.push({
            type: 0,
            value: c
        }) : n === 1 || n === 2 || n === 3 ? (s.length > 1 && (l === "*" || l === "+") && e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), s.push({
            type: 1,
            value: c,
            regexp: u,
            repeatable: l === "*" || l === "+",
            optional: l === "*" || l === "?"
        })) : e("Invalid state to consume buffer"), c = "")
    }

    function f() {
        c += l
    }
    for (; a < t.length;) {
        if (l = t[a++], l === "\\" && n !== 2) {
            r = n, n = 4;
            continue
        }
        switch (n) {
            case 0:
                l === "/" ? (c && d(), o()) : l === ":" ? (d(), n = 1) : f();
                break;
            case 4:
                f(), n = r;
                break;
            case 1:
                l === "(" ? n = 2 : aee.test(l) ? f() : (d(), n = 0, l !== "*" && l !== "?" && l !== "+" && a--);
                break;
            case 2:
                l === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + l : n = 3 : u += l;
                break;
            case 3:
                d(), n = 0, l !== "*" && l !== "?" && l !== "+" && a--, u = "";
                break;
            default:
                e("Unknown state");
                break
        }
    }
    return n === 2 && e(`Unfinished custom RegExp for param "${c}"`), d(), o(), i
}

function cee(t, e, n) {
    const r = ree(lee(t.path), n); {
        const s = new Set;
        for (const o of r.keys) s.has(o.name) && je(`Found duplicated params with name "${o.name}" for path "${t.path}". Only the last one will be available on "$route.params".`), s.add(o.name)
    }
    const i = nt(r, {
        record: t,
        parent: e,
        children: [],
        alias: []
    });
    return e && !i.record.aliasOf == !e.record.aliasOf && e.children.push(i), i
}

function uee(t, e) {
    const n = [],
        r = new Map;
    e = E1({
        strict: !1,
        end: !0,
        sensitive: !1
    }, e);

    function i(u) {
        return r.get(u)
    }

    function s(u, d, f) {
        const h = !f,
            p = dee(u);
        mee(p, d), p.aliasOf = f && f.record;
        const b = E1(e, u),
            y = [p];
        if ("alias" in u) {
            const v = typeof u.alias == "string" ? [u.alias] : u.alias;
            for (const _ of v) y.push(nt({}, p, {
                components: f ? f.record.components : p.components,
                path: _,
                aliasOf: f ? f.record : p
            }))
        }
        let m, g;
        for (const v of y) {
            const {
                path: _
            } = v;
            if (d && _[0] !== "/") {
                const x = d.record.path,
                    w = x[x.length - 1] === "/" ? "" : "/";
                v.path = d.record.path + (_ && w + _)
            }
            if (v.path === "*") throw new Error(`Catch all routes ("*") must now be defined using a param with a custom regexp.
See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.`);
            if (m = cee(v, d, b), d && _[0] === "/" && gee(m, d), f ? (f.alias.push(m), pee(f, m)) : (g = g || m, g !== m && g.alias.push(m), h && u.name && !w1(m) && o(u.name)), p.children) {
                const x = p.children;
                for (let w = 0; w < x.length; w++) s(x[w], m, f && f.children[w])
            }
            f = f || m, (m.record.components && Object.keys(m.record.components).length || m.record.name || m.record.redirect) && l(m)
        }
        return g ? () => {
            o(g)
        } : Dc
    }

    function o(u) {
        if (wM(u)) {
            const d = r.get(u);
            d && (r.delete(u), n.splice(n.indexOf(d), 1), d.children.forEach(o), d.alias.forEach(o))
        } else {
            const d = n.indexOf(u);
            d > -1 && (n.splice(d, 1), u.record.name && r.delete(u.record.name), u.children.forEach(o), u.alias.forEach(o))
        }
    }

    function a() {
        return n
    }

    function l(u) {
        let d = 0;
        for (; d < n.length && see(u, n[d]) >= 0 && (u.record.path !== n[d].record.path || !SM(u, n[d]));) d++;
        n.splice(d, 0, u), u.record.name && !w1(u) && r.set(u.record.name, u)
    }

    function c(u, d) {
        let f, h = {},
            p, b;
        if ("name" in u && u.name) {
            if (f = r.get(u.name), !f) throw hl(1, {
                location: u
            }); {
                const g = Object.keys(u.params || {}).filter(v => !f.keys.find(_ => _.name === v));
                g.length && je(`Discarded invalid param(s) "${g.join('", "')}" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`)
            }
            b = f.record.name, h = nt(x1(d.params, f.keys.filter(g => !g.optional).map(g => g.name)), u.params && x1(u.params, f.keys.map(g => g.name))), p = f.stringify(h)
        } else if ("path" in u) p = u.path, p.startsWith("/") || je(`The Matcher cannot resolve relative paths but received "${p}". Unless you directly called \`matcher.resolve("${p}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`), f = n.find(g => g.re.test(p)), f && (h = f.parse(p), b = f.record.name);
        else {
            if (f = d.name ? r.get(d.name) : n.find(g => g.re.test(d.path)), !f) throw hl(1, {
                location: u,
                currentLocation: d
            });
            b = f.record.name, h = nt({}, d.params, u.params), p = f.stringify(h)
        }
        const y = [];
        let m = f;
        for (; m;) y.unshift(m.record), m = m.parent;
        return {
            name: b,
            path: p,
            params: h,
            matched: y,
            meta: hee(y)
        }
    }
    return t.forEach(u => s(u)), {
        addRoute: s,
        resolve: c,
        removeRoute: o,
        getRoutes: a,
        getRecordMatcher: i
    }
}

function x1(t, e) {
    const n = {};
    for (const r of e) r in t && (n[r] = t[r]);
    return n
}

function dee(t) {
    return {
        path: t.path,
        redirect: t.redirect,
        name: t.name,
        meta: t.meta || {},
        aliasOf: void 0,
        beforeEnter: t.beforeEnter,
        props: fee(t),
        children: t.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in t ? t.components || null : t.component && {
            default: t.component
        }
    }
}

function fee(t) {
    const e = {},
        n = t.props || !1;
    if ("component" in t) e.default = n;
    else
        for (const r in t.components) e[r] = typeof n == "boolean" ? n : n[r];
    return e
}

function w1(t) {
    for (; t;) {
        if (t.record.aliasOf) return !0;
        t = t.parent
    }
    return !1
}

function hee(t) {
    return t.reduce((e, n) => nt(e, n.meta), {})
}

function E1(t, e) {
    const n = {};
    for (const r in t) n[r] = r in e ? e[r] : t[r];
    return n
}

function Ny(t, e) {
    return t.name === e.name && t.optional === e.optional && t.repeatable === e.repeatable
}

function pee(t, e) {
    for (const n of t.keys)
        if (!n.optional && !e.keys.find(Ny.bind(null, n))) return je(`Alias "${e.record.path}" and the original record: "${t.record.path}" must have the exact same param named "${n.name}"`);
    for (const n of e.keys)
        if (!n.optional && !t.keys.find(Ny.bind(null, n))) return je(`Alias "${e.record.path}" and the original record: "${t.record.path}" must have the exact same param named "${n.name}"`)
}

function mee(t, e) {
    e && e.record.name && !t.name && !t.path && je(`The route named "${String(e.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`)
}

function gee(t, e) {
    for (const n of e.keys)
        if (!t.keys.find(Ny.bind(null, n))) return je(`Absolute path "${t.record.path}" must have the exact same param named "${n.name}" as its parent "${e.record.path}".`)
}

function SM(t, e) {
    return e.children.some(n => n === t || SM(t, n))
}
const TM = /#/g,
    vee = /&/g,
    yee = /\//g,
    _ee = /=/g,
    bee = /\?/g,
    CM = /\+/g,
    xee = /%5B/g,
    wee = /%5D/g,
    PM = /%5E/g,
    Eee = /%60/g,
    AM = /%7B/g,
    See = /%7C/g,
    OM = /%7D/g,
    Tee = /%20/g;

function Xb(t) {
    return encodeURI("" + t).replace(See, "|").replace(xee, "[").replace(wee, "]")
}

function Cee(t) {
    return Xb(t).replace(AM, "{").replace(OM, "}").replace(PM, "^")
}

function Uy(t) {
    return Xb(t).replace(CM, "%2B").replace(Tee, "+").replace(TM, "%23").replace(vee, "%26").replace(Eee, "`").replace(AM, "{").replace(OM, "}").replace(PM, "^")
}

function Pee(t) {
    return Uy(t).replace(_ee, "%3D")
}

function Aee(t) {
    return Xb(t).replace(TM, "%23").replace(bee, "%3F")
}

function Oee(t) {
    return t == null ? "" : Aee(t).replace(yee, "%2F")
}

function vu(t) {
    try {
        return decodeURIComponent("" + t)
    } catch {
        je(`Error decoding "${t}". Using original value`)
    }
    return "" + t
}

function Iee(t) {
    const e = {};
    if (t === "" || t === "?") return e;
    const r = (t[0] === "?" ? t.slice(1) : t).split("&");
    for (let i = 0; i < r.length; ++i) {
        const s = r[i].replace(CM, " "),
            o = s.indexOf("="),
            a = vu(o < 0 ? s : s.slice(0, o)),
            l = o < 0 ? null : vu(s.slice(o + 1));
        if (a in e) {
            let c = e[a];
            Jn(c) || (c = e[a] = [c]), c.push(l)
        } else e[a] = l
    }
    return e
}

function S1(t) {
    let e = "";
    for (let n in t) {
        const r = t[n];
        if (n = Pee(n), r == null) {
            r !== void 0 && (e += (e.length ? "&" : "") + n);
            continue
        }(Jn(r) ? r.map(s => s && Uy(s)) : [r && Uy(r)]).forEach(s => {
            s !== void 0 && (e += (e.length ? "&" : "") + n, s != null && (e += "=" + s))
        })
    }
    return e
}

function Ree(t) {
    const e = {};
    for (const n in t) {
        const r = t[n];
        r !== void 0 && (e[n] = Jn(r) ? r.map(i => i == null ? null : "" + i) : r == null ? r : "" + r)
    }
    return e
}
const IM = Symbol("router view location matched"),
    T1 = Symbol("router view depth"),
    Ip = Symbol("router"),
    Kb = Symbol("route location"),
    Gy = Symbol("router view location");

function sc() {
    let t = [];

    function e(r) {
        return t.push(r), () => {
            const i = t.indexOf(r);
            i > -1 && t.splice(i, 1)
        }
    }

    function n() {
        t = []
    }
    return {
        add: e,
        list: () => t,
        reset: n
    }
}

function Mee(t, e, n) {
    const r = () => {
        t[e].delete(n)
    };
    Ki(r), Yi(r), zs(() => {
        t[e].add(n)
    }), t[e].add(n)
}

function lbe(t) {
    if (!it()) {
        je("getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function");
        return
    }
    const e = Nt(IM, {}).value;
    if (!e) {
        je("No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?");
        return
    }
    Mee(e, "leaveGuards", t)
}

function cs(t, e, n, r, i) {
    const s = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []);
    return () => new Promise((o, a) => {
        const l = d => {
                d === !1 ? a(hl(4, {
                    from: n,
                    to: e
                })) : d instanceof Error ? a(d) : JQ(d) ? a(hl(2, {
                    from: e,
                    to: d
                })) : (s && r.enterCallbacks[i] === s && typeof d == "function" && s.push(d), o())
            },
            c = t.call(r && r.instances[i], e, n, kee(l, e, n));
        let u = Promise.resolve(c);
        if (t.length < 3 && (u = u.then(l)), t.length > 2) {
            const d = `The "next" callback was never called inside of ${t.name?'"'+t.name+'"':""}:
${t.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
            if (typeof c == "object" && "then" in c) u = u.then(f => l._called ? f : (je(d), Promise.reject(new Error("Invalid navigation guard"))));
            else if (c !== void 0 && !l._called) {
                je(d), a(new Error("Invalid navigation guard"));
                return
            }
        }
        u.catch(d => a(d))
    })
}

function kee(t, e, n) {
    let r = 0;
    return function() {
        r++ === 1 && je(`The "next" callback was called more than once in one navigation guard when going from "${n.fullPath}" to "${e.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`), t._called = !0, r === 1 && t.apply(null, arguments)
    }
}

function zm(t, e, n, r) {
    const i = [];
    for (const s of t) {
        !s.components && !s.children.length && je(`Record with path "${s.path}" is either missing a "component(s)" or "children" property.`);
        for (const o in s.components) {
            let a = s.components[o]; {
                if (!a || typeof a != "object" && typeof a != "function") throw je(`Component "${o}" in record with path "${s.path}" is not a valid component. Received "${String(a)}".`), new Error("Invalid route component");
                if ("then" in a) {
                    je(`Component "${o}" in record with path "${s.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);
                    const l = a;
                    a = () => l
                } else a.__asyncLoader && !a.__warnedDefineAsync && (a.__warnedDefineAsync = !0, je(`Component "${o}" in record with path "${s.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`))
            }
            if (!(e !== "beforeRouteEnter" && !s.instances[o]))
                if (Bee(a)) {
                    const c = (a.__vccOpts || a)[e];
                    c && i.push(cs(c, n, r, s, o))
                } else {
                    let l = a();
                    "catch" in l || (je(`Component "${o}" in record with path "${s.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`), l = Promise.resolve(l)), i.push(() => l.then(c => {
                        if (!c) return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${s.path}"`));
                        const u = BQ(c) ? c.default : c;
                        s.components[o] = u;
                        const f = (u.__vccOpts || u)[e];
                        return f && cs(f, n, r, s, o)()
                    }))
                }
        }
    }
    return i
}

function Bee(t) {
    return typeof t == "object" || "displayName" in t || "props" in t || "__vccOpts" in t
}

function C1(t) {
    const e = Nt(Ip),
        n = Nt(Kb),
        r = ne(() => e.resolve(En(t.to))),
        i = ne(() => {
            const {
                matched: l
            } = r.value, {
                length: c
            } = l, u = l[c - 1], d = n.matched;
            if (!u || !d.length) return -1;
            const f = d.findIndex(Ls.bind(null, u));
            if (f > -1) return f;
            const h = P1(l[c - 2]);
            return c > 1 && P1(u) === h && d[d.length - 1].path !== h ? d.findIndex(Ls.bind(null, l[c - 2])) : f
        }),
        s = ne(() => i.value > -1 && Lee(n.params, r.value.params)),
        o = ne(() => i.value > -1 && i.value === n.matched.length - 1 && bM(n.params, r.value.params));

    function a(l = {}) {
        return Fee(l) ? e[En(t.replace) ? "replace" : "push"](En(t.to)).catch(Dc) : Promise.resolve()
    }
    if (Ti) {
        const l = it();
        if (l) {
            const c = {
                route: r.value,
                isActive: s.value,
                isExactActive: o.value
            };
            l.__vrl_devtools = l.__vrl_devtools || [], l.__vrl_devtools.push(c), Il(() => {
                c.route = r.value, c.isActive = s.value, c.isExactActive = o.value
            }, {
                flush: "post"
            })
        }
    }
    return {
        route: r,
        href: ne(() => r.value.href),
        isActive: s,
        isExactActive: o,
        navigate: a
    }
}
const Dee = ye({
        name: "RouterLink",
        compatConfig: {
            MODE: 3
        },
        props: {
            to: {
                type: [String, Object],
                required: !0
            },
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: {
                type: String,
                default: "page"
            }
        },
        useLink: C1,
        setup(t, {
            slots: e
        }) {
            const n = ht(C1(t)),
                {
                    options: r
                } = Nt(Ip),
                i = ne(() => ({
                    [A1(t.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
                    [A1(t.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
                }));
            return () => {
                const s = e.default && e.default(n);
                return t.custom ? s : qt("a", {
                    "aria-current": n.isExactActive ? t.ariaCurrentValue : null,
                    href: n.href,
                    onClick: n.navigate,
                    class: i.value
                }, s)
            }
        }
    }),
    $ee = Dee;

function Fee(t) {
    if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && !(t.button !== void 0 && t.button !== 0)) {
        if (t.currentTarget && t.currentTarget.getAttribute) {
            const e = t.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e)) return
        }
        return t.preventDefault && t.preventDefault(), !0
    }
}

function Lee(t, e) {
    for (const n in e) {
        const r = e[n],
            i = t[n];
        if (typeof r == "string") {
            if (r !== i) return !1
        } else if (!Jn(i) || i.length !== r.length || r.some((s, o) => s !== i[o])) return !1
    }
    return !0
}

function P1(t) {
    return t ? t.aliasOf ? t.aliasOf.path : t.path : ""
}
const A1 = (t, e, n) => t ? ? e ? ? n,
    Nee = ye({
        name: "RouterView",
        inheritAttrs: !1,
        props: {
            name: {
                type: String,
                default: "default"
            },
            route: Object
        },
        compatConfig: {
            MODE: 3
        },
        setup(t, {
            attrs: e,
            slots: n
        }) {
            Gee();
            const r = Nt(Gy),
                i = ne(() => t.route || r.value),
                s = Nt(T1, 0),
                o = ne(() => {
                    let c = En(s);
                    const {
                        matched: u
                    } = i.value;
                    let d;
                    for (;
                        (d = u[c]) && !d.components;) c++;
                    return c
                }),
                a = ne(() => i.value.matched[o.value]);
            Pr(T1, ne(() => o.value + 1)), Pr(IM, a), Pr(Gy, i);
            const l = J();
            return pe(() => [l.value, a.value, t.name], ([c, u, d], [f, h, p]) => {
                u && (u.instances[d] = c, h && h !== u && c && c === f && (u.leaveGuards.size || (u.leaveGuards = h.leaveGuards), u.updateGuards.size || (u.updateGuards = h.updateGuards))), c && u && (!h || !Ls(u, h) || !f) && (u.enterCallbacks[d] || []).forEach(b => b(c))
            }, {
                flush: "post"
            }), () => {
                const c = i.value,
                    u = t.name,
                    d = a.value,
                    f = d && d.components[u];
                if (!f) return O1(n.default, {
                    Component: f,
                    route: c
                });
                const h = d.props[u],
                    p = h ? h === !0 ? c.params : typeof h == "function" ? h(c) : h : null,
                    y = qt(f, nt({}, p, e, {
                        onVnodeUnmounted: m => {
                            m.component.isUnmounted && (d.instances[u] = null)
                        },
                        ref: l
                    }));
                if (Ti && y.ref) {
                    const m = {
                        depth: o.value,
                        name: d.name,
                        path: d.path,
                        meta: d.meta
                    };
                    (Jn(y.ref) ? y.ref.map(v => v.i) : [y.ref.i]).forEach(v => {
                        v.__vrv_devtools = m
                    })
                }
                return O1(n.default, {
                    Component: y,
                    route: c
                }) || y
            }
        }
    });

function O1(t, e) {
    if (!t) return null;
    const n = t(e);
    return n.length === 1 ? n[0] : n
}
const Uee = Nee;

function Gee() {
    const t = it(),
        e = t.parent && t.parent.type.name;
    if (e && (e === "KeepAlive" || e.includes("Transition"))) {
        const n = e === "KeepAlive" ? "keep-alive" : "transition";
        je(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${n}>
    <component :is="Component" />
  </${n}>
</router-view>`)
    }
}

function oc(t, e) {
    const n = nt({}, t, {
        matched: t.matched.map(r => qee(r, ["instances", "children", "aliasOf"]))
    });
    return {
        _custom: {
            type: null,
            readOnly: !0,
            display: t.fullPath,
            tooltip: e,
            value: n
        }
    }
}

function Wd(t) {
    return {
        _custom: {
            display: t
        }
    }
}
let Hee = 0;

function zee(t, e, n) {
    if (e.__hasDevtools) return;
    e.__hasDevtools = !0;
    const r = Hee++;
    sp({
        id: "org.vuejs.router" + (r ? "." + r : ""),
        label: "Vue Router",
        packageName: "vue-router",
        homepage: "https://router.vuejs.org",
        logo: "https://router.vuejs.org/logo.png",
        componentStateTypes: ["Routing"],
        app: t
    }, i => {
        typeof i.now != "function" && console.warn("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), i.on.inspectComponent((u, d) => {
            u.instanceData && u.instanceData.state.push({
                type: "Routing",
                key: "$route",
                editable: !1,
                value: oc(e.currentRoute.value, "Current Route")
            })
        }), i.on.visitComponentTree(({
            treeNode: u,
            componentInstance: d
        }) => {
            if (d.__vrv_devtools) {
                const f = d.__vrv_devtools;
                u.tags.push({
                    label: (f.name ? `${f.name.toString()}: ` : "") + f.path,
                    textColor: 0,
                    tooltip: "This component is rendered by &lt;router-view&gt;",
                    backgroundColor: RM
                })
            }
            Jn(d.__vrl_devtools) && (d.__devtoolsApi = i, d.__vrl_devtools.forEach(f => {
                let h = BM,
                    p = "";
                f.isExactActive ? (h = kM, p = "This is exactly active") : f.isActive && (h = MM, p = "This link is active"), u.tags.push({
                    label: f.route.path,
                    textColor: 0,
                    tooltip: p,
                    backgroundColor: h
                })
            }))
        }), pe(e.currentRoute, () => {
            l(), i.notifyComponentUpdate(), i.sendInspectorTree(a), i.sendInspectorState(a)
        });
        const s = "router:navigations:" + r;
        i.addTimelineLayer({
            id: s,
            label: `Router${r?" "+r:""} Navigations`,
            color: 4237508
        }), e.onError((u, d) => {
            i.addTimelineEvent({
                layerId: s,
                event: {
                    title: "Error during Navigation",
                    subtitle: d.fullPath,
                    logType: "error",
                    time: i.now(),
                    data: {
                        error: u
                    },
                    groupId: d.meta.__navigationId
                }
            })
        });
        let o = 0;
        e.beforeEach((u, d) => {
            const f = {
                guard: Wd("beforeEach"),
                from: oc(d, "Current Location during this navigation"),
                to: oc(u, "Target location")
            };
            Object.defineProperty(u.meta, "__navigationId", {
                value: o++
            }), i.addTimelineEvent({
                layerId: s,
                event: {
                    time: i.now(),
                    title: "Start of navigation",
                    subtitle: u.fullPath,
                    data: f,
                    groupId: u.meta.__navigationId
                }
            })
        }), e.afterEach((u, d, f) => {
            const h = {
                guard: Wd("afterEach")
            };
            f ? (h.failure = {
                _custom: {
                    type: Error,
                    readOnly: !0,
                    display: f ? f.message : "",
                    tooltip: "Navigation Failure",
                    value: f
                }
            }, h.status = Wd("❌")) : h.status = Wd("✅"), h.from = oc(d, "Current Location during this navigation"), h.to = oc(u, "Target location"), i.addTimelineEvent({
                layerId: s,
                event: {
                    title: "End of navigation",
                    subtitle: u.fullPath,
                    time: i.now(),
                    data: h,
                    logType: f ? "warning" : "default",
                    groupId: u.meta.__navigationId
                }
            })
        });
        const a = "router-inspector:" + r;
        i.addInspector({
            id: a,
            label: "Routes" + (r ? " " + r : ""),
            icon: "book",
            treeFilterPlaceholder: "Search routes"
        });

        function l() {
            if (!c) return;
            const u = c;
            let d = n.getRoutes().filter(f => !f.parent);
            d.forEach(FM), u.filter && (d = d.filter(f => Hy(f, u.filter.toLowerCase()))), d.forEach(f => $M(f, e.currentRoute.value)), u.rootNodes = d.map(DM)
        }
        let c;
        i.on.getInspectorTree(u => {
            c = u, u.app === t && u.inspectorId === a && l()
        }), i.on.getInspectorState(u => {
            if (u.app === t && u.inspectorId === a) {
                const f = n.getRoutes().find(h => h.record.__vd_id === u.nodeId);
                f && (u.state = {
                    options: Vee(f)
                })
            }
        }), i.sendInspectorTree(a), i.sendInspectorState(a)
    })
}

function jee(t) {
    return t.optional ? t.repeatable ? "*" : "?" : t.repeatable ? "+" : ""
}

function Vee(t) {
    const {
        record: e
    } = t, n = [{
        editable: !1,
        key: "path",
        value: e.path
    }];
    return e.name != null && n.push({
        editable: !1,
        key: "name",
        value: e.name
    }), n.push({
        editable: !1,
        key: "regexp",
        value: t.re
    }), t.keys.length && n.push({
        editable: !1,
        key: "keys",
        value: {
            _custom: {
                type: null,
                readOnly: !0,
                display: t.keys.map(r => `${r.name}${jee(r)}`).join(" "),
                tooltip: "Param keys",
                value: t.keys
            }
        }
    }), e.redirect != null && n.push({
        editable: !1,
        key: "redirect",
        value: e.redirect
    }), t.alias.length && n.push({
        editable: !1,
        key: "aliases",
        value: t.alias.map(r => r.record.path)
    }), Object.keys(t.record.meta).length && n.push({
        editable: !1,
        key: "meta",
        value: t.record.meta
    }), n.push({
        key: "score",
        editable: !1,
        value: {
            _custom: {
                type: null,
                readOnly: !0,
                display: t.score.map(r => r.join(", ")).join(" | "),
                tooltip: "Score used to sort routes",
                value: t.score
            }
        }
    }), n
}
const RM = 15485081,
    MM = 2450411,
    kM = 8702998,
    Wee = 2282478,
    BM = 16486972,
    Yee = 6710886;

function DM(t) {
    const e = [],
        {
            record: n
        } = t;
    n.name != null && e.push({
        label: String(n.name),
        textColor: 0,
        backgroundColor: Wee
    }), n.aliasOf && e.push({
        label: "alias",
        textColor: 0,
        backgroundColor: BM
    }), t.__vd_match && e.push({
        label: "matches",
        textColor: 0,
        backgroundColor: RM
    }), t.__vd_exactActive && e.push({
        label: "exact",
        textColor: 0,
        backgroundColor: kM
    }), t.__vd_active && e.push({
        label: "active",
        textColor: 0,
        backgroundColor: MM
    }), n.redirect && e.push({
        label: typeof n.redirect == "string" ? `redirect: ${n.redirect}` : "redirects",
        textColor: 16777215,
        backgroundColor: Yee
    });
    let r = n.__vd_id;
    return r == null && (r = String(Xee++), n.__vd_id = r), {
        id: r,
        label: n.path,
        tags: e,
        children: t.children.map(DM)
    }
}
let Xee = 0;
const Kee = /^\/(.*)\/([a-z]*)$/;

function $M(t, e) {
    const n = e.matched.length && Ls(e.matched[e.matched.length - 1], t.record);
    t.__vd_exactActive = t.__vd_active = n, n || (t.__vd_active = e.matched.some(r => Ls(r, t.record))), t.children.forEach(r => $M(r, e))
}

function FM(t) {
    t.__vd_match = !1, t.children.forEach(FM)
}

function Hy(t, e) {
    const n = String(t.re).match(Kee);
    if (t.__vd_match = !1, !n || n.length < 3) return !1;
    if (new RegExp(n[1].replace(/\$$/, ""), n[2]).test(e)) return t.children.forEach(o => Hy(o, e)), t.record.path !== "/" || e === "/" ? (t.__vd_match = t.re.test(e), !0) : !1;
    const i = t.record.path.toLowerCase(),
        s = vu(i);
    return !e.startsWith("/") && (s.includes(e) || i.includes(e)) || s.startsWith(e) || i.startsWith(e) || t.record.name && String(t.record.name).includes(e) ? !0 : t.children.some(o => Hy(o, e))
}

function qee(t, e) {
    const n = {};
    for (const r in t) e.includes(r) || (n[r] = t[r]);
    return n
}

function cbe(t) {
    const e = uee(t.routes, t),
        n = t.parseQuery || Iee,
        r = t.stringifyQuery || S1,
        i = t.history;
    if (!i) throw new Error('Provide the "history" option when calling "createRouter()": https://next.router.vuejs.org/api/#history.');
    const s = sc(),
        o = sc(),
        a = sc(),
        l = zh(is);
    let c = is;
    Ti && t.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const u = Gm.bind(null, D => "" + D),
        d = Gm.bind(null, Oee),
        f = Gm.bind(null, vu);

    function h(D, X) {
        let $, Z;
        return wM(D) ? ($ = e.getRecordMatcher(D), Z = X) : Z = D, e.addRoute(Z, $)
    }

    function p(D) {
        const X = e.getRecordMatcher(D);
        X ? e.removeRoute(X) : je(`Cannot remove non-existent route "${String(D)}"`)
    }

    function b() {
        return e.getRoutes().map(D => D.record)
    }

    function y(D) {
        return !!e.getRecordMatcher(D)
    }

    function m(D, X) {
        if (X = nt({}, X || l.value), typeof D == "string") {
            const ge = Hm(n, D, X.path),
                O = e.resolve({
                    path: ge.path
                }, X),
                L = i.createHref(ge.fullPath);
            return L.startsWith("//") ? je(`Location "${D}" resolved to "${L}". A resolved location cannot start with multiple slashes.`) : O.matched.length || je(`No match found for location with path "${D}"`), nt(ge, O, {
                params: f(O.params),
                hash: vu(ge.hash),
                redirectedFrom: void 0,
                href: L
            })
        }
        let $;
        if ("path" in D) "params" in D && !("name" in D) && Object.keys(D.params).length && je(`Path "${D.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`), $ = nt({}, D, {
            path: Hm(n, D.path, X.path).path
        });
        else {
            const ge = nt({}, D.params);
            for (const O in ge) ge[O] == null && delete ge[O];
            $ = nt({}, D, {
                params: d(D.params)
            }), X.params = d(X.params)
        }
        const Z = e.resolve($, X),
            K = D.hash || "";
        K && !K.startsWith("#") && je(`A \`hash\` should always start with the character "#". Replace "${K}" with "#${K}".`), Z.params = u(f(Z.params));
        const ce = FQ(r, nt({}, D, {
                hash: Cee(K),
                path: Z.path
            })),
            de = i.createHref(ce);
        return de.startsWith("//") ? je(`Location "${D}" resolved to "${de}". A resolved location cannot start with multiple slashes.`) : Z.matched.length || je(`No match found for location with path "${"path"in D?D.path:D}"`), nt({
            fullPath: ce,
            hash: K,
            query: r === S1 ? Ree(D.query) : D.query || {}
        }, Z, {
            redirectedFrom: void 0,
            href: de
        })
    }

    function g(D) {
        return typeof D == "string" ? Hm(n, D, l.value.path) : nt({}, D)
    }

    function v(D, X) {
        if (c !== D) return hl(8, {
            from: X,
            to: D
        })
    }

    function _(D) {
        return S(D)
    }

    function x(D) {
        return _(nt(g(D), {
            replace: !0
        }))
    }

    function w(D) {
        const X = D.matched[D.matched.length - 1];
        if (X && X.redirect) {
            const {
                redirect: $
            } = X;
            let Z = typeof $ == "function" ? $(D) : $;
            if (typeof Z == "string" && (Z = Z.includes("?") || Z.includes("#") ? Z = g(Z) : {
                    path: Z
                }, Z.params = {}), !("path" in Z) && !("name" in Z)) throw je(`Invalid redirect found:
${JSON.stringify(Z,null,2)}
 when navigating to "${D.fullPath}". A redirect must contain a name or path. This will break in production.`), new Error("Invalid redirect");
            return nt({
                query: D.query,
                hash: D.hash,
                params: "path" in Z ? {} : D.params
            }, Z)
        }
    }

    function S(D, X) {
        const $ = c = m(D),
            Z = l.value,
            K = D.state,
            ce = D.force,
            de = D.replace === !0,
            ge = w($);
        if (ge) return S(nt(g(ge), {
            state: typeof ge == "object" ? nt({}, K, ge.state) : K,
            force: ce,
            replace: de
        }), X || $);
        const O = $;
        O.redirectedFrom = X;
        let L;
        return !ce && p1(r, Z, $) && (L = hl(16, {
            to: O,
            from: Z
        }), le(Z, Z, !0, !1)), (L ? Promise.resolve(L) : A(O, Z)).catch(j => mi(j) ? mi(j, 2) ? j : Y(j) : N(j, O, Z)).then(j => {
            if (j) {
                if (mi(j, 2)) return p1(r, m(j.to), O) && X && (X._count = X._count ? X._count + 1 : 1) > 10 ? (je(`Detected an infinite redirection in a navigation guard when going from "${Z.fullPath}" to "${O.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`), Promise.reject(new Error("Infinite redirect in navigation guard"))) : S(nt({
                    replace: de
                }, g(j.to), {
                    state: typeof j.to == "object" ? nt({}, K, j.to.state) : K,
                    force: ce
                }), X || O)
            } else j = E(O, Z, !0, de, K);
            return T(O, Z, j), j
        })
    }

    function C(D, X) {
        const $ = v(D, X);
        return $ ? Promise.reject($) : Promise.resolve()
    }

    function A(D, X) {
        let $;
        const [Z, K, ce] = Jee(D, X);
        $ = zm(Z.reverse(), "beforeRouteLeave", D, X);
        for (const ge of Z) ge.leaveGuards.forEach(O => {
            $.push(cs(O, D, X))
        });
        const de = C.bind(null, D, X);
        return $.push(de), Oa($).then(() => {
            $ = [];
            for (const ge of s.list()) $.push(cs(ge, D, X));
            return $.push(de), Oa($)
        }).then(() => {
            $ = zm(K, "beforeRouteUpdate", D, X);
            for (const ge of K) ge.updateGuards.forEach(O => {
                $.push(cs(O, D, X))
            });
            return $.push(de), Oa($)
        }).then(() => {
            $ = [];
            for (const ge of D.matched)
                if (ge.beforeEnter && !X.matched.includes(ge))
                    if (Jn(ge.beforeEnter))
                        for (const O of ge.beforeEnter) $.push(cs(O, D, X));
                    else $.push(cs(ge.beforeEnter, D, X));
            return $.push(de), Oa($)
        }).then(() => (D.matched.forEach(ge => ge.enterCallbacks = {}), $ = zm(ce, "beforeRouteEnter", D, X), $.push(de), Oa($))).then(() => {
            $ = [];
            for (const ge of o.list()) $.push(cs(ge, D, X));
            return $.push(de), Oa($)
        }).catch(ge => mi(ge, 8) ? ge : Promise.reject(ge))
    }

    function T(D, X, $) {
        for (const Z of a.list()) Z(D, X, $)
    }

    function E(D, X, $, Z, K) {
        const ce = v(D, X);
        if (ce) return ce;
        const de = X === is,
            ge = Ti ? history.state : {};
        $ && (Z || de ? i.replace(D.fullPath, nt({
            scroll: de && ge && ge.scroll
        }, K)) : i.push(D.fullPath, K)), l.value = D, le(D, X, $, de), Y()
    }
    let P;

    function B() {
        P || (P = i.listen((D, X, $) => {
            if (!fe.listening) return;
            const Z = m(D),
                K = w(Z);
            if (K) {
                S(nt(K, {
                    replace: !0
                }), Z).catch(Dc);
                return
            }
            c = Z;
            const ce = l.value;
            Ti && VQ(g1(ce.fullPath, $.delta), Op()), A(Z, ce).catch(de => mi(de, 12) ? de : mi(de, 2) ? (S(de.to, Z).then(ge => {
                mi(ge, 20) && !$.delta && $.type === gu.pop && i.go(-1, !1)
            }).catch(Dc), Promise.reject()) : ($.delta && i.go(-$.delta, !1), N(de, Z, ce))).then(de => {
                de = de || E(Z, ce, !1), de && ($.delta && !mi(de, 8) ? i.go(-$.delta, !1) : $.type === gu.pop && mi(de, 20) && i.go(-1, !1)), T(Z, ce, de)
            }).catch(Dc)
        }))
    }
    let F = sc(),
        H = sc(),
        k;

    function N(D, X, $) {
        Y(D);
        const Z = H.list();
        return Z.length ? Z.forEach(K => K(D, X, $)) : (je("uncaught error during route navigation:"), console.error(D)), Promise.reject(D)
    }

    function V() {
        return k && l.value !== is ? Promise.resolve() : new Promise((D, X) => {
            F.add([D, X])
        })
    }

    function Y(D) {
        return k || (k = !D, B(), F.list().forEach(([X, $]) => D ? $(D) : X()), F.reset()), D
    }

    function le(D, X, $, Z) {
        const {
            scrollBehavior: K
        } = t;
        if (!Ti || !K) return Promise.resolve();
        const ce = !$ && WQ(g1(D.fullPath, 0)) || (Z || !$) && history.state && history.state.scroll || null;
        return Ue().then(() => K(D, X, ce)).then(de => de && jQ(de)).catch(de => N(de, D, X))
    }
    const ae = D => i.go(D);
    let W;
    const Q = new Set,
        fe = {
            currentRoute: l,
            listening: !0,
            addRoute: h,
            removeRoute: p,
            hasRoute: y,
            getRoutes: b,
            resolve: m,
            options: t,
            push: _,
            replace: x,
            go: ae,
            back: () => ae(-1),
            forward: () => ae(1),
            beforeEach: s.add,
            beforeResolve: o.add,
            afterEach: a.add,
            onError: H.add,
            isReady: V,
            install(D) {
                const X = this;
                D.component("RouterLink", $ee), D.component("RouterView", Uee), D.config.globalProperties.$router = X, Object.defineProperty(D.config.globalProperties, "$route", {
                    enumerable: !0,
                    get: () => En(l)
                }), Ti && !W && l.value === is && (W = !0, _(i.location).catch(K => {
                    je("Unexpected error when starting the router:", K)
                }));
                const $ = {};
                for (const K in is) $[K] = ne(() => l.value[K]);
                D.provide(Ip, X), D.provide(Kb, ht($)), D.provide(Gy, l);
                const Z = D.unmount;
                Q.add(D), D.unmount = function() {
                    Q.delete(D), Q.size < 1 && (c = is, P && P(), P = null, l.value = is, W = !1, k = !1), Z()
                }, Ti && zee(D, X, e)
            }
        };
    return fe
}

function Oa(t) {
    return t.reduce((e, n) => e.then(() => n()), Promise.resolve())
}

function Jee(t, e) {
    const n = [],
        r = [],
        i = [],
        s = Math.max(e.matched.length, t.matched.length);
    for (let o = 0; o < s; o++) {
        const a = e.matched[o];
        a && (t.matched.find(c => Ls(c, a)) ? r.push(a) : n.push(a));
        const l = t.matched[o];
        l && (e.matched.find(c => Ls(c, l)) || i.push(l))
    }
    return [n, r, i]
}

function ube() {
    return Nt(Ip)
}

function dbe() {
    return Nt(Kb)
}

function LM(t, e) {
    return function() {
        return t.apply(e, arguments)
    }
}
const {
    toString: Zee
} = Object.prototype, {
    getPrototypeOf: qb
} = Object, Rp = (t => e => {
    const n = Zee.call(e);
    return t[n] || (t[n] = n.slice(8, -1).toLowerCase())
})(Object.create(null)), $r = t => (t = t.toLowerCase(), e => Rp(e) === t), Mp = t => e => typeof e === t, {
    isArray: Ll
} = Array, yu = Mp("undefined");

function Qee(t) {
    return t !== null && !yu(t) && t.constructor !== null && !yu(t.constructor) && Xn(t.constructor.isBuffer) && t.constructor.isBuffer(t)
}
const NM = $r("ArrayBuffer");

function ete(t) {
    let e;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && NM(t.buffer), e
}
const tte = Mp("string"),
    Xn = Mp("function"),
    UM = Mp("number"),
    kp = t => t !== null && typeof t == "object",
    nte = t => t === !0 || t === !1,
    Mf = t => {
        if (Rp(t) !== "object") return !1;
        const e = qb(t);
        return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
    },
    rte = $r("Date"),
    ite = $r("File"),
    ste = $r("Blob"),
    ote = $r("FileList"),
    ate = t => kp(t) && Xn(t.pipe),
    lte = t => {
        let e;
        return t && (typeof FormData == "function" && t instanceof FormData || Xn(t.append) && ((e = Rp(t)) === "formdata" || e === "object" && Xn(t.toString) && t.toString() === "[object FormData]"))
    },
    cte = $r("URLSearchParams"),
    [ute, dte, fte, hte] = ["ReadableStream", "Request", "Response", "Headers"].map($r),
    pte = t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");

function td(t, e, {
    allOwnKeys: n = !1
} = {}) {
    if (t === null || typeof t > "u") return;
    let r, i;
    if (typeof t != "object" && (t = [t]), Ll(t))
        for (r = 0, i = t.length; r < i; r++) e.call(null, t[r], r, t);
    else {
        const s = n ? Object.getOwnPropertyNames(t) : Object.keys(t),
            o = s.length;
        let a;
        for (r = 0; r < o; r++) a = s[r], e.call(null, t[a], a, t)
    }
}

function GM(t, e) {
    e = e.toLowerCase();
    const n = Object.keys(t);
    let r = n.length,
        i;
    for (; r-- > 0;)
        if (i = n[r], e === i.toLowerCase()) return i;
    return null
}
const Eo = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(),
    HM = t => !yu(t) && t !== Eo;

function zy() {
    const {
        caseless: t
    } = HM(this) && this || {}, e = {}, n = (r, i) => {
        const s = t && GM(e, i) || i;
        Mf(e[s]) && Mf(r) ? e[s] = zy(e[s], r) : Mf(r) ? e[s] = zy({}, r) : Ll(r) ? e[s] = r.slice() : e[s] = r
    };
    for (let r = 0, i = arguments.length; r < i; r++) arguments[r] && td(arguments[r], n);
    return e
}
const mte = (t, e, n, {
        allOwnKeys: r
    } = {}) => (td(e, (i, s) => {
        n && Xn(i) ? t[s] = LM(i, n) : t[s] = i
    }, {
        allOwnKeys: r
    }), t),
    gte = t => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t),
    vte = (t, e, n, r) => {
        t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
            value: e.prototype
        }), n && Object.assign(t.prototype, n)
    },
    yte = (t, e, n, r) => {
        let i, s, o;
        const a = {};
        if (e = e || {}, t == null) return e;
        do {
            for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0;) o = i[s], (!r || r(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = !0);
            t = n !== !1 && qb(t)
        } while (t && (!n || n(t, e)) && t !== Object.prototype);
        return e
    },
    _te = (t, e, n) => {
        t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
        const r = t.indexOf(e, n);
        return r !== -1 && r === n
    },
    bte = t => {
        if (!t) return null;
        if (Ll(t)) return t;
        let e = t.length;
        if (!UM(e)) return null;
        const n = new Array(e);
        for (; e-- > 0;) n[e] = t[e];
        return n
    },
    xte = (t => e => t && e instanceof t)(typeof Uint8Array < "u" && qb(Uint8Array)),
    wte = (t, e) => {
        const r = (t && t[Symbol.iterator]).call(t);
        let i;
        for (;
            (i = r.next()) && !i.done;) {
            const s = i.value;
            e.call(t, s[0], s[1])
        }
    },
    Ete = (t, e) => {
        let n;
        const r = [];
        for (;
            (n = t.exec(e)) !== null;) r.push(n);
        return r
    },
    Ste = $r("HTMLFormElement"),
    Tte = t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(n, r, i) {
        return r.toUpperCase() + i
    }),
    I1 = (({
        hasOwnProperty: t
    }) => (e, n) => t.call(e, n))(Object.prototype),
    Cte = $r("RegExp"),
    zM = (t, e) => {
        const n = Object.getOwnPropertyDescriptors(t),
            r = {};
        td(n, (i, s) => {
            let o;
            (o = e(i, s, t)) !== !1 && (r[s] = o || i)
        }), Object.defineProperties(t, r)
    },
    Pte = t => {
        zM(t, (e, n) => {
            if (Xn(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return !1;
            const r = t[n];
            if (Xn(r)) {
                if (e.enumerable = !1, "writable" in e) {
                    e.writable = !1;
                    return
                }
                e.set || (e.set = () => {
                    throw Error("Can not rewrite read-only method '" + n + "'")
                })
            }
        })
    },
    Ate = (t, e) => {
        const n = {},
            r = i => {
                i.forEach(s => {
                    n[s] = !0
                })
            };
        return Ll(t) ? r(t) : r(String(t).split(e)), n
    },
    Ote = () => {},
    Ite = (t, e) => t != null && Number.isFinite(t = +t) ? t : e;

function Rte(t) {
    return !!(t && Xn(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator])
}
const Mte = t => {
        const e = new Array(10),
            n = (r, i) => {
                if (kp(r)) {
                    if (e.indexOf(r) >= 0) return;
                    if (!("toJSON" in r)) {
                        e[i] = r;
                        const s = Ll(r) ? [] : {};
                        return td(r, (o, a) => {
                            const l = n(o, i + 1);
                            !yu(l) && (s[a] = l)
                        }), e[i] = void 0, s
                    }
                }
                return r
            };
        return n(t, 0)
    },
    kte = $r("AsyncFunction"),
    Bte = t => t && (kp(t) || Xn(t)) && Xn(t.then) && Xn(t.catch),
    jM = ((t, e) => t ? setImmediate : e ? ((n, r) => (Eo.addEventListener("message", ({
        source: i,
        data: s
    }) => {
        i === Eo && s === n && r.length && r.shift()()
    }, !1), i => {
        r.push(i), Eo.postMessage(n, "*")
    }))(`axios@${Math.random()}`, []) : n => setTimeout(n))(typeof setImmediate == "function", Xn(Eo.postMessage)),
    Dte = typeof queueMicrotask < "u" ? queueMicrotask.bind(Eo) : typeof process < "u" && process.nextTick || jM,
    te = {
        isArray: Ll,
        isArrayBuffer: NM,
        isBuffer: Qee,
        isFormData: lte,
        isArrayBufferView: ete,
        isString: tte,
        isNumber: UM,
        isBoolean: nte,
        isObject: kp,
        isPlainObject: Mf,
        isReadableStream: ute,
        isRequest: dte,
        isResponse: fte,
        isHeaders: hte,
        isUndefined: yu,
        isDate: rte,
        isFile: ite,
        isBlob: ste,
        isRegExp: Cte,
        isFunction: Xn,
        isStream: ate,
        isURLSearchParams: cte,
        isTypedArray: xte,
        isFileList: ote,
        forEach: td,
        merge: zy,
        extend: mte,
        trim: pte,
        stripBOM: gte,
        inherits: vte,
        toFlatObject: yte,
        kindOf: Rp,
        kindOfTest: $r,
        endsWith: _te,
        toArray: bte,
        forEachEntry: wte,
        matchAll: Ete,
        isHTMLForm: Ste,
        hasOwnProperty: I1,
        hasOwnProp: I1,
        reduceDescriptors: zM,
        freezeMethods: Pte,
        toObjectSet: Ate,
        toCamelCase: Tte,
        noop: Ote,
        toFiniteNumber: Ite,
        findKey: GM,
        global: Eo,
        isContextDefined: HM,
        isSpecCompliantForm: Rte,
        toJSONObject: Mte,
        isAsyncFn: kte,
        isThenable: Bte,
        setImmediate: jM,
        asap: Dte
    };

function Le(t, e, n, r, i) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null)
}
te.inherits(Le, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: te.toJSONObject(this.config),
            code: this.code,
            status: this.status
        }
    }
});
const VM = Le.prototype,
    WM = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(t => {
    WM[t] = {
        value: t
    }
});
Object.defineProperties(Le, WM);
Object.defineProperty(VM, "isAxiosError", {
    value: !0
});
Le.from = (t, e, n, r, i, s) => {
    const o = Object.create(VM);
    return te.toFlatObject(t, o, function(l) {
        return l !== Error.prototype
    }, a => a !== "isAxiosError"), Le.call(o, t.message, e, n, r, i), o.cause = t, o.name = t.name, s && Object.assign(o, s), o
};
const $te = null;

function jy(t) {
    return te.isPlainObject(t) || te.isArray(t)
}

function YM(t) {
    return te.endsWith(t, "[]") ? t.slice(0, -2) : t
}

function R1(t, e, n) {
    return t ? t.concat(e).map(function(i, s) {
        return i = YM(i), !n && s ? "[" + i + "]" : i
    }).join(n ? "." : "") : e
}

function Fte(t) {
    return te.isArray(t) && !t.some(jy)
}
const Lte = te.toFlatObject(te, {}, null, function(e) {
    return /^is[A-Z]/.test(e)
});

function Bp(t, e, n) {
    if (!te.isObject(t)) throw new TypeError("target must be an object");
    e = e || new FormData, n = te.toFlatObject(n, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(b, y) {
        return !te.isUndefined(y[b])
    });
    const r = n.metaTokens,
        i = n.visitor || u,
        s = n.dots,
        o = n.indexes,
        l = (n.Blob || typeof Blob < "u" && Blob) && te.isSpecCompliantForm(e);
    if (!te.isFunction(i)) throw new TypeError("visitor must be a function");

    function c(p) {
        if (p === null) return "";
        if (te.isDate(p)) return p.toISOString();
        if (!l && te.isBlob(p)) throw new Le("Blob is not supported. Use a Buffer instead.");
        return te.isArrayBuffer(p) || te.isTypedArray(p) ? l && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p
    }

    function u(p, b, y) {
        let m = p;
        if (p && !y && typeof p == "object") {
            if (te.endsWith(b, "{}")) b = r ? b : b.slice(0, -2), p = JSON.stringify(p);
            else if (te.isArray(p) && Fte(p) || (te.isFileList(p) || te.endsWith(b, "[]")) && (m = te.toArray(p))) return b = YM(b), m.forEach(function(v, _) {
                !(te.isUndefined(v) || v === null) && e.append(o === !0 ? R1([b], _, s) : o === null ? b : b + "[]", c(v))
            }), !1
        }
        return jy(p) ? !0 : (e.append(R1(y, b, s), c(p)), !1)
    }
    const d = [],
        f = Object.assign(Lte, {
            defaultVisitor: u,
            convertValue: c,
            isVisitable: jy
        });

    function h(p, b) {
        if (!te.isUndefined(p)) {
            if (d.indexOf(p) !== -1) throw Error("Circular reference detected in " + b.join("."));
            d.push(p), te.forEach(p, function(m, g) {
                (!(te.isUndefined(m) || m === null) && i.call(e, m, te.isString(g) ? g.trim() : g, b, f)) === !0 && h(m, b ? b.concat(g) : [g])
            }), d.pop()
        }
    }
    if (!te.isObject(t)) throw new TypeError("data must be an object");
    return h(t), e
}

function M1(t) {
    const e = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
        return e[r]
    })
}

function Jb(t, e) {
    this._pairs = [], t && Bp(t, this, e)
}
const XM = Jb.prototype;
XM.append = function(e, n) {
    this._pairs.push([e, n])
};
XM.toString = function(e) {
    const n = e ? function(r) {
        return e.call(this, r, M1)
    } : M1;
    return this._pairs.map(function(i) {
        return n(i[0]) + "=" + n(i[1])
    }, "").join("&")
};

function Nte(t) {
    return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}

function KM(t, e, n) {
    if (!e) return t;
    const r = n && n.encode || Nte;
    te.isFunction(n) && (n = {
        serialize: n
    });
    const i = n && n.serialize;
    let s;
    if (i ? s = i(e, n) : s = te.isURLSearchParams(e) ? e.toString() : new Jb(e, n).toString(r), s) {
        const o = t.indexOf("#");
        o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + s
    }
    return t
}
class Ute {
    constructor() {
        this.handlers = []
    }
    use(e, n, r) {
        return this.handlers.push({
            fulfilled: e,
            rejected: n,
            synchronous: r ? r.synchronous : !1,
            runWhen: r ? r.runWhen : null
        }), this.handlers.length - 1
    }
    eject(e) {
        this.handlers[e] && (this.handlers[e] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(e) {
        te.forEach(this.handlers, function(r) {
            r !== null && e(r)
        })
    }
}
const k1 = Ute,
    qM = {
        silentJSONParsing: !0,
        forcedJSONParsing: !0,
        clarifyTimeoutError: !1
    },
    Gte = typeof URLSearchParams < "u" ? URLSearchParams : Jb,
    Hte = typeof FormData < "u" ? FormData : null,
    zte = typeof Blob < "u" ? Blob : null,
    jte = {
        isBrowser: !0,
        classes: {
            URLSearchParams: Gte,
            FormData: Hte,
            Blob: zte
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
    },
    Zb = typeof window < "u" && typeof document < "u",
    Vy = typeof navigator == "object" && navigator || void 0,
    Vte = Zb && (!Vy || ["ReactNative", "NativeScript", "NS"].indexOf(Vy.product) < 0),
    Wte = (() => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(),
    Yte = Zb && window.location.href || "http://localhost",
    Xte = Object.freeze(Object.defineProperty({
        __proto__: null,
        hasBrowserEnv: Zb,
        hasStandardBrowserEnv: Vte,
        hasStandardBrowserWebWorkerEnv: Wte,
        navigator: Vy,
        origin: Yte
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    un = { ...Xte,
        ...jte
    };

function Kte(t, e) {
    return Bp(t, new un.classes.URLSearchParams, Object.assign({
        visitor: function(n, r, i, s) {
            return un.isNode && te.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments)
        }
    }, e))
}

function qte(t) {
    return te.matchAll(/\w+|\[(\w*)]/g, t).map(e => e[0] === "[]" ? "" : e[1] || e[0])
}

function Jte(t) {
    const e = {},
        n = Object.keys(t);
    let r;
    const i = n.length;
    let s;
    for (r = 0; r < i; r++) s = n[r], e[s] = t[s];
    return e
}

function JM(t) {
    function e(n, r, i, s) {
        let o = n[s++];
        if (o === "__proto__") return !0;
        const a = Number.isFinite(+o),
            l = s >= n.length;
        return o = !o && te.isArray(i) ? i.length : o, l ? (te.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !a) : ((!i[o] || !te.isObject(i[o])) && (i[o] = []), e(n, r, i[o], s) && te.isArray(i[o]) && (i[o] = Jte(i[o])), !a)
    }
    if (te.isFormData(t) && te.isFunction(t.entries)) {
        const n = {};
        return te.forEachEntry(t, (r, i) => {
            e(qte(r), i, n, 0)
        }), n
    }
    return null
}

function Zte(t, e, n) {
    if (te.isString(t)) try {
        return (e || JSON.parse)(t), te.trim(t)
    } catch (r) {
        if (r.name !== "SyntaxError") throw r
    }
    return (n || JSON.stringify)(t)
}
const Qb = {
    transitional: qM,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(e, n) {
        const r = n.getContentType() || "",
            i = r.indexOf("application/json") > -1,
            s = te.isObject(e);
        if (s && te.isHTMLForm(e) && (e = new FormData(e)), te.isFormData(e)) return i ? JSON.stringify(JM(e)) : e;
        if (te.isArrayBuffer(e) || te.isBuffer(e) || te.isStream(e) || te.isFile(e) || te.isBlob(e) || te.isReadableStream(e)) return e;
        if (te.isArrayBufferView(e)) return e.buffer;
        if (te.isURLSearchParams(e)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
        let a;
        if (s) {
            if (r.indexOf("application/x-www-form-urlencoded") > -1) return Kte(e, this.formSerializer).toString();
            if ((a = te.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
                const l = this.env && this.env.FormData;
                return Bp(a ? {
                    "files[]": e
                } : e, l && new l, this.formSerializer)
            }
        }
        return s || i ? (n.setContentType("application/json", !1), Zte(e)) : e
    }],
    transformResponse: [function(e) {
        const n = this.transitional || Qb.transitional,
            r = n && n.forcedJSONParsing,
            i = this.responseType === "json";
        if (te.isResponse(e) || te.isReadableStream(e)) return e;
        if (e && te.isString(e) && (r && !this.responseType || i)) {
            const o = !(n && n.silentJSONParsing) && i;
            try {
                return JSON.parse(e)
            } catch (a) {
                if (o) throw a.name === "SyntaxError" ? Le.from(a, Le.ERR_BAD_RESPONSE, this, null, this.response) : a
            }
        }
        return e
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: un.classes.FormData,
        Blob: un.classes.Blob
    },
    validateStatus: function(e) {
        return e >= 200 && e < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
te.forEach(["delete", "get", "head", "post", "put", "patch"], t => {
    Qb.headers[t] = {}
});
const ex = Qb,
    Qte = te.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
    ene = t => {
        const e = {};
        let n, r, i;
        return t && t.split(`
`).forEach(function(o) {
            i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || e[n] && Qte[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r)
        }), e
    },
    B1 = Symbol("internals");

function ac(t) {
    return t && String(t).trim().toLowerCase()
}

function kf(t) {
    return t === !1 || t == null ? t : te.isArray(t) ? t.map(kf) : String(t)
}

function tne(t) {
    const e = Object.create(null),
        n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let r;
    for (; r = n.exec(t);) e[r[1]] = r[2];
    return e
}
const nne = t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());

function jm(t, e, n, r, i) {
    if (te.isFunction(r)) return r.call(this, e, n);
    if (i && (e = n), !!te.isString(e)) {
        if (te.isString(r)) return e.indexOf(r) !== -1;
        if (te.isRegExp(r)) return r.test(e)
    }
}

function rne(t) {
    return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r)
}

function ine(t, e) {
    const n = te.toCamelCase(" " + e);
    ["get", "set", "has"].forEach(r => {
        Object.defineProperty(t, r + n, {
            value: function(i, s, o) {
                return this[r].call(this, e, i, s, o)
            },
            configurable: !0
        })
    })
}
class Dp {
    constructor(e) {
        e && this.set(e)
    }
    set(e, n, r) {
        const i = this;

        function s(a, l, c) {
            const u = ac(l);
            if (!u) throw new Error("header name must be a non-empty string");
            const d = te.findKey(i, u);
            (!d || i[d] === void 0 || c === !0 || c === void 0 && i[d] !== !1) && (i[d || l] = kf(a))
        }
        const o = (a, l) => te.forEach(a, (c, u) => s(c, u, l));
        if (te.isPlainObject(e) || e instanceof this.constructor) o(e, n);
        else if (te.isString(e) && (e = e.trim()) && !nne(e)) o(ene(e), n);
        else if (te.isHeaders(e))
            for (const [a, l] of e.entries()) s(l, a, r);
        else e != null && s(n, e, r);
        return this
    }
    get(e, n) {
        if (e = ac(e), e) {
            const r = te.findKey(this, e);
            if (r) {
                const i = this[r];
                if (!n) return i;
                if (n === !0) return tne(i);
                if (te.isFunction(n)) return n.call(this, i, r);
                if (te.isRegExp(n)) return n.exec(i);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(e, n) {
        if (e = ac(e), e) {
            const r = te.findKey(this, e);
            return !!(r && this[r] !== void 0 && (!n || jm(this, this[r], r, n)))
        }
        return !1
    }
    delete(e, n) {
        const r = this;
        let i = !1;

        function s(o) {
            if (o = ac(o), o) {
                const a = te.findKey(r, o);
                a && (!n || jm(r, r[a], a, n)) && (delete r[a], i = !0)
            }
        }
        return te.isArray(e) ? e.forEach(s) : s(e), i
    }
    clear(e) {
        const n = Object.keys(this);
        let r = n.length,
            i = !1;
        for (; r--;) {
            const s = n[r];
            (!e || jm(this, this[s], s, e, !0)) && (delete this[s], i = !0)
        }
        return i
    }
    normalize(e) {
        const n = this,
            r = {};
        return te.forEach(this, (i, s) => {
            const o = te.findKey(r, s);
            if (o) {
                n[o] = kf(i), delete n[s];
                return
            }
            const a = e ? rne(s) : String(s).trim();
            a !== s && delete n[s], n[a] = kf(i), r[a] = !0
        }), this
    }
    concat(...e) {
        return this.constructor.concat(this, ...e)
    }
    toJSON(e) {
        const n = Object.create(null);
        return te.forEach(this, (r, i) => {
            r != null && r !== !1 && (n[i] = e && te.isArray(r) ? r.join(", ") : r)
        }), n
    }[Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`)
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(e) {
        return e instanceof this ? e : new this(e)
    }
    static concat(e, ...n) {
        const r = new this(e);
        return n.forEach(i => r.set(i)), r
    }
    static accessor(e) {
        const r = (this[B1] = this[B1] = {
                accessors: {}
            }).accessors,
            i = this.prototype;

        function s(o) {
            const a = ac(o);
            r[a] || (ine(i, o), r[a] = !0)
        }
        return te.isArray(e) ? e.forEach(s) : s(e), this
    }
}
Dp.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
te.reduceDescriptors(Dp.prototype, ({
    value: t
}, e) => {
    let n = e[0].toUpperCase() + e.slice(1);
    return {
        get: () => t,
        set(r) {
            this[n] = r
        }
    }
});
te.freezeMethods(Dp);
const Ir = Dp;

function Vm(t, e) {
    const n = this || ex,
        r = e || n,
        i = Ir.from(r.headers);
    let s = r.data;
    return te.forEach(t, function(a) {
        s = a.call(n, s, i.normalize(), e ? e.status : void 0)
    }), i.normalize(), s
}

function ZM(t) {
    return !!(t && t.__CANCEL__)
}

function Nl(t, e, n) {
    Le.call(this, t ? ? "canceled", Le.ERR_CANCELED, e, n), this.name = "CanceledError"
}
te.inherits(Nl, Le, {
    __CANCEL__: !0
});

function QM(t, e, n) {
    const r = n.config.validateStatus;
    !n.status || !r || r(n.status) ? t(n) : e(new Le("Request failed with status code " + n.status, [Le.ERR_BAD_REQUEST, Le.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n))
}

function sne(t) {
    const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
    return e && e[1] || ""
}

function one(t, e) {
    t = t || 10;
    const n = new Array(t),
        r = new Array(t);
    let i = 0,
        s = 0,
        o;
    return e = e !== void 0 ? e : 1e3,
        function(l) {
            const c = Date.now(),
                u = r[s];
            o || (o = c), n[i] = l, r[i] = c;
            let d = s,
                f = 0;
            for (; d !== i;) f += n[d++], d = d % t;
            if (i = (i + 1) % t, i === s && (s = (s + 1) % t), c - o < e) return;
            const h = u && c - u;
            return h ? Math.round(f * 1e3 / h) : void 0
        }
}

function ane(t, e) {
    let n = 0,
        r = 1e3 / e,
        i, s;
    const o = (c, u = Date.now()) => {
        n = u, i = null, s && (clearTimeout(s), s = null), t.apply(null, c)
    };
    return [(...c) => {
        const u = Date.now(),
            d = u - n;
        d >= r ? o(c, u) : (i = c, s || (s = setTimeout(() => {
            s = null, o(i)
        }, r - d)))
    }, () => i && o(i)]
}
const hh = (t, e, n = 3) => {
        let r = 0;
        const i = one(50, 250);
        return ane(s => {
            const o = s.loaded,
                a = s.lengthComputable ? s.total : void 0,
                l = o - r,
                c = i(l),
                u = o <= a;
            r = o;
            const d = {
                loaded: o,
                total: a,
                progress: a ? o / a : void 0,
                bytes: l,
                rate: c || void 0,
                estimated: c && a && u ? (a - o) / c : void 0,
                event: s,
                lengthComputable: a != null,
                [e ? "download" : "upload"]: !0
            };
            t(d)
        }, n)
    },
    D1 = (t, e) => {
        const n = t != null;
        return [r => e[0]({
            lengthComputable: n,
            total: t,
            loaded: r
        }), e[1]]
    },
    $1 = t => (...e) => te.asap(() => t(...e)),
    lne = un.hasStandardBrowserEnv ? ((t, e) => n => (n = new URL(n, un.origin), t.protocol === n.protocol && t.host === n.host && (e || t.port === n.port)))(new URL(un.origin), un.navigator && /(msie|trident)/i.test(un.navigator.userAgent)) : () => !0,
    cne = un.hasStandardBrowserEnv ? {
        write(t, e, n, r, i, s) {
            const o = [t + "=" + encodeURIComponent(e)];
            te.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), te.isString(r) && o.push("path=" + r), te.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ")
        },
        read(t) {
            const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
            return e ? decodeURIComponent(e[3]) : null
        },
        remove(t) {
            this.write(t, "", Date.now() - 864e5)
        }
    } : {
        write() {},
        read() {
            return null
        },
        remove() {}
    };

function une(t) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)
}

function dne(t, e) {
    return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t
}

function ek(t, e, n) {
    let r = !une(e);
    return t && r || n == !1 ? dne(t, e) : e
}
const F1 = t => t instanceof Ir ? { ...t
} : t;

function Xo(t, e) {
    e = e || {};
    const n = {};

    function r(c, u, d, f) {
        return te.isPlainObject(c) && te.isPlainObject(u) ? te.merge.call({
            caseless: f
        }, c, u) : te.isPlainObject(u) ? te.merge({}, u) : te.isArray(u) ? u.slice() : u
    }

    function i(c, u, d, f) {
        if (te.isUndefined(u)) {
            if (!te.isUndefined(c)) return r(void 0, c, d, f)
        } else return r(c, u, d, f)
    }

    function s(c, u) {
        if (!te.isUndefined(u)) return r(void 0, u)
    }

    function o(c, u) {
        if (te.isUndefined(u)) {
            if (!te.isUndefined(c)) return r(void 0, c)
        } else return r(void 0, u)
    }

    function a(c, u, d) {
        if (d in e) return r(c, u);
        if (d in t) return r(void 0, c)
    }
    const l = {
        url: s,
        method: s,
        data: s,
        baseURL: o,
        transformRequest: o,
        transformResponse: o,
        paramsSerializer: o,
        timeout: o,
        timeoutMessage: o,
        withCredentials: o,
        withXSRFToken: o,
        adapter: o,
        responseType: o,
        xsrfCookieName: o,
        xsrfHeaderName: o,
        onUploadProgress: o,
        onDownloadProgress: o,
        decompress: o,
        maxContentLength: o,
        maxBodyLength: o,
        beforeRedirect: o,
        transport: o,
        httpAgent: o,
        httpsAgent: o,
        cancelToken: o,
        socketPath: o,
        responseEncoding: o,
        validateStatus: a,
        headers: (c, u, d) => i(F1(c), F1(u), d, !0)
    };
    return te.forEach(Object.keys(Object.assign({}, t, e)), function(u) {
        const d = l[u] || i,
            f = d(t[u], e[u], u);
        te.isUndefined(f) && d !== a || (n[u] = f)
    }), n
}
const tk = t => {
        const e = Xo({}, t);
        let {
            data: n,
            withXSRFToken: r,
            xsrfHeaderName: i,
            xsrfCookieName: s,
            headers: o,
            auth: a
        } = e;
        e.headers = o = Ir.from(o), e.url = KM(ek(e.baseURL, e.url, e.allowAbsoluteUrls), t.params, t.paramsSerializer), a && o.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : "")));
        let l;
        if (te.isFormData(n)) {
            if (un.hasStandardBrowserEnv || un.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0);
            else if ((l = o.getContentType()) !== !1) {
                const [c, ...u] = l ? l.split(";").map(d => d.trim()).filter(Boolean) : [];
                o.setContentType([c || "multipart/form-data", ...u].join("; "))
            }
        }
        if (un.hasStandardBrowserEnv && (r && te.isFunction(r) && (r = r(e)), r || r !== !1 && lne(e.url))) {
            const c = i && s && cne.read(s);
            c && o.set(i, c)
        }
        return e
    },
    fne = typeof XMLHttpRequest < "u",
    hne = fne && function(t) {
        return new Promise(function(n, r) {
            const i = tk(t);
            let s = i.data;
            const o = Ir.from(i.headers).normalize();
            let {
                responseType: a,
                onUploadProgress: l,
                onDownloadProgress: c
            } = i, u, d, f, h, p;

            function b() {
                h && h(), p && p(), i.cancelToken && i.cancelToken.unsubscribe(u), i.signal && i.signal.removeEventListener("abort", u)
            }
            let y = new XMLHttpRequest;
            y.open(i.method.toUpperCase(), i.url, !0), y.timeout = i.timeout;

            function m() {
                if (!y) return;
                const v = Ir.from("getAllResponseHeaders" in y && y.getAllResponseHeaders()),
                    x = {
                        data: !a || a === "text" || a === "json" ? y.responseText : y.response,
                        status: y.status,
                        statusText: y.statusText,
                        headers: v,
                        config: t,
                        request: y
                    };
                QM(function(S) {
                    n(S), b()
                }, function(S) {
                    r(S), b()
                }, x), y = null
            }
            "onloadend" in y ? y.onloadend = m : y.onreadystatechange = function() {
                !y || y.readyState !== 4 || y.status === 0 && !(y.responseURL && y.responseURL.indexOf("file:") === 0) || setTimeout(m)
            }, y.onabort = function() {
                y && (r(new Le("Request aborted", Le.ECONNABORTED, t, y)), y = null)
            }, y.onerror = function() {
                r(new Le("Network Error", Le.ERR_NETWORK, t, y)), y = null
            }, y.ontimeout = function() {
                let _ = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
                const x = i.transitional || qM;
                i.timeoutErrorMessage && (_ = i.timeoutErrorMessage), r(new Le(_, x.clarifyTimeoutError ? Le.ETIMEDOUT : Le.ECONNABORTED, t, y)), y = null
            }, s === void 0 && o.setContentType(null), "setRequestHeader" in y && te.forEach(o.toJSON(), function(_, x) {
                y.setRequestHeader(x, _)
            }), te.isUndefined(i.withCredentials) || (y.withCredentials = !!i.withCredentials), a && a !== "json" && (y.responseType = i.responseType), c && ([f, p] = hh(c, !0), y.addEventListener("progress", f)), l && y.upload && ([d, h] = hh(l), y.upload.addEventListener("progress", d), y.upload.addEventListener("loadend", h)), (i.cancelToken || i.signal) && (u = v => {
                y && (r(!v || v.type ? new Nl(null, t, y) : v), y.abort(), y = null)
            }, i.cancelToken && i.cancelToken.subscribe(u), i.signal && (i.signal.aborted ? u() : i.signal.addEventListener("abort", u)));
            const g = sne(i.url);
            if (g && un.protocols.indexOf(g) === -1) {
                r(new Le("Unsupported protocol " + g + ":", Le.ERR_BAD_REQUEST, t));
                return
            }
            y.send(s || null)
        })
    },
    pne = (t, e) => {
        const {
            length: n
        } = t = t ? t.filter(Boolean) : [];
        if (e || n) {
            let r = new AbortController,
                i;
            const s = function(c) {
                if (!i) {
                    i = !0, a();
                    const u = c instanceof Error ? c : this.reason;
                    r.abort(u instanceof Le ? u : new Nl(u instanceof Error ? u.message : u))
                }
            };
            let o = e && setTimeout(() => {
                o = null, s(new Le(`timeout ${e} of ms exceeded`, Le.ETIMEDOUT))
            }, e);
            const a = () => {
                t && (o && clearTimeout(o), o = null, t.forEach(c => {
                    c.unsubscribe ? c.unsubscribe(s) : c.removeEventListener("abort", s)
                }), t = null)
            };
            t.forEach(c => c.addEventListener("abort", s));
            const {
                signal: l
            } = r;
            return l.unsubscribe = () => te.asap(a), l
        }
    },
    mne = pne,
    gne = function*(t, e) {
        let n = t.byteLength;
        if (!e || n < e) {
            yield t;
            return
        }
        let r = 0,
            i;
        for (; r < n;) i = r + e, yield t.slice(r, i), r = i
    },
    vne = async function*(t, e) {
        for await (const n of yne(t)) yield* gne(n, e)
    },
    yne = async function*(t) {
        if (t[Symbol.asyncIterator]) {
            yield* t;
            return
        }
        const e = t.getReader();
        try {
            for (;;) {
                const {
                    done: n,
                    value: r
                } = await e.read();
                if (n) break;
                yield r
            }
        } finally {
            await e.cancel()
        }
    },
    L1 = (t, e, n, r) => {
        const i = vne(t, e);
        let s = 0,
            o, a = l => {
                o || (o = !0, r && r(l))
            };
        return new ReadableStream({
            async pull(l) {
                try {
                    const {
                        done: c,
                        value: u
                    } = await i.next();
                    if (c) {
                        a(), l.close();
                        return
                    }
                    let d = u.byteLength;
                    if (n) {
                        let f = s += d;
                        n(f)
                    }
                    l.enqueue(new Uint8Array(u))
                } catch (c) {
                    throw a(c), c
                }
            },
            cancel(l) {
                return a(l), i.return()
            }
        }, {
            highWaterMark: 2
        })
    },
    $p = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function",
    nk = $p && typeof ReadableStream == "function",
    _ne = $p && (typeof TextEncoder == "function" ? (t => e => t.encode(e))(new TextEncoder) : async t => new Uint8Array(await new Response(t).arrayBuffer())),
    rk = (t, ...e) => {
        try {
            return !!t(...e)
        } catch {
            return !1
        }
    },
    bne = nk && rk(() => {
        let t = !1;
        const e = new Request(un.origin, {
            body: new ReadableStream,
            method: "POST",
            get duplex() {
                return t = !0, "half"
            }
        }).headers.has("Content-Type");
        return t && !e
    }),
    N1 = 64 * 1024,
    Wy = nk && rk(() => te.isReadableStream(new Response("").body)),
    ph = {
        stream: Wy && (t => t.body)
    };
$p && (t => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => {
        !ph[e] && (ph[e] = te.isFunction(t[e]) ? n => n[e]() : (n, r) => {
            throw new Le(`Response type '${e}' is not supported`, Le.ERR_NOT_SUPPORT, r)
        })
    })
})(new Response);
const xne = async t => {
        if (t == null) return 0;
        if (te.isBlob(t)) return t.size;
        if (te.isSpecCompliantForm(t)) return (await new Request(un.origin, {
            method: "POST",
            body: t
        }).arrayBuffer()).byteLength;
        if (te.isArrayBufferView(t) || te.isArrayBuffer(t)) return t.byteLength;
        if (te.isURLSearchParams(t) && (t = t + ""), te.isString(t)) return (await _ne(t)).byteLength
    },
    wne = async (t, e) => {
        const n = te.toFiniteNumber(t.getContentLength());
        return n ? ? xne(e)
    },
    Ene = $p && (async t => {
        let {
            url: e,
            method: n,
            data: r,
            signal: i,
            cancelToken: s,
            timeout: o,
            onDownloadProgress: a,
            onUploadProgress: l,
            responseType: c,
            headers: u,
            withCredentials: d = "same-origin",
            fetchOptions: f
        } = tk(t);
        c = c ? (c + "").toLowerCase() : "text";
        let h = mne([i, s && s.toAbortSignal()], o),
            p;
        const b = h && h.unsubscribe && (() => {
            h.unsubscribe()
        });
        let y;
        try {
            if (l && bne && n !== "get" && n !== "head" && (y = await wne(u, r)) !== 0) {
                let x = new Request(e, {
                        method: "POST",
                        body: r,
                        duplex: "half"
                    }),
                    w;
                if (te.isFormData(r) && (w = x.headers.get("content-type")) && u.setContentType(w), x.body) {
                    const [S, C] = D1(y, hh($1(l)));
                    r = L1(x.body, N1, S, C)
                }
            }
            te.isString(d) || (d = d ? "include" : "omit");
            const m = "credentials" in Request.prototype;
            p = new Request(e, { ...f,
                signal: h,
                method: n.toUpperCase(),
                headers: u.normalize().toJSON(),
                body: r,
                duplex: "half",
                credentials: m ? d : void 0
            });
            let g = await fetch(p);
            const v = Wy && (c === "stream" || c === "response");
            if (Wy && (a || v && b)) {
                const x = {};
                ["status", "statusText", "headers"].forEach(A => {
                    x[A] = g[A]
                });
                const w = te.toFiniteNumber(g.headers.get("content-length")),
                    [S, C] = a && D1(w, hh($1(a), !0)) || [];
                g = new Response(L1(g.body, N1, S, () => {
                    C && C(), b && b()
                }), x)
            }
            c = c || "text";
            let _ = await ph[te.findKey(ph, c) || "text"](g, t);
            return !v && b && b(), await new Promise((x, w) => {
                QM(x, w, {
                    data: _,
                    headers: Ir.from(g.headers),
                    status: g.status,
                    statusText: g.statusText,
                    config: t,
                    request: p
                })
            })
        } catch (m) {
            throw b && b(), m && m.name === "TypeError" && /fetch/i.test(m.message) ? Object.assign(new Le("Network Error", Le.ERR_NETWORK, t, p), {
                cause: m.cause || m
            }) : Le.from(m, m && m.code, t, p)
        }
    }),
    Yy = {
        http: $te,
        xhr: hne,
        fetch: Ene
    };
te.forEach(Yy, (t, e) => {
    if (t) {
        try {
            Object.defineProperty(t, "name", {
                value: e
            })
        } catch {}
        Object.defineProperty(t, "adapterName", {
            value: e
        })
    }
});
const U1 = t => `- ${t}`,
    Sne = t => te.isFunction(t) || t === null || t === !1,
    ik = {
        getAdapter: t => {
            t = te.isArray(t) ? t : [t];
            const {
                length: e
            } = t;
            let n, r;
            const i = {};
            for (let s = 0; s < e; s++) {
                n = t[s];
                let o;
                if (r = n, !Sne(n) && (r = Yy[(o = String(n)).toLowerCase()], r === void 0)) throw new Le(`Unknown adapter '${o}'`);
                if (r) break;
                i[o || "#" + s] = r
            }
            if (!r) {
                const s = Object.entries(i).map(([a, l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build"));
                let o = e ? s.length > 1 ? `since :
` + s.map(U1).join(`
`) : " " + U1(s[0]) : "as no adapter specified";
                throw new Le("There is no suitable adapter to dispatch the request " + o, "ERR_NOT_SUPPORT")
            }
            return r
        },
        adapters: Yy
    };

function Wm(t) {
    if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new Nl(null, t)
}

function G1(t) {
    return Wm(t), t.headers = Ir.from(t.headers), t.data = Vm.call(t, t.transformRequest), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), ik.getAdapter(t.adapter || ex.adapter)(t).then(function(r) {
        return Wm(t), r.data = Vm.call(t, t.transformResponse, r), r.headers = Ir.from(r.headers), r
    }, function(r) {
        return ZM(r) || (Wm(t), r && r.response && (r.response.data = Vm.call(t, t.transformResponse, r.response), r.response.headers = Ir.from(r.response.headers))), Promise.reject(r)
    })
}
const sk = "1.8.3",
    Fp = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
    Fp[t] = function(r) {
        return typeof r === t || "a" + (e < 1 ? "n " : " ") + t
    }
});
const H1 = {};
Fp.transitional = function(e, n, r) {
    function i(s, o) {
        return "[Axios v" + sk + "] Transitional option '" + s + "'" + o + (r ? ". " + r : "")
    }
    return (s, o, a) => {
        if (e === !1) throw new Le(i(o, " has been removed" + (n ? " in " + n : "")), Le.ERR_DEPRECATED);
        return n && !H1[o] && (H1[o] = !0, console.warn(i(o, " has been deprecated since v" + n + " and will be removed in the near future"))), e ? e(s, o, a) : !0
    }
};
Fp.spelling = function(e) {
    return (n, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0)
};

function Tne(t, e, n) {
    if (typeof t != "object") throw new Le("options must be an object", Le.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(t);
    let i = r.length;
    for (; i-- > 0;) {
        const s = r[i],
            o = e[s];
        if (o) {
            const a = t[s],
                l = a === void 0 || o(a, s, t);
            if (l !== !0) throw new Le("option " + s + " must be " + l, Le.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (n !== !0) throw new Le("Unknown option " + s, Le.ERR_BAD_OPTION)
    }
}
const Bf = {
        assertOptions: Tne,
        validators: Fp
    },
    Ur = Bf.validators;
class mh {
    constructor(e) {
        this.defaults = e, this.interceptors = {
            request: new k1,
            response: new k1
        }
    }
    async request(e, n) {
        try {
            return await this._request(e, n)
        } catch (r) {
            if (r instanceof Error) {
                let i = {};
                Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error;
                const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
                try {
                    r.stack ? s && !String(r.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + s) : r.stack = s
                } catch {}
            }
            throw r
        }
    }
    _request(e, n) {
        typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Xo(this.defaults, n);
        const {
            transitional: r,
            paramsSerializer: i,
            headers: s
        } = n;
        r !== void 0 && Bf.assertOptions(r, {
            silentJSONParsing: Ur.transitional(Ur.boolean),
            forcedJSONParsing: Ur.transitional(Ur.boolean),
            clarifyTimeoutError: Ur.transitional(Ur.boolean)
        }, !1), i != null && (te.isFunction(i) ? n.paramsSerializer = {
            serialize: i
        } : Bf.assertOptions(i, {
            encode: Ur.function,
            serialize: Ur.function
        }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Bf.assertOptions(n, {
            baseUrl: Ur.spelling("baseURL"),
            withXsrfToken: Ur.spelling("withXSRFToken")
        }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
        let o = s && te.merge(s.common, s[n.method]);
        s && te.forEach(["delete", "get", "head", "post", "put", "patch", "common"], p => {
            delete s[p]
        }), n.headers = Ir.concat(o, s);
        const a = [];
        let l = !0;
        this.interceptors.request.forEach(function(b) {
            typeof b.runWhen == "function" && b.runWhen(n) === !1 || (l = l && b.synchronous, a.unshift(b.fulfilled, b.rejected))
        });
        const c = [];
        this.interceptors.response.forEach(function(b) {
            c.push(b.fulfilled, b.rejected)
        });
        let u, d = 0,
            f;
        if (!l) {
            const p = [G1.bind(this), void 0];
            for (p.unshift.apply(p, a), p.push.apply(p, c), f = p.length, u = Promise.resolve(n); d < f;) u = u.then(p[d++], p[d++]);
            return u
        }
        f = a.length;
        let h = n;
        for (d = 0; d < f;) {
            const p = a[d++],
                b = a[d++];
            try {
                h = p(h)
            } catch (y) {
                b.call(this, y);
                break
            }
        }
        try {
            u = G1.call(this, h)
        } catch (p) {
            return Promise.reject(p)
        }
        for (d = 0, f = c.length; d < f;) u = u.then(c[d++], c[d++]);
        return u
    }
    getUri(e) {
        e = Xo(this.defaults, e);
        const n = ek(e.baseURL, e.url, e.allowAbsoluteUrls);
        return KM(n, e.params, e.paramsSerializer)
    }
}
te.forEach(["delete", "get", "head", "options"], function(e) {
    mh.prototype[e] = function(n, r) {
        return this.request(Xo(r || {}, {
            method: e,
            url: n,
            data: (r || {}).data
        }))
    }
});
te.forEach(["post", "put", "patch"], function(e) {
    function n(r) {
        return function(s, o, a) {
            return this.request(Xo(a || {}, {
                method: e,
                headers: r ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: s,
                data: o
            }))
        }
    }
    mh.prototype[e] = n(), mh.prototype[e + "Form"] = n(!0)
});
const Df = mh;
class tx {
    constructor(e) {
        if (typeof e != "function") throw new TypeError("executor must be a function.");
        let n;
        this.promise = new Promise(function(s) {
            n = s
        });
        const r = this;
        this.promise.then(i => {
            if (!r._listeners) return;
            let s = r._listeners.length;
            for (; s-- > 0;) r._listeners[s](i);
            r._listeners = null
        }), this.promise.then = i => {
            let s;
            const o = new Promise(a => {
                r.subscribe(a), s = a
            }).then(i);
            return o.cancel = function() {
                r.unsubscribe(s)
            }, o
        }, e(function(s, o, a) {
            r.reason || (r.reason = new Nl(s, o, a), n(r.reason))
        })
    }
    throwIfRequested() {
        if (this.reason) throw this.reason
    }
    subscribe(e) {
        if (this.reason) {
            e(this.reason);
            return
        }
        this._listeners ? this._listeners.push(e) : this._listeners = [e]
    }
    unsubscribe(e) {
        if (!this._listeners) return;
        const n = this._listeners.indexOf(e);
        n !== -1 && this._listeners.splice(n, 1)
    }
    toAbortSignal() {
        const e = new AbortController,
            n = r => {
                e.abort(r)
            };
        return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal
    }
    static source() {
        let e;
        return {
            token: new tx(function(i) {
                e = i
            }),
            cancel: e
        }
    }
}
const Cne = tx;

function Pne(t) {
    return function(n) {
        return t.apply(null, n)
    }
}

function Ane(t) {
    return te.isObject(t) && t.isAxiosError === !0
}
const Xy = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(Xy).forEach(([t, e]) => {
    Xy[e] = t
});
const One = Xy;

function ok(t) {
    const e = new Df(t),
        n = LM(Df.prototype.request, e);
    return te.extend(n, Df.prototype, e, {
        allOwnKeys: !0
    }), te.extend(n, e, null, {
        allOwnKeys: !0
    }), n.create = function(i) {
        return ok(Xo(t, i))
    }, n
}
const Gt = ok(ex);
Gt.Axios = Df;
Gt.CanceledError = Nl;
Gt.CancelToken = Cne;
Gt.isCancel = ZM;
Gt.VERSION = sk;
Gt.toFormData = Bp;
Gt.AxiosError = Le;
Gt.Cancel = Gt.CanceledError;
Gt.all = function(e) {
    return Promise.all(e)
};
Gt.spread = Pne;
Gt.isAxiosError = Ane;
Gt.mergeConfig = Xo;
Gt.AxiosHeaders = Ir;
Gt.formToJSON = t => JM(te.isHTMLForm(t) ? new FormData(t) : t);
Gt.getAdapter = ik.getAdapter;
Gt.HttpStatusCode = One;
Gt.default = Gt;
const fbe = Gt;
const Ine = () => {};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ak = function(t) {
        const e = [];
        let n = 0;
        for (let r = 0; r < t.length; r++) {
            let i = t.charCodeAt(r);
            i < 128 ? e[n++] = i : i < 2048 ? (e[n++] = i >> 6 | 192, e[n++] = i & 63 | 128) : (i & 64512) === 55296 && r + 1 < t.length && (t.charCodeAt(r + 1) & 64512) === 56320 ? (i = 65536 + ((i & 1023) << 10) + (t.charCodeAt(++r) & 1023), e[n++] = i >> 18 | 240, e[n++] = i >> 12 & 63 | 128, e[n++] = i >> 6 & 63 | 128, e[n++] = i & 63 | 128) : (e[n++] = i >> 12 | 224, e[n++] = i >> 6 & 63 | 128, e[n++] = i & 63 | 128)
        }
        return e
    },
    Rne = function(t) {
        const e = [];
        let n = 0,
            r = 0;
        for (; n < t.length;) {
            const i = t[n++];
            if (i < 128) e[r++] = String.fromCharCode(i);
            else if (i > 191 && i < 224) {
                const s = t[n++];
                e[r++] = String.fromCharCode((i & 31) << 6 | s & 63)
            } else if (i > 239 && i < 365) {
                const s = t[n++],
                    o = t[n++],
                    a = t[n++],
                    l = ((i & 7) << 18 | (s & 63) << 12 | (o & 63) << 6 | a & 63) - 65536;
                e[r++] = String.fromCharCode(55296 + (l >> 10)), e[r++] = String.fromCharCode(56320 + (l & 1023))
            } else {
                const s = t[n++],
                    o = t[n++];
                e[r++] = String.fromCharCode((i & 15) << 12 | (s & 63) << 6 | o & 63)
            }
        }
        return e.join("")
    },
    lk = {
        byteToCharMap_: null,
        charToByteMap_: null,
        byteToCharMapWebSafe_: null,
        charToByteMapWebSafe_: null,
        ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
        get ENCODED_VALS() {
            return this.ENCODED_VALS_BASE + "+/="
        },
        get ENCODED_VALS_WEBSAFE() {
            return this.ENCODED_VALS_BASE + "-_."
        },
        HAS_NATIVE_SUPPORT: typeof atob == "function",
        encodeByteArray(t, e) {
            if (!Array.isArray(t)) throw Error("encodeByteArray takes an array as a parameter");
            this.init_();
            const n = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
                r = [];
            for (let i = 0; i < t.length; i += 3) {
                const s = t[i],
                    o = i + 1 < t.length,
                    a = o ? t[i + 1] : 0,
                    l = i + 2 < t.length,
                    c = l ? t[i + 2] : 0,
                    u = s >> 2,
                    d = (s & 3) << 4 | a >> 4;
                let f = (a & 15) << 2 | c >> 6,
                    h = c & 63;
                l || (h = 64, o || (f = 64)), r.push(n[u], n[d], n[f], n[h])
            }
            return r.join("")
        },
        encodeString(t, e) {
            return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(ak(t), e)
        },
        decodeString(t, e) {
            return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : Rne(this.decodeStringToByteArray(t, e))
        },
        decodeStringToByteArray(t, e) {
            this.init_();
            const n = e ? this.charToByteMapWebSafe_ : this.charToByteMap_,
                r = [];
            for (let i = 0; i < t.length;) {
                const s = n[t.charAt(i++)],
                    a = i < t.length ? n[t.charAt(i)] : 0;
                ++i;
                const c = i < t.length ? n[t.charAt(i)] : 64;
                ++i;
                const d = i < t.length ? n[t.charAt(i)] : 64;
                if (++i, s == null || a == null || c == null || d == null) throw new Mne;
                const f = s << 2 | a >> 4;
                if (r.push(f), c !== 64) {
                    const h = a << 4 & 240 | c >> 2;
                    if (r.push(h), d !== 64) {
                        const p = c << 6 & 192 | d;
                        r.push(p)
                    }
                }
            }
            return r
        },
        init_() {
            if (!this.byteToCharMap_) {
                this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
                for (let t = 0; t < this.ENCODED_VALS.length; t++) this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t), this.charToByteMap_[this.byteToCharMap_[t]] = t, this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t, t >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t)
            }
        }
    };
class Mne extends Error {
    constructor() {
        super(...arguments), this.name = "DecodeBase64StringError"
    }
}
const kne = function(t) {
        const e = ak(t);
        return lk.encodeByteArray(e, !0)
    },
    ck = function(t) {
        return kne(t).replace(/\./g, "")
    },
    Bne = function(t) {
        try {
            return lk.decodeString(t, !0)
        } catch (e) {
            console.error("base64Decode failed: ", e)
        }
        return null
    };
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Dne() {
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global;
    throw new Error("Unable to locate global object.")
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $ne = () => Dne().__FIREBASE_DEFAULTS__,
    Fne = () => {
        if (typeof process > "u" || typeof process.env > "u") return;
        const t = {}.__FIREBASE_DEFAULTS__;
        if (t) return JSON.parse(t)
    },
    Lne = () => {
        if (typeof document > "u") return;
        let t;
        try {
            t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
        } catch {
            return
        }
        const e = t && Bne(t[1]);
        return e && JSON.parse(e)
    },
    Nne = () => {
        try {
            return Ine() || $ne() || Fne() || Lne()
        } catch (t) {
            console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`);
            return
        }
    },
    uk = () => {
        var t;
        return (t = Nne()) === null || t === void 0 ? void 0 : t.config
    };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Une {
    constructor() {
        this.reject = () => {}, this.resolve = () => {}, this.promise = new Promise((e, n) => {
            this.resolve = e, this.reject = n
        })
    }
    wrapCallback(e) {
        return (n, r) => {
            n ? this.reject(n) : this.resolve(r), typeof e == "function" && (this.promise.catch(() => {}), e.length === 1 ? e(n) : e(n, r))
        }
    }
}

function dk() {
    try {
        return typeof indexedDB == "object"
    } catch {
        return !1
    }
}

function fk() {
    return new Promise((t, e) => {
        try {
            let n = !0;
            const r = "validate-browser-context-for-indexeddb-analytics-module",
                i = self.indexedDB.open(r);
            i.onsuccess = () => {
                i.result.close(), n || self.indexedDB.deleteDatabase(r), t(!0)
            }, i.onupgradeneeded = () => {
                n = !1
            }, i.onerror = () => {
                var s;
                e(((s = i.error) === null || s === void 0 ? void 0 : s.message) || "")
            }
        } catch (n) {
            e(n)
        }
    })
}

function Gne() {
    return !(typeof navigator > "u" || !navigator.cookieEnabled)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Hne = "FirebaseError";
class Ul extends Error {
    constructor(e, n, r) {
        super(n), this.code = e, this.customData = r, this.name = Hne, Object.setPrototypeOf(this, Ul.prototype), Error.captureStackTrace && Error.captureStackTrace(this, Lp.prototype.create)
    }
}
class Lp {
    constructor(e, n, r) {
        this.service = e, this.serviceName = n, this.errors = r
    }
    create(e, ...n) {
        const r = n[0] || {},
            i = `${this.service}/${e}`,
            s = this.errors[e],
            o = s ? zne(s, r) : "Error",
            a = `${this.serviceName}: ${o} (${i}).`;
        return new Ul(i, a, r)
    }
}

function zne(t, e) {
    return t.replace(jne, (n, r) => {
        const i = e[r];
        return i != null ? String(i) : `<${r}?>`
    })
}
const jne = /\{\$([^}]+)}/g;

function Ky(t, e) {
    if (t === e) return !0;
    const n = Object.keys(t),
        r = Object.keys(e);
    for (const i of n) {
        if (!r.includes(i)) return !1;
        const s = t[i],
            o = e[i];
        if (z1(s) && z1(o)) {
            if (!Ky(s, o)) return !1
        } else if (s !== o) return !1
    }
    for (const i of r)
        if (!n.includes(i)) return !1;
    return !0
}

function z1(t) {
    return t !== null && typeof t == "object"
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nx(t) {
    return t && t._delegate ? t._delegate : t
}
class Ns {
    constructor(e, n, r) {
        this.name = e, this.instanceFactory = n, this.type = r, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null
    }
    setInstantiationMode(e) {
        return this.instantiationMode = e, this
    }
    setMultipleInstances(e) {
        return this.multipleInstances = e, this
    }
    setServiceProps(e) {
        return this.serviceProps = e, this
    }
    setInstanceCreatedCallback(e) {
        return this.onInstanceCreated = e, this
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const co = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vne {
    constructor(e, n) {
        this.name = e, this.container = n, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map
    }
    get(e) {
        const n = this.normalizeInstanceIdentifier(e);
        if (!this.instancesDeferred.has(n)) {
            const r = new Une;
            if (this.instancesDeferred.set(n, r), this.isInitialized(n) || this.shouldAutoInitialize()) try {
                const i = this.getOrInitializeService({
                    instanceIdentifier: n
                });
                i && r.resolve(i)
            } catch {}
        }
        return this.instancesDeferred.get(n).promise
    }
    getImmediate(e) {
        var n;
        const r = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier),
            i = (n = e == null ? void 0 : e.optional) !== null && n !== void 0 ? n : !1;
        if (this.isInitialized(r) || this.shouldAutoInitialize()) try {
            return this.getOrInitializeService({
                instanceIdentifier: r
            })
        } catch (s) {
            if (i) return null;
            throw s
        } else {
            if (i) return null;
            throw Error(`Service ${this.name} is not available`)
        }
    }
    getComponent() {
        return this.component
    }
    setComponent(e) {
        if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
        if (this.component) throw Error(`Component for ${this.name} has already been provided`);
        if (this.component = e, !!this.shouldAutoInitialize()) {
            if (Yne(e)) try {
                this.getOrInitializeService({
                    instanceIdentifier: co
                })
            } catch {}
            for (const [n, r] of this.instancesDeferred.entries()) {
                const i = this.normalizeInstanceIdentifier(n);
                try {
                    const s = this.getOrInitializeService({
                        instanceIdentifier: i
                    });
                    r.resolve(s)
                } catch {}
            }
        }
    }
    clearInstance(e = co) {
        this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e)
    }
    async delete() {
        const e = Array.from(this.instances.values());
        await Promise.all([...e.filter(n => "INTERNAL" in n).map(n => n.INTERNAL.delete()), ...e.filter(n => "_delete" in n).map(n => n._delete())])
    }
    isComponentSet() {
        return this.component != null
    }
    isInitialized(e = co) {
        return this.instances.has(e)
    }
    getOptions(e = co) {
        return this.instancesOptions.get(e) || {}
    }
    initialize(e = {}) {
        const {
            options: n = {}
        } = e, r = this.normalizeInstanceIdentifier(e.instanceIdentifier);
        if (this.isInitialized(r)) throw Error(`${this.name}(${r}) has already been initialized`);
        if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
        const i = this.getOrInitializeService({
            instanceIdentifier: r,
            options: n
        });
        for (const [s, o] of this.instancesDeferred.entries()) {
            const a = this.normalizeInstanceIdentifier(s);
            r === a && o.resolve(i)
        }
        return i
    }
    onInit(e, n) {
        var r;
        const i = this.normalizeInstanceIdentifier(n),
            s = (r = this.onInitCallbacks.get(i)) !== null && r !== void 0 ? r : new Set;
        s.add(e), this.onInitCallbacks.set(i, s);
        const o = this.instances.get(i);
        return o && e(o, i), () => {
            s.delete(e)
        }
    }
    invokeOnInitCallbacks(e, n) {
        const r = this.onInitCallbacks.get(n);
        if (r)
            for (const i of r) try {
                i(e, n)
            } catch {}
    }
    getOrInitializeService({
        instanceIdentifier: e,
        options: n = {}
    }) {
        let r = this.instances.get(e);
        if (!r && this.component && (r = this.component.instanceFactory(this.container, {
                instanceIdentifier: Wne(e),
                options: n
            }), this.instances.set(e, r), this.instancesOptions.set(e, n), this.invokeOnInitCallbacks(r, e), this.component.onInstanceCreated)) try {
            this.component.onInstanceCreated(this.container, e, r)
        } catch {}
        return r || null
    }
    normalizeInstanceIdentifier(e = co) {
        return this.component ? this.component.multipleInstances ? e : co : e
    }
    shouldAutoInitialize() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT"
    }
}

function Wne(t) {
    return t === co ? void 0 : t
}

function Yne(t) {
    return t.instantiationMode === "EAGER"
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xne {
    constructor(e) {
        this.name = e, this.providers = new Map
    }
    addComponent(e) {
        const n = this.getProvider(e.name);
        if (n.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
        n.setComponent(e)
    }
    addOrOverwriteComponent(e) {
        this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e)
    }
    getProvider(e) {
        if (this.providers.has(e)) return this.providers.get(e);
        const n = new Vne(e, this);
        return this.providers.set(e, n), n
    }
    getProviders() {
        return Array.from(this.providers.values())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var mt;
(function(t) {
    t[t.DEBUG = 0] = "DEBUG", t[t.VERBOSE = 1] = "VERBOSE", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.SILENT = 5] = "SILENT"
})(mt || (mt = {}));
const Kne = {
        debug: mt.DEBUG,
        verbose: mt.VERBOSE,
        info: mt.INFO,
        warn: mt.WARN,
        error: mt.ERROR,
        silent: mt.SILENT
    },
    qne = mt.INFO,
    Jne = {
        [mt.DEBUG]: "log",
        [mt.VERBOSE]: "log",
        [mt.INFO]: "info",
        [mt.WARN]: "warn",
        [mt.ERROR]: "error"
    },
    Zne = (t, e, ...n) => {
        if (e < t.logLevel) return;
        const r = new Date().toISOString(),
            i = Jne[e];
        if (i) console[i](`[${r}]  ${t.name}:`, ...n);
        else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`)
    };
class Qne {
    constructor(e) {
        this.name = e, this._logLevel = qne, this._logHandler = Zne, this._userLogHandler = null
    }
    get logLevel() {
        return this._logLevel
    }
    set logLevel(e) {
        if (!(e in mt)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
        this._logLevel = e
    }
    setLogLevel(e) {
        this._logLevel = typeof e == "string" ? Kne[e] : e
    }
    get logHandler() {
        return this._logHandler
    }
    set logHandler(e) {
        if (typeof e != "function") throw new TypeError("Value assigned to `logHandler` must be a function");
        this._logHandler = e
    }
    get userLogHandler() {
        return this._userLogHandler
    }
    set userLogHandler(e) {
        this._userLogHandler = e
    }
    debug(...e) {
        this._userLogHandler && this._userLogHandler(this, mt.DEBUG, ...e), this._logHandler(this, mt.DEBUG, ...e)
    }
    log(...e) {
        this._userLogHandler && this._userLogHandler(this, mt.VERBOSE, ...e), this._logHandler(this, mt.VERBOSE, ...e)
    }
    info(...e) {
        this._userLogHandler && this._userLogHandler(this, mt.INFO, ...e), this._logHandler(this, mt.INFO, ...e)
    }
    warn(...e) {
        this._userLogHandler && this._userLogHandler(this, mt.WARN, ...e), this._logHandler(this, mt.WARN, ...e)
    }
    error(...e) {
        this._userLogHandler && this._userLogHandler(this, mt.ERROR, ...e), this._logHandler(this, mt.ERROR, ...e)
    }
}
const ere = (t, e) => e.some(n => t instanceof n);
let j1, V1;

function tre() {
    return j1 || (j1 = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
}

function nre() {
    return V1 || (V1 = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])
}
const hk = new WeakMap,
    qy = new WeakMap,
    pk = new WeakMap,
    Ym = new WeakMap,
    rx = new WeakMap;

function rre(t) {
    const e = new Promise((n, r) => {
        const i = () => {
                t.removeEventListener("success", s), t.removeEventListener("error", o)
            },
            s = () => {
                n(Mi(t.result)), i()
            },
            o = () => {
                r(t.error), i()
            };
        t.addEventListener("success", s), t.addEventListener("error", o)
    });
    return e.then(n => {
        n instanceof IDBCursor && hk.set(n, t)
    }).catch(() => {}), rx.set(e, t), e
}

function ire(t) {
    if (qy.has(t)) return;
    const e = new Promise((n, r) => {
        const i = () => {
                t.removeEventListener("complete", s), t.removeEventListener("error", o), t.removeEventListener("abort", o)
            },
            s = () => {
                n(), i()
            },
            o = () => {
                r(t.error || new DOMException("AbortError", "AbortError")), i()
            };
        t.addEventListener("complete", s), t.addEventListener("error", o), t.addEventListener("abort", o)
    });
    qy.set(t, e)
}
let Jy = {
    get(t, e, n) {
        if (t instanceof IDBTransaction) {
            if (e === "done") return qy.get(t);
            if (e === "objectStoreNames") return t.objectStoreNames || pk.get(t);
            if (e === "store") return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0])
        }
        return Mi(t[e])
    },
    set(t, e, n) {
        return t[e] = n, !0
    },
    has(t, e) {
        return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t
    }
};

function sre(t) {
    Jy = t(Jy)
}

function ore(t) {
    return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
        const r = t.call(Xm(this), e, ...n);
        return pk.set(r, e.sort ? e.sort() : [e]), Mi(r)
    } : nre().includes(t) ? function(...e) {
        return t.apply(Xm(this), e), Mi(hk.get(this))
    } : function(...e) {
        return Mi(t.apply(Xm(this), e))
    }
}

function are(t) {
    return typeof t == "function" ? ore(t) : (t instanceof IDBTransaction && ire(t), ere(t, tre()) ? new Proxy(t, Jy) : t)
}

function Mi(t) {
    if (t instanceof IDBRequest) return rre(t);
    if (Ym.has(t)) return Ym.get(t);
    const e = are(t);
    return e !== t && (Ym.set(t, e), rx.set(e, t)), e
}
const Xm = t => rx.get(t);

function Np(t, e, {
    blocked: n,
    upgrade: r,
    blocking: i,
    terminated: s
} = {}) {
    const o = indexedDB.open(t, e),
        a = Mi(o);
    return r && o.addEventListener("upgradeneeded", l => {
        r(Mi(o.result), l.oldVersion, l.newVersion, Mi(o.transaction), l)
    }), n && o.addEventListener("blocked", l => n(l.oldVersion, l.newVersion, l)), a.then(l => {
        s && l.addEventListener("close", () => s()), i && l.addEventListener("versionchange", c => i(c.oldVersion, c.newVersion, c))
    }).catch(() => {}), a
}

function Km(t, {
    blocked: e
} = {}) {
    const n = indexedDB.deleteDatabase(t);
    return e && n.addEventListener("blocked", r => e(r.oldVersion, r)), Mi(n).then(() => {})
}
const lre = ["get", "getKey", "getAll", "getAllKeys", "count"],
    cre = ["put", "add", "delete", "clear"],
    qm = new Map;

function W1(t, e) {
    if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string")) return;
    if (qm.get(e)) return qm.get(e);
    const n = e.replace(/FromIndex$/, ""),
        r = e !== n,
        i = cre.includes(n);
    if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || lre.includes(n))) return;
    const s = async function(o, ...a) {
        const l = this.transaction(o, i ? "readwrite" : "readonly");
        let c = l.store;
        return r && (c = c.index(a.shift())), (await Promise.all([c[n](...a), i && l.done]))[0]
    };
    return qm.set(e, s), s
}
sre(t => ({ ...t,
    get: (e, n, r) => W1(e, n) || t.get(e, n, r),
    has: (e, n) => !!W1(e, n) || t.has(e, n)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ure {
    constructor(e) {
        this.container = e
    }
    getPlatformInfoString() {
        return this.container.getProviders().map(n => {
            if (dre(n)) {
                const r = n.getImmediate();
                return `${r.library}/${r.version}`
            } else return null
        }).filter(n => n).join(" ")
    }
}

function dre(t) {
    const e = t.getComponent();
    return (e == null ? void 0 : e.type) === "VERSION"
}
const Zy = "@firebase/app",
    Y1 = "0.11.4";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Vi = new Qne("@firebase/app"),
    fre = "@firebase/app-compat",
    hre = "@firebase/analytics-compat",
    pre = "@firebase/analytics",
    mre = "@firebase/app-check-compat",
    gre = "@firebase/app-check",
    vre = "@firebase/auth",
    yre = "@firebase/auth-compat",
    _re = "@firebase/database",
    bre = "@firebase/data-connect",
    xre = "@firebase/database-compat",
    wre = "@firebase/functions",
    Ere = "@firebase/functions-compat",
    Sre = "@firebase/installations",
    Tre = "@firebase/installations-compat",
    Cre = "@firebase/messaging",
    Pre = "@firebase/messaging-compat",
    Are = "@firebase/performance",
    Ore = "@firebase/performance-compat",
    Ire = "@firebase/remote-config",
    Rre = "@firebase/remote-config-compat",
    Mre = "@firebase/storage",
    kre = "@firebase/storage-compat",
    Bre = "@firebase/firestore",
    Dre = "@firebase/vertexai",
    $re = "@firebase/firestore-compat",
    Fre = "firebase";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Qy = "[DEFAULT]",
    Lre = {
        [Zy]: "fire-core",
        [fre]: "fire-core-compat",
        [pre]: "fire-analytics",
        [hre]: "fire-analytics-compat",
        [gre]: "fire-app-check",
        [mre]: "fire-app-check-compat",
        [vre]: "fire-auth",
        [yre]: "fire-auth-compat",
        [_re]: "fire-rtdb",
        [bre]: "fire-data-connect",
        [xre]: "fire-rtdb-compat",
        [wre]: "fire-fn",
        [Ere]: "fire-fn-compat",
        [Sre]: "fire-iid",
        [Tre]: "fire-iid-compat",
        [Cre]: "fire-fcm",
        [Pre]: "fire-fcm-compat",
        [Are]: "fire-perf",
        [Ore]: "fire-perf-compat",
        [Ire]: "fire-rc",
        [Rre]: "fire-rc-compat",
        [Mre]: "fire-gcs",
        [kre]: "fire-gcs-compat",
        [Bre]: "fire-fst",
        [$re]: "fire-fst-compat",
        [Dre]: "fire-vertex",
        "fire-js": "fire-js",
        [Fre]: "fire-js-all"
    };
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const gh = new Map,
    Nre = new Map,
    e0 = new Map;

function X1(t, e) {
    try {
        t.container.addComponent(e)
    } catch (n) {
        Vi.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`, n)
    }
}

function Ko(t) {
    const e = t.name;
    if (e0.has(e)) return Vi.debug(`There were multiple attempts to register component ${e}.`), !1;
    e0.set(e, t);
    for (const n of gh.values()) X1(n, t);
    for (const n of Nre.values()) X1(n, t);
    return !0
}

function ix(t, e) {
    const n = t.container.getProvider("heartbeat").getImmediate({
        optional: !0
    });
    return n && n.triggerHeartbeat(), t.container.getProvider(e)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ure = {
        "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
        "bad-app-name": "Illegal App name: '{$appName}'",
        "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
        "app-deleted": "Firebase App named '{$appName}' already deleted",
        "server-app-deleted": "Firebase Server App has been deleted",
        "no-options": "Need to provide options, when not being deployed to hosting via source.",
        "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
        "invalid-log-argument": "First argument to `onLog` must be null or a function.",
        "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
        "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
        "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
        "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
        "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
        "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
    },
    As = new Lp("app", "Firebase", Ure);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Gre {
    constructor(e, n, r) {
        this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, n), this._name = n.name, this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled, this._container = r, this.container.addComponent(new Ns("app", () => this, "PUBLIC"))
    }
    get automaticDataCollectionEnabled() {
        return this.checkDestroyed(), this._automaticDataCollectionEnabled
    }
    set automaticDataCollectionEnabled(e) {
        this.checkDestroyed(), this._automaticDataCollectionEnabled = e
    }
    get name() {
        return this.checkDestroyed(), this._name
    }
    get options() {
        return this.checkDestroyed(), this._options
    }
    get config() {
        return this.checkDestroyed(), this._config
    }
    get container() {
        return this._container
    }
    get isDeleted() {
        return this._isDeleted
    }
    set isDeleted(e) {
        this._isDeleted = e
    }
    checkDestroyed() {
        if (this.isDeleted) throw As.create("app-deleted", {
            appName: this._name
        })
    }
}

function Hre(t, e = {}) {
    let n = t;
    typeof e != "object" && (e = {
        name: e
    });
    const r = Object.assign({
            name: Qy,
            automaticDataCollectionEnabled: !1
        }, e),
        i = r.name;
    if (typeof i != "string" || !i) throw As.create("bad-app-name", {
        appName: String(i)
    });
    if (n || (n = uk()), !n) throw As.create("no-options");
    const s = gh.get(i);
    if (s) {
        if (Ky(n, s.options) && Ky(r, s.config)) return s;
        throw As.create("duplicate-app", {
            appName: i
        })
    }
    const o = new Xne(i);
    for (const l of e0.values()) o.addComponent(l);
    const a = new Gre(n, r, o);
    return gh.set(i, a), a
}

function zre(t = Qy) {
    const e = gh.get(t);
    if (!e && t === Qy && uk()) return Hre();
    if (!e) throw As.create("no-app", {
        appName: t
    });
    return e
}

function Os(t, e, n) {
    var r;
    let i = (r = Lre[t]) !== null && r !== void 0 ? r : t;
    n && (i += `-${n}`);
    const s = i.match(/\s|\//),
        o = e.match(/\s|\//);
    if (s || o) {
        const a = [`Unable to register library "${i}" with version "${e}":`];
        s && a.push(`library name "${i}" contains illegal characters (whitespace or "/")`), s && o && a.push("and"), o && a.push(`version name "${e}" contains illegal characters (whitespace or "/")`), Vi.warn(a.join(" "));
        return
    }
    Ko(new Ns(`${i}-version`, () => ({
        library: i,
        version: e
    }), "VERSION"))
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const jre = "firebase-heartbeat-database",
    Vre = 1,
    _u = "firebase-heartbeat-store";
let Jm = null;

function mk() {
    return Jm || (Jm = Np(jre, Vre, {
        upgrade: (t, e) => {
            switch (e) {
                case 0:
                    try {
                        t.createObjectStore(_u)
                    } catch (n) {
                        console.warn(n)
                    }
            }
        }
    }).catch(t => {
        throw As.create("idb-open", {
            originalErrorMessage: t.message
        })
    })), Jm
}
async function Wre(t) {
    try {
        const n = (await mk()).transaction(_u),
            r = await n.objectStore(_u).get(gk(t));
        return await n.done, r
    } catch (e) {
        if (e instanceof Ul) Vi.warn(e.message);
        else {
            const n = As.create("idb-get", {
                originalErrorMessage: e == null ? void 0 : e.message
            });
            Vi.warn(n.message)
        }
    }
}
async function K1(t, e) {
    try {
        const r = (await mk()).transaction(_u, "readwrite");
        await r.objectStore(_u).put(e, gk(t)), await r.done
    } catch (n) {
        if (n instanceof Ul) Vi.warn(n.message);
        else {
            const r = As.create("idb-set", {
                originalErrorMessage: n == null ? void 0 : n.message
            });
            Vi.warn(r.message)
        }
    }
}

function gk(t) {
    return `${t.name}!${t.options.appId}`
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Yre = 1024,
    Xre = 30;
class Kre {
    constructor(e) {
        this.container = e, this._heartbeatsCache = null;
        const n = this.container.getProvider("app").getImmediate();
        this._storage = new Jre(n), this._heartbeatsCachePromise = this._storage.read().then(r => (this._heartbeatsCache = r, r))
    }
    async triggerHeartbeat() {
        var e, n;
        try {
            const i = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),
                s = q1();
            if (((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, ((n = this._heartbeatsCache) === null || n === void 0 ? void 0 : n.heartbeats) == null) || this._heartbeatsCache.lastSentHeartbeatDate === s || this._heartbeatsCache.heartbeats.some(o => o.date === s)) return;
            if (this._heartbeatsCache.heartbeats.push({
                    date: s,
                    agent: i
                }), this._heartbeatsCache.heartbeats.length > Xre) {
                const o = Zre(this._heartbeatsCache.heartbeats);
                this._heartbeatsCache.heartbeats.splice(o, 1)
            }
            return this._storage.overwrite(this._heartbeatsCache)
        } catch (r) {
            Vi.warn(r)
        }
    }
    async getHeartbeatsHeader() {
        var e;
        try {
            if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) return "";
            const n = q1(),
                {
                    heartbeatsToSend: r,
                    unsentEntries: i
                } = qre(this._heartbeatsCache.heartbeats),
                s = ck(JSON.stringify({
                    version: 2,
                    heartbeats: r
                }));
            return this._heartbeatsCache.lastSentHeartbeatDate = n, i.length > 0 ? (this._heartbeatsCache.heartbeats = i, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s
        } catch (n) {
            return Vi.warn(n), ""
        }
    }
}

function q1() {
    return new Date().toISOString().substring(0, 10)
}

function qre(t, e = Yre) {
    const n = [];
    let r = t.slice();
    for (const i of t) {
        const s = n.find(o => o.agent === i.agent);
        if (s) {
            if (s.dates.push(i.date), J1(n) > e) {
                s.dates.pop();
                break
            }
        } else if (n.push({
                agent: i.agent,
                dates: [i.date]
            }), J1(n) > e) {
            n.pop();
            break
        }
        r = r.slice(1)
    }
    return {
        heartbeatsToSend: n,
        unsentEntries: r
    }
}
class Jre {
    constructor(e) {
        this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck()
    }
    async runIndexedDBEnvironmentCheck() {
        return dk() ? fk().then(() => !0).catch(() => !1) : !1
    }
    async read() {
        if (await this._canUseIndexedDBPromise) {
            const n = await Wre(this.app);
            return n != null && n.heartbeats ? n : {
                heartbeats: []
            }
        } else return {
            heartbeats: []
        }
    }
    async overwrite(e) {
        var n;
        if (await this._canUseIndexedDBPromise) {
            const i = await this.read();
            return K1(this.app, {
                lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
                heartbeats: e.heartbeats
            })
        } else return
    }
    async add(e) {
        var n;
        if (await this._canUseIndexedDBPromise) {
            const i = await this.read();
            return K1(this.app, {
                lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
                heartbeats: [...i.heartbeats, ...e.heartbeats]
            })
        } else return
    }
}

function J1(t) {
    return ck(JSON.stringify({
        version: 2,
        heartbeats: t
    })).length
}

function Zre(t) {
    if (t.length === 0) return -1;
    let e = 0,
        n = t[0].date;
    for (let r = 1; r < t.length; r++) t[r].date < n && (n = t[r].date, e = r);
    return e
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Qre(t) {
    Ko(new Ns("platform-logger", e => new ure(e), "PRIVATE")), Ko(new Ns("heartbeat", e => new Kre(e), "PRIVATE")), Os(Zy, Y1, t), Os(Zy, Y1, "esm2017"), Os("fire-js", "")
}
Qre("");
var eie = "firebase",
    tie = "11.6.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Os(eie, tie, "app");
const vk = "@firebase/installations",
    sx = "0.6.13";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const yk = 1e4,
    _k = `w:${sx}`,
    bk = "FIS_v2",
    nie = "https://firebaseinstallations.googleapis.com/v1",
    rie = 60 * 60 * 1e3,
    iie = "installations",
    sie = "Installations";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const oie = {
        "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
        "not-registered": "Firebase Installation is not registered.",
        "installation-not-found": "Firebase Installation not found.",
        "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
        "app-offline": "Could not process request. Application offline.",
        "delete-pending-registration": "Can't delete installation while there is a pending registration request."
    },
    qo = new Lp(iie, sie, oie);

function xk(t) {
    return t instanceof Ul && t.code.includes("request-failed")
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function wk({
    projectId: t
}) {
    return `${nie}/projects/${t}/installations`
}

function Ek(t) {
    return {
        token: t.token,
        requestStatus: 2,
        expiresIn: lie(t.expiresIn),
        creationTime: Date.now()
    }
}
async function Sk(t, e) {
    const r = (await e.json()).error;
    return qo.create("request-failed", {
        requestName: t,
        serverCode: r.code,
        serverMessage: r.message,
        serverStatus: r.status
    })
}

function Tk({
    apiKey: t
}) {
    return new Headers({
        "Content-Type": "application/json",
        Accept: "application/json",
        "x-goog-api-key": t
    })
}

function aie(t, {
    refreshToken: e
}) {
    const n = Tk(t);
    return n.append("Authorization", cie(e)), n
}
async function Ck(t) {
    const e = await t();
    return e.status >= 500 && e.status < 600 ? t() : e
}

function lie(t) {
    return Number(t.replace("s", "000"))
}

function cie(t) {
    return `${bk} ${t}`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function uie({
    appConfig: t,
    heartbeatServiceProvider: e
}, {
    fid: n
}) {
    const r = wk(t),
        i = Tk(t),
        s = e.getImmediate({
            optional: !0
        });
    if (s) {
        const c = await s.getHeartbeatsHeader();
        c && i.append("x-firebase-client", c)
    }
    const o = {
            fid: n,
            authVersion: bk,
            appId: t.appId,
            sdkVersion: _k
        },
        a = {
            method: "POST",
            headers: i,
            body: JSON.stringify(o)
        },
        l = await Ck(() => fetch(r, a));
    if (l.ok) {
        const c = await l.json();
        return {
            fid: c.fid || n,
            registrationStatus: 2,
            refreshToken: c.refreshToken,
            authToken: Ek(c.authToken)
        }
    } else throw await Sk("Create Installation", l)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Pk(t) {
    return new Promise(e => {
        setTimeout(e, t)
    })
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function die(t) {
    return btoa(String.fromCharCode(...t)).replace(/\+/g, "-").replace(/\//g, "_")
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fie = /^[cdef][\w-]{21}$/,
    t0 = "";

function hie() {
    try {
        const t = new Uint8Array(17);
        (self.crypto || self.msCrypto).getRandomValues(t), t[0] = 112 + t[0] % 16;
        const n = pie(t);
        return fie.test(n) ? n : t0
    } catch {
        return t0
    }
}

function pie(t) {
    return die(t).substr(0, 22)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Up(t) {
    return `${t.appName}!${t.appId}`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ak = new Map;

function Ok(t, e) {
    const n = Up(t);
    Ik(n, e), mie(n, e)
}

function Ik(t, e) {
    const n = Ak.get(t);
    if (n)
        for (const r of n) r(e)
}

function mie(t, e) {
    const n = gie();
    n && n.postMessage({
        key: t,
        fid: e
    }), vie()
}
let So = null;

function gie() {
    return !So && "BroadcastChannel" in self && (So = new BroadcastChannel("[Firebase] FID Change"), So.onmessage = t => {
        Ik(t.data.key, t.data.fid)
    }), So
}

function vie() {
    Ak.size === 0 && So && (So.close(), So = null)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const yie = "firebase-installations-database",
    _ie = 1,
    Jo = "firebase-installations-store";
let Zm = null;

function ox() {
    return Zm || (Zm = Np(yie, _ie, {
        upgrade: (t, e) => {
            switch (e) {
                case 0:
                    t.createObjectStore(Jo)
            }
        }
    })), Zm
}
async function vh(t, e) {
    const n = Up(t),
        i = (await ox()).transaction(Jo, "readwrite"),
        s = i.objectStore(Jo),
        o = await s.get(n);
    return await s.put(e, n), await i.done, (!o || o.fid !== e.fid) && Ok(t, e.fid), e
}
async function Rk(t) {
    const e = Up(t),
        r = (await ox()).transaction(Jo, "readwrite");
    await r.objectStore(Jo).delete(e), await r.done
}
async function Gp(t, e) {
    const n = Up(t),
        i = (await ox()).transaction(Jo, "readwrite"),
        s = i.objectStore(Jo),
        o = await s.get(n),
        a = e(o);
    return a === void 0 ? await s.delete(n) : await s.put(a, n), await i.done, a && (!o || o.fid !== a.fid) && Ok(t, a.fid), a
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ax(t) {
    let e;
    const n = await Gp(t.appConfig, r => {
        const i = bie(r),
            s = xie(t, i);
        return e = s.registrationPromise, s.installationEntry
    });
    return n.fid === t0 ? {
        installationEntry: await e
    } : {
        installationEntry: n,
        registrationPromise: e
    }
}

function bie(t) {
    const e = t || {
        fid: hie(),
        registrationStatus: 0
    };
    return Mk(e)
}

function xie(t, e) {
    if (e.registrationStatus === 0) {
        if (!navigator.onLine) {
            const i = Promise.reject(qo.create("app-offline"));
            return {
                installationEntry: e,
                registrationPromise: i
            }
        }
        const n = {
                fid: e.fid,
                registrationStatus: 1,
                registrationTime: Date.now()
            },
            r = wie(t, n);
        return {
            installationEntry: n,
            registrationPromise: r
        }
    } else return e.registrationStatus === 1 ? {
        installationEntry: e,
        registrationPromise: Eie(t)
    } : {
        installationEntry: e
    }
}
async function wie(t, e) {
    try {
        const n = await uie(t, e);
        return vh(t.appConfig, n)
    } catch (n) {
        throw xk(n) && n.customData.serverCode === 409 ? await Rk(t.appConfig) : await vh(t.appConfig, {
            fid: e.fid,
            registrationStatus: 0
        }), n
    }
}
async function Eie(t) {
    let e = await Z1(t.appConfig);
    for (; e.registrationStatus === 1;) await Pk(100), e = await Z1(t.appConfig);
    if (e.registrationStatus === 0) {
        const {
            installationEntry: n,
            registrationPromise: r
        } = await ax(t);
        return r || n
    }
    return e
}

function Z1(t) {
    return Gp(t, e => {
        if (!e) throw qo.create("installation-not-found");
        return Mk(e)
    })
}

function Mk(t) {
    return Sie(t) ? {
        fid: t.fid,
        registrationStatus: 0
    } : t
}

function Sie(t) {
    return t.registrationStatus === 1 && t.registrationTime + yk < Date.now()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Tie({
    appConfig: t,
    heartbeatServiceProvider: e
}, n) {
    const r = Cie(t, n),
        i = aie(t, n),
        s = e.getImmediate({
            optional: !0
        });
    if (s) {
        const c = await s.getHeartbeatsHeader();
        c && i.append("x-firebase-client", c)
    }
    const o = {
            installation: {
                sdkVersion: _k,
                appId: t.appId
            }
        },
        a = {
            method: "POST",
            headers: i,
            body: JSON.stringify(o)
        },
        l = await Ck(() => fetch(r, a));
    if (l.ok) {
        const c = await l.json();
        return Ek(c)
    } else throw await Sk("Generate Auth Token", l)
}

function Cie(t, {
    fid: e
}) {
    return `${wk(t)}/${e}/authTokens:generate`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function lx(t, e = !1) {
    let n;
    const r = await Gp(t.appConfig, s => {
        if (!kk(s)) throw qo.create("not-registered");
        const o = s.authToken;
        if (!e && Oie(o)) return s;
        if (o.requestStatus === 1) return n = Pie(t, e), s; {
            if (!navigator.onLine) throw qo.create("app-offline");
            const a = Rie(s);
            return n = Aie(t, a), a
        }
    });
    return n ? await n : r.authToken
}
async function Pie(t, e) {
    let n = await Q1(t.appConfig);
    for (; n.authToken.requestStatus === 1;) await Pk(100), n = await Q1(t.appConfig);
    const r = n.authToken;
    return r.requestStatus === 0 ? lx(t, e) : r
}

function Q1(t) {
    return Gp(t, e => {
        if (!kk(e)) throw qo.create("not-registered");
        const n = e.authToken;
        return Mie(n) ? Object.assign(Object.assign({}, e), {
            authToken: {
                requestStatus: 0
            }
        }) : e
    })
}
async function Aie(t, e) {
    try {
        const n = await Tie(t, e),
            r = Object.assign(Object.assign({}, e), {
                authToken: n
            });
        return await vh(t.appConfig, r), n
    } catch (n) {
        if (xk(n) && (n.customData.serverCode === 401 || n.customData.serverCode === 404)) await Rk(t.appConfig);
        else {
            const r = Object.assign(Object.assign({}, e), {
                authToken: {
                    requestStatus: 0
                }
            });
            await vh(t.appConfig, r)
        }
        throw n
    }
}

function kk(t) {
    return t !== void 0 && t.registrationStatus === 2
}

function Oie(t) {
    return t.requestStatus === 2 && !Iie(t)
}

function Iie(t) {
    const e = Date.now();
    return e < t.creationTime || t.creationTime + t.expiresIn < e + rie
}

function Rie(t) {
    const e = {
        requestStatus: 1,
        requestTime: Date.now()
    };
    return Object.assign(Object.assign({}, t), {
        authToken: e
    })
}

function Mie(t) {
    return t.requestStatus === 1 && t.requestTime + yk < Date.now()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function kie(t) {
    const e = t,
        {
            installationEntry: n,
            registrationPromise: r
        } = await ax(e);
    return r ? r.catch(console.error) : lx(e).catch(console.error), n.fid
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Bie(t, e = !1) {
    const n = t;
    return await Die(n), (await lx(n, e)).token
}
async function Die(t) {
    const {
        registrationPromise: e
    } = await ax(t);
    e && await e
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $ie(t) {
    if (!t || !t.options) throw Qm("App Configuration");
    if (!t.name) throw Qm("App Name");
    const e = ["projectId", "apiKey", "appId"];
    for (const n of e)
        if (!t.options[n]) throw Qm(n);
    return {
        appName: t.name,
        projectId: t.options.projectId,
        apiKey: t.options.apiKey,
        appId: t.options.appId
    }
}

function Qm(t) {
    return qo.create("missing-app-config-values", {
        valueName: t
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Bk = "installations",
    Fie = "installations-internal",
    Lie = t => {
        const e = t.getProvider("app").getImmediate(),
            n = $ie(e),
            r = ix(e, "heartbeat");
        return {
            app: e,
            appConfig: n,
            heartbeatServiceProvider: r,
            _delete: () => Promise.resolve()
        }
    },
    Nie = t => {
        const e = t.getProvider("app").getImmediate(),
            n = ix(e, Bk).getImmediate();
        return {
            getId: () => kie(n),
            getToken: i => Bie(n, i)
        }
    };

function Uie() {
    Ko(new Ns(Bk, Lie, "PUBLIC")), Ko(new Ns(Fie, Nie, "PRIVATE"))
}
Uie();
Os(vk, sx);
Os(vk, sx, "esm2017");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Gie = "/firebase-messaging-sw.js",
    Hie = "/firebase-cloud-messaging-push-scope",
    Dk = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4",
    zie = "https://fcmregistrations.googleapis.com/v1",
    $k = "google.c.a.c_id",
    jie = "google.c.a.c_l",
    Vie = "google.c.a.ts",
    Wie = "google.c.a.e",
    eT = 1e4;
var tT;
(function(t) {
    t[t.DATA_MESSAGE = 1] = "DATA_MESSAGE", t[t.DISPLAY_NOTIFICATION = 3] = "DISPLAY_NOTIFICATION"
})(tT || (tT = {}));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
var bu;
(function(t) {
    t.PUSH_RECEIVED = "push-received", t.NOTIFICATION_CLICKED = "notification-clicked"
})(bu || (bu = {}));
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function wi(t) {
    const e = new Uint8Array(t);
    return btoa(String.fromCharCode(...e)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_")
}

function Yie(t) {
    const e = "=".repeat((4 - t.length % 4) % 4),
        n = (t + e).replace(/\-/g, "+").replace(/_/g, "/"),
        r = atob(n),
        i = new Uint8Array(r.length);
    for (let s = 0; s < r.length; ++s) i[s] = r.charCodeAt(s);
    return i
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const eg = "fcm_token_details_db",
    Xie = 5,
    nT = "fcm_token_object_Store";
async function Kie(t) {
    if ("databases" in indexedDB && !(await indexedDB.databases()).map(s => s.name).includes(eg)) return null;
    let e = null;
    return (await Np(eg, Xie, {
        upgrade: async (r, i, s, o) => {
            var a;
            if (i < 2 || !r.objectStoreNames.contains(nT)) return;
            const l = o.objectStore(nT),
                c = await l.index("fcmSenderId").get(t);
            if (await l.clear(), !!c) {
                if (i === 2) {
                    const u = c;
                    if (!u.auth || !u.p256dh || !u.endpoint) return;
                    e = {
                        token: u.fcmToken,
                        createTime: (a = u.createTime) !== null && a !== void 0 ? a : Date.now(),
                        subscriptionOptions: {
                            auth: u.auth,
                            p256dh: u.p256dh,
                            endpoint: u.endpoint,
                            swScope: u.swScope,
                            vapidKey: typeof u.vapidKey == "string" ? u.vapidKey : wi(u.vapidKey)
                        }
                    }
                } else if (i === 3) {
                    const u = c;
                    e = {
                        token: u.fcmToken,
                        createTime: u.createTime,
                        subscriptionOptions: {
                            auth: wi(u.auth),
                            p256dh: wi(u.p256dh),
                            endpoint: u.endpoint,
                            swScope: u.swScope,
                            vapidKey: wi(u.vapidKey)
                        }
                    }
                } else if (i === 4) {
                    const u = c;
                    e = {
                        token: u.fcmToken,
                        createTime: u.createTime,
                        subscriptionOptions: {
                            auth: wi(u.auth),
                            p256dh: wi(u.p256dh),
                            endpoint: u.endpoint,
                            swScope: u.swScope,
                            vapidKey: wi(u.vapidKey)
                        }
                    }
                }
            }
        }
    })).close(), await Km(eg), await Km("fcm_vapid_details_db"), await Km("undefined"), qie(e) ? e : null
}

function qie(t) {
    if (!t || !t.subscriptionOptions) return !1;
    const {
        subscriptionOptions: e
    } = t;
    return typeof t.createTime == "number" && t.createTime > 0 && typeof t.token == "string" && t.token.length > 0 && typeof e.auth == "string" && e.auth.length > 0 && typeof e.p256dh == "string" && e.p256dh.length > 0 && typeof e.endpoint == "string" && e.endpoint.length > 0 && typeof e.swScope == "string" && e.swScope.length > 0 && typeof e.vapidKey == "string" && e.vapidKey.length > 0
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Jie = "firebase-messaging-database",
    Zie = 1,
    xu = "firebase-messaging-store";
let tg = null;

function Fk() {
    return tg || (tg = Np(Jie, Zie, {
        upgrade: (t, e) => {
            switch (e) {
                case 0:
                    t.createObjectStore(xu)
            }
        }
    })), tg
}
async function Qie(t) {
    const e = Lk(t),
        r = await (await Fk()).transaction(xu).objectStore(xu).get(e);
    if (r) return r; {
        const i = await Kie(t.appConfig.senderId);
        if (i) return await cx(t, i), i
    }
}
async function cx(t, e) {
    const n = Lk(t),
        i = (await Fk()).transaction(xu, "readwrite");
    return await i.objectStore(xu).put(e, n), await i.done, e
}

function Lk({
    appConfig: t
}) {
    return t.appId
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ese = {
        "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
        "only-available-in-window": "This method is available in a Window context.",
        "only-available-in-sw": "This method is available in a service worker context.",
        "permission-default": "The notification permission was not granted and dismissed instead.",
        "permission-blocked": "The notification permission was not granted and blocked instead.",
        "unsupported-browser": "This browser doesn't support the API's required to use the Firebase SDK.",
        "indexed-db-unsupported": "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
        "failed-service-worker-registration": "We are unable to register the default service worker. {$browserErrorMessage}",
        "token-subscribe-failed": "A problem occurred while subscribing the user to FCM: {$errorInfo}",
        "token-subscribe-no-token": "FCM returned no token when subscribing the user to push.",
        "token-unsubscribe-failed": "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
        "token-update-failed": "A problem occurred while updating the user from FCM: {$errorInfo}",
        "token-update-no-token": "FCM returned no token when updating the user to push.",
        "use-sw-after-get-token": "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
        "invalid-sw-registration": "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
        "invalid-bg-handler": "The input to setBackgroundMessageHandler() must be a function.",
        "invalid-vapid-key": "The public VAPID key must be a string.",
        "use-vapid-key-after-get-token": "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
    },
    fn = new Lp("messaging", "Messaging", ese);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function tse(t, e) {
    const n = await dx(t),
        r = Nk(e),
        i = {
            method: "POST",
            headers: n,
            body: JSON.stringify(r)
        };
    let s;
    try {
        s = await (await fetch(ux(t.appConfig), i)).json()
    } catch (o) {
        throw fn.create("token-subscribe-failed", {
            errorInfo: o == null ? void 0 : o.toString()
        })
    }
    if (s.error) {
        const o = s.error.message;
        throw fn.create("token-subscribe-failed", {
            errorInfo: o
        })
    }
    if (!s.token) throw fn.create("token-subscribe-no-token");
    return s.token
}
async function nse(t, e) {
    const n = await dx(t),
        r = Nk(e.subscriptionOptions),
        i = {
            method: "PATCH",
            headers: n,
            body: JSON.stringify(r)
        };
    let s;
    try {
        s = await (await fetch(`${ux(t.appConfig)}/${e.token}`, i)).json()
    } catch (o) {
        throw fn.create("token-update-failed", {
            errorInfo: o == null ? void 0 : o.toString()
        })
    }
    if (s.error) {
        const o = s.error.message;
        throw fn.create("token-update-failed", {
            errorInfo: o
        })
    }
    if (!s.token) throw fn.create("token-update-no-token");
    return s.token
}
async function rse(t, e) {
    const r = {
        method: "DELETE",
        headers: await dx(t)
    };
    try {
        const s = await (await fetch(`${ux(t.appConfig)}/${e}`, r)).json();
        if (s.error) {
            const o = s.error.message;
            throw fn.create("token-unsubscribe-failed", {
                errorInfo: o
            })
        }
    } catch (i) {
        throw fn.create("token-unsubscribe-failed", {
            errorInfo: i == null ? void 0 : i.toString()
        })
    }
}

function ux({
    projectId: t
}) {
    return `${zie}/projects/${t}/registrations`
}
async function dx({
    appConfig: t,
    installations: e
}) {
    const n = await e.getToken();
    return new Headers({
        "Content-Type": "application/json",
        Accept: "application/json",
        "x-goog-api-key": t.apiKey,
        "x-goog-firebase-installations-auth": `FIS ${n}`
    })
}

function Nk({
    p256dh: t,
    auth: e,
    endpoint: n,
    vapidKey: r
}) {
    const i = {
        web: {
            endpoint: n,
            auth: e,
            p256dh: t
        }
    };
    return r !== Dk && (i.web.applicationPubKey = r), i
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ise = 7 * 24 * 60 * 60 * 1e3;
async function sse(t) {
    const e = await ase(t.swRegistration, t.vapidKey),
        n = {
            vapidKey: t.vapidKey,
            swScope: t.swRegistration.scope,
            endpoint: e.endpoint,
            auth: wi(e.getKey("auth")),
            p256dh: wi(e.getKey("p256dh"))
        },
        r = await Qie(t.firebaseDependencies);
    if (r) {
        if (lse(r.subscriptionOptions, n)) return Date.now() >= r.createTime + ise ? ose(t, {
            token: r.token,
            createTime: Date.now(),
            subscriptionOptions: n
        }) : r.token;
        try {
            await rse(t.firebaseDependencies, r.token)
        } catch (i) {
            console.warn(i)
        }
        return rT(t.firebaseDependencies, n)
    } else return rT(t.firebaseDependencies, n)
}
async function ose(t, e) {
    try {
        const n = await nse(t.firebaseDependencies, e),
            r = Object.assign(Object.assign({}, e), {
                token: n,
                createTime: Date.now()
            });
        return await cx(t.firebaseDependencies, r), n
    } catch (n) {
        throw n
    }
}
async function rT(t, e) {
    const r = {
        token: await tse(t, e),
        createTime: Date.now(),
        subscriptionOptions: e
    };
    return await cx(t, r), r.token
}
async function ase(t, e) {
    const n = await t.pushManager.getSubscription();
    return n || t.pushManager.subscribe({
        userVisibleOnly: !0,
        applicationServerKey: Yie(e)
    })
}

function lse(t, e) {
    const n = e.vapidKey === t.vapidKey,
        r = e.endpoint === t.endpoint,
        i = e.auth === t.auth,
        s = e.p256dh === t.p256dh;
    return n && r && i && s
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function iT(t) {
    const e = {
        from: t.from,
        collapseKey: t.collapse_key,
        messageId: t.fcmMessageId
    };
    return cse(e, t), use(e, t), dse(e, t), e
}

function cse(t, e) {
    if (!e.notification) return;
    t.notification = {};
    const n = e.notification.title;
    n && (t.notification.title = n);
    const r = e.notification.body;
    r && (t.notification.body = r);
    const i = e.notification.image;
    i && (t.notification.image = i);
    const s = e.notification.icon;
    s && (t.notification.icon = s)
}

function use(t, e) {
    e.data && (t.data = e.data)
}

function dse(t, e) {
    var n, r, i, s, o;
    if (!e.fcmOptions && !(!((n = e.notification) === null || n === void 0) && n.click_action)) return;
    t.fcmOptions = {};
    const a = (i = (r = e.fcmOptions) === null || r === void 0 ? void 0 : r.link) !== null && i !== void 0 ? i : (s = e.notification) === null || s === void 0 ? void 0 : s.click_action;
    a && (t.fcmOptions.link = a);
    const l = (o = e.fcmOptions) === null || o === void 0 ? void 0 : o.analytics_label;
    l && (t.fcmOptions.analyticsLabel = l)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function fse(t) {
    return typeof t == "object" && !!t && $k in t
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
hse("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4");

function hse(t, e) {
    const n = [];
    for (let r = 0; r < t.length; r++) n.push(t.charAt(r)), r < e.length && n.push(e.charAt(r));
    return n.join("")
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function pse(t) {
    if (!t || !t.options) throw ng("App Configuration Object");
    if (!t.name) throw ng("App Name");
    const e = ["projectId", "apiKey", "appId", "messagingSenderId"],
        {
            options: n
        } = t;
    for (const r of e)
        if (!n[r]) throw ng(r);
    return {
        appName: t.name,
        projectId: n.projectId,
        apiKey: n.apiKey,
        appId: n.appId,
        senderId: n.messagingSenderId
    }
}

function ng(t) {
    return fn.create("missing-app-config-values", {
        valueName: t
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mse {
    constructor(e, n, r) {
        this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1;
        const i = pse(e);
        this.firebaseDependencies = {
            app: e,
            appConfig: i,
            installations: n,
            analyticsProvider: r
        }
    }
    _delete() {
        return Promise.resolve()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function gse(t) {
    try {
        t.swRegistration = await navigator.serviceWorker.register(Gie, {
            scope: Hie
        }), t.swRegistration.update().catch(() => {}), await vse(t.swRegistration)
    } catch (e) {
        throw fn.create("failed-service-worker-registration", {
            browserErrorMessage: e == null ? void 0 : e.message
        })
    }
}
async function vse(t) {
    return new Promise((e, n) => {
        const r = setTimeout(() => n(new Error(`Service worker not registered after ${eT} ms`)), eT),
            i = t.installing || t.waiting;
        t.active ? (clearTimeout(r), e()) : i ? i.onstatechange = s => {
            var o;
            ((o = s.target) === null || o === void 0 ? void 0 : o.state) === "activated" && (i.onstatechange = null, clearTimeout(r), e())
        } : (clearTimeout(r), n(new Error("No incoming service worker found.")))
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function yse(t, e) {
    if (!e && !t.swRegistration && await gse(t), !(!e && t.swRegistration)) {
        if (!(e instanceof ServiceWorkerRegistration)) throw fn.create("invalid-sw-registration");
        t.swRegistration = e
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _se(t, e) {
    e ? t.vapidKey = e : t.vapidKey || (t.vapidKey = Dk)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Uk(t, e) {
    if (!navigator) throw fn.create("only-available-in-window");
    if (Notification.permission === "default" && await Notification.requestPermission(), Notification.permission !== "granted") throw fn.create("permission-blocked");
    return await _se(t, e == null ? void 0 : e.vapidKey), await yse(t, e == null ? void 0 : e.serviceWorkerRegistration), sse(t)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function bse(t, e, n) {
    const r = xse(e);
    (await t.firebaseDependencies.analyticsProvider.get()).logEvent(r, {
        message_id: n[$k],
        message_name: n[jie],
        message_time: n[Vie],
        message_device_time: Math.floor(Date.now() / 1e3)
    })
}

function xse(t) {
    switch (t) {
        case bu.NOTIFICATION_CLICKED:
            return "notification_open";
        case bu.PUSH_RECEIVED:
            return "notification_foreground";
        default:
            throw new Error
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function wse(t, e) {
    const n = e.data;
    if (!n.isFirebaseMessaging) return;
    t.onMessageHandler && n.messageType === bu.PUSH_RECEIVED && (typeof t.onMessageHandler == "function" ? t.onMessageHandler(iT(n)) : t.onMessageHandler.next(iT(n)));
    const r = n.data;
    fse(r) && r[Wie] === "1" && await bse(t, n.messageType, r)
}
const sT = "@firebase/messaging",
    oT = "0.12.17";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ese = t => {
        const e = new mse(t.getProvider("app").getImmediate(), t.getProvider("installations-internal").getImmediate(), t.getProvider("analytics-internal"));
        return navigator.serviceWorker.addEventListener("message", n => wse(e, n)), e
    },
    Sse = t => {
        const e = t.getProvider("messaging").getImmediate();
        return {
            getToken: r => Uk(e, r)
        }
    };

function Tse() {
    Ko(new Ns("messaging", Ese, "PUBLIC")), Ko(new Ns("messaging-internal", Sse, "PRIVATE")), Os(sT, oT), Os(sT, oT, "esm2017")
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Cse() {
    try {
        await fk()
    } catch {
        return !1
    }
    return typeof window < "u" && dk() && Gne() && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey")
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Pse(t, e) {
    if (!navigator) throw fn.create("only-available-in-window");
    return t.onMessageHandler = e, () => {
        t.onMessageHandler = null
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function hbe(t = zre()) {
    return Cse().then(e => {
        if (!e) throw fn.create("unsupported-browser")
    }, e => {
        throw fn.create("indexed-db-unsupported")
    }), ix(nx(t), "messaging").getImmediate()
}
async function pbe(t, e) {
    return t = nx(t), Uk(t, e)
}

function mbe(t, e) {
    return t = nx(t), Pse(t, e)
}
Tse();
var nd = {},
    Ase = function() {
        return typeof Promise == "function" && Promise.prototype && Promise.prototype.then
    },
    Gk = {},
    nr = {};
let fx;
const Ose = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
nr.getSymbolSize = function(e) {
    if (!e) throw new Error('"version" cannot be null or undefined');
    if (e < 1 || e > 40) throw new Error('"version" should be in range from 1 to 40');
    return e * 4 + 17
};
nr.getSymbolTotalCodewords = function(e) {
    return Ose[e]
};
nr.getBCHDigit = function(t) {
    let e = 0;
    for (; t !== 0;) e++, t >>>= 1;
    return e
};
nr.setToSJISFunction = function(e) {
    if (typeof e != "function") throw new Error('"toSJISFunc" is not a valid function.');
    fx = e
};
nr.isKanjiModeEnabled = function() {
    return typeof fx < "u"
};
nr.toSJIS = function(e) {
    return fx(e)
};
var Hp = {};
(function(t) {
    t.L = {
        bit: 1
    }, t.M = {
        bit: 0
    }, t.Q = {
        bit: 3
    }, t.H = {
        bit: 2
    };

    function e(n) {
        if (typeof n != "string") throw new Error("Param is not a string");
        switch (n.toLowerCase()) {
            case "l":
            case "low":
                return t.L;
            case "m":
            case "medium":
                return t.M;
            case "q":
            case "quartile":
                return t.Q;
            case "h":
            case "high":
                return t.H;
            default:
                throw new Error("Unknown EC Level: " + n)
        }
    }
    t.isValid = function(r) {
        return r && typeof r.bit < "u" && r.bit >= 0 && r.bit < 4
    }, t.from = function(r, i) {
        if (t.isValid(r)) return r;
        try {
            return e(r)
        } catch {
            return i
        }
    }
})(Hp);

function Hk() {
    this.buffer = [], this.length = 0
}
Hk.prototype = {
    get: function(t) {
        const e = Math.floor(t / 8);
        return (this.buffer[e] >>> 7 - t % 8 & 1) === 1
    },
    put: function(t, e) {
        for (let n = 0; n < e; n++) this.putBit((t >>> e - n - 1 & 1) === 1)
    },
    getLengthInBits: function() {
        return this.length
    },
    putBit: function(t) {
        const e = Math.floor(this.length / 8);
        this.buffer.length <= e && this.buffer.push(0), t && (this.buffer[e] |= 128 >>> this.length % 8), this.length++
    }
};
var Ise = Hk;

function rd(t) {
    if (!t || t < 1) throw new Error("BitMatrix size must be defined and greater than 0");
    this.size = t, this.data = new Uint8Array(t * t), this.reservedBit = new Uint8Array(t * t)
}
rd.prototype.set = function(t, e, n, r) {
    const i = t * this.size + e;
    this.data[i] = n, r && (this.reservedBit[i] = !0)
};
rd.prototype.get = function(t, e) {
    return this.data[t * this.size + e]
};
rd.prototype.xor = function(t, e, n) {
    this.data[t * this.size + e] ^= n
};
rd.prototype.isReserved = function(t, e) {
    return this.reservedBit[t * this.size + e]
};
var Rse = rd,
    zk = {};
(function(t) {
    const e = nr.getSymbolSize;
    t.getRowColCoords = function(r) {
        if (r === 1) return [];
        const i = Math.floor(r / 7) + 2,
            s = e(r),
            o = s === 145 ? 26 : Math.ceil((s - 13) / (2 * i - 2)) * 2,
            a = [s - 7];
        for (let l = 1; l < i - 1; l++) a[l] = a[l - 1] - o;
        return a.push(6), a.reverse()
    }, t.getPositions = function(r) {
        const i = [],
            s = t.getRowColCoords(r),
            o = s.length;
        for (let a = 0; a < o; a++)
            for (let l = 0; l < o; l++) a === 0 && l === 0 || a === 0 && l === o - 1 || a === o - 1 && l === 0 || i.push([s[a], s[l]]);
        return i
    }
})(zk);
var jk = {};
const Mse = nr.getSymbolSize,
    aT = 7;
jk.getPositions = function(e) {
    const n = Mse(e);
    return [
        [0, 0],
        [n - aT, 0],
        [0, n - aT]
    ]
};
var Vk = {};
(function(t) {
    t.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
    };
    const e = {
        N1: 3,
        N2: 3,
        N3: 40,
        N4: 10
    };
    t.isValid = function(i) {
        return i != null && i !== "" && !isNaN(i) && i >= 0 && i <= 7
    }, t.from = function(i) {
        return t.isValid(i) ? parseInt(i, 10) : void 0
    }, t.getPenaltyN1 = function(i) {
        const s = i.size;
        let o = 0,
            a = 0,
            l = 0,
            c = null,
            u = null;
        for (let d = 0; d < s; d++) {
            a = l = 0, c = u = null;
            for (let f = 0; f < s; f++) {
                let h = i.get(d, f);
                h === c ? a++ : (a >= 5 && (o += e.N1 + (a - 5)), c = h, a = 1), h = i.get(f, d), h === u ? l++ : (l >= 5 && (o += e.N1 + (l - 5)), u = h, l = 1)
            }
            a >= 5 && (o += e.N1 + (a - 5)), l >= 5 && (o += e.N1 + (l - 5))
        }
        return o
    }, t.getPenaltyN2 = function(i) {
        const s = i.size;
        let o = 0;
        for (let a = 0; a < s - 1; a++)
            for (let l = 0; l < s - 1; l++) {
                const c = i.get(a, l) + i.get(a, l + 1) + i.get(a + 1, l) + i.get(a + 1, l + 1);
                (c === 4 || c === 0) && o++
            }
        return o * e.N2
    }, t.getPenaltyN3 = function(i) {
        const s = i.size;
        let o = 0,
            a = 0,
            l = 0;
        for (let c = 0; c < s; c++) {
            a = l = 0;
            for (let u = 0; u < s; u++) a = a << 1 & 2047 | i.get(c, u), u >= 10 && (a === 1488 || a === 93) && o++, l = l << 1 & 2047 | i.get(u, c), u >= 10 && (l === 1488 || l === 93) && o++
        }
        return o * e.N3
    }, t.getPenaltyN4 = function(i) {
        let s = 0;
        const o = i.data.length;
        for (let l = 0; l < o; l++) s += i.data[l];
        return Math.abs(Math.ceil(s * 100 / o / 5) - 10) * e.N4
    };

    function n(r, i, s) {
        switch (r) {
            case t.Patterns.PATTERN000:
                return (i + s) % 2 === 0;
            case t.Patterns.PATTERN001:
                return i % 2 === 0;
            case t.Patterns.PATTERN010:
                return s % 3 === 0;
            case t.Patterns.PATTERN011:
                return (i + s) % 3 === 0;
            case t.Patterns.PATTERN100:
                return (Math.floor(i / 2) + Math.floor(s / 3)) % 2 === 0;
            case t.Patterns.PATTERN101:
                return i * s % 2 + i * s % 3 === 0;
            case t.Patterns.PATTERN110:
                return (i * s % 2 + i * s % 3) % 2 === 0;
            case t.Patterns.PATTERN111:
                return (i * s % 3 + (i + s) % 2) % 2 === 0;
            default:
                throw new Error("bad maskPattern:" + r)
        }
    }
    t.applyMask = function(i, s) {
        const o = s.size;
        for (let a = 0; a < o; a++)
            for (let l = 0; l < o; l++) s.isReserved(l, a) || s.xor(l, a, n(i, l, a))
    }, t.getBestMask = function(i, s) {
        const o = Object.keys(t.Patterns).length;
        let a = 0,
            l = 1 / 0;
        for (let c = 0; c < o; c++) {
            s(c), t.applyMask(c, i);
            const u = t.getPenaltyN1(i) + t.getPenaltyN2(i) + t.getPenaltyN3(i) + t.getPenaltyN4(i);
            t.applyMask(c, i), u < l && (l = u, a = c)
        }
        return a
    }
})(Vk);
var zp = {};
const vs = Hp,
    Yd = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81],
    Xd = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
zp.getBlocksCount = function(e, n) {
    switch (n) {
        case vs.L:
            return Yd[(e - 1) * 4 + 0];
        case vs.M:
            return Yd[(e - 1) * 4 + 1];
        case vs.Q:
            return Yd[(e - 1) * 4 + 2];
        case vs.H:
            return Yd[(e - 1) * 4 + 3];
        default:
            return
    }
};
zp.getTotalCodewordsCount = function(e, n) {
    switch (n) {
        case vs.L:
            return Xd[(e - 1) * 4 + 0];
        case vs.M:
            return Xd[(e - 1) * 4 + 1];
        case vs.Q:
            return Xd[(e - 1) * 4 + 2];
        case vs.H:
            return Xd[(e - 1) * 4 + 3];
        default:
            return
    }
};
var Wk = {},
    jp = {};
const Fc = new Uint8Array(512),
    yh = new Uint8Array(256);
(function() {
    let e = 1;
    for (let n = 0; n < 255; n++) Fc[n] = e, yh[e] = n, e <<= 1, e & 256 && (e ^= 285);
    for (let n = 255; n < 512; n++) Fc[n] = Fc[n - 255]
})();
jp.log = function(e) {
    if (e < 1) throw new Error("log(" + e + ")");
    return yh[e]
};
jp.exp = function(e) {
    return Fc[e]
};
jp.mul = function(e, n) {
    return e === 0 || n === 0 ? 0 : Fc[yh[e] + yh[n]]
};
(function(t) {
    const e = jp;
    t.mul = function(r, i) {
        const s = new Uint8Array(r.length + i.length - 1);
        for (let o = 0; o < r.length; o++)
            for (let a = 0; a < i.length; a++) s[o + a] ^= e.mul(r[o], i[a]);
        return s
    }, t.mod = function(r, i) {
        let s = new Uint8Array(r);
        for (; s.length - i.length >= 0;) {
            const o = s[0];
            for (let l = 0; l < i.length; l++) s[l] ^= e.mul(i[l], o);
            let a = 0;
            for (; a < s.length && s[a] === 0;) a++;
            s = s.slice(a)
        }
        return s
    }, t.generateECPolynomial = function(r) {
        let i = new Uint8Array([1]);
        for (let s = 0; s < r; s++) i = t.mul(i, new Uint8Array([1, e.exp(s)]));
        return i
    }
})(Wk);
const Yk = Wk;

function hx(t) {
    this.genPoly = void 0, this.degree = t, this.degree && this.initialize(this.degree)
}
hx.prototype.initialize = function(e) {
    this.degree = e, this.genPoly = Yk.generateECPolynomial(this.degree)
};
hx.prototype.encode = function(e) {
    if (!this.genPoly) throw new Error("Encoder not initialized");
    const n = new Uint8Array(e.length + this.degree);
    n.set(e);
    const r = Yk.mod(n, this.genPoly),
        i = this.degree - r.length;
    if (i > 0) {
        const s = new Uint8Array(this.degree);
        return s.set(r, i), s
    }
    return r
};
var kse = hx,
    Xk = {},
    qs = {},
    px = {};
px.isValid = function(e) {
    return !isNaN(e) && e >= 1 && e <= 40
};
var ui = {};
const Kk = "[0-9]+",
    Bse = "[A-Z $%*+\\-./:]+";
let wu = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
wu = wu.replace(/u/g, "\\u");
const Dse = "(?:(?![A-Z0-9 $%*+\\-./:]|" + wu + `)(?:.|[\r
]))+`;
ui.KANJI = new RegExp(wu, "g");
ui.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
ui.BYTE = new RegExp(Dse, "g");
ui.NUMERIC = new RegExp(Kk, "g");
ui.ALPHANUMERIC = new RegExp(Bse, "g");
const $se = new RegExp("^" + wu + "$"),
    Fse = new RegExp("^" + Kk + "$"),
    Lse = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
ui.testKanji = function(e) {
    return $se.test(e)
};
ui.testNumeric = function(e) {
    return Fse.test(e)
};
ui.testAlphanumeric = function(e) {
    return Lse.test(e)
};
(function(t) {
    const e = px,
        n = ui;
    t.NUMERIC = {
        id: "Numeric",
        bit: 1,
        ccBits: [10, 12, 14]
    }, t.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 2,
        ccBits: [9, 11, 13]
    }, t.BYTE = {
        id: "Byte",
        bit: 4,
        ccBits: [8, 16, 16]
    }, t.KANJI = {
        id: "Kanji",
        bit: 8,
        ccBits: [8, 10, 12]
    }, t.MIXED = {
        bit: -1
    }, t.getCharCountIndicator = function(s, o) {
        if (!s.ccBits) throw new Error("Invalid mode: " + s);
        if (!e.isValid(o)) throw new Error("Invalid version: " + o);
        return o >= 1 && o < 10 ? s.ccBits[0] : o < 27 ? s.ccBits[1] : s.ccBits[2]
    }, t.getBestModeForData = function(s) {
        return n.testNumeric(s) ? t.NUMERIC : n.testAlphanumeric(s) ? t.ALPHANUMERIC : n.testKanji(s) ? t.KANJI : t.BYTE
    }, t.toString = function(s) {
        if (s && s.id) return s.id;
        throw new Error("Invalid mode")
    }, t.isValid = function(s) {
        return s && s.bit && s.ccBits
    };

    function r(i) {
        if (typeof i != "string") throw new Error("Param is not a string");
        switch (i.toLowerCase()) {
            case "numeric":
                return t.NUMERIC;
            case "alphanumeric":
                return t.ALPHANUMERIC;
            case "kanji":
                return t.KANJI;
            case "byte":
                return t.BYTE;
            default:
                throw new Error("Unknown mode: " + i)
        }
    }
    t.from = function(s, o) {
        if (t.isValid(s)) return s;
        try {
            return r(s)
        } catch {
            return o
        }
    }
})(qs);
(function(t) {
    const e = nr,
        n = zp,
        r = Hp,
        i = qs,
        s = px,
        o = 7973,
        a = e.getBCHDigit(o);

    function l(f, h, p) {
        for (let b = 1; b <= 40; b++)
            if (h <= t.getCapacity(b, p, f)) return b
    }

    function c(f, h) {
        return i.getCharCountIndicator(f, h) + 4
    }

    function u(f, h) {
        let p = 0;
        return f.forEach(function(b) {
            const y = c(b.mode, h);
            p += y + b.getBitsLength()
        }), p
    }

    function d(f, h) {
        for (let p = 1; p <= 40; p++)
            if (u(f, p) <= t.getCapacity(p, h, i.MIXED)) return p
    }
    t.from = function(h, p) {
        return s.isValid(h) ? parseInt(h, 10) : p
    }, t.getCapacity = function(h, p, b) {
        if (!s.isValid(h)) throw new Error("Invalid QR Code version");
        typeof b > "u" && (b = i.BYTE);
        const y = e.getSymbolTotalCodewords(h),
            m = n.getTotalCodewordsCount(h, p),
            g = (y - m) * 8;
        if (b === i.MIXED) return g;
        const v = g - c(b, h);
        switch (b) {
            case i.NUMERIC:
                return Math.floor(v / 10 * 3);
            case i.ALPHANUMERIC:
                return Math.floor(v / 11 * 2);
            case i.KANJI:
                return Math.floor(v / 13);
            case i.BYTE:
            default:
                return Math.floor(v / 8)
        }
    }, t.getBestVersionForData = function(h, p) {
        let b;
        const y = r.from(p, r.M);
        if (Array.isArray(h)) {
            if (h.length > 1) return d(h, y);
            if (h.length === 0) return 1;
            b = h[0]
        } else b = h;
        return l(b.mode, b.getLength(), y)
    }, t.getEncodedBits = function(h) {
        if (!s.isValid(h) || h < 7) throw new Error("Invalid QR Code version");
        let p = h << 12;
        for (; e.getBCHDigit(p) - a >= 0;) p ^= o << e.getBCHDigit(p) - a;
        return h << 12 | p
    }
})(Xk);
var qk = {};
const n0 = nr,
    Jk = 1335,
    Nse = 21522,
    lT = n0.getBCHDigit(Jk);
qk.getEncodedBits = function(e, n) {
    const r = e.bit << 3 | n;
    let i = r << 10;
    for (; n0.getBCHDigit(i) - lT >= 0;) i ^= Jk << n0.getBCHDigit(i) - lT;
    return (r << 10 | i) ^ Nse
};
var Zk = {};
const Use = qs;

function pl(t) {
    this.mode = Use.NUMERIC, this.data = t.toString()
}
pl.getBitsLength = function(e) {
    return 10 * Math.floor(e / 3) + (e % 3 ? e % 3 * 3 + 1 : 0)
};
pl.prototype.getLength = function() {
    return this.data.length
};
pl.prototype.getBitsLength = function() {
    return pl.getBitsLength(this.data.length)
};
pl.prototype.write = function(e) {
    let n, r, i;
    for (n = 0; n + 3 <= this.data.length; n += 3) r = this.data.substr(n, 3), i = parseInt(r, 10), e.put(i, 10);
    const s = this.data.length - n;
    s > 0 && (r = this.data.substr(n), i = parseInt(r, 10), e.put(i, s * 3 + 1))
};
var Gse = pl;
const Hse = qs,
    rg = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];

function ml(t) {
    this.mode = Hse.ALPHANUMERIC, this.data = t
}
ml.getBitsLength = function(e) {
    return 11 * Math.floor(e / 2) + 6 * (e % 2)
};
ml.prototype.getLength = function() {
    return this.data.length
};
ml.prototype.getBitsLength = function() {
    return ml.getBitsLength(this.data.length)
};
ml.prototype.write = function(e) {
    let n;
    for (n = 0; n + 2 <= this.data.length; n += 2) {
        let r = rg.indexOf(this.data[n]) * 45;
        r += rg.indexOf(this.data[n + 1]), e.put(r, 11)
    }
    this.data.length % 2 && e.put(rg.indexOf(this.data[n]), 6)
};
var zse = ml;
const jse = qs;

function gl(t) {
    this.mode = jse.BYTE, typeof t == "string" ? this.data = new TextEncoder().encode(t) : this.data = new Uint8Array(t)
}
gl.getBitsLength = function(e) {
    return e * 8
};
gl.prototype.getLength = function() {
    return this.data.length
};
gl.prototype.getBitsLength = function() {
    return gl.getBitsLength(this.data.length)
};
gl.prototype.write = function(t) {
    for (let e = 0, n = this.data.length; e < n; e++) t.put(this.data[e], 8)
};
var Vse = gl;
const Wse = qs,
    Yse = nr;

function vl(t) {
    this.mode = Wse.KANJI, this.data = t
}
vl.getBitsLength = function(e) {
    return e * 13
};
vl.prototype.getLength = function() {
    return this.data.length
};
vl.prototype.getBitsLength = function() {
    return vl.getBitsLength(this.data.length)
};
vl.prototype.write = function(t) {
    let e;
    for (e = 0; e < this.data.length; e++) {
        let n = Yse.toSJIS(this.data[e]);
        if (n >= 33088 && n <= 40956) n -= 33088;
        else if (n >= 57408 && n <= 60351) n -= 49472;
        else throw new Error("Invalid SJIS character: " + this.data[e] + `
Make sure your charset is UTF-8`);
        n = (n >>> 8 & 255) * 192 + (n & 255), t.put(n, 13)
    }
};
var Xse = vl,
    Qk = {
        exports: {}
    };
(function(t) {
    var e = {
        single_source_shortest_paths: function(n, r, i) {
            var s = {},
                o = {};
            o[r] = 0;
            var a = e.PriorityQueue.make();
            a.push(r, 0);
            for (var l, c, u, d, f, h, p, b, y; !a.empty();) {
                l = a.pop(), c = l.value, d = l.cost, f = n[c] || {};
                for (u in f) f.hasOwnProperty(u) && (h = f[u], p = d + h, b = o[u], y = typeof o[u] > "u", (y || b > p) && (o[u] = p, a.push(u, p), s[u] = c))
            }
            if (typeof i < "u" && typeof o[i] > "u") {
                var m = ["Could not find a path from ", r, " to ", i, "."].join("");
                throw new Error(m)
            }
            return s
        },
        extract_shortest_path_from_predecessor_list: function(n, r) {
            for (var i = [], s = r; s;) i.push(s), n[s], s = n[s];
            return i.reverse(), i
        },
        find_path: function(n, r, i) {
            var s = e.single_source_shortest_paths(n, r, i);
            return e.extract_shortest_path_from_predecessor_list(s, i)
        },
        PriorityQueue: {
            make: function(n) {
                var r = e.PriorityQueue,
                    i = {},
                    s;
                n = n || {};
                for (s in r) r.hasOwnProperty(s) && (i[s] = r[s]);
                return i.queue = [], i.sorter = n.sorter || r.default_sorter, i
            },
            default_sorter: function(n, r) {
                return n.cost - r.cost
            },
            push: function(n, r) {
                var i = {
                    value: n,
                    cost: r
                };
                this.queue.push(i), this.queue.sort(this.sorter)
            },
            pop: function() {
                return this.queue.shift()
            },
            empty: function() {
                return this.queue.length === 0
            }
        }
    };
    t.exports = e
})(Qk);
var Kse = Qk.exports;
(function(t) {
    const e = qs,
        n = Gse,
        r = zse,
        i = Vse,
        s = Xse,
        o = ui,
        a = nr,
        l = Kse;

    function c(m) {
        return unescape(encodeURIComponent(m)).length
    }

    function u(m, g, v) {
        const _ = [];
        let x;
        for (;
            (x = m.exec(v)) !== null;) _.push({
            data: x[0],
            index: x.index,
            mode: g,
            length: x[0].length
        });
        return _
    }

    function d(m) {
        const g = u(o.NUMERIC, e.NUMERIC, m),
            v = u(o.ALPHANUMERIC, e.ALPHANUMERIC, m);
        let _, x;
        return a.isKanjiModeEnabled() ? (_ = u(o.BYTE, e.BYTE, m), x = u(o.KANJI, e.KANJI, m)) : (_ = u(o.BYTE_KANJI, e.BYTE, m), x = []), g.concat(v, _, x).sort(function(S, C) {
            return S.index - C.index
        }).map(function(S) {
            return {
                data: S.data,
                mode: S.mode,
                length: S.length
            }
        })
    }

    function f(m, g) {
        switch (g) {
            case e.NUMERIC:
                return n.getBitsLength(m);
            case e.ALPHANUMERIC:
                return r.getBitsLength(m);
            case e.KANJI:
                return s.getBitsLength(m);
            case e.BYTE:
                return i.getBitsLength(m)
        }
    }

    function h(m) {
        return m.reduce(function(g, v) {
            const _ = g.length - 1 >= 0 ? g[g.length - 1] : null;
            return _ && _.mode === v.mode ? (g[g.length - 1].data += v.data, g) : (g.push(v), g)
        }, [])
    }

    function p(m) {
        const g = [];
        for (let v = 0; v < m.length; v++) {
            const _ = m[v];
            switch (_.mode) {
                case e.NUMERIC:
                    g.push([_, {
                        data: _.data,
                        mode: e.ALPHANUMERIC,
                        length: _.length
                    }, {
                        data: _.data,
                        mode: e.BYTE,
                        length: _.length
                    }]);
                    break;
                case e.ALPHANUMERIC:
                    g.push([_, {
                        data: _.data,
                        mode: e.BYTE,
                        length: _.length
                    }]);
                    break;
                case e.KANJI:
                    g.push([_, {
                        data: _.data,
                        mode: e.BYTE,
                        length: c(_.data)
                    }]);
                    break;
                case e.BYTE:
                    g.push([{
                        data: _.data,
                        mode: e.BYTE,
                        length: c(_.data)
                    }])
            }
        }
        return g
    }

    function b(m, g) {
        const v = {},
            _ = {
                start: {}
            };
        let x = ["start"];
        for (let w = 0; w < m.length; w++) {
            const S = m[w],
                C = [];
            for (let A = 0; A < S.length; A++) {
                const T = S[A],
                    E = "" + w + A;
                C.push(E), v[E] = {
                    node: T,
                    lastCount: 0
                }, _[E] = {};
                for (let P = 0; P < x.length; P++) {
                    const B = x[P];
                    v[B] && v[B].node.mode === T.mode ? (_[B][E] = f(v[B].lastCount + T.length, T.mode) - f(v[B].lastCount, T.mode), v[B].lastCount += T.length) : (v[B] && (v[B].lastCount = T.length), _[B][E] = f(T.length, T.mode) + 4 + e.getCharCountIndicator(T.mode, g))
                }
            }
            x = C
        }
        for (let w = 0; w < x.length; w++) _[x[w]].end = 0;
        return {
            map: _,
            table: v
        }
    }

    function y(m, g) {
        let v;
        const _ = e.getBestModeForData(m);
        if (v = e.from(g, _), v !== e.BYTE && v.bit < _.bit) throw new Error('"' + m + '" cannot be encoded with mode ' + e.toString(v) + `.
 Suggested mode is: ` + e.toString(_));
        switch (v === e.KANJI && !a.isKanjiModeEnabled() && (v = e.BYTE), v) {
            case e.NUMERIC:
                return new n(m);
            case e.ALPHANUMERIC:
                return new r(m);
            case e.KANJI:
                return new s(m);
            case e.BYTE:
                return new i(m)
        }
    }
    t.fromArray = function(g) {
        return g.reduce(function(v, _) {
            return typeof _ == "string" ? v.push(y(_, null)) : _.data && v.push(y(_.data, _.mode)), v
        }, [])
    }, t.fromString = function(g, v) {
        const _ = d(g, a.isKanjiModeEnabled()),
            x = p(_),
            w = b(x, v),
            S = l.find_path(w.map, "start", "end"),
            C = [];
        for (let A = 1; A < S.length - 1; A++) C.push(w.table[S[A]].node);
        return t.fromArray(h(C))
    }, t.rawSplit = function(g) {
        return t.fromArray(d(g, a.isKanjiModeEnabled()))
    }
})(Zk);
const Vp = nr,
    ig = Hp,
    qse = Ise,
    Jse = Rse,
    Zse = zk,
    Qse = jk,
    r0 = Vk,
    i0 = zp,
    eoe = kse,
    _h = Xk,
    toe = qk,
    noe = qs,
    sg = Zk;

function roe(t, e) {
    const n = t.size,
        r = Qse.getPositions(e);
    for (let i = 0; i < r.length; i++) {
        const s = r[i][0],
            o = r[i][1];
        for (let a = -1; a <= 7; a++)
            if (!(s + a <= -1 || n <= s + a))
                for (let l = -1; l <= 7; l++) o + l <= -1 || n <= o + l || (a >= 0 && a <= 6 && (l === 0 || l === 6) || l >= 0 && l <= 6 && (a === 0 || a === 6) || a >= 2 && a <= 4 && l >= 2 && l <= 4 ? t.set(s + a, o + l, !0, !0) : t.set(s + a, o + l, !1, !0))
    }
}

function ioe(t) {
    const e = t.size;
    for (let n = 8; n < e - 8; n++) {
        const r = n % 2 === 0;
        t.set(n, 6, r, !0), t.set(6, n, r, !0)
    }
}

function soe(t, e) {
    const n = Zse.getPositions(e);
    for (let r = 0; r < n.length; r++) {
        const i = n[r][0],
            s = n[r][1];
        for (let o = -2; o <= 2; o++)
            for (let a = -2; a <= 2; a++) o === -2 || o === 2 || a === -2 || a === 2 || o === 0 && a === 0 ? t.set(i + o, s + a, !0, !0) : t.set(i + o, s + a, !1, !0)
    }
}

function ooe(t, e) {
    const n = t.size,
        r = _h.getEncodedBits(e);
    let i, s, o;
    for (let a = 0; a < 18; a++) i = Math.floor(a / 3), s = a % 3 + n - 8 - 3, o = (r >> a & 1) === 1, t.set(i, s, o, !0), t.set(s, i, o, !0)
}

function og(t, e, n) {
    const r = t.size,
        i = toe.getEncodedBits(e, n);
    let s, o;
    for (s = 0; s < 15; s++) o = (i >> s & 1) === 1, s < 6 ? t.set(s, 8, o, !0) : s < 8 ? t.set(s + 1, 8, o, !0) : t.set(r - 15 + s, 8, o, !0), s < 8 ? t.set(8, r - s - 1, o, !0) : s < 9 ? t.set(8, 15 - s - 1 + 1, o, !0) : t.set(8, 15 - s - 1, o, !0);
    t.set(r - 8, 8, 1, !0)
}

function aoe(t, e) {
    const n = t.size;
    let r = -1,
        i = n - 1,
        s = 7,
        o = 0;
    for (let a = n - 1; a > 0; a -= 2)
        for (a === 6 && a--;;) {
            for (let l = 0; l < 2; l++)
                if (!t.isReserved(i, a - l)) {
                    let c = !1;
                    o < e.length && (c = (e[o] >>> s & 1) === 1), t.set(i, a - l, c), s--, s === -1 && (o++, s = 7)
                }
            if (i += r, i < 0 || n <= i) {
                i -= r, r = -r;
                break
            }
        }
}

function loe(t, e, n) {
    const r = new qse;
    n.forEach(function(l) {
        r.put(l.mode.bit, 4), r.put(l.getLength(), noe.getCharCountIndicator(l.mode, t)), l.write(r)
    });
    const i = Vp.getSymbolTotalCodewords(t),
        s = i0.getTotalCodewordsCount(t, e),
        o = (i - s) * 8;
    for (r.getLengthInBits() + 4 <= o && r.put(0, 4); r.getLengthInBits() % 8 !== 0;) r.putBit(0);
    const a = (o - r.getLengthInBits()) / 8;
    for (let l = 0; l < a; l++) r.put(l % 2 ? 17 : 236, 8);
    return coe(r, t, e)
}

function coe(t, e, n) {
    const r = Vp.getSymbolTotalCodewords(e),
        i = i0.getTotalCodewordsCount(e, n),
        s = r - i,
        o = i0.getBlocksCount(e, n),
        a = r % o,
        l = o - a,
        c = Math.floor(r / o),
        u = Math.floor(s / o),
        d = u + 1,
        f = c - u,
        h = new eoe(f);
    let p = 0;
    const b = new Array(o),
        y = new Array(o);
    let m = 0;
    const g = new Uint8Array(t.buffer);
    for (let S = 0; S < o; S++) {
        const C = S < l ? u : d;
        b[S] = g.slice(p, p + C), y[S] = h.encode(b[S]), p += C, m = Math.max(m, C)
    }
    const v = new Uint8Array(r);
    let _ = 0,
        x, w;
    for (x = 0; x < m; x++)
        for (w = 0; w < o; w++) x < b[w].length && (v[_++] = b[w][x]);
    for (x = 0; x < f; x++)
        for (w = 0; w < o; w++) v[_++] = y[w][x];
    return v
}

function uoe(t, e, n, r) {
    let i;
    if (Array.isArray(t)) i = sg.fromArray(t);
    else if (typeof t == "string") {
        let c = e;
        if (!c) {
            const u = sg.rawSplit(t);
            c = _h.getBestVersionForData(u, n)
        }
        i = sg.fromString(t, c || 40)
    } else throw new Error("Invalid data");
    const s = _h.getBestVersionForData(i, n);
    if (!s) throw new Error("The amount of data is too big to be stored in a QR Code");
    if (!e) e = s;
    else if (e < s) throw new Error(`
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + s + `.
`);
    const o = loe(e, n, i),
        a = Vp.getSymbolSize(e),
        l = new Jse(a);
    return roe(l, e), ioe(l), soe(l, e), og(l, n, 0), e >= 7 && ooe(l, e), aoe(l, o), isNaN(r) && (r = r0.getBestMask(l, og.bind(null, l, n))), r0.applyMask(r, l), og(l, n, r), {
        modules: l,
        version: e,
        errorCorrectionLevel: n,
        maskPattern: r,
        segments: i
    }
}
Gk.create = function(e, n) {
    if (typeof e > "u" || e === "") throw new Error("No input text");
    let r = ig.M,
        i, s;
    return typeof n < "u" && (r = ig.from(n.errorCorrectionLevel, ig.M), i = _h.from(n.version), s = r0.from(n.maskPattern), n.toSJISFunc && Vp.setToSJISFunction(n.toSJISFunc)), uoe(e, i, r, s)
};
var eB = {},
    mx = {};
(function(t) {
    function e(n) {
        if (typeof n == "number" && (n = n.toString()), typeof n != "string") throw new Error("Color should be defined as hex string");
        let r = n.slice().replace("#", "").split("");
        if (r.length < 3 || r.length === 5 || r.length > 8) throw new Error("Invalid hex color: " + n);
        (r.length === 3 || r.length === 4) && (r = Array.prototype.concat.apply([], r.map(function(s) {
            return [s, s]
        }))), r.length === 6 && r.push("F", "F");
        const i = parseInt(r.join(""), 16);
        return {
            r: i >> 24 & 255,
            g: i >> 16 & 255,
            b: i >> 8 & 255,
            a: i & 255,
            hex: "#" + r.slice(0, 6).join("")
        }
    }
    t.getOptions = function(r) {
        r || (r = {}), r.color || (r.color = {});
        const i = typeof r.margin > "u" || r.margin === null || r.margin < 0 ? 4 : r.margin,
            s = r.width && r.width >= 21 ? r.width : void 0,
            o = r.scale || 4;
        return {
            width: s,
            scale: s ? 4 : o,
            margin: i,
            color: {
                dark: e(r.color.dark || "#000000ff"),
                light: e(r.color.light || "#ffffffff")
            },
            type: r.type,
            rendererOpts: r.rendererOpts || {}
        }
    }, t.getScale = function(r, i) {
        return i.width && i.width >= r + i.margin * 2 ? i.width / (r + i.margin * 2) : i.scale
    }, t.getImageWidth = function(r, i) {
        const s = t.getScale(r, i);
        return Math.floor((r + i.margin * 2) * s)
    }, t.qrToImageData = function(r, i, s) {
        const o = i.modules.size,
            a = i.modules.data,
            l = t.getScale(o, s),
            c = Math.floor((o + s.margin * 2) * l),
            u = s.margin * l,
            d = [s.color.light, s.color.dark];
        for (let f = 0; f < c; f++)
            for (let h = 0; h < c; h++) {
                let p = (f * c + h) * 4,
                    b = s.color.light;
                if (f >= u && h >= u && f < c - u && h < c - u) {
                    const y = Math.floor((f - u) / l),
                        m = Math.floor((h - u) / l);
                    b = d[a[y * o + m] ? 1 : 0]
                }
                r[p++] = b.r, r[p++] = b.g, r[p++] = b.b, r[p] = b.a
            }
    }
})(mx);
(function(t) {
    const e = mx;

    function n(i, s, o) {
        i.clearRect(0, 0, s.width, s.height), s.style || (s.style = {}), s.height = o, s.width = o, s.style.height = o + "px", s.style.width = o + "px"
    }

    function r() {
        try {
            return document.createElement("canvas")
        } catch {
            throw new Error("You need to specify a canvas element")
        }
    }
    t.render = function(s, o, a) {
        let l = a,
            c = o;
        typeof l > "u" && (!o || !o.getContext) && (l = o, o = void 0), o || (c = r()), l = e.getOptions(l);
        const u = e.getImageWidth(s.modules.size, l),
            d = c.getContext("2d"),
            f = d.createImageData(u, u);
        return e.qrToImageData(f.data, s, l), n(d, c, u), d.putImageData(f, 0, 0), c
    }, t.renderToDataURL = function(s, o, a) {
        let l = a;
        typeof l > "u" && (!o || !o.getContext) && (l = o, o = void 0), l || (l = {});
        const c = t.render(s, o, l),
            u = l.type || "image/png",
            d = l.rendererOpts || {};
        return c.toDataURL(u, d.quality)
    }
})(eB);
var tB = {};
const doe = mx;

function cT(t, e) {
    const n = t.a / 255,
        r = e + '="' + t.hex + '"';
    return n < 1 ? r + " " + e + '-opacity="' + n.toFixed(2).slice(1) + '"' : r
}

function ag(t, e, n) {
    let r = t + e;
    return typeof n < "u" && (r += " " + n), r
}

function foe(t, e, n) {
    let r = "",
        i = 0,
        s = !1,
        o = 0;
    for (let a = 0; a < t.length; a++) {
        const l = Math.floor(a % e),
            c = Math.floor(a / e);
        !l && !s && (s = !0), t[a] ? (o++, a > 0 && l > 0 && t[a - 1] || (r += s ? ag("M", l + n, .5 + c + n) : ag("m", i, 0), i = 0, s = !1), l + 1 < e && t[a + 1] || (r += ag("h", o), o = 0)) : i++
    }
    return r
}
tB.render = function(e, n, r) {
    const i = doe.getOptions(n),
        s = e.modules.size,
        o = e.modules.data,
        a = s + i.margin * 2,
        l = i.color.light.a ? "<path " + cT(i.color.light, "fill") + ' d="M0 0h' + a + "v" + a + 'H0z"/>' : "",
        c = "<path " + cT(i.color.dark, "stroke") + ' d="' + foe(o, s, i.margin) + '"/>',
        u = 'viewBox="0 0 ' + a + " " + a + '"',
        f = '<svg xmlns="http://www.w3.org/2000/svg" ' + (i.width ? 'width="' + i.width + '" height="' + i.width + '" ' : "") + u + ' shape-rendering="crispEdges">' + l + c + `</svg>
`;
    return typeof r == "function" && r(null, f), f
};
const hoe = Ase,
    s0 = Gk,
    nB = eB,
    poe = tB;

function gx(t, e, n, r, i) {
    const s = [].slice.call(arguments, 1),
        o = s.length,
        a = typeof s[o - 1] == "function";
    if (!a && !hoe()) throw new Error("Callback required as last argument");
    if (a) {
        if (o < 2) throw new Error("Too few arguments provided");
        o === 2 ? (i = n, n = e, e = r = void 0) : o === 3 && (e.getContext && typeof i > "u" ? (i = r, r = void 0) : (i = r, r = n, n = e, e = void 0))
    } else {
        if (o < 1) throw new Error("Too few arguments provided");
        return o === 1 ? (n = e, e = r = void 0) : o === 2 && !e.getContext && (r = n, n = e, e = void 0), new Promise(function(l, c) {
            try {
                const u = s0.create(n, r);
                l(t(u, e, r))
            } catch (u) {
                c(u)
            }
        })
    }
    try {
        const l = s0.create(n, r);
        i(null, t(l, e, r))
    } catch (l) {
        i(l)
    }
}
nd.create = s0.create;
nd.toCanvas = gx.bind(null, nB.render);
nd.toDataURL = gx.bind(null, nB.renderToDataURL);
nd.toString = gx.bind(null, function(t, e, n) {
    return poe.render(t, n)
});

function gbe(t, e) {
    const n = fM(t),
        r = J("");
    return pe(n, async i => {
        n.value && Fs && (r.value = await nd.toDataURL(i, e))
    }, {
        immediate: !0
    }), r
}

function uT(t) {
    return t !== null && typeof t == "object" && "constructor" in t && t.constructor === Object
}

function vx(t = {}, e = {}) {
    Object.keys(e).forEach(n => {
        typeof t[n] > "u" ? t[n] = e[n] : uT(e[n]) && uT(t[n]) && Object.keys(e[n]).length > 0 && vx(t[n], e[n])
    })
}
const rB = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector() {
        return null
    },
    querySelectorAll() {
        return []
    },
    getElementById() {
        return null
    },
    createEvent() {
        return {
            initEvent() {}
        }
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName() {
                return []
            }
        }
    },
    createElementNS() {
        return {}
    },
    importNode() {
        return null
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};

function hn() {
    const t = typeof document < "u" ? document : {};
    return vx(t, rB), t
}
const moe = {
    document: rB,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function() {
        return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
        return {
            getPropertyValue() {
                return ""
            }
        }
    },
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia() {
        return {}
    },
    requestAnimationFrame(t) {
        return typeof setTimeout > "u" ? (t(), null) : setTimeout(t, 0)
    },
    cancelAnimationFrame(t) {
        typeof setTimeout > "u" || clearTimeout(t)
    }
};

function en() {
    const t = typeof window < "u" ? window : {};
    return vx(t, moe), t
}

function goe(t) {
    const e = t.__proto__;
    Object.defineProperty(t, "__proto__", {
        get() {
            return e
        },
        set(n) {
            e.__proto__ = n
        }
    })
}
class ys extends Array {
    constructor(e) {
        typeof e == "number" ? super(e) : (super(...e || []), goe(this))
    }
}

function id(t = []) {
    const e = [];
    return t.forEach(n => {
        Array.isArray(n) ? e.push(...id(n)) : e.push(n)
    }), e
}

function iB(t, e) {
    return Array.prototype.filter.call(t, e)
}

function voe(t) {
    const e = [];
    for (let n = 0; n < t.length; n += 1) e.indexOf(t[n]) === -1 && e.push(t[n]);
    return e
}

function yoe(t, e) {
    if (typeof t != "string") return [t];
    const n = [],
        r = e.querySelectorAll(t);
    for (let i = 0; i < r.length; i += 1) n.push(r[i]);
    return n
}

function Se(t, e) {
    const n = en(),
        r = hn();
    let i = [];
    if (!e && t instanceof ys) return t;
    if (!t) return new ys(i);
    if (typeof t == "string") {
        const s = t.trim();
        if (s.indexOf("<") >= 0 && s.indexOf(">") >= 0) {
            let o = "div";
            s.indexOf("<li") === 0 && (o = "ul"), s.indexOf("<tr") === 0 && (o = "tbody"), (s.indexOf("<td") === 0 || s.indexOf("<th") === 0) && (o = "tr"), s.indexOf("<tbody") === 0 && (o = "table"), s.indexOf("<option") === 0 && (o = "select");
            const a = r.createElement(o);
            a.innerHTML = s;
            for (let l = 0; l < a.childNodes.length; l += 1) i.push(a.childNodes[l])
        } else i = yoe(t.trim(), e || r)
    } else if (t.nodeType || t === n || t === r) i.push(t);
    else if (Array.isArray(t)) {
        if (t instanceof ys) return t;
        i = t
    }
    return new ys(voe(i))
}
Se.fn = ys.prototype;

function _oe(...t) {
    const e = id(t.map(n => n.split(" ")));
    return this.forEach(n => {
        n.classList.add(...e)
    }), this
}

function boe(...t) {
    const e = id(t.map(n => n.split(" ")));
    return this.forEach(n => {
        n.classList.remove(...e)
    }), this
}

function xoe(...t) {
    const e = id(t.map(n => n.split(" ")));
    this.forEach(n => {
        e.forEach(r => {
            n.classList.toggle(r)
        })
    })
}

function woe(...t) {
    const e = id(t.map(n => n.split(" ")));
    return iB(this, n => e.filter(r => n.classList.contains(r)).length > 0).length > 0
}

function Eoe(t, e) {
    if (arguments.length === 1 && typeof t == "string") return this[0] ? this[0].getAttribute(t) : void 0;
    for (let n = 0; n < this.length; n += 1)
        if (arguments.length === 2) this[n].setAttribute(t, e);
        else
            for (const r in t) this[n][r] = t[r], this[n].setAttribute(r, t[r]);
    return this
}

function Soe(t) {
    for (let e = 0; e < this.length; e += 1) this[e].removeAttribute(t);
    return this
}

function Toe(t) {
    for (let e = 0; e < this.length; e += 1) this[e].style.transform = t;
    return this
}

function Coe(t) {
    for (let e = 0; e < this.length; e += 1) this[e].style.transitionDuration = typeof t != "string" ? `${t}ms` : t;
    return this
}

function Poe(...t) {
    let [e, n, r, i] = t;
    typeof t[1] == "function" && ([e, r, i] = t, n = void 0), i || (i = !1);

    function s(c) {
        const u = c.target;
        if (!u) return;
        const d = c.target.dom7EventData || [];
        if (d.indexOf(c) < 0 && d.unshift(c), Se(u).is(n)) r.apply(u, d);
        else {
            const f = Se(u).parents();
            for (let h = 0; h < f.length; h += 1) Se(f[h]).is(n) && r.apply(f[h], d)
        }
    }

    function o(c) {
        const u = c && c.target ? c.target.dom7EventData || [] : [];
        u.indexOf(c) < 0 && u.unshift(c), r.apply(this, u)
    }
    const a = e.split(" ");
    let l;
    for (let c = 0; c < this.length; c += 1) {
        const u = this[c];
        if (n)
            for (l = 0; l < a.length; l += 1) {
                const d = a[l];
                u.dom7LiveListeners || (u.dom7LiveListeners = {}), u.dom7LiveListeners[d] || (u.dom7LiveListeners[d] = []), u.dom7LiveListeners[d].push({
                    listener: r,
                    proxyListener: s
                }), u.addEventListener(d, s, i)
            } else
                for (l = 0; l < a.length; l += 1) {
                    const d = a[l];
                    u.dom7Listeners || (u.dom7Listeners = {}), u.dom7Listeners[d] || (u.dom7Listeners[d] = []), u.dom7Listeners[d].push({
                        listener: r,
                        proxyListener: o
                    }), u.addEventListener(d, o, i)
                }
    }
    return this
}

function Aoe(...t) {
    let [e, n, r, i] = t;
    typeof t[1] == "function" && ([e, r, i] = t, n = void 0), i || (i = !1);
    const s = e.split(" ");
    for (let o = 0; o < s.length; o += 1) {
        const a = s[o];
        for (let l = 0; l < this.length; l += 1) {
            const c = this[l];
            let u;
            if (!n && c.dom7Listeners ? u = c.dom7Listeners[a] : n && c.dom7LiveListeners && (u = c.dom7LiveListeners[a]), u && u.length)
                for (let d = u.length - 1; d >= 0; d -= 1) {
                    const f = u[d];
                    r && f.listener === r || r && f.listener && f.listener.dom7proxy && f.listener.dom7proxy === r ? (c.removeEventListener(a, f.proxyListener, i), u.splice(d, 1)) : r || (c.removeEventListener(a, f.proxyListener, i), u.splice(d, 1))
                }
        }
    }
    return this
}

function Ooe(...t) {
    const e = en(),
        n = t[0].split(" "),
        r = t[1];
    for (let i = 0; i < n.length; i += 1) {
        const s = n[i];
        for (let o = 0; o < this.length; o += 1) {
            const a = this[o];
            if (e.CustomEvent) {
                const l = new e.CustomEvent(s, {
                    detail: r,
                    bubbles: !0,
                    cancelable: !0
                });
                a.dom7EventData = t.filter((c, u) => u > 0), a.dispatchEvent(l), a.dom7EventData = [], delete a.dom7EventData
            }
        }
    }
    return this
}

function Ioe(t) {
    const e = this;

    function n(r) {
        r.target === this && (t.call(this, r), e.off("transitionend", n))
    }
    return t && e.on("transitionend", n), this
}

function Roe(t) {
    if (this.length > 0) {
        if (t) {
            const e = this.styles();
            return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left"))
        }
        return this[0].offsetWidth
    }
    return null
}

function Moe(t) {
    if (this.length > 0) {
        if (t) {
            const e = this.styles();
            return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom"))
        }
        return this[0].offsetHeight
    }
    return null
}

function koe() {
    if (this.length > 0) {
        const t = en(),
            e = hn(),
            n = this[0],
            r = n.getBoundingClientRect(),
            i = e.body,
            s = n.clientTop || i.clientTop || 0,
            o = n.clientLeft || i.clientLeft || 0,
            a = n === t ? t.scrollY : n.scrollTop,
            l = n === t ? t.scrollX : n.scrollLeft;
        return {
            top: r.top + a - s,
            left: r.left + l - o
        }
    }
    return null
}

function Boe() {
    const t = en();
    return this[0] ? t.getComputedStyle(this[0], null) : {}
}

function Doe(t, e) {
    const n = en();
    let r;
    if (arguments.length === 1)
        if (typeof t == "string") {
            if (this[0]) return n.getComputedStyle(this[0], null).getPropertyValue(t)
        } else {
            for (r = 0; r < this.length; r += 1)
                for (const i in t) this[r].style[i] = t[i];
            return this
        }
    if (arguments.length === 2 && typeof t == "string") {
        for (r = 0; r < this.length; r += 1) this[r].style[t] = e;
        return this
    }
    return this
}

function $oe(t) {
    return t ? (this.forEach((e, n) => {
        t.apply(e, [e, n])
    }), this) : this
}

function Foe(t) {
    const e = iB(this, t);
    return Se(e)
}

function Loe(t) {
    if (typeof t > "u") return this[0] ? this[0].innerHTML : null;
    for (let e = 0; e < this.length; e += 1) this[e].innerHTML = t;
    return this
}

function Noe(t) {
    if (typeof t > "u") return this[0] ? this[0].textContent.trim() : null;
    for (let e = 0; e < this.length; e += 1) this[e].textContent = t;
    return this
}

function Uoe(t) {
    const e = en(),
        n = hn(),
        r = this[0];
    let i, s;
    if (!r || typeof t > "u") return !1;
    if (typeof t == "string") {
        if (r.matches) return r.matches(t);
        if (r.webkitMatchesSelector) return r.webkitMatchesSelector(t);
        if (r.msMatchesSelector) return r.msMatchesSelector(t);
        for (i = Se(t), s = 0; s < i.length; s += 1)
            if (i[s] === r) return !0;
        return !1
    }
    if (t === n) return r === n;
    if (t === e) return r === e;
    if (t.nodeType || t instanceof ys) {
        for (i = t.nodeType ? [t] : t, s = 0; s < i.length; s += 1)
            if (i[s] === r) return !0;
        return !1
    }
    return !1
}

function Goe() {
    let t = this[0],
        e;
    if (t) {
        for (e = 0;
            (t = t.previousSibling) !== null;) t.nodeType === 1 && (e += 1);
        return e
    }
}

function Hoe(t) {
    if (typeof t > "u") return this;
    const e = this.length;
    if (t > e - 1) return Se([]);
    if (t < 0) {
        const n = e + t;
        return n < 0 ? Se([]) : Se([this[n]])
    }
    return Se([this[t]])
}

function zoe(...t) {
    let e;
    const n = hn();
    for (let r = 0; r < t.length; r += 1) {
        e = t[r];
        for (let i = 0; i < this.length; i += 1)
            if (typeof e == "string") {
                const s = n.createElement("div");
                for (s.innerHTML = e; s.firstChild;) this[i].appendChild(s.firstChild)
            } else if (e instanceof ys)
            for (let s = 0; s < e.length; s += 1) this[i].appendChild(e[s]);
        else this[i].appendChild(e)
    }
    return this
}

function joe(t) {
    const e = hn();
    let n, r;
    for (n = 0; n < this.length; n += 1)
        if (typeof t == "string") {
            const i = e.createElement("div");
            for (i.innerHTML = t, r = i.childNodes.length - 1; r >= 0; r -= 1) this[n].insertBefore(i.childNodes[r], this[n].childNodes[0])
        } else if (t instanceof ys)
        for (r = 0; r < t.length; r += 1) this[n].insertBefore(t[r], this[n].childNodes[0]);
    else this[n].insertBefore(t, this[n].childNodes[0]);
    return this
}

function Voe(t) {
    return this.length > 0 ? t ? this[0].nextElementSibling && Se(this[0].nextElementSibling).is(t) ? Se([this[0].nextElementSibling]) : Se([]) : this[0].nextElementSibling ? Se([this[0].nextElementSibling]) : Se([]) : Se([])
}

function Woe(t) {
    const e = [];
    let n = this[0];
    if (!n) return Se([]);
    for (; n.nextElementSibling;) {
        const r = n.nextElementSibling;
        t ? Se(r).is(t) && e.push(r) : e.push(r), n = r
    }
    return Se(e)
}

function Yoe(t) {
    if (this.length > 0) {
        const e = this[0];
        return t ? e.previousElementSibling && Se(e.previousElementSibling).is(t) ? Se([e.previousElementSibling]) : Se([]) : e.previousElementSibling ? Se([e.previousElementSibling]) : Se([])
    }
    return Se([])
}

function Xoe(t) {
    const e = [];
    let n = this[0];
    if (!n) return Se([]);
    for (; n.previousElementSibling;) {
        const r = n.previousElementSibling;
        t ? Se(r).is(t) && e.push(r) : e.push(r), n = r
    }
    return Se(e)
}

function Koe(t) {
    const e = [];
    for (let n = 0; n < this.length; n += 1) this[n].parentNode !== null && (t ? Se(this[n].parentNode).is(t) && e.push(this[n].parentNode) : e.push(this[n].parentNode));
    return Se(e)
}

function qoe(t) {
    const e = [];
    for (let n = 0; n < this.length; n += 1) {
        let r = this[n].parentNode;
        for (; r;) t ? Se(r).is(t) && e.push(r) : e.push(r), r = r.parentNode
    }
    return Se(e)
}

function Joe(t) {
    let e = this;
    return typeof t > "u" ? Se([]) : (e.is(t) || (e = e.parents(t).eq(0)), e)
}

function Zoe(t) {
    const e = [];
    for (let n = 0; n < this.length; n += 1) {
        const r = this[n].querySelectorAll(t);
        for (let i = 0; i < r.length; i += 1) e.push(r[i])
    }
    return Se(e)
}

function Qoe(t) {
    const e = [];
    for (let n = 0; n < this.length; n += 1) {
        const r = this[n].children;
        for (let i = 0; i < r.length; i += 1)(!t || Se(r[i]).is(t)) && e.push(r[i])
    }
    return Se(e)
}

function eae() {
    for (let t = 0; t < this.length; t += 1) this[t].parentNode && this[t].parentNode.removeChild(this[t]);
    return this
}
const dT = {
    addClass: _oe,
    removeClass: boe,
    hasClass: woe,
    toggleClass: xoe,
    attr: Eoe,
    removeAttr: Soe,
    transform: Toe,
    transition: Coe,
    on: Poe,
    off: Aoe,
    trigger: Ooe,
    transitionEnd: Ioe,
    outerWidth: Roe,
    outerHeight: Moe,
    styles: Boe,
    offset: koe,
    css: Doe,
    each: $oe,
    html: Loe,
    text: Noe,
    is: Uoe,
    index: Goe,
    eq: Hoe,
    append: zoe,
    prepend: joe,
    next: Voe,
    nextAll: Woe,
    prev: Yoe,
    prevAll: Xoe,
    parent: Koe,
    parents: qoe,
    closest: Joe,
    find: Zoe,
    children: Qoe,
    filter: Foe,
    remove: eae
};
Object.keys(dT).forEach(t => {
    Object.defineProperty(Se.fn, t, {
        value: dT[t],
        writable: !0
    })
});

function tae(t) {
    const e = t;
    Object.keys(e).forEach(n => {
        try {
            e[n] = null
        } catch {}
        try {
            delete e[n]
        } catch {}
    })
}

function bh(t, e = 0) {
    return setTimeout(t, e)
}

function Eu() {
    return Date.now()
}

function nae(t) {
    const e = en();
    let n;
    return e.getComputedStyle && (n = e.getComputedStyle(t, null)), !n && t.currentStyle && (n = t.currentStyle), n || (n = t.style), n
}

function rae(t, e = "x") {
    const n = en();
    let r, i, s;
    const o = nae(t);
    return n.WebKitCSSMatrix ? (i = o.transform || o.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map(a => a.replace(",", ".")).join(", ")), s = new n.WebKitCSSMatrix(i === "none" ? "" : i)) : (s = o.MozTransform || o.OTransform || o.MsTransform || o.msTransform || o.transform || o.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), r = s.toString().split(",")), e === "x" && (n.WebKitCSSMatrix ? i = s.m41 : r.length === 16 ? i = parseFloat(r[12]) : i = parseFloat(r[4])), e === "y" && (n.WebKitCSSMatrix ? i = s.m42 : r.length === 16 ? i = parseFloat(r[13]) : i = parseFloat(r[5])), i || 0
}

function Kd(t) {
    return typeof t == "object" && t !== null && t.constructor && Object.prototype.toString.call(t).slice(8, -1) === "Object"
}

function iae(t) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? t instanceof HTMLElement : t && (t.nodeType === 1 || t.nodeType === 11)
}

function zn(...t) {
    const e = Object(t[0]),
        n = ["__proto__", "constructor", "prototype"];
    for (let r = 1; r < t.length; r += 1) {
        const i = t[r];
        if (i != null && !iae(i)) {
            const s = Object.keys(Object(i)).filter(o => n.indexOf(o) < 0);
            for (let o = 0, a = s.length; o < a; o += 1) {
                const l = s[o],
                    c = Object.getOwnPropertyDescriptor(i, l);
                c !== void 0 && c.enumerable && (Kd(e[l]) && Kd(i[l]) ? i[l].__swiper__ ? e[l] = i[l] : zn(e[l], i[l]) : !Kd(e[l]) && Kd(i[l]) ? (e[l] = {}, i[l].__swiper__ ? e[l] = i[l] : zn(e[l], i[l])) : e[l] = i[l])
            }
        }
    }
    return e
}

function qd(t, e, n) {
    t.style.setProperty(e, n)
}

function sB({
    swiper: t,
    targetPosition: e,
    side: n
}) {
    const r = en(),
        i = -t.translate;
    let s = null,
        o;
    const a = t.params.speed;
    t.wrapperEl.style.scrollSnapType = "none", r.cancelAnimationFrame(t.cssModeFrameID);
    const l = e > i ? "next" : "prev",
        c = (d, f) => l === "next" && d >= f || l === "prev" && d <= f,
        u = () => {
            o = new Date().getTime(), s === null && (s = o);
            const d = Math.max(Math.min((o - s) / a, 1), 0),
                f = .5 - Math.cos(d * Math.PI) / 2;
            let h = i + f * (e - i);
            if (c(h, e) && (h = e), t.wrapperEl.scrollTo({
                    [n]: h
                }), c(h, e)) {
                t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
                    t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({
                        [n]: h
                    })
                }), r.cancelAnimationFrame(t.cssModeFrameID);
                return
            }
            t.cssModeFrameID = r.requestAnimationFrame(u)
        };
    u()
}
let lg;

function sae() {
    const t = en(),
        e = hn();
    return {
        smoothScroll: e.documentElement && "scrollBehavior" in e.documentElement.style,
        touch: !!("ontouchstart" in t || t.DocumentTouch && e instanceof t.DocumentTouch),
        passiveListener: function() {
            let r = !1;
            try {
                const i = Object.defineProperty({}, "passive", {
                    get() {
                        r = !0
                    }
                });
                t.addEventListener("testPassiveListener", null, i)
            } catch {}
            return r
        }(),
        gestures: function() {
            return "ongesturestart" in t
        }()
    }
}

function oB() {
    return lg || (lg = sae()), lg
}
let cg;

function oae({
    userAgent: t
} = {}) {
    const e = oB(),
        n = en(),
        r = n.navigator.platform,
        i = t || n.navigator.userAgent,
        s = {
            ios: !1,
            android: !1
        },
        o = n.screen.width,
        a = n.screen.height,
        l = i.match(/(Android);?[\s\/]+([\d.]+)?/);
    let c = i.match(/(iPad).*OS\s([\d_]+)/);
    const u = i.match(/(iPod)(.*OS\s([\d_]+))?/),
        d = !c && i.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
        f = r === "Win32";
    let h = r === "MacIntel";
    const p = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !c && h && e.touch && p.indexOf(`${o}x${a}`) >= 0 && (c = i.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), h = !1), l && !f && (s.os = "android", s.android = !0), (c || d || u) && (s.os = "ios", s.ios = !0), s
}

function aae(t = {}) {
    return cg || (cg = oae(t)), cg
}
let ug;

function lae() {
    const t = en();

    function e() {
        const n = t.navigator.userAgent.toLowerCase();
        return n.indexOf("safari") >= 0 && n.indexOf("chrome") < 0 && n.indexOf("android") < 0
    }
    return {
        isSafari: e(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent)
    }
}

function cae() {
    return ug || (ug = lae()), ug
}

function uae({
    swiper: t,
    on: e,
    emit: n
}) {
    const r = en();
    let i = null,
        s = null;
    const o = () => {
            !t || t.destroyed || !t.initialized || (n("beforeResize"), n("resize"))
        },
        a = () => {
            !t || t.destroyed || !t.initialized || (i = new ResizeObserver(u => {
                s = r.requestAnimationFrame(() => {
                    const {
                        width: d,
                        height: f
                    } = t;
                    let h = d,
                        p = f;
                    u.forEach(({
                        contentBoxSize: b,
                        contentRect: y,
                        target: m
                    }) => {
                        m && m !== t.el || (h = y ? y.width : (b[0] || b).inlineSize, p = y ? y.height : (b[0] || b).blockSize)
                    }), (h !== d || p !== f) && o()
                })
            }), i.observe(t.el))
        },
        l = () => {
            s && r.cancelAnimationFrame(s), i && i.unobserve && t.el && (i.unobserve(t.el), i = null)
        },
        c = () => {
            !t || t.destroyed || !t.initialized || n("orientationchange")
        };
    e("init", () => {
        if (t.params.resizeObserver && typeof r.ResizeObserver < "u") {
            a();
            return
        }
        r.addEventListener("resize", o), r.addEventListener("orientationchange", c)
    }), e("destroy", () => {
        l(), r.removeEventListener("resize", o), r.removeEventListener("orientationchange", c)
    })
}

function dae({
    swiper: t,
    extendParams: e,
    on: n,
    emit: r
}) {
    const i = [],
        s = en(),
        o = (c, u = {}) => {
            const d = s.MutationObserver || s.WebkitMutationObserver,
                f = new d(h => {
                    if (h.length === 1) {
                        r("observerUpdate", h[0]);
                        return
                    }
                    const p = function() {
                        r("observerUpdate", h[0])
                    };
                    s.requestAnimationFrame ? s.requestAnimationFrame(p) : s.setTimeout(p, 0)
                });
            f.observe(c, {
                attributes: typeof u.attributes > "u" ? !0 : u.attributes,
                childList: typeof u.childList > "u" ? !0 : u.childList,
                characterData: typeof u.characterData > "u" ? !0 : u.characterData
            }), i.push(f)
        },
        a = () => {
            if (t.params.observer) {
                if (t.params.observeParents) {
                    const c = t.$el.parents();
                    for (let u = 0; u < c.length; u += 1) o(c[u])
                }
                o(t.$el[0], {
                    childList: t.params.observeSlideChildren
                }), o(t.$wrapperEl[0], {
                    attributes: !1
                })
            }
        },
        l = () => {
            i.forEach(c => {
                c.disconnect()
            }), i.splice(0, i.length)
        };
    e({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }), n("init", a), n("destroy", l)
}
const fae = {
    on(t, e, n) {
        const r = this;
        if (!r.eventsListeners || r.destroyed || typeof e != "function") return r;
        const i = n ? "unshift" : "push";
        return t.split(" ").forEach(s => {
            r.eventsListeners[s] || (r.eventsListeners[s] = []), r.eventsListeners[s][i](e)
        }), r
    },
    once(t, e, n) {
        const r = this;
        if (!r.eventsListeners || r.destroyed || typeof e != "function") return r;

        function i(...s) {
            r.off(t, i), i.__emitterProxy && delete i.__emitterProxy, e.apply(r, s)
        }
        return i.__emitterProxy = e, r.on(t, i, n)
    },
    onAny(t, e) {
        const n = this;
        if (!n.eventsListeners || n.destroyed || typeof t != "function") return n;
        const r = e ? "unshift" : "push";
        return n.eventsAnyListeners.indexOf(t) < 0 && n.eventsAnyListeners[r](t), n
    },
    offAny(t) {
        const e = this;
        if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e;
        const n = e.eventsAnyListeners.indexOf(t);
        return n >= 0 && e.eventsAnyListeners.splice(n, 1), e
    },
    off(t, e) {
        const n = this;
        return !n.eventsListeners || n.destroyed || !n.eventsListeners || t.split(" ").forEach(r => {
            typeof e > "u" ? n.eventsListeners[r] = [] : n.eventsListeners[r] && n.eventsListeners[r].forEach((i, s) => {
                (i === e || i.__emitterProxy && i.__emitterProxy === e) && n.eventsListeners[r].splice(s, 1)
            })
        }), n
    },
    emit(...t) {
        const e = this;
        if (!e.eventsListeners || e.destroyed || !e.eventsListeners) return e;
        let n, r, i;
        return typeof t[0] == "string" || Array.isArray(t[0]) ? (n = t[0], r = t.slice(1, t.length), i = e) : (n = t[0].events, r = t[0].data, i = t[0].context || e), r.unshift(i), (Array.isArray(n) ? n : n.split(" ")).forEach(o => {
            e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(a => {
                a.apply(i, [o, ...r])
            }), e.eventsListeners && e.eventsListeners[o] && e.eventsListeners[o].forEach(a => {
                a.apply(i, r)
            })
        }), e
    }
};

function hae() {
    const t = this;
    let e, n;
    const r = t.$el;
    typeof t.params.width < "u" && t.params.width !== null ? e = t.params.width : e = r[0].clientWidth, typeof t.params.height < "u" && t.params.height !== null ? n = t.params.height : n = r[0].clientHeight, !(e === 0 && t.isHorizontal() || n === 0 && t.isVertical()) && (e = e - parseInt(r.css("padding-left") || 0, 10) - parseInt(r.css("padding-right") || 0, 10), n = n - parseInt(r.css("padding-top") || 0, 10) - parseInt(r.css("padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(n) && (n = 0), Object.assign(t, {
        width: e,
        height: n,
        size: t.isHorizontal() ? e : n
    }))
}

function pae() {
    const t = this;

    function e(T) {
        return t.isHorizontal() ? T : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[T]
    }

    function n(T, E) {
        return parseFloat(T.getPropertyValue(e(E)) || 0)
    }
    const r = t.params,
        {
            $wrapperEl: i,
            size: s,
            rtlTranslate: o,
            wrongRTL: a
        } = t,
        l = t.virtual && r.virtual.enabled,
        c = l ? t.virtual.slides.length : t.slides.length,
        u = i.children(`.${t.params.slideClass}`),
        d = l ? t.virtual.slides.length : u.length;
    let f = [];
    const h = [],
        p = [];
    let b = r.slidesOffsetBefore;
    typeof b == "function" && (b = r.slidesOffsetBefore.call(t));
    let y = r.slidesOffsetAfter;
    typeof y == "function" && (y = r.slidesOffsetAfter.call(t));
    const m = t.snapGrid.length,
        g = t.slidesGrid.length;
    let v = r.spaceBetween,
        _ = -b,
        x = 0,
        w = 0;
    if (typeof s > "u") return;
    typeof v == "string" && v.indexOf("%") >= 0 && (v = parseFloat(v.replace("%", "")) / 100 * s), t.virtualSize = -v, o ? u.css({
        marginLeft: "",
        marginBottom: "",
        marginTop: ""
    }) : u.css({
        marginRight: "",
        marginBottom: "",
        marginTop: ""
    }), r.centeredSlides && r.cssMode && (qd(t.wrapperEl, "--swiper-centered-offset-before", ""), qd(t.wrapperEl, "--swiper-centered-offset-after", ""));
    const S = r.grid && r.grid.rows > 1 && t.grid;
    S && t.grid.initSlides(d);
    let C;
    const A = r.slidesPerView === "auto" && r.breakpoints && Object.keys(r.breakpoints).filter(T => typeof r.breakpoints[T].slidesPerView < "u").length > 0;
    for (let T = 0; T < d; T += 1) {
        C = 0;
        const E = u.eq(T);
        if (S && t.grid.updateSlide(T, E, d, e), E.css("display") !== "none") {
            if (r.slidesPerView === "auto") {
                A && (u[T].style[e("width")] = "");
                const P = getComputedStyle(E[0]),
                    B = E[0].style.transform,
                    F = E[0].style.webkitTransform;
                if (B && (E[0].style.transform = "none"), F && (E[0].style.webkitTransform = "none"), r.roundLengths) C = t.isHorizontal() ? E.outerWidth(!0) : E.outerHeight(!0);
                else {
                    const H = n(P, "width"),
                        k = n(P, "padding-left"),
                        N = n(P, "padding-right"),
                        V = n(P, "margin-left"),
                        Y = n(P, "margin-right"),
                        le = P.getPropertyValue("box-sizing");
                    if (le && le === "border-box") C = H + V + Y;
                    else {
                        const {
                            clientWidth: ae,
                            offsetWidth: W
                        } = E[0];
                        C = H + k + N + V + Y + (W - ae)
                    }
                }
                B && (E[0].style.transform = B), F && (E[0].style.webkitTransform = F), r.roundLengths && (C = Math.floor(C))
            } else C = (s - (r.slidesPerView - 1) * v) / r.slidesPerView, r.roundLengths && (C = Math.floor(C)), u[T] && (u[T].style[e("width")] = `${C}px`);
            u[T] && (u[T].swiperSlideSize = C), p.push(C), r.centeredSlides ? (_ = _ + C / 2 + x / 2 + v, x === 0 && T !== 0 && (_ = _ - s / 2 - v), T === 0 && (_ = _ - s / 2 - v), Math.abs(_) < 1 / 1e3 && (_ = 0), r.roundLengths && (_ = Math.floor(_)), w % r.slidesPerGroup === 0 && f.push(_), h.push(_)) : (r.roundLengths && (_ = Math.floor(_)), (w - Math.min(t.params.slidesPerGroupSkip, w)) % t.params.slidesPerGroup === 0 && f.push(_), h.push(_), _ = _ + C + v), t.virtualSize += C + v, x = C, w += 1
        }
    }
    if (t.virtualSize = Math.max(t.virtualSize, s) + y, o && a && (r.effect === "slide" || r.effect === "coverflow") && i.css({
            width: `${t.virtualSize+r.spaceBetween}px`
        }), r.setWrapperSize && i.css({
            [e("width")]: `${t.virtualSize+r.spaceBetween}px`
        }), S && t.grid.updateWrapperSize(C, f, e), !r.centeredSlides) {
        const T = [];
        for (let E = 0; E < f.length; E += 1) {
            let P = f[E];
            r.roundLengths && (P = Math.floor(P)), f[E] <= t.virtualSize - s && T.push(P)
        }
        f = T, Math.floor(t.virtualSize - s) - Math.floor(f[f.length - 1]) > 1 && f.push(t.virtualSize - s)
    }
    if (f.length === 0 && (f = [0]), r.spaceBetween !== 0) {
        const T = t.isHorizontal() && o ? "marginLeft" : e("marginRight");
        u.filter((E, P) => r.cssMode ? P !== u.length - 1 : !0).css({
            [T]: `${v}px`
        })
    }
    if (r.centeredSlides && r.centeredSlidesBounds) {
        let T = 0;
        p.forEach(P => {
            T += P + (r.spaceBetween ? r.spaceBetween : 0)
        }), T -= r.spaceBetween;
        const E = T - s;
        f = f.map(P => P < 0 ? -b : P > E ? E + y : P)
    }
    if (r.centerInsufficientSlides) {
        let T = 0;
        if (p.forEach(E => {
                T += E + (r.spaceBetween ? r.spaceBetween : 0)
            }), T -= r.spaceBetween, T < s) {
            const E = (s - T) / 2;
            f.forEach((P, B) => {
                f[B] = P - E
            }), h.forEach((P, B) => {
                h[B] = P + E
            })
        }
    }
    if (Object.assign(t, {
            slides: u,
            snapGrid: f,
            slidesGrid: h,
            slidesSizesGrid: p
        }), r.centeredSlides && r.cssMode && !r.centeredSlidesBounds) {
        qd(t.wrapperEl, "--swiper-centered-offset-before", `${-f[0]}px`), qd(t.wrapperEl, "--swiper-centered-offset-after", `${t.size/2-p[p.length-1]/2}px`);
        const T = -t.snapGrid[0],
            E = -t.slidesGrid[0];
        t.snapGrid = t.snapGrid.map(P => P + T), t.slidesGrid = t.slidesGrid.map(P => P + E)
    }
    if (d !== c && t.emit("slidesLengthChange"), f.length !== m && (t.params.watchOverflow && t.checkOverflow(), t.emit("snapGridLengthChange")), h.length !== g && t.emit("slidesGridLengthChange"), r.watchSlidesProgress && t.updateSlidesOffset(), !l && !r.cssMode && (r.effect === "slide" || r.effect === "fade")) {
        const T = `${r.containerModifierClass}backface-hidden`,
            E = t.$el.hasClass(T);
        d <= r.maxBackfaceHiddenSlides ? E || t.$el.addClass(T) : E && t.$el.removeClass(T)
    }
}

function mae(t) {
    const e = this,
        n = [],
        r = e.virtual && e.params.virtual.enabled;
    let i = 0,
        s;
    typeof t == "number" ? e.setTransition(t) : t === !0 && e.setTransition(e.params.speed);
    const o = a => r ? e.slides.filter(l => parseInt(l.getAttribute("data-swiper-slide-index"), 10) === a)[0] : e.slides.eq(a)[0];
    if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1)
        if (e.params.centeredSlides)(e.visibleSlides || Se([])).each(a => {
            n.push(a)
        });
        else
            for (s = 0; s < Math.ceil(e.params.slidesPerView); s += 1) {
                const a = e.activeIndex + s;
                if (a > e.slides.length && !r) break;
                n.push(o(a))
            } else n.push(o(e.activeIndex));
    for (s = 0; s < n.length; s += 1)
        if (typeof n[s] < "u") {
            const a = n[s].offsetHeight;
            i = a > i ? a : i
        }(i || i === 0) && e.$wrapperEl.css("height", `${i}px`)
}

function gae() {
    const t = this,
        e = t.slides;
    for (let n = 0; n < e.length; n += 1) e[n].swiperSlideOffset = t.isHorizontal() ? e[n].offsetLeft : e[n].offsetTop
}

function vae(t = this && this.translate || 0) {
    const e = this,
        n = e.params,
        {
            slides: r,
            rtlTranslate: i,
            snapGrid: s
        } = e;
    if (r.length === 0) return;
    typeof r[0].swiperSlideOffset > "u" && e.updateSlidesOffset();
    let o = -t;
    i && (o = t), r.removeClass(n.slideVisibleClass), e.visibleSlidesIndexes = [], e.visibleSlides = [];
    for (let a = 0; a < r.length; a += 1) {
        const l = r[a];
        let c = l.swiperSlideOffset;
        n.cssMode && n.centeredSlides && (c -= r[0].swiperSlideOffset);
        const u = (o + (n.centeredSlides ? e.minTranslate() : 0) - c) / (l.swiperSlideSize + n.spaceBetween),
            d = (o - s[0] + (n.centeredSlides ? e.minTranslate() : 0) - c) / (l.swiperSlideSize + n.spaceBetween),
            f = -(o - c),
            h = f + e.slidesSizesGrid[a];
        (f >= 0 && f < e.size - 1 || h > 1 && h <= e.size || f <= 0 && h >= e.size) && (e.visibleSlides.push(l), e.visibleSlidesIndexes.push(a), r.eq(a).addClass(n.slideVisibleClass)), l.progress = i ? -u : u, l.originalProgress = i ? -d : d
    }
    e.visibleSlides = Se(e.visibleSlides)
}

function yae(t) {
    const e = this;
    if (typeof t > "u") {
        const c = e.rtlTranslate ? -1 : 1;
        t = e && e.translate && e.translate * c || 0
    }
    const n = e.params,
        r = e.maxTranslate() - e.minTranslate();
    let {
        progress: i,
        isBeginning: s,
        isEnd: o
    } = e;
    const a = s,
        l = o;
    r === 0 ? (i = 0, s = !0, o = !0) : (i = (t - e.minTranslate()) / r, s = i <= 0, o = i >= 1), Object.assign(e, {
        progress: i,
        isBeginning: s,
        isEnd: o
    }), (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && e.updateSlidesProgress(t), s && !a && e.emit("reachBeginning toEdge"), o && !l && e.emit("reachEnd toEdge"), (a && !s || l && !o) && e.emit("fromEdge"), e.emit("progress", i)
}

function _ae() {
    const t = this,
        {
            slides: e,
            params: n,
            $wrapperEl: r,
            activeIndex: i,
            realIndex: s
        } = t,
        o = t.virtual && n.virtual.enabled;
    e.removeClass(`${n.slideActiveClass} ${n.slideNextClass} ${n.slidePrevClass} ${n.slideDuplicateActiveClass} ${n.slideDuplicateNextClass} ${n.slideDuplicatePrevClass}`);
    let a;
    o ? a = t.$wrapperEl.find(`.${n.slideClass}[data-swiper-slide-index="${i}"]`) : a = e.eq(i), a.addClass(n.slideActiveClass), n.loop && (a.hasClass(n.slideDuplicateClass) ? r.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${s}"]`).addClass(n.slideDuplicateActiveClass) : r.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${s}"]`).addClass(n.slideDuplicateActiveClass));
    let l = a.nextAll(`.${n.slideClass}`).eq(0).addClass(n.slideNextClass);
    n.loop && l.length === 0 && (l = e.eq(0), l.addClass(n.slideNextClass));
    let c = a.prevAll(`.${n.slideClass}`).eq(0).addClass(n.slidePrevClass);
    n.loop && c.length === 0 && (c = e.eq(-1), c.addClass(n.slidePrevClass)), n.loop && (l.hasClass(n.slideDuplicateClass) ? r.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicateNextClass) : r.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicateNextClass), c.hasClass(n.slideDuplicateClass) ? r.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicatePrevClass) : r.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicatePrevClass)), t.emitSlidesClasses()
}

function bae(t) {
    const e = this,
        n = e.rtlTranslate ? e.translate : -e.translate,
        {
            slidesGrid: r,
            snapGrid: i,
            params: s,
            activeIndex: o,
            realIndex: a,
            snapIndex: l
        } = e;
    let c = t,
        u;
    if (typeof c > "u") {
        for (let f = 0; f < r.length; f += 1) typeof r[f + 1] < "u" ? n >= r[f] && n < r[f + 1] - (r[f + 1] - r[f]) / 2 ? c = f : n >= r[f] && n < r[f + 1] && (c = f + 1) : n >= r[f] && (c = f);
        s.normalizeSlideIndex && (c < 0 || typeof c > "u") && (c = 0)
    }
    if (i.indexOf(n) >= 0) u = i.indexOf(n);
    else {
        const f = Math.min(s.slidesPerGroupSkip, c);
        u = f + Math.floor((c - f) / s.slidesPerGroup)
    }
    if (u >= i.length && (u = i.length - 1), c === o) {
        u !== l && (e.snapIndex = u, e.emit("snapIndexChange"));
        return
    }
    const d = parseInt(e.slides.eq(c).attr("data-swiper-slide-index") || c, 10);
    Object.assign(e, {
        snapIndex: u,
        realIndex: d,
        previousIndex: o,
        activeIndex: c
    }), e.emit("activeIndexChange"), e.emit("snapIndexChange"), a !== d && e.emit("realIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && e.emit("slideChange")
}

function xae(t) {
    const e = this,
        n = e.params,
        r = Se(t).closest(`.${n.slideClass}`)[0];
    let i = !1,
        s;
    if (r) {
        for (let o = 0; o < e.slides.length; o += 1)
            if (e.slides[o] === r) {
                i = !0, s = o;
                break
            }
    }
    if (r && i) e.clickedSlide = r, e.virtual && e.params.virtual.enabled ? e.clickedIndex = parseInt(Se(r).attr("data-swiper-slide-index"), 10) : e.clickedIndex = s;
    else {
        e.clickedSlide = void 0, e.clickedIndex = void 0;
        return
    }
    n.slideToClickedSlide && e.clickedIndex !== void 0 && e.clickedIndex !== e.activeIndex && e.slideToClickedSlide()
}
const wae = {
    updateSize: hae,
    updateSlides: pae,
    updateAutoHeight: mae,
    updateSlidesOffset: gae,
    updateSlidesProgress: vae,
    updateProgress: yae,
    updateSlidesClasses: _ae,
    updateActiveIndex: bae,
    updateClickedSlide: xae
};

function Eae(t = this.isHorizontal() ? "x" : "y") {
    const e = this,
        {
            params: n,
            rtlTranslate: r,
            translate: i,
            $wrapperEl: s
        } = e;
    if (n.virtualTranslate) return r ? -i : i;
    if (n.cssMode) return i;
    let o = rae(s[0], t);
    return r && (o = -o), o || 0
}

function Sae(t, e) {
    const n = this,
        {
            rtlTranslate: r,
            params: i,
            $wrapperEl: s,
            wrapperEl: o,
            progress: a
        } = n;
    let l = 0,
        c = 0;
    const u = 0;
    n.isHorizontal() ? l = r ? -t : t : c = t, i.roundLengths && (l = Math.floor(l), c = Math.floor(c)), i.cssMode ? o[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -l : -c : i.virtualTranslate || s.transform(`translate3d(${l}px, ${c}px, ${u}px)`), n.previousTranslate = n.translate, n.translate = n.isHorizontal() ? l : c;
    let d;
    const f = n.maxTranslate() - n.minTranslate();
    f === 0 ? d = 0 : d = (t - n.minTranslate()) / f, d !== a && n.updateProgress(t), n.emit("setTranslate", n.translate, e)
}

function Tae() {
    return -this.snapGrid[0]
}

function Cae() {
    return -this.snapGrid[this.snapGrid.length - 1]
}

function Pae(t = 0, e = this.params.speed, n = !0, r = !0, i) {
    const s = this,
        {
            params: o,
            wrapperEl: a
        } = s;
    if (s.animating && o.preventInteractionOnTransition) return !1;
    const l = s.minTranslate(),
        c = s.maxTranslate();
    let u;
    if (r && t > l ? u = l : r && t < c ? u = c : u = t, s.updateProgress(u), o.cssMode) {
        const d = s.isHorizontal();
        if (e === 0) a[d ? "scrollLeft" : "scrollTop"] = -u;
        else {
            if (!s.support.smoothScroll) return sB({
                swiper: s,
                targetPosition: -u,
                side: d ? "left" : "top"
            }), !0;
            a.scrollTo({
                [d ? "left" : "top"]: -u,
                behavior: "smooth"
            })
        }
        return !0
    }
    return e === 0 ? (s.setTransition(0), s.setTranslate(u), n && (s.emit("beforeTransitionStart", e, i), s.emit("transitionEnd"))) : (s.setTransition(e), s.setTranslate(u), n && (s.emit("beforeTransitionStart", e, i), s.emit("transitionStart")), s.animating || (s.animating = !0, s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function(f) {
        !s || s.destroyed || f.target === this && (s.$wrapperEl[0].removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.$wrapperEl[0].removeEventListener("webkitTransitionEnd", s.onTranslateToWrapperTransitionEnd), s.onTranslateToWrapperTransitionEnd = null, delete s.onTranslateToWrapperTransitionEnd, n && s.emit("transitionEnd"))
    }), s.$wrapperEl[0].addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.$wrapperEl[0].addEventListener("webkitTransitionEnd", s.onTranslateToWrapperTransitionEnd))), !0
}
const Aae = {
    getTranslate: Eae,
    setTranslate: Sae,
    minTranslate: Tae,
    maxTranslate: Cae,
    translateTo: Pae
};

function Oae(t, e) {
    const n = this;
    n.params.cssMode || n.$wrapperEl.transition(t), n.emit("setTransition", t, e)
}

function aB({
    swiper: t,
    runCallbacks: e,
    direction: n,
    step: r
}) {
    const {
        activeIndex: i,
        previousIndex: s
    } = t;
    let o = n;
    if (o || (i > s ? o = "next" : i < s ? o = "prev" : o = "reset"), t.emit(`transition${r}`), e && i !== s) {
        if (o === "reset") {
            t.emit(`slideResetTransition${r}`);
            return
        }
        t.emit(`slideChangeTransition${r}`), o === "next" ? t.emit(`slideNextTransition${r}`) : t.emit(`slidePrevTransition${r}`)
    }
}

function Iae(t = !0, e) {
    const n = this,
        {
            params: r
        } = n;
    r.cssMode || (r.autoHeight && n.updateAutoHeight(), aB({
        swiper: n,
        runCallbacks: t,
        direction: e,
        step: "Start"
    }))
}

function Rae(t = !0, e) {
    const n = this,
        {
            params: r
        } = n;
    n.animating = !1, !r.cssMode && (n.setTransition(0), aB({
        swiper: n,
        runCallbacks: t,
        direction: e,
        step: "End"
    }))
}
const Mae = {
    setTransition: Oae,
    transitionStart: Iae,
    transitionEnd: Rae
};

function kae(t = 0, e = this.params.speed, n = !0, r, i) {
    if (typeof t != "number" && typeof t != "string") throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof t}] given.`);
    if (typeof t == "string") {
        const v = parseInt(t, 10);
        if (!isFinite(v)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${t}] given.`);
        t = v
    }
    const s = this;
    let o = t;
    o < 0 && (o = 0);
    const {
        params: a,
        snapGrid: l,
        slidesGrid: c,
        previousIndex: u,
        activeIndex: d,
        rtlTranslate: f,
        wrapperEl: h,
        enabled: p
    } = s;
    if (s.animating && a.preventInteractionOnTransition || !p && !r && !i) return !1;
    const b = Math.min(s.params.slidesPerGroupSkip, o);
    let y = b + Math.floor((o - b) / s.params.slidesPerGroup);
    y >= l.length && (y = l.length - 1);
    const m = -l[y];
    if (a.normalizeSlideIndex)
        for (let v = 0; v < c.length; v += 1) {
            const _ = -Math.floor(m * 100),
                x = Math.floor(c[v] * 100),
                w = Math.floor(c[v + 1] * 100);
            typeof c[v + 1] < "u" ? _ >= x && _ < w - (w - x) / 2 ? o = v : _ >= x && _ < w && (o = v + 1) : _ >= x && (o = v)
        }
    if (s.initialized && o !== d && (!s.allowSlideNext && m < s.translate && m < s.minTranslate() || !s.allowSlidePrev && m > s.translate && m > s.maxTranslate() && (d || 0) !== o)) return !1;
    o !== (u || 0) && n && s.emit("beforeSlideChangeStart"), s.updateProgress(m);
    let g;
    if (o > d ? g = "next" : o < d ? g = "prev" : g = "reset", f && -m === s.translate || !f && m === s.translate) return s.updateActiveIndex(o), a.autoHeight && s.updateAutoHeight(), s.updateSlidesClasses(), a.effect !== "slide" && s.setTranslate(m), g !== "reset" && (s.transitionStart(n, g), s.transitionEnd(n, g)), !1;
    if (a.cssMode) {
        const v = s.isHorizontal(),
            _ = f ? m : -m;
        if (e === 0) {
            const x = s.virtual && s.params.virtual.enabled;
            x && (s.wrapperEl.style.scrollSnapType = "none", s._immediateVirtual = !0), h[v ? "scrollLeft" : "scrollTop"] = _, x && requestAnimationFrame(() => {
                s.wrapperEl.style.scrollSnapType = "", s._swiperImmediateVirtual = !1
            })
        } else {
            if (!s.support.smoothScroll) return sB({
                swiper: s,
                targetPosition: _,
                side: v ? "left" : "top"
            }), !0;
            h.scrollTo({
                [v ? "left" : "top"]: _,
                behavior: "smooth"
            })
        }
        return !0
    }
    return s.setTransition(e), s.setTranslate(m), s.updateActiveIndex(o), s.updateSlidesClasses(), s.emit("beforeTransitionStart", e, r), s.transitionStart(n, g), e === 0 ? s.transitionEnd(n, g) : s.animating || (s.animating = !0, s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function(_) {
        !s || s.destroyed || _.target === this && (s.$wrapperEl[0].removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.$wrapperEl[0].removeEventListener("webkitTransitionEnd", s.onSlideToWrapperTransitionEnd), s.onSlideToWrapperTransitionEnd = null, delete s.onSlideToWrapperTransitionEnd, s.transitionEnd(n, g))
    }), s.$wrapperEl[0].addEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.$wrapperEl[0].addEventListener("webkitTransitionEnd", s.onSlideToWrapperTransitionEnd)), !0
}

function Bae(t = 0, e = this.params.speed, n = !0, r) {
    if (typeof t == "string") {
        const o = parseInt(t, 10);
        if (!isFinite(o)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${t}] given.`);
        t = o
    }
    const i = this;
    let s = t;
    return i.params.loop && (s += i.loopedSlides), i.slideTo(s, e, n, r)
}

function Dae(t = this.params.speed, e = !0, n) {
    const r = this,
        {
            animating: i,
            enabled: s,
            params: o
        } = r;
    if (!s) return r;
    let a = o.slidesPerGroup;
    o.slidesPerView === "auto" && o.slidesPerGroup === 1 && o.slidesPerGroupAuto && (a = Math.max(r.slidesPerViewDynamic("current", !0), 1));
    const l = r.activeIndex < o.slidesPerGroupSkip ? 1 : a;
    if (o.loop) {
        if (i && o.loopPreventsSlide) return !1;
        r.loopFix(), r._clientLeft = r.$wrapperEl[0].clientLeft
    }
    return o.rewind && r.isEnd ? r.slideTo(0, t, e, n) : r.slideTo(r.activeIndex + l, t, e, n)
}

function $ae(t = this.params.speed, e = !0, n) {
    const r = this,
        {
            params: i,
            animating: s,
            snapGrid: o,
            slidesGrid: a,
            rtlTranslate: l,
            enabled: c
        } = r;
    if (!c) return r;
    if (i.loop) {
        if (s && i.loopPreventsSlide) return !1;
        r.loopFix(), r._clientLeft = r.$wrapperEl[0].clientLeft
    }
    const u = l ? r.translate : -r.translate;

    function d(y) {
        return y < 0 ? -Math.floor(Math.abs(y)) : Math.floor(y)
    }
    const f = d(u),
        h = o.map(y => d(y));
    let p = o[h.indexOf(f) - 1];
    if (typeof p > "u" && i.cssMode) {
        let y;
        o.forEach((m, g) => {
            f >= m && (y = g)
        }), typeof y < "u" && (p = o[y > 0 ? y - 1 : y])
    }
    let b = 0;
    if (typeof p < "u" && (b = a.indexOf(p), b < 0 && (b = r.activeIndex - 1), i.slidesPerView === "auto" && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (b = b - r.slidesPerViewDynamic("previous", !0) + 1, b = Math.max(b, 0))), i.rewind && r.isBeginning) {
        const y = r.params.virtual && r.params.virtual.enabled && r.virtual ? r.virtual.slides.length - 1 : r.slides.length - 1;
        return r.slideTo(y, t, e, n)
    }
    return r.slideTo(b, t, e, n)
}

function Fae(t = this.params.speed, e = !0, n) {
    const r = this;
    return r.slideTo(r.activeIndex, t, e, n)
}

function Lae(t = this.params.speed, e = !0, n, r = .5) {
    const i = this;
    let s = i.activeIndex;
    const o = Math.min(i.params.slidesPerGroupSkip, s),
        a = o + Math.floor((s - o) / i.params.slidesPerGroup),
        l = i.rtlTranslate ? i.translate : -i.translate;
    if (l >= i.snapGrid[a]) {
        const c = i.snapGrid[a],
            u = i.snapGrid[a + 1];
        l - c > (u - c) * r && (s += i.params.slidesPerGroup)
    } else {
        const c = i.snapGrid[a - 1],
            u = i.snapGrid[a];
        l - c <= (u - c) * r && (s -= i.params.slidesPerGroup)
    }
    return s = Math.max(s, 0), s = Math.min(s, i.slidesGrid.length - 1), i.slideTo(s, t, e, n)
}

function Nae() {
    const t = this,
        {
            params: e,
            $wrapperEl: n
        } = t,
        r = e.slidesPerView === "auto" ? t.slidesPerViewDynamic() : e.slidesPerView;
    let i = t.clickedIndex,
        s;
    if (e.loop) {
        if (t.animating) return;
        s = parseInt(Se(t.clickedSlide).attr("data-swiper-slide-index"), 10), e.centeredSlides ? i < t.loopedSlides - r / 2 || i > t.slides.length - t.loopedSlides + r / 2 ? (t.loopFix(), i = n.children(`.${e.slideClass}[data-swiper-slide-index="${s}"]:not(.${e.slideDuplicateClass})`).eq(0).index(), bh(() => {
            t.slideTo(i)
        })) : t.slideTo(i) : i > t.slides.length - r ? (t.loopFix(), i = n.children(`.${e.slideClass}[data-swiper-slide-index="${s}"]:not(.${e.slideDuplicateClass})`).eq(0).index(), bh(() => {
            t.slideTo(i)
        })) : t.slideTo(i)
    } else t.slideTo(i)
}
const Uae = {
    slideTo: kae,
    slideToLoop: Bae,
    slideNext: Dae,
    slidePrev: $ae,
    slideReset: Fae,
    slideToClosest: Lae,
    slideToClickedSlide: Nae
};

function Gae() {
    const t = this,
        e = hn(),
        {
            params: n,
            $wrapperEl: r
        } = t,
        i = r.children().length > 0 ? Se(r.children()[0].parentNode) : r;
    i.children(`.${n.slideClass}.${n.slideDuplicateClass}`).remove();
    let s = i.children(`.${n.slideClass}`);
    if (n.loopFillGroupWithBlank) {
        const l = n.slidesPerGroup - s.length % n.slidesPerGroup;
        if (l !== n.slidesPerGroup) {
            for (let c = 0; c < l; c += 1) {
                const u = Se(e.createElement("div")).addClass(`${n.slideClass} ${n.slideBlankClass}`);
                i.append(u)
            }
            s = i.children(`.${n.slideClass}`)
        }
    }
    n.slidesPerView === "auto" && !n.loopedSlides && (n.loopedSlides = s.length), t.loopedSlides = Math.ceil(parseFloat(n.loopedSlides || n.slidesPerView, 10)), t.loopedSlides += n.loopAdditionalSlides, t.loopedSlides > s.length && t.params.loopedSlidesLimit && (t.loopedSlides = s.length);
    const o = [],
        a = [];
    s.each((l, c) => {
        Se(l).attr("data-swiper-slide-index", c)
    });
    for (let l = 0; l < t.loopedSlides; l += 1) {
        const c = l - Math.floor(l / s.length) * s.length;
        a.push(s.eq(c)[0]), o.unshift(s.eq(s.length - c - 1)[0])
    }
    for (let l = 0; l < a.length; l += 1) i.append(Se(a[l].cloneNode(!0)).addClass(n.slideDuplicateClass));
    for (let l = o.length - 1; l >= 0; l -= 1) i.prepend(Se(o[l].cloneNode(!0)).addClass(n.slideDuplicateClass))
}

function Hae() {
    const t = this;
    t.emit("beforeLoopFix");
    const {
        activeIndex: e,
        slides: n,
        loopedSlides: r,
        allowSlidePrev: i,
        allowSlideNext: s,
        snapGrid: o,
        rtlTranslate: a
    } = t;
    let l;
    t.allowSlidePrev = !0, t.allowSlideNext = !0;
    const u = -o[e] - t.getTranslate();
    e < r ? (l = n.length - r * 3 + e, l += r, t.slideTo(l, 0, !1, !0) && u !== 0 && t.setTranslate((a ? -t.translate : t.translate) - u)) : e >= n.length - r && (l = -n.length + e + r, l += r, t.slideTo(l, 0, !1, !0) && u !== 0 && t.setTranslate((a ? -t.translate : t.translate) - u)), t.allowSlidePrev = i, t.allowSlideNext = s, t.emit("loopFix")
}

function zae() {
    const t = this,
        {
            $wrapperEl: e,
            params: n,
            slides: r
        } = t;
    e.children(`.${n.slideClass}.${n.slideDuplicateClass},.${n.slideClass}.${n.slideBlankClass}`).remove(), r.removeAttr("data-swiper-slide-index")
}
const jae = {
    loopCreate: Gae,
    loopFix: Hae,
    loopDestroy: zae
};

function Vae(t) {
    const e = this;
    if (e.support.touch || !e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return;
    const n = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl;
    n.style.cursor = "move", n.style.cursor = t ? "grabbing" : "grab"
}

function Wae() {
    const t = this;
    t.support.touch || t.params.watchOverflow && t.isLocked || t.params.cssMode || (t[t.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "")
}
const Yae = {
    setGrabCursor: Vae,
    unsetGrabCursor: Wae
};

function Xae(t, e = this) {
    function n(r) {
        if (!r || r === hn() || r === en()) return null;
        r.assignedSlot && (r = r.assignedSlot);
        const i = r.closest(t);
        return !i && !r.getRootNode ? null : i || n(r.getRootNode().host)
    }
    return n(e)
}

function Kae(t) {
    const e = this,
        n = hn(),
        r = en(),
        i = e.touchEventsData,
        {
            params: s,
            touches: o,
            enabled: a
        } = e;
    if (!a || e.animating && s.preventInteractionOnTransition) return;
    !e.animating && s.cssMode && s.loop && e.loopFix();
    let l = t;
    l.originalEvent && (l = l.originalEvent);
    let c = Se(l.target);
    if (s.touchEventsTarget === "wrapper" && !c.closest(e.wrapperEl).length || (i.isTouchEvent = l.type === "touchstart", !i.isTouchEvent && "which" in l && l.which === 3) || !i.isTouchEvent && "button" in l && l.button > 0 || i.isTouched && i.isMoved) return;
    const u = !!s.noSwipingClass && s.noSwipingClass !== "",
        d = t.composedPath ? t.composedPath() : t.path;
    u && l.target && l.target.shadowRoot && d && (c = Se(d[0]));
    const f = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`,
        h = !!(l.target && l.target.shadowRoot);
    if (s.noSwiping && (h ? Xae(f, c[0]) : c.closest(f)[0])) {
        e.allowClick = !0;
        return
    }
    if (s.swipeHandler && !c.closest(s.swipeHandler)[0]) return;
    o.currentX = l.type === "touchstart" ? l.targetTouches[0].pageX : l.pageX, o.currentY = l.type === "touchstart" ? l.targetTouches[0].pageY : l.pageY;
    const p = o.currentX,
        b = o.currentY,
        y = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection,
        m = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold;
    if (y && (p <= m || p >= r.innerWidth - m))
        if (y === "prevent") t.preventDefault();
        else return;
    if (Object.assign(i, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0
        }), o.startX = p, o.startY = b, i.touchStartTime = Eu(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, s.threshold > 0 && (i.allowThresholdMove = !1), l.type !== "touchstart") {
        let g = !0;
        c.is(i.focusableElements) && (g = !1, c[0].nodeName === "SELECT" && (i.isTouched = !1)), n.activeElement && Se(n.activeElement).is(i.focusableElements) && n.activeElement !== c[0] && n.activeElement.blur();
        const v = g && e.allowTouchMove && s.touchStartPreventDefault;
        (s.touchStartForcePreventDefault || v) && !c[0].isContentEditable && l.preventDefault()
    }
    e.params.freeMode && e.params.freeMode.enabled && e.freeMode && e.animating && !s.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", l)
}

function qae(t) {
    const e = hn(),
        n = this,
        r = n.touchEventsData,
        {
            params: i,
            touches: s,
            rtlTranslate: o,
            enabled: a
        } = n;
    if (!a) return;
    let l = t;
    if (l.originalEvent && (l = l.originalEvent), !r.isTouched) {
        r.startMoving && r.isScrolling && n.emit("touchMoveOpposite", l);
        return
    }
    if (r.isTouchEvent && l.type !== "touchmove") return;
    const c = l.type === "touchmove" && l.targetTouches && (l.targetTouches[0] || l.changedTouches[0]),
        u = l.type === "touchmove" ? c.pageX : l.pageX,
        d = l.type === "touchmove" ? c.pageY : l.pageY;
    if (l.preventedByNestedSwiper) {
        s.startX = u, s.startY = d;
        return
    }
    if (!n.allowTouchMove) {
        Se(l.target).is(r.focusableElements) || (n.allowClick = !1), r.isTouched && (Object.assign(s, {
            startX: u,
            startY: d,
            currentX: u,
            currentY: d
        }), r.touchStartTime = Eu());
        return
    }
    if (r.isTouchEvent && i.touchReleaseOnEdges && !i.loop) {
        if (n.isVertical()) {
            if (d < s.startY && n.translate <= n.maxTranslate() || d > s.startY && n.translate >= n.minTranslate()) {
                r.isTouched = !1, r.isMoved = !1;
                return
            }
        } else if (u < s.startX && n.translate <= n.maxTranslate() || u > s.startX && n.translate >= n.minTranslate()) return
    }
    if (r.isTouchEvent && e.activeElement && l.target === e.activeElement && Se(l.target).is(r.focusableElements)) {
        r.isMoved = !0, n.allowClick = !1;
        return
    }
    if (r.allowTouchCallbacks && n.emit("touchMove", l), l.targetTouches && l.targetTouches.length > 1) return;
    s.currentX = u, s.currentY = d;
    const f = s.currentX - s.startX,
        h = s.currentY - s.startY;
    if (n.params.threshold && Math.sqrt(f ** 2 + h ** 2) < n.params.threshold) return;
    if (typeof r.isScrolling > "u") {
        let m;
        n.isHorizontal() && s.currentY === s.startY || n.isVertical() && s.currentX === s.startX ? r.isScrolling = !1 : f * f + h * h >= 25 && (m = Math.atan2(Math.abs(h), Math.abs(f)) * 180 / Math.PI, r.isScrolling = n.isHorizontal() ? m > i.touchAngle : 90 - m > i.touchAngle)
    }
    if (r.isScrolling && n.emit("touchMoveOpposite", l), typeof r.startMoving > "u" && (s.currentX !== s.startX || s.currentY !== s.startY) && (r.startMoving = !0), r.isScrolling) {
        r.isTouched = !1;
        return
    }
    if (!r.startMoving) return;
    n.allowClick = !1, !i.cssMode && l.cancelable && l.preventDefault(), i.touchMoveStopPropagation && !i.nested && l.stopPropagation(), r.isMoved || (i.loop && !i.cssMode && n.loopFix(), r.startTranslate = n.getTranslate(), n.setTransition(0), n.animating && n.$wrapperEl.trigger("webkitTransitionEnd transitionend"), r.allowMomentumBounce = !1, i.grabCursor && (n.allowSlideNext === !0 || n.allowSlidePrev === !0) && n.setGrabCursor(!0), n.emit("sliderFirstMove", l)), n.emit("sliderMove", l), r.isMoved = !0;
    let p = n.isHorizontal() ? f : h;
    s.diff = p, p *= i.touchRatio, o && (p = -p), n.swipeDirection = p > 0 ? "prev" : "next", r.currentTranslate = p + r.startTranslate;
    let b = !0,
        y = i.resistanceRatio;
    if (i.touchReleaseOnEdges && (y = 0), p > 0 && r.currentTranslate > n.minTranslate() ? (b = !1, i.resistance && (r.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + r.startTranslate + p) ** y)) : p < 0 && r.currentTranslate < n.maxTranslate() && (b = !1, i.resistance && (r.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - r.startTranslate - p) ** y)), b && (l.preventedByNestedSwiper = !0), !n.allowSlideNext && n.swipeDirection === "next" && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !n.allowSlidePrev && n.swipeDirection === "prev" && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), !n.allowSlidePrev && !n.allowSlideNext && (r.currentTranslate = r.startTranslate), i.threshold > 0)
        if (Math.abs(p) > i.threshold || r.allowThresholdMove) {
            if (!r.allowThresholdMove) {
                r.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, r.currentTranslate = r.startTranslate, s.diff = n.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY;
                return
            }
        } else {
            r.currentTranslate = r.startTranslate;
            return
        }!i.followFinger || i.cssMode || ((i.freeMode && i.freeMode.enabled && n.freeMode || i.watchSlidesProgress) && (n.updateActiveIndex(), n.updateSlidesClasses()), n.params.freeMode && i.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(), n.updateProgress(r.currentTranslate), n.setTranslate(r.currentTranslate))
}

function Jae(t) {
    const e = this,
        n = e.touchEventsData,
        {
            params: r,
            touches: i,
            rtlTranslate: s,
            slidesGrid: o,
            enabled: a
        } = e;
    if (!a) return;
    let l = t;
    if (l.originalEvent && (l = l.originalEvent), n.allowTouchCallbacks && e.emit("touchEnd", l), n.allowTouchCallbacks = !1, !n.isTouched) {
        n.isMoved && r.grabCursor && e.setGrabCursor(!1), n.isMoved = !1, n.startMoving = !1;
        return
    }
    r.grabCursor && n.isMoved && n.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1);
    const c = Eu(),
        u = c - n.touchStartTime;
    if (e.allowClick) {
        const g = l.path || l.composedPath && l.composedPath();
        e.updateClickedSlide(g && g[0] || l.target), e.emit("tap click", l), u < 300 && c - n.lastClickTime < 300 && e.emit("doubleTap doubleClick", l)
    }
    if (n.lastClickTime = Eu(), bh(() => {
            e.destroyed || (e.allowClick = !0)
        }), !n.isTouched || !n.isMoved || !e.swipeDirection || i.diff === 0 || n.currentTranslate === n.startTranslate) {
        n.isTouched = !1, n.isMoved = !1, n.startMoving = !1;
        return
    }
    n.isTouched = !1, n.isMoved = !1, n.startMoving = !1;
    let d;
    if (r.followFinger ? d = s ? e.translate : -e.translate : d = -n.currentTranslate, r.cssMode) return;
    if (e.params.freeMode && r.freeMode.enabled) {
        e.freeMode.onTouchEnd({
            currentPos: d
        });
        return
    }
    let f = 0,
        h = e.slidesSizesGrid[0];
    for (let g = 0; g < o.length; g += g < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup) {
        const v = g < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
        typeof o[g + v] < "u" ? d >= o[g] && d < o[g + v] && (f = g, h = o[g + v] - o[g]) : d >= o[g] && (f = g, h = o[o.length - 1] - o[o.length - 2])
    }
    let p = null,
        b = null;
    r.rewind && (e.isBeginning ? b = e.params.virtual && e.params.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (p = 0));
    const y = (d - o[f]) / h,
        m = f < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
    if (u > r.longSwipesMs) {
        if (!r.longSwipes) {
            e.slideTo(e.activeIndex);
            return
        }
        e.swipeDirection === "next" && (y >= r.longSwipesRatio ? e.slideTo(r.rewind && e.isEnd ? p : f + m) : e.slideTo(f)), e.swipeDirection === "prev" && (y > 1 - r.longSwipesRatio ? e.slideTo(f + m) : b !== null && y < 0 && Math.abs(y) > r.longSwipesRatio ? e.slideTo(b) : e.slideTo(f))
    } else {
        if (!r.shortSwipes) {
            e.slideTo(e.activeIndex);
            return
        }
        e.navigation && (l.target === e.navigation.nextEl || l.target === e.navigation.prevEl) ? l.target === e.navigation.nextEl ? e.slideTo(f + m) : e.slideTo(f) : (e.swipeDirection === "next" && e.slideTo(p !== null ? p : f + m), e.swipeDirection === "prev" && e.slideTo(b !== null ? b : f))
    }
}

function fT() {
    const t = this,
        {
            params: e,
            el: n
        } = t;
    if (n && n.offsetWidth === 0) return;
    e.breakpoints && t.setBreakpoint();
    const {
        allowSlideNext: r,
        allowSlidePrev: i,
        snapGrid: s
    } = t;
    t.allowSlideNext = !0, t.allowSlidePrev = !0, t.updateSize(), t.updateSlides(), t.updateSlidesClasses(), (e.slidesPerView === "auto" || e.slidesPerView > 1) && t.isEnd && !t.isBeginning && !t.params.centeredSlides ? t.slideTo(t.slides.length - 1, 0, !1, !0) : t.slideTo(t.activeIndex, 0, !1, !0), t.autoplay && t.autoplay.running && t.autoplay.paused && t.autoplay.run(), t.allowSlidePrev = i, t.allowSlideNext = r, t.params.watchOverflow && s !== t.snapGrid && t.checkOverflow()
}

function Zae(t) {
    const e = this;
    e.enabled && (e.allowClick || (e.params.preventClicks && t.preventDefault(), e.params.preventClicksPropagation && e.animating && (t.stopPropagation(), t.stopImmediatePropagation())))
}

function Qae() {
    const t = this,
        {
            wrapperEl: e,
            rtlTranslate: n,
            enabled: r
        } = t;
    if (!r) return;
    t.previousTranslate = t.translate, t.isHorizontal() ? t.translate = -e.scrollLeft : t.translate = -e.scrollTop, t.translate === 0 && (t.translate = 0), t.updateActiveIndex(), t.updateSlidesClasses();
    let i;
    const s = t.maxTranslate() - t.minTranslate();
    s === 0 ? i = 0 : i = (t.translate - t.minTranslate()) / s, i !== t.progress && t.updateProgress(n ? -t.translate : t.translate), t.emit("setTranslate", t.translate, !1)
}
let hT = !1;

function ele() {}
const lB = (t, e) => {
    const n = hn(),
        {
            params: r,
            touchEvents: i,
            el: s,
            wrapperEl: o,
            device: a,
            support: l
        } = t,
        c = !!r.nested,
        u = e === "on" ? "addEventListener" : "removeEventListener",
        d = e;
    if (!l.touch) s[u](i.start, t.onTouchStart, !1), n[u](i.move, t.onTouchMove, c), n[u](i.end, t.onTouchEnd, !1);
    else {
        const f = i.start === "touchstart" && l.passiveListener && r.passiveListeners ? {
            passive: !0,
            capture: !1
        } : !1;
        s[u](i.start, t.onTouchStart, f), s[u](i.move, t.onTouchMove, l.passiveListener ? {
            passive: !1,
            capture: c
        } : c), s[u](i.end, t.onTouchEnd, f), i.cancel && s[u](i.cancel, t.onTouchEnd, f)
    }(r.preventClicks || r.preventClicksPropagation) && s[u]("click", t.onClick, !0), r.cssMode && o[u]("scroll", t.onScroll), r.updateOnWindowResize ? t[d](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", fT, !0) : t[d]("observerUpdate", fT, !0)
};

function tle() {
    const t = this,
        e = hn(),
        {
            params: n,
            support: r
        } = t;
    t.onTouchStart = Kae.bind(t), t.onTouchMove = qae.bind(t), t.onTouchEnd = Jae.bind(t), n.cssMode && (t.onScroll = Qae.bind(t)), t.onClick = Zae.bind(t), r.touch && !hT && (e.addEventListener("touchstart", ele), hT = !0), lB(t, "on")
}

function nle() {
    lB(this, "off")
}
const rle = {
        attachEvents: tle,
        detachEvents: nle
    },
    pT = (t, e) => t.grid && e.grid && e.grid.rows > 1;

function ile() {
    const t = this,
        {
            activeIndex: e,
            initialized: n,
            loopedSlides: r = 0,
            params: i,
            $el: s
        } = t,
        o = i.breakpoints;
    if (!o || o && Object.keys(o).length === 0) return;
    const a = t.getBreakpoint(o, t.params.breakpointsBase, t.el);
    if (!a || t.currentBreakpoint === a) return;
    const c = (a in o ? o[a] : void 0) || t.originalParams,
        u = pT(t, i),
        d = pT(t, c),
        f = i.enabled;
    u && !d ? (s.removeClass(`${i.containerModifierClass}grid ${i.containerModifierClass}grid-column`), t.emitContainerClasses()) : !u && d && (s.addClass(`${i.containerModifierClass}grid`), (c.grid.fill && c.grid.fill === "column" || !c.grid.fill && i.grid.fill === "column") && s.addClass(`${i.containerModifierClass}grid-column`), t.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach(y => {
        const m = i[y] && i[y].enabled,
            g = c[y] && c[y].enabled;
        m && !g && t[y].disable(), !m && g && t[y].enable()
    });
    const h = c.direction && c.direction !== i.direction,
        p = i.loop && (c.slidesPerView !== i.slidesPerView || h);
    h && n && t.changeDirection(), zn(t.params, c);
    const b = t.params.enabled;
    Object.assign(t, {
        allowTouchMove: t.params.allowTouchMove,
        allowSlideNext: t.params.allowSlideNext,
        allowSlidePrev: t.params.allowSlidePrev
    }), f && !b ? t.disable() : !f && b && t.enable(), t.currentBreakpoint = a, t.emit("_beforeBreakpoint", c), p && n && (t.loopDestroy(), t.loopCreate(), t.updateSlides(), t.slideTo(e - r + t.loopedSlides, 0, !1)), t.emit("breakpoint", c)
}

function sle(t, e = "window", n) {
    if (!t || e === "container" && !n) return;
    let r = !1;
    const i = en(),
        s = e === "window" ? i.innerHeight : n.clientHeight,
        o = Object.keys(t).map(a => {
            if (typeof a == "string" && a.indexOf("@") === 0) {
                const l = parseFloat(a.substr(1));
                return {
                    value: s * l,
                    point: a
                }
            }
            return {
                value: a,
                point: a
            }
        });
    o.sort((a, l) => parseInt(a.value, 10) - parseInt(l.value, 10));
    for (let a = 0; a < o.length; a += 1) {
        const {
            point: l,
            value: c
        } = o[a];
        e === "window" ? i.matchMedia(`(min-width: ${c}px)`).matches && (r = l) : c <= n.clientWidth && (r = l)
    }
    return r || "max"
}
const ole = {
    setBreakpoint: ile,
    getBreakpoint: sle
};

function ale(t, e) {
    const n = [];
    return t.forEach(r => {
        typeof r == "object" ? Object.keys(r).forEach(i => {
            r[i] && n.push(e + i)
        }) : typeof r == "string" && n.push(e + r)
    }), n
}

function lle() {
    const t = this,
        {
            classNames: e,
            params: n,
            rtl: r,
            $el: i,
            device: s,
            support: o
        } = t,
        a = ale(["initialized", n.direction, {
            "pointer-events": !o.touch
        }, {
            "free-mode": t.params.freeMode && n.freeMode.enabled
        }, {
            autoheight: n.autoHeight
        }, {
            rtl: r
        }, {
            grid: n.grid && n.grid.rows > 1
        }, {
            "grid-column": n.grid && n.grid.rows > 1 && n.grid.fill === "column"
        }, {
            android: s.android
        }, {
            ios: s.ios
        }, {
            "css-mode": n.cssMode
        }, {
            centered: n.cssMode && n.centeredSlides
        }, {
            "watch-progress": n.watchSlidesProgress
        }], n.containerModifierClass);
    e.push(...a), i.addClass([...e].join(" ")), t.emitContainerClasses()
}

function cle() {
    const t = this,
        {
            $el: e,
            classNames: n
        } = t;
    e.removeClass(n.join(" ")), t.emitContainerClasses()
}
const ule = {
    addClasses: lle,
    removeClasses: cle
};

function dle(t, e, n, r, i, s) {
    const o = en();
    let a;

    function l() {
        s && s()
    }!Se(t).parent("picture")[0] && (!t.complete || !i) && e ? (a = new o.Image, a.onload = l, a.onerror = l, r && (a.sizes = r), n && (a.srcset = n), e && (a.src = e)) : l()
}

function fle() {
    const t = this;
    t.imagesToLoad = t.$el.find("img");

    function e() {
        typeof t > "u" || t === null || !t || t.destroyed || (t.imagesLoaded !== void 0 && (t.imagesLoaded += 1), t.imagesLoaded === t.imagesToLoad.length && (t.params.updateOnImagesReady && t.update(), t.emit("imagesReady")))
    }
    for (let n = 0; n < t.imagesToLoad.length; n += 1) {
        const r = t.imagesToLoad[n];
        t.loadImage(r, r.currentSrc || r.getAttribute("src"), r.srcset || r.getAttribute("srcset"), r.sizes || r.getAttribute("sizes"), !0, e)
    }
}
const hle = {
    loadImage: dle,
    preloadImages: fle
};

function ple() {
    const t = this,
        {
            isLocked: e,
            params: n
        } = t,
        {
            slidesOffsetBefore: r
        } = n;
    if (r) {
        const i = t.slides.length - 1,
            s = t.slidesGrid[i] + t.slidesSizesGrid[i] + r * 2;
        t.isLocked = t.size > s
    } else t.isLocked = t.snapGrid.length === 1;
    n.allowSlideNext === !0 && (t.allowSlideNext = !t.isLocked), n.allowSlidePrev === !0 && (t.allowSlidePrev = !t.isLocked), e && e !== t.isLocked && (t.isEnd = !1), e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock")
}
const mle = {
        checkOverflow: ple
    },
    mT = {
        init: !0,
        direction: "horizontal",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 0,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        preloadImages: !0,
        updateOnImagesReady: !0,
        loop: !1,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopedSlidesLimit: !0,
        loopFillGroupWithBlank: !1,
        loopPreventsSlide: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-invisible-blank",
        slideActiveClass: "swiper-slide-active",
        slideDuplicateActiveClass: "swiper-slide-duplicate-active",
        slideVisibleClass: "swiper-slide-visible",
        slideDuplicateClass: "swiper-slide-duplicate",
        slideNextClass: "swiper-slide-next",
        slideDuplicateNextClass: "swiper-slide-duplicate-next",
        slidePrevClass: "swiper-slide-prev",
        slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
        wrapperClass: "swiper-wrapper",
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };

function gle(t, e) {
    return function(r = {}) {
        const i = Object.keys(r)[0],
            s = r[i];
        if (typeof s != "object" || s === null) {
            zn(e, r);
            return
        }
        if (["navigation", "pagination", "scrollbar"].indexOf(i) >= 0 && t[i] === !0 && (t[i] = {
                auto: !0
            }), !(i in t && "enabled" in s)) {
            zn(e, r);
            return
        }
        t[i] === !0 && (t[i] = {
            enabled: !0
        }), typeof t[i] == "object" && !("enabled" in t[i]) && (t[i].enabled = !0), t[i] || (t[i] = {
            enabled: !1
        }), zn(e, r)
    }
}
const dg = {
        eventsEmitter: fae,
        update: wae,
        translate: Aae,
        transition: Mae,
        slide: Uae,
        loop: jae,
        grabCursor: Yae,
        events: rle,
        breakpoints: ole,
        checkOverflow: mle,
        classes: ule,
        images: hle
    },
    fg = {};
let yl = class xi {
    constructor(...e) {
        let n, r;
        if (e.length === 1 && e[0].constructor && Object.prototype.toString.call(e[0]).slice(8, -1) === "Object" ? r = e[0] : [n, r] = e, r || (r = {}), r = zn({}, r), n && !r.el && (r.el = n), r.el && Se(r.el).length > 1) {
            const a = [];
            return Se(r.el).each(l => {
                const c = zn({}, r, {
                    el: l
                });
                a.push(new xi(c))
            }), a
        }
        const i = this;
        i.__swiper__ = !0, i.support = oB(), i.device = aae({
            userAgent: r.userAgent
        }), i.browser = cae(), i.eventsListeners = {}, i.eventsAnyListeners = [], i.modules = [...i.__modules__], r.modules && Array.isArray(r.modules) && i.modules.push(...r.modules);
        const s = {};
        i.modules.forEach(a => {
            a({
                swiper: i,
                extendParams: gle(r, s),
                on: i.on.bind(i),
                once: i.once.bind(i),
                off: i.off.bind(i),
                emit: i.emit.bind(i)
            })
        });
        const o = zn({}, mT, s);
        return i.params = zn({}, o, fg, r), i.originalParams = zn({}, i.params), i.passedParams = zn({}, r), i.params && i.params.on && Object.keys(i.params.on).forEach(a => {
            i.on(a, i.params.on[a])
        }), i.params && i.params.onAny && i.onAny(i.params.onAny), i.$ = Se, Object.assign(i, {
            enabled: i.params.enabled,
            el: n,
            classNames: [],
            slides: Se(),
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() {
                return i.params.direction === "horizontal"
            },
            isVertical() {
                return i.params.direction === "vertical"
            },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            allowSlideNext: i.params.allowSlideNext,
            allowSlidePrev: i.params.allowSlidePrev,
            touchEvents: function() {
                const l = ["touchstart", "touchmove", "touchend", "touchcancel"],
                    c = ["pointerdown", "pointermove", "pointerup"];
                return i.touchEventsTouch = {
                    start: l[0],
                    move: l[1],
                    end: l[2],
                    cancel: l[3]
                }, i.touchEventsDesktop = {
                    start: c[0],
                    move: c[1],
                    end: c[2]
                }, i.support.touch || !i.params.simulateTouch ? i.touchEventsTouch : i.touchEventsDesktop
            }(),
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: i.params.focusableElements,
                lastClickTime: Eu(),
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                isTouchEvent: void 0,
                startMoving: void 0
            },
            allowClick: !0,
            allowTouchMove: i.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }), i.emit("_swiper"), i.params.init && i.init(), i
    }
    enable() {
        const e = this;
        e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
    }
    disable() {
        const e = this;
        e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
    }
    setProgress(e, n) {
        const r = this;
        e = Math.min(Math.max(e, 0), 1);
        const i = r.minTranslate(),
            o = (r.maxTranslate() - i) * e + i;
        r.translateTo(o, typeof n > "u" ? 0 : n), r.updateActiveIndex(), r.updateSlidesClasses()
    }
    emitContainerClasses() {
        const e = this;
        if (!e.params._emitClasses || !e.el) return;
        const n = e.el.className.split(" ").filter(r => r.indexOf("swiper") === 0 || r.indexOf(e.params.containerModifierClass) === 0);
        e.emit("_containerClasses", n.join(" "))
    }
    getSlideClasses(e) {
        const n = this;
        return n.destroyed ? "" : e.className.split(" ").filter(r => r.indexOf("swiper-slide") === 0 || r.indexOf(n.params.slideClass) === 0).join(" ")
    }
    emitSlidesClasses() {
        const e = this;
        if (!e.params._emitClasses || !e.el) return;
        const n = [];
        e.slides.each(r => {
            const i = e.getSlideClasses(r);
            n.push({
                slideEl: r,
                classNames: i
            }), e.emit("_slideClass", r, i)
        }), e.emit("_slideClasses", n)
    }
    slidesPerViewDynamic(e = "current", n = !1) {
        const r = this,
            {
                params: i,
                slides: s,
                slidesGrid: o,
                slidesSizesGrid: a,
                size: l,
                activeIndex: c
            } = r;
        let u = 1;
        if (i.centeredSlides) {
            let d = s[c].swiperSlideSize,
                f;
            for (let h = c + 1; h < s.length; h += 1) s[h] && !f && (d += s[h].swiperSlideSize, u += 1, d > l && (f = !0));
            for (let h = c - 1; h >= 0; h -= 1) s[h] && !f && (d += s[h].swiperSlideSize, u += 1, d > l && (f = !0))
        } else if (e === "current")
            for (let d = c + 1; d < s.length; d += 1)(n ? o[d] + a[d] - o[c] < l : o[d] - o[c] < l) && (u += 1);
        else
            for (let d = c - 1; d >= 0; d -= 1) o[c] - o[d] < l && (u += 1);
        return u
    }
    update() {
        const e = this;
        if (!e || e.destroyed) return;
        const {
            snapGrid: n,
            params: r
        } = e;
        r.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses();

        function i() {
            const o = e.rtlTranslate ? e.translate * -1 : e.translate,
                a = Math.min(Math.max(o, e.maxTranslate()), e.minTranslate());
            e.setTranslate(a), e.updateActiveIndex(), e.updateSlidesClasses()
        }
        let s;
        e.params.freeMode && e.params.freeMode.enabled ? (i(), e.params.autoHeight && e.updateAutoHeight()) : ((e.params.slidesPerView === "auto" || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? s = e.slideTo(e.slides.length - 1, 0, !1, !0) : s = e.slideTo(e.activeIndex, 0, !1, !0), s || i()), r.watchOverflow && n !== e.snapGrid && e.checkOverflow(), e.emit("update")
    }
    changeDirection(e, n = !0) {
        const r = this,
            i = r.params.direction;
        return e || (e = i === "horizontal" ? "vertical" : "horizontal"), e === i || e !== "horizontal" && e !== "vertical" || (r.$el.removeClass(`${r.params.containerModifierClass}${i}`).addClass(`${r.params.containerModifierClass}${e}`), r.emitContainerClasses(), r.params.direction = e, r.slides.each(s => {
            e === "vertical" ? s.style.width = "" : s.style.height = ""
        }), r.emit("changeDirection"), n && r.update()), r
    }
    changeLanguageDirection(e) {
        const n = this;
        n.rtl && e === "rtl" || !n.rtl && e === "ltr" || (n.rtl = e === "rtl", n.rtlTranslate = n.params.direction === "horizontal" && n.rtl, n.rtl ? (n.$el.addClass(`${n.params.containerModifierClass}rtl`), n.el.dir = "rtl") : (n.$el.removeClass(`${n.params.containerModifierClass}rtl`), n.el.dir = "ltr"), n.update())
    }
    mount(e) {
        const n = this;
        if (n.mounted) return !0;
        const r = Se(e || n.params.el);
        if (e = r[0], !e) return !1;
        e.swiper = n;
        const i = () => `.${(n.params.wrapperClass||"").trim().split(" ").join(".")}`;
        let o = (() => {
            if (e && e.shadowRoot && e.shadowRoot.querySelector) {
                const a = Se(e.shadowRoot.querySelector(i()));
                return a.children = l => r.children(l), a
            }
            return r.children ? r.children(i()) : Se(r).children(i())
        })();
        if (o.length === 0 && n.params.createElements) {
            const l = hn().createElement("div");
            o = Se(l), l.className = n.params.wrapperClass, r.append(l), r.children(`.${n.params.slideClass}`).each(c => {
                o.append(c)
            })
        }
        return Object.assign(n, {
            $el: r,
            el: e,
            $wrapperEl: o,
            wrapperEl: o[0],
            mounted: !0,
            rtl: e.dir.toLowerCase() === "rtl" || r.css("direction") === "rtl",
            rtlTranslate: n.params.direction === "horizontal" && (e.dir.toLowerCase() === "rtl" || r.css("direction") === "rtl"),
            wrongRTL: o.css("display") === "-webkit-box"
        }), !0
    }
    init(e) {
        const n = this;
        return n.initialized || n.mount(e) === !1 || (n.emit("beforeInit"), n.params.breakpoints && n.setBreakpoint(), n.addClasses(), n.params.loop && n.loopCreate(), n.updateSize(), n.updateSlides(), n.params.watchOverflow && n.checkOverflow(), n.params.grabCursor && n.enabled && n.setGrabCursor(), n.params.preloadImages && n.preloadImages(), n.params.loop ? n.slideTo(n.params.initialSlide + n.loopedSlides, 0, n.params.runCallbacksOnInit, !1, !0) : n.slideTo(n.params.initialSlide, 0, n.params.runCallbacksOnInit, !1, !0), n.attachEvents(), n.initialized = !0, n.emit("init"), n.emit("afterInit")), n
    }
    destroy(e = !0, n = !0) {
        const r = this,
            {
                params: i,
                $el: s,
                $wrapperEl: o,
                slides: a
            } = r;
        return typeof r.params > "u" || r.destroyed || (r.emit("beforeDestroy"), r.initialized = !1, r.detachEvents(), i.loop && r.loopDestroy(), n && (r.removeClasses(), s.removeAttr("style"), o.removeAttr("style"), a && a.length && a.removeClass([i.slideVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), r.emit("destroy"), Object.keys(r.eventsListeners).forEach(l => {
            r.off(l)
        }), e !== !1 && (r.$el[0].swiper = null, tae(r)), r.destroyed = !0), null
    }
    static extendDefaults(e) {
        zn(fg, e)
    }
    static get extendedDefaults() {
        return fg
    }
    static get defaults() {
        return mT
    }
    static installModule(e) {
        xi.prototype.__modules__ || (xi.prototype.__modules__ = []);
        const n = xi.prototype.__modules__;
        typeof e == "function" && n.indexOf(e) < 0 && n.push(e)
    }
    static use(e) {
        return Array.isArray(e) ? (e.forEach(n => xi.installModule(n)), xi) : (xi.installModule(e), xi)
    }
};
Object.keys(dg).forEach(t => {
    Object.keys(dg[t]).forEach(e => {
        yl.prototype[e] = dg[t][e]
    })
});
yl.use([uae, dae]);

function vbe({
    swiper: t,
    extendParams: e,
    on: n,
    emit: r
}) {
    let i;
    t.autoplay = {
        running: !1,
        paused: !1
    }, e({
        autoplay: {
            enabled: !1,
            delay: 3e3,
            waitForTransition: !0,
            disableOnInteraction: !0,
            stopOnLastSlide: !1,
            reverseDirection: !1,
            pauseOnMouseEnter: !1
        }
    });

    function s() {
        if (!t.size) {
            t.autoplay.running = !1, t.autoplay.paused = !1;
            return
        }
        const b = t.slides.eq(t.activeIndex);
        let y = t.params.autoplay.delay;
        b.attr("data-swiper-autoplay") && (y = b.attr("data-swiper-autoplay") || t.params.autoplay.delay), clearTimeout(i), i = bh(() => {
            let m;
            t.params.autoplay.reverseDirection ? t.params.loop ? (t.loopFix(), m = t.slidePrev(t.params.speed, !0, !0), r("autoplay")) : t.isBeginning ? t.params.autoplay.stopOnLastSlide ? a() : (m = t.slideTo(t.slides.length - 1, t.params.speed, !0, !0), r("autoplay")) : (m = t.slidePrev(t.params.speed, !0, !0), r("autoplay")) : t.params.loop ? (t.loopFix(), m = t.slideNext(t.params.speed, !0, !0), r("autoplay")) : t.isEnd ? t.params.autoplay.stopOnLastSlide ? a() : (m = t.slideTo(0, t.params.speed, !0, !0), r("autoplay")) : (m = t.slideNext(t.params.speed, !0, !0), r("autoplay")), (t.params.cssMode && t.autoplay.running || m === !1) && s()
        }, y)
    }

    function o() {
        return typeof i < "u" || t.autoplay.running ? !1 : (t.autoplay.running = !0, r("autoplayStart"), s(), !0)
    }

    function a() {
        return !t.autoplay.running || typeof i > "u" ? !1 : (i && (clearTimeout(i), i = void 0), t.autoplay.running = !1, r("autoplayStop"), !0)
    }

    function l(b) {
        t.autoplay.running && (t.autoplay.paused || (i && clearTimeout(i), t.autoplay.paused = !0, b === 0 || !t.params.autoplay.waitForTransition ? (t.autoplay.paused = !1, s()) : ["transitionend", "webkitTransitionEnd"].forEach(y => {
            t.$wrapperEl[0].addEventListener(y, u)
        })))
    }

    function c() {
        const b = hn();
        b.visibilityState === "hidden" && t.autoplay.running && l(), b.visibilityState === "visible" && t.autoplay.paused && (s(), t.autoplay.paused = !1)
    }

    function u(b) {
        !t || t.destroyed || !t.$wrapperEl || b.target === t.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach(y => {
            t.$wrapperEl[0].removeEventListener(y, u)
        }), t.autoplay.paused = !1, t.autoplay.running ? s() : a())
    }

    function d() {
        t.params.autoplay.disableOnInteraction ? a() : (r("autoplayPause"), l()), ["transitionend", "webkitTransitionEnd"].forEach(b => {
            t.$wrapperEl[0].removeEventListener(b, u)
        })
    }

    function f() {
        t.params.autoplay.disableOnInteraction || (t.autoplay.paused = !1, r("autoplayResume"), s())
    }

    function h() {
        t.params.autoplay.pauseOnMouseEnter && (t.$el.on("mouseenter", d), t.$el.on("mouseleave", f))
    }

    function p() {
        t.$el.off("mouseenter", d), t.$el.off("mouseleave", f)
    }
    n("init", () => {
        t.params.autoplay.enabled && (o(), hn().addEventListener("visibilitychange", c), h())
    }), n("beforeTransitionStart", (b, y, m) => {
        t.autoplay.running && (m || !t.params.autoplay.disableOnInteraction ? t.autoplay.pause(y) : a())
    }), n("sliderFirstMove", () => {
        t.autoplay.running && (t.params.autoplay.disableOnInteraction ? a() : l())
    }), n("touchEnd", () => {
        t.params.cssMode && t.autoplay.paused && !t.params.autoplay.disableOnInteraction && s()
    }), n("destroy", () => {
        p(), t.autoplay.running && a(), hn().removeEventListener("visibilitychange", c)
    }), Object.assign(t.autoplay, {
        pause: l,
        run: s,
        start: o,
        stop: a
    })
}

function Zo(t) {
    return typeof t == "object" && t !== null && t.constructor && Object.prototype.toString.call(t).slice(8, -1) === "Object"
}

function _s(t, e) {
    const n = ["__proto__", "constructor", "prototype"];
    Object.keys(e).filter(r => n.indexOf(r) < 0).forEach(r => {
        typeof t[r] > "u" ? t[r] = e[r] : Zo(e[r]) && Zo(t[r]) && Object.keys(e[r]).length > 0 ? e[r].__swiper__ ? t[r] = e[r] : _s(t[r], e[r]) : t[r] = e[r]
    })
}

function cB(t = {}) {
    return t.navigation && typeof t.navigation.nextEl > "u" && typeof t.navigation.prevEl > "u"
}

function uB(t = {}) {
    return t.pagination && typeof t.pagination.el > "u"
}

function dB(t = {}) {
    return t.scrollbar && typeof t.scrollbar.el > "u"
}

function fB(t = "") {
    const e = t.split(" ").map(r => r.trim()).filter(r => !!r),
        n = [];
    return e.forEach(r => {
        n.indexOf(r) < 0 && n.push(r)
    }), n.join(" ")
}
const hB = ["modules", "init", "_direction", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_preloadImages", "updateOnImagesReady", "_loop", "_loopAdditionalSlides", "_loopedSlides", "_loopedSlidesLimit", "_loopFillGroupWithBlank", "loopPreventsSlide", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideBlankClass", "slideActiveClass", "slideDuplicateActiveClass", "slideVisibleClass", "slideDuplicateClass", "slideNextClass", "slideDuplicateNextClass", "slidePrevClass", "slideDuplicatePrevClass", "wrapperClass", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "lazy", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom"];

function gT(t = {}, e = !0) {
    const n = {
            on: {}
        },
        r = {},
        i = {};
    _s(n, yl.defaults), _s(n, yl.extendedDefaults), n._emitClasses = !0, n.init = !1;
    const s = {},
        o = hB.map(l => l.replace(/_/, "")),
        a = Object.assign({}, t);
    return Object.keys(a).forEach(l => {
        typeof t[l] > "u" || (o.indexOf(l) >= 0 ? Zo(t[l]) ? (n[l] = {}, i[l] = {}, _s(n[l], t[l]), _s(i[l], t[l])) : (n[l] = t[l], i[l] = t[l]) : l.search(/on[A-Z]/) === 0 && typeof t[l] == "function" ? e ? r[`${l[2].toLowerCase()}${l.substr(3)}`] = t[l] : n.on[`${l[2].toLowerCase()}${l.substr(3)}`] = t[l] : s[l] = t[l])
    }), ["navigation", "pagination", "scrollbar"].forEach(l => {
        n[l] === !0 && (n[l] = {}), n[l] === !1 && delete n[l]
    }), {
        params: n,
        passedParams: i,
        rest: s,
        events: r
    }
}

function vle({
    el: t,
    nextEl: e,
    prevEl: n,
    paginationEl: r,
    scrollbarEl: i,
    swiper: s
}, o) {
    cB(o) && e && n && (s.params.navigation.nextEl = e, s.originalParams.navigation.nextEl = e, s.params.navigation.prevEl = n, s.originalParams.navigation.prevEl = n), uB(o) && r && (s.params.pagination.el = r, s.originalParams.pagination.el = r), dB(o) && i && (s.params.scrollbar.el = i, s.originalParams.scrollbar.el = i), s.init(t)
}
const pB = (t, e) => {
    let n = e.slidesPerView;
    if (e.breakpoints) {
        const i = yl.prototype.getBreakpoint(e.breakpoints),
            s = i in e.breakpoints ? e.breakpoints[i] : void 0;
        s && s.slidesPerView && (n = s.slidesPerView)
    }
    let r = Math.ceil(parseFloat(e.loopedSlides || n, 10));
    return r += e.loopAdditionalSlides, r > t.length && e.loopedSlidesLimit && (r = t.length), r
};

function yle(t, e, n) {
    const r = e.map((l, c) => (l.props || (l.props = {}), l.props.swiperRef = t, l.props["data-swiper-slide-index"] = c, l));

    function i(l, c, u) {
        return l.props || (l.props = {}), qt(l.type, { ...l.props,
            key: `${l.key}-duplicate-${c}-${u}`,
            class: `${l.props.className||""} ${n.slideDuplicateClass} ${l.props.class||""}`
        }, l.children)
    }
    if (n.loopFillGroupWithBlank) {
        const l = n.slidesPerGroup - r.length % n.slidesPerGroup;
        if (l !== n.slidesPerGroup)
            for (let c = 0; c < l; c += 1) {
                const u = qt("div", {
                    class: `${n.slideClass} ${n.slideBlankClass}`
                });
                r.push(u)
            }
    }
    n.slidesPerView === "auto" && !n.loopedSlides && (n.loopedSlides = r.length);
    const s = pB(r, n),
        o = [],
        a = [];
    for (let l = 0; l < s; l += 1) {
        const c = l - Math.floor(l / r.length) * r.length;
        a.push(i(r[c], l, "append")), o.unshift(i(r[r.length - c - 1], l, "prepend"))
    }
    return t.value && (t.value.loopedSlides = s), [...o, ...r, ...a]
}

function _le(t, e, n, r, i) {
    const s = [];
    if (!e) return s;
    const o = l => {
        s.indexOf(l) < 0 && s.push(l)
    };
    if (n && r) {
        const l = r.map(i),
            c = n.map(i);
        l.join("") !== c.join("") && o("children"), r.length !== n.length && o("children")
    }
    return hB.filter(l => l[0] === "_").map(l => l.replace(/_/, "")).forEach(l => {
        if (l in t && l in e)
            if (Zo(t[l]) && Zo(e[l])) {
                const c = Object.keys(t[l]),
                    u = Object.keys(e[l]);
                c.length !== u.length ? o(l) : (c.forEach(d => {
                    t[l][d] !== e[l][d] && o(l)
                }), u.forEach(d => {
                    t[l][d] !== e[l][d] && o(l)
                }))
            } else t[l] !== e[l] && o(l)
    }), s
}

function hg(t, e, n) {
    t === void 0 && (t = {});
    const r = [],
        i = {
            "container-start": [],
            "container-end": [],
            "wrapper-start": [],
            "wrapper-end": []
        },
        s = (o, a) => {
            Array.isArray(o) && o.forEach(l => {
                const c = typeof l.type == "symbol";
                a === "default" && (a = "container-end"), c && l.children ? s(l.children, "default") : l.type && (l.type.name === "SwiperSlide" || l.type.name === "AsyncComponentWrapper") ? r.push(l) : i[a] && i[a].push(l)
            })
        };
    return Object.keys(t).forEach(o => {
        if (typeof t[o] != "function") return;
        const a = t[o]();
        s(a, o)
    }), n.value = e.value, e.value = r, {
        slides: r,
        slots: i
    }
}

function ble({
    swiper: t,
    slides: e,
    passedParams: n,
    changedParams: r,
    nextEl: i,
    prevEl: s,
    scrollbarEl: o,
    paginationEl: a
}) {
    const l = r.filter(x => x !== "children" && x !== "direction"),
        {
            params: c,
            pagination: u,
            navigation: d,
            scrollbar: f,
            virtual: h,
            thumbs: p
        } = t;
    let b, y, m, g, v;
    r.includes("thumbs") && n.thumbs && n.thumbs.swiper && c.thumbs && !c.thumbs.swiper && (b = !0), r.includes("controller") && n.controller && n.controller.control && c.controller && !c.controller.control && (y = !0), r.includes("pagination") && n.pagination && (n.pagination.el || a) && (c.pagination || c.pagination === !1) && u && !u.el && (m = !0), r.includes("scrollbar") && n.scrollbar && (n.scrollbar.el || o) && (c.scrollbar || c.scrollbar === !1) && f && !f.el && (g = !0), r.includes("navigation") && n.navigation && (n.navigation.prevEl || s) && (n.navigation.nextEl || i) && (c.navigation || c.navigation === !1) && d && !d.prevEl && !d.nextEl && (v = !0);
    const _ = x => {
        t[x] && (t[x].destroy(), x === "navigation" ? (c[x].prevEl = void 0, c[x].nextEl = void 0, t[x].prevEl = void 0, t[x].nextEl = void 0) : (c[x].el = void 0, t[x].el = void 0))
    };
    l.forEach(x => {
        if (Zo(c[x]) && Zo(n[x])) _s(c[x], n[x]);
        else {
            const w = n[x];
            (w === !0 || w === !1) && (x === "navigation" || x === "pagination" || x === "scrollbar") ? w === !1 && _(x): c[x] = n[x]
        }
    }), l.includes("controller") && !y && t.controller && t.controller.control && c.controller && c.controller.control && (t.controller.control = c.controller.control), r.includes("children") && e && h && c.virtual.enabled ? (h.slides = e, h.update(!0)) : r.includes("children") && t.lazy && t.params.lazy.enabled && t.lazy.load(), b && p.init() && p.update(!0), y && (t.controller.control = c.controller.control), m && (a && (c.pagination.el = a), u.init(), u.render(), u.update()), g && (o && (c.scrollbar.el = o), f.init(), f.updateSize(), f.setTranslate()), v && (i && (c.navigation.nextEl = i), s && (c.navigation.prevEl = s), d.init(), d.update()), r.includes("allowSlideNext") && (t.allowSlideNext = n.allowSlideNext), r.includes("allowSlidePrev") && (t.allowSlidePrev = n.allowSlidePrev), r.includes("direction") && t.changeDirection(n.direction, !1), t.update()
}

function xle(t, e, n) {
    if (!n) return null;
    const r = t.value.isHorizontal() ? {
        [t.value.rtlTranslate ? "right" : "left"]: `${n.offset}px`
    } : {
        top: `${n.offset}px`
    };
    return e.filter((i, s) => s >= n.from && s <= n.to).map(i => (i.props || (i.props = {}), i.props.style || (i.props.style = {}), i.props.swiperRef = t, i.props.style = r, qt(i.type, { ...i.props
    }, i.children)))
}
const wle = t => {
        !t || t.destroyed || !t.params.virtual || t.params.virtual && !t.params.virtual.enabled || (t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.lazy && t.params.lazy.enabled && t.lazy.load(), t.parallax && t.params.parallax && t.params.parallax.enabled && t.parallax.setTranslate())
    },
    ybe = {
        name: "Swiper",
        props: {
            tag: {
                type: String,
                default: "div"
            },
            wrapperTag: {
                type: String,
                default: "div"
            },
            modules: {
                type: Array,
                default: void 0
            },
            init: {
                type: Boolean,
                default: void 0
            },
            direction: {
                type: String,
                default: void 0
            },
            touchEventsTarget: {
                type: String,
                default: void 0
            },
            initialSlide: {
                type: Number,
                default: void 0
            },
            speed: {
                type: Number,
                default: void 0
            },
            cssMode: {
                type: Boolean,
                default: void 0
            },
            updateOnWindowResize: {
                type: Boolean,
                default: void 0
            },
            resizeObserver: {
                type: Boolean,
                default: void 0
            },
            nested: {
                type: Boolean,
                default: void 0
            },
            focusableElements: {
                type: String,
                default: void 0
            },
            width: {
                type: Number,
                default: void 0
            },
            height: {
                type: Number,
                default: void 0
            },
            preventInteractionOnTransition: {
                type: Boolean,
                default: void 0
            },
            userAgent: {
                type: String,
                default: void 0
            },
            url: {
                type: String,
                default: void 0
            },
            edgeSwipeDetection: {
                type: [Boolean, String],
                default: void 0
            },
            edgeSwipeThreshold: {
                type: Number,
                default: void 0
            },
            autoHeight: {
                type: Boolean,
                default: void 0
            },
            setWrapperSize: {
                type: Boolean,
                default: void 0
            },
            virtualTranslate: {
                type: Boolean,
                default: void 0
            },
            effect: {
                type: String,
                default: void 0
            },
            breakpoints: {
                type: Object,
                default: void 0
            },
            spaceBetween: {
                type: Number,
                default: void 0
            },
            slidesPerView: {
                type: [Number, String],
                default: void 0
            },
            maxBackfaceHiddenSlides: {
                type: Number,
                default: void 0
            },
            slidesPerGroup: {
                type: Number,
                default: void 0
            },
            slidesPerGroupSkip: {
                type: Number,
                default: void 0
            },
            slidesPerGroupAuto: {
                type: Boolean,
                default: void 0
            },
            centeredSlides: {
                type: Boolean,
                default: void 0
            },
            centeredSlidesBounds: {
                type: Boolean,
                default: void 0
            },
            slidesOffsetBefore: {
                type: Number,
                default: void 0
            },
            slidesOffsetAfter: {
                type: Number,
                default: void 0
            },
            normalizeSlideIndex: {
                type: Boolean,
                default: void 0
            },
            centerInsufficientSlides: {
                type: Boolean,
                default: void 0
            },
            watchOverflow: {
                type: Boolean,
                default: void 0
            },
            roundLengths: {
                type: Boolean,
                default: void 0
            },
            touchRatio: {
                type: Number,
                default: void 0
            },
            touchAngle: {
                type: Number,
                default: void 0
            },
            simulateTouch: {
                type: Boolean,
                default: void 0
            },
            shortSwipes: {
                type: Boolean,
                default: void 0
            },
            longSwipes: {
                type: Boolean,
                default: void 0
            },
            longSwipesRatio: {
                type: Number,
                default: void 0
            },
            longSwipesMs: {
                type: Number,
                default: void 0
            },
            followFinger: {
                type: Boolean,
                default: void 0
            },
            allowTouchMove: {
                type: Boolean,
                default: void 0
            },
            threshold: {
                type: Number,
                default: void 0
            },
            touchMoveStopPropagation: {
                type: Boolean,
                default: void 0
            },
            touchStartPreventDefault: {
                type: Boolean,
                default: void 0
            },
            touchStartForcePreventDefault: {
                type: Boolean,
                default: void 0
            },
            touchReleaseOnEdges: {
                type: Boolean,
                default: void 0
            },
            uniqueNavElements: {
                type: Boolean,
                default: void 0
            },
            resistance: {
                type: Boolean,
                default: void 0
            },
            resistanceRatio: {
                type: Number,
                default: void 0
            },
            watchSlidesProgress: {
                type: Boolean,
                default: void 0
            },
            grabCursor: {
                type: Boolean,
                default: void 0
            },
            preventClicks: {
                type: Boolean,
                default: void 0
            },
            preventClicksPropagation: {
                type: Boolean,
                default: void 0
            },
            slideToClickedSlide: {
                type: Boolean,
                default: void 0
            },
            preloadImages: {
                type: Boolean,
                default: void 0
            },
            updateOnImagesReady: {
                type: Boolean,
                default: void 0
            },
            loop: {
                type: Boolean,
                default: void 0
            },
            loopAdditionalSlides: {
                type: Number,
                default: void 0
            },
            loopedSlides: {
                type: Number,
                default: void 0
            },
            loopedSlidesLimit: {
                type: Boolean,
                default: !0
            },
            loopFillGroupWithBlank: {
                type: Boolean,
                default: void 0
            },
            loopPreventsSlide: {
                type: Boolean,
                default: void 0
            },
            rewind: {
                type: Boolean,
                default: void 0
            },
            allowSlidePrev: {
                type: Boolean,
                default: void 0
            },
            allowSlideNext: {
                type: Boolean,
                default: void 0
            },
            swipeHandler: {
                type: Boolean,
                default: void 0
            },
            noSwiping: {
                type: Boolean,
                default: void 0
            },
            noSwipingClass: {
                type: String,
                default: void 0
            },
            noSwipingSelector: {
                type: String,
                default: void 0
            },
            passiveListeners: {
                type: Boolean,
                default: void 0
            },
            containerModifierClass: {
                type: String,
                default: void 0
            },
            slideClass: {
                type: String,
                default: void 0
            },
            slideBlankClass: {
                type: String,
                default: void 0
            },
            slideActiveClass: {
                type: String,
                default: void 0
            },
            slideDuplicateActiveClass: {
                type: String,
                default: void 0
            },
            slideVisibleClass: {
                type: String,
                default: void 0
            },
            slideDuplicateClass: {
                type: String,
                default: void 0
            },
            slideNextClass: {
                type: String,
                default: void 0
            },
            slideDuplicateNextClass: {
                type: String,
                default: void 0
            },
            slidePrevClass: {
                type: String,
                default: void 0
            },
            slideDuplicatePrevClass: {
                type: String,
                default: void 0
            },
            wrapperClass: {
                type: String,
                default: void 0
            },
            runCallbacksOnInit: {
                type: Boolean,
                default: void 0
            },
            observer: {
                type: Boolean,
                default: void 0
            },
            observeParents: {
                type: Boolean,
                default: void 0
            },
            observeSlideChildren: {
                type: Boolean,
                default: void 0
            },
            a11y: {
                type: [Boolean, Object],
                default: void 0
            },
            autoplay: {
                type: [Boolean, Object],
                default: void 0
            },
            controller: {
                type: Object,
                default: void 0
            },
            coverflowEffect: {
                type: Object,
                default: void 0
            },
            cubeEffect: {
                type: Object,
                default: void 0
            },
            fadeEffect: {
                type: Object,
                default: void 0
            },
            flipEffect: {
                type: Object,
                default: void 0
            },
            creativeEffect: {
                type: Object,
                default: void 0
            },
            cardsEffect: {
                type: Object,
                default: void 0
            },
            hashNavigation: {
                type: [Boolean, Object],
                default: void 0
            },
            history: {
                type: [Boolean, Object],
                default: void 0
            },
            keyboard: {
                type: [Boolean, Object],
                default: void 0
            },
            lazy: {
                type: [Boolean, Object],
                default: void 0
            },
            mousewheel: {
                type: [Boolean, Object],
                default: void 0
            },
            navigation: {
                type: [Boolean, Object],
                default: void 0
            },
            pagination: {
                type: [Boolean, Object],
                default: void 0
            },
            parallax: {
                type: [Boolean, Object],
                default: void 0
            },
            scrollbar: {
                type: [Boolean, Object],
                default: void 0
            },
            thumbs: {
                type: Object,
                default: void 0
            },
            virtual: {
                type: [Boolean, Object],
                default: void 0
            },
            zoom: {
                type: [Boolean, Object],
                default: void 0
            },
            grid: {
                type: [Object],
                default: void 0
            },
            freeMode: {
                type: [Boolean, Object],
                default: void 0
            },
            enabled: {
                type: Boolean,
                default: void 0
            }
        },
        emits: ["_beforeBreakpoint", "_containerClasses", "_slideClass", "_slideClasses", "_swiper", "_freeModeNoMomentumRelease", "activeIndexChange", "afterInit", "autoplay", "autoplayStart", "autoplayStop", "autoplayPause", "autoplayResume", "beforeDestroy", "beforeInit", "beforeLoopFix", "beforeResize", "beforeSlideChangeStart", "beforeTransitionStart", "breakpoint", "changeDirection", "click", "disable", "doubleTap", "doubleClick", "destroy", "enable", "fromEdge", "hashChange", "hashSet", "imagesReady", "init", "keyPress", "lazyImageLoad", "lazyImageReady", "lock", "loopFix", "momentumBounce", "navigationHide", "navigationShow", "navigationPrev", "navigationNext", "observerUpdate", "orientationchange", "paginationHide", "paginationRender", "paginationShow", "paginationUpdate", "progress", "reachBeginning", "reachEnd", "realIndexChange", "resize", "scroll", "scrollbarDragEnd", "scrollbarDragMove", "scrollbarDragStart", "setTransition", "setTranslate", "slideChange", "slideChangeTransitionEnd", "slideChangeTransitionStart", "slideNextTransitionEnd", "slideNextTransitionStart", "slidePrevTransitionEnd", "slidePrevTransitionStart", "slideResetTransitionStart", "slideResetTransitionEnd", "sliderMove", "sliderFirstMove", "slidesLengthChange", "slidesGridLengthChange", "snapGridLengthChange", "snapIndexChange", "swiper", "tap", "toEdge", "touchEnd", "touchMove", "touchMoveOpposite", "touchStart", "transitionEnd", "transitionStart", "unlock", "update", "virtualUpdate", "zoomChange"],
        setup(t, e) {
            let {
                slots: n,
                emit: r
            } = e;
            const {
                tag: i,
                wrapperTag: s
            } = t, o = J("swiper"), a = J(null), l = J(!1), c = J(!1), u = J(null), d = J(null), f = J(null), h = {
                value: []
            }, p = {
                value: []
            }, b = J(null), y = J(null), m = J(null), g = J(null), {
                params: v,
                passedParams: _
            } = gT(t, !1);
            hg(n, h, p), f.value = _, p.value = h.value;
            const x = () => {
                hg(n, h, p), l.value = !0
            };
            if (v.onAny = function(S) {
                    for (var C = arguments.length, A = new Array(C > 1 ? C - 1 : 0), T = 1; T < C; T++) A[T - 1] = arguments[T];
                    r(S, ...A)
                }, Object.assign(v.on, {
                    _beforeBreakpoint: x,
                    _containerClasses(S, C) {
                        o.value = C
                    }
                }), d.value = new yl(v), d.value.loopCreate = () => {}, d.value.loopDestroy = () => {}, v.loop && (d.value.loopedSlides = pB(h.value, v)), d.value.virtual && d.value.params.virtual.enabled) {
                d.value.virtual.slides = h.value;
                const S = {
                    cache: !1,
                    slides: h.value,
                    renderExternal: C => {
                        a.value = C
                    },
                    renderExternalUpdate: !1
                };
                _s(d.value.params.virtual, S), _s(d.value.originalParams.virtual, S)
            }
            la(() => {
                !c.value && d.value && (d.value.emitSlidesClasses(), c.value = !0);
                const {
                    passedParams: S
                } = gT(t, !1), C = _le(S, f.value, h.value, p.value, A => A.props && A.props.key);
                f.value = S, (C.length || l.value) && d.value && !d.value.destroyed && ble({
                    swiper: d.value,
                    slides: h.value,
                    passedParams: S,
                    changedParams: C,
                    nextEl: b.value,
                    prevEl: y.value,
                    scrollbarEl: g.value,
                    paginationEl: m.value
                }), l.value = !1
            }), Pr("swiper", d), pe(a, () => {
                Ue(() => {
                    wle(d.value)
                })
            }), St(() => {
                u.value && (vle({
                    el: u.value,
                    nextEl: b.value,
                    prevEl: y.value,
                    paginationEl: m.value,
                    scrollbarEl: g.value,
                    swiper: d.value
                }, v), r("swiper", d.value))
            }), er(() => {
                d.value && !d.value.destroyed && d.value.destroy(!0, !1)
            });

            function w(S) {
                return v.virtual ? xle(d, S, a.value) : !v.loop || d.value && d.value.destroyed ? (S.forEach(C => {
                    C.props || (C.props = {}), C.props.swiperRef = d
                }), S) : yle(d, S, v)
            }
            return () => {
                const {
                    slides: S,
                    slots: C
                } = hg(n, h, p);
                return qt(i, {
                    ref: u,
                    class: fB(o.value)
                }, [C["container-start"], qt(s, {
                    class: "swiper-wrapper"
                }, [C["wrapper-start"], w(S), C["wrapper-end"]]), cB(t) && [qt("div", {
                    ref: y,
                    class: "swiper-button-prev"
                }), qt("div", {
                    ref: b,
                    class: "swiper-button-next"
                })], dB(t) && qt("div", {
                    ref: g,
                    class: "swiper-scrollbar"
                }), uB(t) && qt("div", {
                    ref: m,
                    class: "swiper-pagination"
                }), C["container-end"]])
            }
        }
    },
    _be = {
        name: "SwiperSlide",
        props: {
            tag: {
                type: String,
                default: "div"
            },
            swiperRef: {
                type: Object,
                required: !1
            },
            zoom: {
                type: Boolean,
                default: void 0
            },
            virtualIndex: {
                type: [String, Number],
                default: void 0
            }
        },
        setup(t, e) {
            let {
                slots: n
            } = e, r = !1;
            const {
                swiperRef: i
            } = t, s = J(null), o = J("swiper-slide");

            function a(c, u, d) {
                u === s.value && (o.value = d)
            }
            St(() => {
                !i || !i.value || (i.value.on("_slideClass", a), r = !0)
            }), Jh(() => {
                r || !i || !i.value || (i.value.on("_slideClass", a), r = !0)
            }), la(() => {
                !s.value || !i || !i.value || i.value.destroyed && o.value !== "swiper-slide" && (o.value = "swiper-slide")
            }), er(() => {
                !i || !i.value || i.value.off("_slideClass", a)
            });
            const l = ne(() => ({
                isActive: o.value.indexOf("swiper-slide-active") >= 0 || o.value.indexOf("swiper-slide-duplicate-active") >= 0,
                isVisible: o.value.indexOf("swiper-slide-visible") >= 0,
                isDuplicate: o.value.indexOf("swiper-slide-duplicate") >= 0,
                isPrev: o.value.indexOf("swiper-slide-prev") >= 0 || o.value.indexOf("swiper-slide-duplicate-prev") >= 0,
                isNext: o.value.indexOf("swiper-slide-next") >= 0 || o.value.indexOf("swiper-slide-duplicate-next") >= 0
            }));
            return Pr("swiperSlide", l), () => qt(t.tag, {
                class: fB(`${o.value}`),
                ref: s,
                "data-swiper-slide-index": t.virtualIndex
            }, t.zoom ? qt("div", {
                class: "swiper-zoom-container",
                "data-swiper-zoom": typeof t.zoom == "number" ? t.zoom : void 0
            }, n.default && n.default(l.value)) : n.default && n.default(l.value))
        }
    };
var ve = {
    pullStartY: null,
    pullMoveY: null,
    handlers: [],
    styleEl: null,
    events: null,
    dist: 0,
    state: "pending",
    timeout: null,
    distResisted: 0,
    supportsPassive: !1,
    supportsPointerEvents: typeof window < "u" && !!window.PointerEvent
};
try {
    window.addEventListener("test", null, {
        get passive() {
            ve.supportsPassive = !0
        }
    })
} catch {}

function Ele(t) {
    if (!t.ptrElement) {
        var e = document.createElement("div");
        t.mainElement !== document.body ? t.mainElement.parentNode.insertBefore(e, t.mainElement) : document.body.insertBefore(e, document.body.firstChild), e.classList.add(t.classPrefix + "ptr"), e.innerHTML = t.getMarkup().replace(/__PREFIX__/g, t.classPrefix), t.ptrElement = e, typeof t.onInit == "function" && t.onInit(t), ve.styleEl || (ve.styleEl = document.createElement("style"), ve.styleEl.setAttribute("id", "pull-to-refresh-js-style"), document.head.appendChild(ve.styleEl)), ve.styleEl.textContent = t.getStyles().replace(/__PREFIX__/g, t.classPrefix).replace(/\s+/g, " ")
    }
    return t
}

function Sle(t) {
    t.ptrElement && (t.ptrElement.classList.remove(t.classPrefix + "refresh"), t.ptrElement.style[t.cssProp] = "0px", setTimeout(function() {
        t.ptrElement && t.ptrElement.parentNode && (t.ptrElement.parentNode.removeChild(t.ptrElement), t.ptrElement = null), ve.state = "pending"
    }, t.refreshTimeout))
}

function Tle(t) {
    var e = t.ptrElement.querySelector("." + t.classPrefix + "icon"),
        n = t.ptrElement.querySelector("." + t.classPrefix + "text");
    e && (ve.state === "refreshing" ? e.innerHTML = t.iconRefreshing : e.innerHTML = t.iconArrow), n && (ve.state === "releasing" && (n.innerHTML = t.instructionsReleaseToRefresh), (ve.state === "pulling" || ve.state === "pending") && (n.innerHTML = t.instructionsPullToRefresh), ve.state === "refreshing" && (n.innerHTML = t.instructionsRefreshing))
}
var Gn = {
        setupDOM: Ele,
        onReset: Sle,
        update: Tle
    },
    vT, pg = function(e) {
        return ve.pointerEventsEnabled && ve.supportsPointerEvents ? e.screenY : e.touches[0].screenY
    },
    mB = function() {
        var t;

        function e(o) {
            var a = ve.handlers.filter(function(l) {
                return l.contains(o.target)
            })[0];
            ve.enable = !!a, a && ve.state === "pending" && (t = Gn.setupDOM(a), a.shouldPullToRefresh() && (ve.pullStartY = pg(o)), clearTimeout(ve.timeout), Gn.update(a))
        }

        function n(o) {
            if (t && t.ptrElement && ve.enable) {
                if (ve.pullStartY ? ve.pullMoveY = pg(o) : t.shouldPullToRefresh() && (ve.pullStartY = pg(o)), ve.state === "refreshing") {
                    o.cancelable && t.shouldPullToRefresh() && ve.pullStartY < ve.pullMoveY && o.preventDefault();
                    return
                }
                ve.state === "pending" && (t.ptrElement.classList.add(t.classPrefix + "pull"), ve.state = "pulling", Gn.update(t)), ve.pullStartY && ve.pullMoveY && (ve.dist = ve.pullMoveY - ve.pullStartY), ve.distExtra = ve.dist - t.distIgnore, ve.distExtra > 0 && (o.cancelable && o.preventDefault(), t.ptrElement.style[t.cssProp] = ve.distResisted + "px", ve.distResisted = t.resistanceFunction(ve.distExtra / t.distThreshold) * Math.min(t.distMax, ve.distExtra), ve.state === "pulling" && ve.distResisted > t.distThreshold && (t.ptrElement.classList.add(t.classPrefix + "release"), ve.state = "releasing", Gn.update(t)), ve.state === "releasing" && ve.distResisted < t.distThreshold && (t.ptrElement.classList.remove(t.classPrefix + "release"), ve.state = "pulling", Gn.update(t)))
            }
        }

        function r() {
            if (t && t.ptrElement && ve.enable) {
                if (clearTimeout(vT), vT = setTimeout(function() {
                        t && t.ptrElement && ve.state === "pending" && Gn.onReset(t)
                    }, 500), ve.state === "releasing" && ve.distResisted > t.distThreshold) ve.state = "refreshing", t.ptrElement.style[t.cssProp] = t.distReload + "px", t.ptrElement.classList.add(t.classPrefix + "refresh"), ve.timeout = setTimeout(function() {
                    var o = t.onRefresh(function() {
                        return Gn.onReset(t)
                    });
                    o && typeof o.then == "function" && o.then(function() {
                        return Gn.onReset(t)
                    }), !o && !t.onRefresh.length && Gn.onReset(t)
                }, t.refreshTimeout);
                else {
                    if (ve.state === "refreshing") return;
                    t.ptrElement.style[t.cssProp] = "0px", ve.state = "pending"
                }
                Gn.update(t), t.ptrElement.classList.remove(t.classPrefix + "release"), t.ptrElement.classList.remove(t.classPrefix + "pull"), ve.pullStartY = ve.pullMoveY = null, ve.dist = ve.distResisted = 0
            }
        }

        function i() {
            t && t.mainElement.classList.toggle(t.classPrefix + "top", t.shouldPullToRefresh())
        }
        var s = ve.supportsPassive ? {
            passive: ve.passive || !1
        } : void 0;
        return ve.pointerEventsEnabled && ve.supportsPointerEvents ? (window.addEventListener("pointerup", r), window.addEventListener("pointerdown", e), window.addEventListener("pointermove", n, s)) : (window.addEventListener("touchend", r), window.addEventListener("touchstart", e), window.addEventListener("touchmove", n, s)), window.addEventListener("scroll", i), {
            onTouchEnd: r,
            onTouchStart: e,
            onTouchMove: n,
            onScroll: i,
            destroy: function() {
                ve.pointerEventsEnabled && ve.supportsPointerEvents ? (window.removeEventListener("pointerdown", e), window.removeEventListener("pointerup", r), window.removeEventListener("pointermove", n, s)) : (window.removeEventListener("touchstart", e), window.removeEventListener("touchend", r), window.removeEventListener("touchmove", n, s)), window.removeEventListener("scroll", i)
            }
        }
    },
    Cle = `
<div class="__PREFIX__box">
  <div class="__PREFIX__content">
    <div class="__PREFIX__icon"></div>
    <div class="__PREFIX__text"></div>
  </div>
</div>
`,
    Ple = `
.__PREFIX__ptr {
  box-shadow: inset 0 -3px 5px rgba(0, 0, 0, 0.12);
  pointer-events: none;
  font-size: 0.85em;
  font-weight: bold;
  top: 0;
  height: 0;
  transition: height 0.3s, min-height 0.3s;
  text-align: center;
  width: 100%;
  overflow: hidden;
  display: flex;
  align-items: flex-end;
  align-content: stretch;
}

.__PREFIX__box {
  padding: 10px;
  flex-basis: 100%;
}

.__PREFIX__pull {
  transition: none;
}

.__PREFIX__text {
  margin-top: .33em;
  color: rgba(0, 0, 0, 0.3);
}

.__PREFIX__icon {
  color: rgba(0, 0, 0, 0.3);
  transition: transform .3s;
}

/*
When at the top of the page, disable vertical overscroll so passive touch
listeners can take over.
*/
.__PREFIX__top {
  touch-action: pan-x pan-down pinch-zoom;
}

.__PREFIX__release .__PREFIX__icon {
  transform: rotate(180deg);
}
`,
    mg = {
        distThreshold: 60,
        distMax: 80,
        distReload: 50,
        distIgnore: 0,
        mainElement: "body",
        triggerElement: "body",
        ptrElement: ".ptr",
        classPrefix: "ptr--",
        cssProp: "min-height",
        iconArrow: "&#8675;",
        iconRefreshing: "&hellip;",
        instructionsPullToRefresh: "Pull down to refresh",
        instructionsReleaseToRefresh: "Release to refresh",
        instructionsRefreshing: "Refreshing",
        refreshTimeout: 500,
        getMarkup: function() {
            return Cle
        },
        getStyles: function() {
            return Ple
        },
        onInit: function() {},
        onRefresh: function() {
            return location.reload()
        },
        resistanceFunction: function(t) {
            return Math.min(1, t / 2.5)
        },
        shouldPullToRefresh: function() {
            return !window.scrollY
        }
    },
    Ale = ["mainElement", "ptrElement", "triggerElement"],
    yT = function(t) {
        var e = {};
        return Object.keys(mg).forEach(function(n) {
            e[n] = t[n] || mg[n]
        }), e.refreshTimeout = typeof t.refreshTimeout == "number" ? t.refreshTimeout : mg.refreshTimeout, Ale.forEach(function(n) {
            typeof e[n] == "string" && (e[n] = document.querySelector(e[n]))
        }), ve.events || (ve.events = mB()), e.contains = function(n) {
            return e.triggerElement.contains(n)
        }, e.destroy = function() {
            clearTimeout(ve.timeout);
            var n = ve.handlers.indexOf(e);
            ve.handlers.splice(n, 1)
        }, e
    },
    Ole = {
        setPassiveMode: function(e) {
            ve.passive = e
        },
        setPointerEventsMode: function(e) {
            ve.pointerEventsEnabled = e
        },
        destroyAll: function() {
            ve.events && (ve.events.destroy(), ve.events = null), ve.handlers.forEach(function(e) {
                e.destroy()
            })
        },
        init: function(e) {
            e === void 0 && (e = {});
            var n = yT(e);
            return ve.handlers.push(n), n
        },
        _: {
            setupHandler: yT,
            setupEvents: mB,
            setupDOM: Gn.setupDOM,
            onReset: Gn.onReset,
            update: Gn.update
        }
    };
const bbe = Ole;
var gB = !1;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Mn = function() {
    return Mn = Object.assign || function(t) {
        for (var e, n = 1, r = arguments.length; n < r; n++)
            for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
        return t
    }, Mn.apply(this, arguments)
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var o0 = function(t, e) {
    return o0 = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array && function(n, r) {
        n.__proto__ = r
    } || function(n, r) {
        for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i])
    }, o0(t, e)
};

function yx(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");

    function n() {
        this.constructor = t
    }
    o0(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n)
}
var ki = function() {
    return ki = Object.assign || function(t) {
        for (var e, n = 1, r = arguments.length; n < r; n++)
            for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
        return t
    }, ki.apply(this, arguments)
};

function Bi(t, e, n, r) {
    return new(n || (n = Promise))(function(i, s) {
        function o(c) {
            try {
                l(r.next(c))
            } catch (u) {
                s(u)
            }
        }

        function a(c) {
            try {
                l(r.throw(c))
            } catch (u) {
                s(u)
            }
        }

        function l(c) {
            var u;
            c.done ? i(c.value) : (u = c.value, u instanceof n ? u : new n(function(d) {
                d(u)
            })).then(o, a)
        }
        l((r = r.apply(t, e || [])).next())
    })
}

function Di(t, e) {
    var n, r, i, s, o = {
        label: 0,
        sent: function() {
            if (1 & i[0]) throw i[1];
            return i[1]
        },
        trys: [],
        ops: []
    };
    return s = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
        return this
    }), s;

    function a(l) {
        return function(c) {
            return function(u) {
                if (n) throw new TypeError("Generator is already executing.");
                for (; o;) try {
                    if (n = 1, r && (i = 2 & u[0] ? r.return : u[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, u[1])).done) return i;
                    switch (r = 0, i && (u = [2 & u[0], i.value]), u[0]) {
                        case 0:
                        case 1:
                            i = u;
                            break;
                        case 4:
                            return o.label++, {
                                value: u[1],
                                done: !1
                            };
                        case 5:
                            o.label++, r = u[1], u = [0];
                            continue;
                        case 7:
                            u = o.ops.pop(), o.trys.pop();
                            continue;
                        default:
                            if (!((i = (i = o.trys).length > 0 && i[i.length - 1]) || u[0] !== 6 && u[0] !== 2)) {
                                o = 0;
                                continue
                            }
                            if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
                                o.label = u[1];
                                break
                            }
                            if (u[0] === 6 && o.label < i[1]) {
                                o.label = i[1], i = u;
                                break
                            }
                            if (i && o.label < i[2]) {
                                o.label = i[2], o.ops.push(u);
                                break
                            }
                            i[2] && o.ops.pop(), o.trys.pop();
                            continue
                    }
                    u = e.call(t, o)
                } catch (d) {
                    u = [6, d], r = 0
                } finally {
                    n = i = 0
                }
                if (5 & u[0]) throw u[1];
                return {
                    value: u[0] ? u[1] : void 0,
                    done: !0
                }
            }([l, c])
        }
    }
}

function Ha(t, e) {
    for (var n = 0, r = e.length, i = t.length; n < r; n++, i++) t[i] = e[n];
    return t
}
Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", {
    value: function(t, e) {
        if (this == null) throw new TypeError('"this" is null or not defined');
        var n = Object(this),
            r = n.length >>> 0;
        if (r === 0) return !1;
        for (var i, s, o = 0 | e, a = Math.max(o >= 0 ? o : r - Math.abs(o), 0); a < r;) {
            if ((i = n[a]) === (s = t) || typeof i == "number" && typeof s == "number" && isNaN(i) && isNaN(s)) return !0;
            a++
        }
        return !1
    }
}), String.prototype.includes || (String.prototype.includes = function(t, e) {
    return typeof e != "number" && (e = 0), !(e + t.length > this.length) && this.indexOf(t, e) !== -1
}), Array.prototype.find || Object.defineProperty(Array.prototype, "find", {
    value: function(t) {
        if (this == null) throw new TypeError('"this" is null or not defined');
        var e = Object(this),
            n = e.length >>> 0;
        if (typeof t != "function") throw new TypeError("predicate must be a function");
        for (var r = arguments[1], i = 0; i < n;) {
            var s = e[i];
            if (t.call(r, s, i, e)) return s;
            i++
        }
    }
});
var Su = function(t) {
        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        return e.some(function(r) {
            return Object.prototype.toString.call(t).slice(8, -1).toLowerCase() === r
        })
    },
    _l = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    },
    _x = function(t) {
        return [].filter.call(t, function(e) {
            return e !== `
`
        }).join("")
    },
    bs = function(t) {
        if (typeof t != "string" || (t = t.toLocaleLowerCase().trim()) === "transparent") return !1;
        var e;
        return !(/^rgba/.test(t) && ((e = /([^\s,]+)\)$/.exec(t)) === null ? 0 : typeof e == "object" ? NaN : typeof e == "number" ? e : typeof e == "string" ? e[e.length - 1] === "%" ? Number(e.slice(0, -1)) / 100 : Number(e) : NaN) === 0)
    },
    vB = function(t, e) {
        var n, r = ((n = t.padding) === null || n === void 0 ? void 0 : n.split(" ").map(function(u) {
                return e(u)
            })) || [0],
            i = 0,
            s = 0,
            o = 0,
            a = 0;
        switch (r.length) {
            case 1:
                i = s = o = a = r[0];
                break;
            case 2:
                i = s = r[0], o = a = r[1];
                break;
            case 3:
                i = r[0], o = a = r[1], s = r[2];
                break;
            default:
                i = r[0], s = r[1], o = r[2], a = r[3]
        }
        var l = {
            paddingTop: i,
            paddingBottom: s,
            paddingLeft: o,
            paddingRight: a
        };
        for (var c in l) l[c] = _l(t, c) && Su(t[c], "string", "number") ? e(t[c]) : l[c];
        return [i, s, o, a]
    },
    yB = function(t) {
        var e = [],
            n = t.map(function(i) {
                return Number(i)
            }).reduce(function(i, s) {
                if (s > 0) {
                    var o = i + s;
                    return e.push(o), o
                }
                return e.push(NaN), i
            }, 0),
            r = Math.random() * n;
        return e.findIndex(function(i) {
            return r <= i
        })
    },
    bx = function(t, e, n, r) {
        r === void 0 && (r = 1 / 0), r <= 0 && (r = 1 / 0);
        for (var i = "", s = [], o = t.measureText("...").width, a = 0; a < e.length; a++) {
            i += e[a];
            var l = t.measureText(i).width,
                c = n(s);
            if (r === s.length + 1 && (l += o), c < 0) return s;
            if (l > c && (s.push(i.slice(0, -1)), i = e[a]), r === s.length) return s[s.length - 1] += "...", s
        }
        return i && s.push(i), s.length || s.push(e), s
    },
    To = function() {
        function t() {
            this.subs = []
        }
        return t.prototype.addSub = function(e) {
            this.subs.includes(e) || this.subs.push(e)
        }, t.prototype.notify = function() {
            this.subs.forEach(function(e) {
                e.update()
            })
        }, t
    }(),
    Ile = "__proto__" in {};

function _T(t, e, n, r) {
    Object.defineProperty(t, e, {
        value: n,
        enumerable: !!r,
        writable: !0,
        configurable: !0
    })
}
var _B = Array.prototype,
    $f = Object.create(_B);
["push", "pop", "shift", "unshift", "sort", "splice", "reverse"].forEach(function(t) {
    $f[t] = function() {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
        var r = _B[t].apply(this, e),
            i = this.__luckyOb__;
        return ["push", "unshift", "splice"].includes(t) && i.walk(this), i.dep.notify(), r
    }
});
var Rle = function() {
    function t(e) {
        this.dep = new To, _T(e, "__luckyOb__", this), Array.isArray(e) && (Ile ? e.__proto__ = $f : Object.getOwnPropertyNames($f).forEach(function(n) {
            _T(e, n, $f[n])
        })), this.walk(e)
    }
    return t.prototype.walk = function(e) {
        Object.keys(e).forEach(function(n) {
            bB(e, n, e[n])
        })
    }, t
}();

function bT(t) {
    if (t && typeof t == "object") return "__luckyOb__" in t ? t.__luckyOb__ : new Rle(t)
}

function bB(t, e, n) {
    var r = new To,
        i = Object.getOwnPropertyDescriptor(t, e);
    if (!i || i.configurable !== !1) {
        var s = i && i.get,
            o = i && i.set;
        s && !o || arguments.length !== 2 || (n = t[e]);
        var a = bT(n);
        Object.defineProperty(t, e, {
            get: function() {
                var l = s ? s.call(t) : n;
                return To.target && (r.addSub(To.target), a && a.dep.addSub(To.target)), l
            },
            set: function(l) {
                l !== n && (n = l, s && !o || (o ? o.call(t, l) : n = l, a = bT(l), r.notify()))
            }
        })
    }
}
var Mle = 0,
    kle = function() {
        function t(e, n, r, i) {
            i === void 0 && (i = {}), this.id = Mle++, this.$lucky = e, this.expr = n, this.deep = !!i.deep, this.getter = typeof n == "function" ? n : function(s) {
                s += ".";
                for (var o = [], a = "", l = 0; l < s.length; l++) {
                    var c = s[l];
                    if (/\[|\./.test(c)) o.push(a), a = "";
                    else {
                        if (/\W/.test(c)) continue;
                        a += c
                    }
                }
                return function(u) {
                    return o.reduce(function(d, f) {
                        return d[f]
                    }, u)
                }
            }(n), this.cb = r, this.value = this.get()
        }
        return t.prototype.get = function() {
            To.target = this;
            var e = this.getter.call(this.$lucky, this.$lucky);
            return this.deep && function(n) {
                var r = function(i) {
                    Su(i, "array", "object") && Object.keys(i).forEach(function(s) {
                        var o = i[s];
                        r(o)
                    })
                };
                r(n)
            }(e), To.target = null, e
        }, t.prototype.update = function() {
            var e = this.get(),
                n = this.value;
            this.value = e, this.cb.call(this.$lucky, e, n)
        }, t
    }(),
    xx = function() {
        function t(e, n) {
            var r = this;
            this.version = "1.7.21", this.htmlFontSize = 16, this.rAF = function() {}, this.boxWidth = 0, this.boxHeight = 0, typeof e == "string" ? e = {
                el: e
            } : e.nodeType === 1 && (e = {
                el: "",
                divElement: e
            }), e = e, this.config = e, this.data = n, e.flag || (e.flag = "WEB"), e.el && (e.divElement = document.querySelector(e.el)), e.divElement && (e.canvasElement = document.createElement("canvas"), e.divElement.appendChild(e.canvasElement)), e.canvasElement && (e.ctx = e.canvasElement.getContext("2d"), e.canvasElement.setAttribute("package", "lucky-canvas@1.7.21"), e.canvasElement.addEventListener("click", function(i) {
                return r.handleClick(i)
            })), this.ctx = e.ctx, this.initWindowFunction(), this.config.ctx || console.error("无法获取到 CanvasContext2D"), window && typeof window.addEventListener == "function" && window.addEventListener("resize", function(i, s) {
                s === void 0 && (s = 300);
                var o = null;
                return function() {
                    for (var a = this, l = [], c = 0; c < arguments.length; c++) l[c] = arguments[c];
                    o || (o = setTimeout(function() {
                        i.apply(a, l), clearTimeout(o), o = null
                    }, s))
                }
            }(function() {
                return r.resize()
            }, 300)), window && typeof window.MutationObserver == "function" && new window.MutationObserver(function() {
                r.resize()
            }).observe(document.documentElement, {
                attributes: !0
            })
        }
        return t.prototype.resize = function() {
            var e, n;
            (n = (e = this.config).beforeResize) === null || n === void 0 || n.call(e), this.setHTMLFontSize(), this.setDpr(), this.resetWidthAndHeight(), this.zoomCanvas()
        }, t.prototype.initLucky = function() {
            if (this.resize(), !this.boxWidth || !this.boxHeight) return console.error("无法获取到宽度或高度")
        }, t.prototype.handleClick = function(e) {}, t.prototype.setHTMLFontSize = function() {
            window && (this.htmlFontSize = +window.getComputedStyle(document.documentElement).fontSize.slice(0, -2))
        }, t.prototype.clearCanvas = function() {
            var e = [this.boxWidth, this.boxHeight],
                n = e[0],
                r = e[1];
            this.ctx.clearRect(-n, -r, 2 * n, 2 * r)
        }, t.prototype.setDpr = function() {
            var e = this.config;
            e.dpr || (window ? window.dpr = e.dpr = window.devicePixelRatio || 1 : e.dpr || console.error(e, "未传入 dpr 可能会导致绘制异常"))
        }, t.prototype.resetWidthAndHeight = function() {
            var e = this.config,
                n = this.data,
                r = 0,
                i = 0;
            e.divElement && (r = e.divElement.offsetWidth, i = e.divElement.offsetHeight), this.boxWidth = this.getLength(n.width || e.width) || r, this.boxHeight = this.getLength(n.height || e.height) || i, e.divElement && (e.divElement.style.overflow = "hidden", e.divElement.style.width = this.boxWidth + "px", e.divElement.style.height = this.boxHeight + "px")
        }, t.prototype.zoomCanvas = function() {
            var e = this.config,
                n = this.ctx,
                r = e.canvasElement,
                i = e.dpr,
                s = [this.boxWidth * i, this.boxHeight * i],
                o = s[0],
                a = s[1];
            r && (r.width = o, r.height = a, r.style.width = o + "px", r.style.height = a + "px", r.style["transform-origin"] = "left top", r.style.transform = "scale(" + 1 / i + ")", n.scale(i, i))
        }, t.prototype.initWindowFunction = function() {
            var e = this.config;
            if (window) return this.rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(r) {
                window.setTimeout(r, 1e3 / 60)
            }, e.setTimeout = window.setTimeout, e.setInterval = window.setInterval, e.clearTimeout = window.clearTimeout, void(e.clearInterval = window.clearInterval);
            if (e.rAF) this.rAF = e.rAF;
            else if (e.setTimeout) {
                var n = e.setTimeout;
                this.rAF = function(r) {
                    return n(r, 16.7)
                }
            } else this.rAF = function(r) {
                return setTimeout(r, 16.7)
            }
        }, t.prototype.loadImg = function(e, n, r) {
            var i = this;
            return r === void 0 && (r = "$resolve"), new Promise(function(s, o) {
                if (e || o("=> '" + n.src + "' 不能为空或不合法"), i.config.flag !== "WEB") return n[r] = s, void(n.$reject = o);
                var a = new Image;
                a.onload = function() {
                    return s(a)
                }, a.onerror = function() {
                    return o("=> '" + n.src + "' 图片加载失败")
                }, a.src = e
            })
        }, t.prototype.drawImage = function(e, n) {
            for (var r, i = [], s = 2; s < arguments.length; s++) i[s - 2] = arguments[s];
            var o = this.config,
                a = o.flag,
                l = o.dpr;
            if (["WEB", "MP-WX"].includes(a)) r = n;
            else {
                if (!["UNI-H5", "UNI-MP", "TARO-H5", "TARO-MP"].includes(a)) return console.error("意料之外的 flag, 该平台尚未兼容!");
                r = n.path
            }
            if (!r.canvas) return i.length === 8 && (i = i.map(function(d, f) {
                return f < 4 ? d * l : d
            })), e.drawImage.apply(e, Ha([r], i));
            var c = r.canvas.getContext("2d");
            i = i.map(function(d) {
                return d * l
            });
            var u = c.getImageData.apply(c, i.slice(0, 4));
            e.putImageData.apply(e, Ha([u], i.slice(4, 6)))
        }, t.prototype.computedWidthAndHeight = function(e, n, r, i) {
            if (!n.width && !n.height) return [e.width, e.height];
            if (n.width && !n.height) {
                var s = this.getLength(n.width, r);
                return [s, e.height * (s / e.width)]
            }
            if (!n.width && n.height) {
                var o = this.getLength(n.height, i);
                return [e.width * (o / e.height), o]
            }
            return [this.getLength(n.width, r), this.getLength(n.height, i)]
        }, t.prototype.changeUnits = function(e, n) {
            var r = this;
            n === void 0 && (n = 1);
            var i = this.config;
            return Number(e.replace(/^([-]*[0-9.]*)([a-z%]*)$/, function(s, o, a) {
                var l = {
                    "%": function(u) {
                        return u * (n / 100)
                    },
                    px: function(u) {
                        return 1 * u
                    },
                    rem: function(u) {
                        return u * r.htmlFontSize
                    },
                    vw: function(u) {
                        return u / 100 * window.innerWidth
                    }
                }[a];
                if (l) return l(o);
                var c = i.handleCssUnit || i.unitFunc;
                return c ? c(o, a) : o
            }))
        }, t.prototype.getLength = function(e, n) {
            return Su(e, "number") ? e : Su(e, "string") ? this.changeUnits(e, n) : 0
        }, t.prototype.getOffsetX = function(e, n) {
            return n === void 0 && (n = 0), (n - e) / 2
        }, t.prototype.getOffscreenCanvas = function(e, n) {
            if (!_l(this, "_offscreenCanvas") && (window && window.document && this.config.flag === "WEB" ? this._offscreenCanvas = document.createElement("canvas") : this._offscreenCanvas = this.config.offscreenCanvas, !this._offscreenCanvas)) return console.error("离屏 Canvas 无法渲染!");
            var r = this.config.dpr,
                i = this._offscreenCanvas;
            i.width = (e || 300) * r, i.height = (n || 150) * r;
            var s = i.getContext("2d");
            return s.clearRect(0, 0, e, n), s.scale(r, r), s.dpr = r, {
                _offscreenCanvas: i,
                _ctx: s
            }
        }, t.prototype.$set = function(e, n, r) {
            e && typeof e == "object" && bB(e, n, r)
        }, t.prototype.$computed = function(e, n, r) {
            var i = this;
            Object.defineProperty(e, n, {
                get: function() {
                    return r.call(i)
                }
            })
        }, t.prototype.$watch = function(e, n, r) {
            r === void 0 && (r = {}), typeof n == "object" && (n = (r = n).handler);
            var i = new kle(this, e, n, r);
            return r.immediate && n.call(this, i.value),
                function() {}
        }, t.version = "1.7.21", t
    }(),
    oo = function(t) {
        return Math.PI / 180 * t
    },
    xh = function(t) {
        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        var r = e[0],
            i = e[1],
            s = e[2],
            o = e[3],
            a = e[4],
            l = Math.min(s, o),
            c = Math.PI;
        a > l / 2 && (a = l / 2), t.beginPath(), t.moveTo(r + a, i), t.lineTo(r + a, i), t.lineTo(r + s - a, i), t.arc(r + s - a, i + a, a, -c / 2, 0), t.lineTo(r + s, i + o - a), t.arc(r + s - a, i + o - a, a, 0, c / 2), t.lineTo(r + a, i + o), t.arc(r + a, i + o - a, a, c / 2, c), t.lineTo(r, i + a), t.arc(r + a, i + a, a, c, -c / 2), t.closePath()
    },
    wx = function(t, e, n, r) {
        return t >= r && (t = r), n * (t /= r) * t + e
    },
    bl = function(t, e, n, r) {
        return t >= r && (t = r), -n * (t /= r) * (t - 2) + e
    },
    Ble = function(t) {
        function e(n, r) {
            var i, s = t.call(this, n, {
                width: r.width,
                height: r.height
            }) || this;
            return s.blocks = [], s.prizes = [], s.buttons = [], s.defaultConfig = {}, s.defaultStyle = {}, s._defaultConfig = {}, s._defaultStyle = {}, s.Radius = 0, s.prizeRadius = 0, s.prizeDeg = 0, s.prizeAng = 0, s.rotateDeg = 0, s.maxBtnRadius = 0, s.startTime = 0, s.endTime = 0, s.stopDeg = 0, s.endDeg = 0, s.FPS = 16.6, s.step = 0, s.ImageCache = new Map, s.initData(r), s.initWatch(), s.initComputed(), (i = n.beforeCreate) === null || i === void 0 || i.call(s), s.init(), s
        }
        return yx(e, t), e.prototype.resize = function() {
            var n, r;
            t.prototype.resize.call(this), this.Radius = Math.min(this.boxWidth, this.boxHeight) / 2, this.ctx.translate(this.Radius, this.Radius), this.draw(), (r = (n = this.config).afterResize) === null || r === void 0 || r.call(n)
        }, e.prototype.initLucky = function() {
            this.Radius = 0, this.prizeRadius = 0, this.prizeDeg = 0, this.prizeAng = 0, this.rotateDeg = 0, this.maxBtnRadius = 0, this.startTime = 0, this.endTime = 0, this.stopDeg = 0, this.endDeg = 0, this.FPS = 16.6, this.prizeFlag = -1, this.step = 0, t.prototype.initLucky.call(this)
        }, e.prototype.initData = function(n) {
            this.$set(this, "width", n.width || "300px"), this.$set(this, "height", n.height || "300px"), this.$set(this, "blocks", n.blocks || []), this.$set(this, "prizes", n.prizes || []), this.$set(this, "buttons", n.buttons || []), this.$set(this, "defaultConfig", n.defaultConfig || {}), this.$set(this, "defaultStyle", n.defaultStyle || {}), this.$set(this, "startCallback", n.start), this.$set(this, "endCallback", n.end)
        }, e.prototype.initComputed = function() {
            var n = this;
            this.$computed(this, "_defaultConfig", function() {
                return ki({
                    gutter: "0px",
                    offsetDegree: 0,
                    speed: 20,
                    speedFunction: "quad",
                    accelerationTime: 2500,
                    decelerationTime: 2500,
                    stopRange: 0
                }, n.defaultConfig)
            }), this.$computed(this, "_defaultStyle", function() {
                return ki({
                    fontSize: "18px",
                    fontColor: "#000",
                    fontStyle: "sans-serif",
                    fontWeight: "400",
                    background: "rgba(0,0,0,0)",
                    wordWrap: !0,
                    lengthLimit: "90%"
                }, n.defaultStyle)
            })
        }, e.prototype.initWatch = function() {
            var n = this;
            this.$watch("width", function(r) {
                n.data.width = r, n.resize()
            }), this.$watch("height", function(r) {
                n.data.height = r, n.resize()
            }), this.$watch("blocks", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("prizes", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("buttons", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("defaultConfig", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("defaultStyle", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("startCallback", function() {
                return n.init()
            }), this.$watch("endCallback", function() {
                return n.init()
            })
        }, e.prototype.init = function() {
            var n, r;
            return Bi(this, void 0, void 0, function() {
                var i;
                return Di(this, function(s) {
                    switch (s.label) {
                        case 0:
                            return this.initLucky(), i = this.config, (n = i.beforeInit) === null || n === void 0 || n.call(this), this.draw(), this.draw(), [4, this.initImageCache()];
                        case 1:
                            return s.sent(), (r = i.afterInit) === null || r === void 0 || r.call(this), [2]
                    }
                })
            })
        }, e.prototype.initImageCache = function() {
            var n = this;
            return new Promise(function(r) {
                var i = {
                    blocks: n.blocks.map(function(s) {
                        return s.imgs
                    }),
                    prizes: n.prizes.map(function(s) {
                        return s.imgs
                    }),
                    buttons: n.buttons.map(function(s) {
                        return s.imgs
                    })
                };
                Object.keys(i).forEach(function(s) {
                    var o = i[s],
                        a = [];
                    o && o.forEach(function(l, c) {
                        l && l.forEach(function(u, d) {
                            a.push(n.loadAndCacheImg(s, c, d))
                        })
                    }), Promise.all(a).then(function() {
                        n.draw(), r()
                    })
                })
            })
        }, e.prototype.handleClick = function(n) {
            var r, i = this.ctx;
            i.beginPath(), i.arc(0, 0, this.maxBtnRadius, 0, 2 * Math.PI, !1), i.isPointInPath(n.offsetX, n.offsetY) && this.step === 0 && ((r = this.startCallback) === null || r === void 0 || r.call(this, n))
        }, e.prototype.loadAndCacheImg = function(n, r, i) {
            return Bi(this, void 0, void 0, function() {
                var s = this;
                return Di(this, function(o) {
                    return [2, new Promise(function(a, l) {
                        var c = s[n][r];
                        if (c && c.imgs) {
                            var u = c.imgs[i];
                            u && s.loadImg(u.src, u).then(function(d) {
                                return Bi(s, void 0, void 0, function() {
                                    return Di(this, function(f) {
                                        switch (f.label) {
                                            case 0:
                                                return typeof u.formatter != "function" ? [3, 2] : [4, Promise.resolve(u.formatter.call(this, d))];
                                            case 1:
                                                d = f.sent(), f.label = 2;
                                            case 2:
                                                return this.ImageCache.set(u.src, d), a(), [2]
                                        }
                                    })
                                })
                            }).catch(function(d) {
                                console.error(n + "[" + r + "].imgs[" + i + "] " + d), l()
                            })
                        }
                    })]
                })
            })
        }, e.prototype.drawBlock = function(n, r, i) {
            var s = this,
                o = this.ctx;
            bs(r.background) && (o.beginPath(), o.fillStyle = r.background, o.arc(0, 0, n, 0, 2 * Math.PI, !1), o.fill()), r.imgs && r.imgs.forEach(function(a, l) {
                var c = s.ImageCache.get(a.src);
                if (c) {
                    var u = s.computedWidthAndHeight(c, a, 2 * n, 2 * n),
                        d = u[0],
                        f = u[1],
                        h = [s.getOffsetX(d) + s.getLength(a.left, 2 * n), s.getLength(a.top, 2 * n) - n],
                        p = h[0],
                        b = h[1];
                    o.save(), a.rotate && o.rotate(oo(s.rotateDeg)), s.drawImage(o, c, p, b, d, f), o.restore()
                }
            })
        }, e.prototype.draw = function() {
            var n, r, i = this,
                s = this,
                o = s.config,
                a = s.ctx,
                l = s._defaultConfig,
                c = s._defaultStyle;
            (n = o.beforeDraw) === null || n === void 0 || n.call(this, a), a.clearRect(-this.Radius, -this.Radius, 2 * this.Radius, 2 * this.Radius), this.prizeRadius = this.blocks.reduce(function(p, b, y) {
                return i.drawBlock(p, b, y), p - i.getLength(b.padding && b.padding.split(" ")[0])
            }, this.Radius), this.prizeDeg = 360 / this.prizes.length, this.prizeAng = oo(this.prizeDeg);
            var u = this.prizeRadius * Math.sin(this.prizeAng / 2) * 2,
                d = oo(this.rotateDeg - 90 + this.prizeDeg / 2 + l.offsetDegree),
                f = function(p, b) {
                    return i.getOffsetX(a.measureText(b).width) + i.getLength(p.left, u)
                },
                h = function(p, b, y) {
                    var m = p.lineHeight || c.lineHeight || p.fontSize || c.fontSize;
                    return i.getLength(p.top, b) + (y + 1) * i.getLength(m)
                };
            a.save(), this.prizes.forEach(function(p, b) {
                var y = d + b * i.prizeAng,
                    m = i.prizeRadius - i.maxBtnRadius,
                    g = p.background || c.background;
                bs(g) && (a.fillStyle = g, function(x, w, S, C, A, T) {
                    x.beginPath();
                    var E, P, B = oo(90 / Math.PI / S * T),
                        F = C + B,
                        H = A - B;
                    x.arc(0, 0, S, F, H, !1), x.lineTo.apply(x, (E = (C + A) / 2, P = T / 2 / Math.abs(Math.sin((C - A) / 2)), [+(Math.cos(E) * P).toFixed(8), +(Math.sin(E) * P).toFixed(8)])), x.closePath()
                }(a, i.maxBtnRadius, i.prizeRadius, y - i.prizeAng / 2, y + i.prizeAng / 2, i.getLength(l.gutter)), a.fill());
                var v = Math.cos(y) * i.prizeRadius,
                    _ = Math.sin(y) * i.prizeRadius;
                a.translate(v, _), a.rotate(y + oo(90)), p.imgs && p.imgs.forEach(function(x, w) {
                    var S = i.ImageCache.get(x.src);
                    if (S) {
                        var C = i.computedWidthAndHeight(S, x, i.prizeAng * i.prizeRadius, m),
                            A = C[0],
                            T = C[1],
                            E = [i.getOffsetX(A) + i.getLength(x.left, u), i.getLength(x.top, m)],
                            P = E[0],
                            B = E[1];
                        i.drawImage(a, S, P, B, A, T)
                    }
                }), p.fonts && p.fonts.forEach(function(x) {
                    var w = x.fontColor || c.fontColor,
                        S = x.fontWeight || c.fontWeight,
                        C = i.getLength(x.fontSize || c.fontSize),
                        A = x.fontStyle || c.fontStyle,
                        T = _l(x, "wordWrap") ? x.wordWrap : c.wordWrap,
                        E = x.lengthLimit || c.lengthLimit,
                        P = x.lineClamp || c.lineClamp;
                    a.fillStyle = w, a.font = S + " " + (C >> 0) + "px " + A;
                    var B = String(x.text);
                    (T ? bx(a, _x(B), function(F) {
                        var H = (i.prizeRadius - h(x, m, F.length)) * Math.tan(i.prizeAng / 2) * 2 - i.getLength(l.gutter);
                        return i.getLength(E, H)
                    }, P) : B.split(`
`)).filter(function(F) {
                        return !!F
                    }).forEach(function(F, H) {
                        a.fillText(F, f(x, F), h(x, m, H))
                    })
                }), a.rotate(oo(360) - y - oo(90)), a.translate(-v, -_)
            }), a.restore(), this.buttons.forEach(function(p, b) {
                var y = i.getLength(p.radius, i.prizeRadius);
                i.maxBtnRadius = Math.max(i.maxBtnRadius, y), bs(p.background) && (a.beginPath(), a.fillStyle = p.background, a.arc(0, 0, y, 0, 2 * Math.PI, !1), a.fill()), p.pointer && bs(p.background) && (a.beginPath(), a.fillStyle = p.background, a.moveTo(-y, 0), a.lineTo(y, 0), a.lineTo(0, 2 * -y), a.closePath(), a.fill()), p.imgs && p.imgs.forEach(function(m, g) {
                    var v = i.ImageCache.get(m.src);
                    if (v) {
                        var _ = i.computedWidthAndHeight(v, m, 2 * y, 2 * y),
                            x = _[0],
                            w = _[1],
                            S = [i.getOffsetX(x) + i.getLength(m.left, y), i.getLength(m.top, y)],
                            C = S[0],
                            A = S[1];
                        i.drawImage(a, v, C, A, x, w)
                    }
                }), p.fonts && p.fonts.forEach(function(m) {
                    var g = m.fontColor || c.fontColor,
                        v = m.fontWeight || c.fontWeight,
                        _ = i.getLength(m.fontSize || c.fontSize),
                        x = m.fontStyle || c.fontStyle;
                    a.fillStyle = g, a.font = v + " " + (_ >> 0) + "px " + x, String(m.text).split(`
`).forEach(function(w, S) {
                        a.fillText(w, f(m, w), h(m, y, S))
                    })
                })
            }), (r = o.afterDraw) === null || r === void 0 || r.call(this, a)
        }, e.prototype.carveOnGunwaleOfAMovingBoat = function() {
            var n = this,
                r = n._defaultConfig,
                i = n.prizeFlag,
                s = n.prizeDeg,
                o = n.rotateDeg;
            this.endTime = Date.now();
            for (var a = this.stopDeg = o, l = r.speed, c = (Math.random() * s - s / 2) * this.getLength(r.stopRange), u = 0, d = 0, f = 0; ++u;) {
                var h = 360 * u - i * s - o - r.offsetDegree + c - s / 2,
                    p = bl(this.FPS, a, h, r.decelerationTime) - a;
                if (p > l) {
                    this.endDeg = l - d > p - l ? h : f;
                    break
                }
                f = h, d = p
            }
        }, e.prototype.play = function() {
            var n, r;
            this.step === 0 && (this.startTime = Date.now(), this.prizeFlag = void 0, this.step = 1, (r = (n = this.config).afterStart) === null || r === void 0 || r.call(n), this.run())
        }, e.prototype.stop = function(n) {
            if (this.step !== 0 && this.step !== 3) {
                if (!n && n !== 0) {
                    var r = this.prizes.map(function(i) {
                        return i.range
                    });
                    n = yB(r)
                }
                n < 0 ? (this.step = 0, this.prizeFlag = -1) : (this.step = 2, this.prizeFlag = n % this.prizes.length)
            }
        }, e.prototype.run = function(n) {
            var r;
            n === void 0 && (n = 0);
            var i = this,
                s = i.rAF,
                o = i.step,
                a = i.prizeFlag,
                l = i._defaultConfig,
                c = l.accelerationTime,
                u = l.decelerationTime,
                d = l.speed;
            if (o !== 0) {
                if (a !== -1) {
                    o !== 3 || this.endDeg || this.carveOnGunwaleOfAMovingBoat();
                    var f = Date.now() - this.startTime,
                        h = Date.now() - this.endTime,
                        p = this.rotateDeg;
                    if (o === 1 || f < c) {
                        this.FPS = f / n;
                        var b = wx(f, 0, d, c);
                        b === d && (this.step = 2), p += b % 360
                    } else o === 2 ? (p += d % 360, a !== void 0 && a >= 0 && (this.step = 3, this.stopDeg = 0, this.endDeg = 0)) : o === 3 ? (p = bl(h, this.stopDeg, this.endDeg, u), h >= u && (this.step = 0)) : this.stop(-1);
                    this.rotateDeg = p, this.draw(), s(this.run.bind(this, n + 1))
                }
            } else(r = this.endCallback) === null || r === void 0 || r.call(this, this.prizes.find(function(y, m) {
                return m === a
            }) || {})
        }, e.prototype.conversionAxis = function(n, r) {
            var i = this.config;
            return [n / i.dpr - this.Radius, r / i.dpr - this.Radius]
        }, e
    }(xx),
    Dle = function(t) {
        function e(n, r) {
            var i, s = t.call(this, n, {
                width: r.width,
                height: r.height
            }) || this;
            return s.rows = 3, s.cols = 3, s.blocks = [], s.prizes = [], s.buttons = [], s.defaultConfig = {}, s.defaultStyle = {}, s.activeStyle = {}, s._defaultConfig = {}, s._defaultStyle = {}, s._activeStyle = {}, s.cellWidth = 0, s.cellHeight = 0, s.startTime = 0, s.endTime = 0, s.currIndex = 0, s.stopIndex = 0, s.endIndex = 0, s.demo = !1, s.timer = 0, s.FPS = 16.6, s.step = 0, s.prizeFlag = -1, s.cells = [], s.ImageCache = new Map, s.initData(r), s.initWatch(), s.initComputed(), (i = n.beforeCreate) === null || i === void 0 || i.call(s), s.init(), s
        }
        return yx(e, t), e.prototype.resize = function() {
            var n, r;
            t.prototype.resize.call(this), this.draw(), (r = (n = this.config).afterResize) === null || r === void 0 || r.call(n)
        }, e.prototype.initLucky = function() {
            this.cellWidth = 0, this.cellHeight = 0, this.startTime = 0, this.endTime = 0, this.currIndex = 0, this.stopIndex = 0, this.endIndex = 0, this.demo = !1, this.timer = 0, this.FPS = 16.6, this.prizeFlag = -1, this.step = 0, t.prototype.initLucky.call(this)
        }, e.prototype.initData = function(n) {
            this.$set(this, "width", n.width || "300px"), this.$set(this, "height", n.height || "300px"), this.$set(this, "rows", Number(n.rows) || 3), this.$set(this, "cols", Number(n.cols) || 3), this.$set(this, "blocks", n.blocks || []), this.$set(this, "prizes", n.prizes || []), this.$set(this, "buttons", n.buttons || []), this.$set(this, "button", n.button), this.$set(this, "defaultConfig", n.defaultConfig || {}), this.$set(this, "defaultStyle", n.defaultStyle || {}), this.$set(this, "activeStyle", n.activeStyle || {}), this.$set(this, "startCallback", n.start), this.$set(this, "endCallback", n.end)
        }, e.prototype.initComputed = function() {
            var n = this;
            this.$computed(this, "_defaultConfig", function() {
                var r = ki({
                    gutter: 5,
                    speed: 20,
                    accelerationTime: 2500,
                    decelerationTime: 2500
                }, n.defaultConfig);
                return r.gutter = n.getLength(r.gutter), r.speed = r.speed / 40, r
            }), this.$computed(this, "_defaultStyle", function() {
                return ki({
                    borderRadius: 20,
                    fontColor: "#000",
                    fontSize: "18px",
                    fontStyle: "sans-serif",
                    fontWeight: "400",
                    background: "rgba(0,0,0,0)",
                    shadow: "",
                    wordWrap: !0,
                    lengthLimit: "90%"
                }, n.defaultStyle)
            }), this.$computed(this, "_activeStyle", function() {
                return ki({
                    background: "#ffce98",
                    shadow: ""
                }, n.activeStyle)
            })
        }, e.prototype.initWatch = function() {
            var n = this;
            this.$watch("width", function(r) {
                n.data.width = r, n.resize()
            }), this.$watch("height", function(r) {
                n.data.height = r, n.resize()
            }), this.$watch("blocks", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("prizes", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("buttons", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("rows", function() {
                return n.init()
            }), this.$watch("cols", function() {
                return n.init()
            }), this.$watch("defaultConfig", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("defaultStyle", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("activeStyle", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("startCallback", function() {
                return n.init()
            }), this.$watch("endCallback", function() {
                return n.init()
            })
        }, e.prototype.init = function() {
            var n, r;
            return Bi(this, void 0, void 0, function() {
                var i;
                return Di(this, function(s) {
                    switch (s.label) {
                        case 0:
                            return this.initLucky(), i = this.config, (n = i.beforeInit) === null || n === void 0 || n.call(this), this.draw(), [4, this.initImageCache()];
                        case 1:
                            return s.sent(), (r = i.afterInit) === null || r === void 0 || r.call(this), [2]
                    }
                })
            })
        }, e.prototype.initImageCache = function() {
            var n = this;
            return new Promise(function(r) {
                var i = n.buttons.map(function(o) {
                    return o.imgs
                });
                n.button && i.push(n.button.imgs);
                var s = {
                    blocks: n.blocks.map(function(o) {
                        return o.imgs
                    }),
                    prizes: n.prizes.map(function(o) {
                        return o.imgs
                    }),
                    buttons: i
                };
                Object.keys(s).forEach(function(o) {
                    var a = s[o],
                        l = [];
                    a && a.forEach(function(c, u) {
                        c && c.forEach(function(d, f) {
                            l.push(n.loadAndCacheImg(o, u, f))
                        })
                    }), Promise.all(l).then(function() {
                        n.draw(), r()
                    })
                })
            })
        }, e.prototype.handleClick = function(n) {
            var r = this,
                i = this.ctx;
            Ha(Ha([], this.buttons), [this.button]).forEach(function(s) {
                var o;
                if (s) {
                    var a = r.getGeometricProperty([s.x, s.y, s.col || 1, s.row || 1]),
                        l = a[0],
                        c = a[1],
                        u = a[2],
                        d = a[3];
                    i.beginPath(), i.rect(l, c, u, d), i.isPointInPath(n.offsetX, n.offsetY) && r.step === 0 && (typeof s.callback == "function" && s.callback.call(r, s), (o = r.startCallback) === null || o === void 0 || o.call(r, n, s))
                }
            })
        }, e.prototype.loadAndCacheImg = function(n, r, i) {
            return Bi(this, void 0, void 0, function() {
                var s = this;
                return Di(this, function(o) {
                    return [2, new Promise(function(a, l) {
                        var c = s[n][r];
                        if (n === "buttons" && !s.buttons.length && s.button && (c = s.button), c && c.imgs) {
                            var u = c.imgs[i];
                            if (u) {
                                var d = [s.loadImg(u.src, u), u.activeSrc && s.loadImg(u.activeSrc, u, "$activeResolve")];
                                Promise.all(d).then(function(f) {
                                    var h = f[0],
                                        p = f[1];
                                    return Bi(s, void 0, void 0, function() {
                                        var b;
                                        return Di(this, function(y) {
                                            switch (y.label) {
                                                case 0:
                                                    return typeof(b = u.formatter) != "function" ? [3, 3] : [4, Promise.resolve(b.call(this, h))];
                                                case 1:
                                                    return h = y.sent(), p ? [4, Promise.resolve(b.call(this, p))] : [3, 3];
                                                case 2:
                                                    p = y.sent(), y.label = 3;
                                                case 3:
                                                    return this.ImageCache.set(u.src, h), p && this.ImageCache.set(u.activeSrc, p), a(), [2]
                                            }
                                        })
                                    })
                                }).catch(function(f) {
                                    console.error(n + "[" + r + "].imgs[" + i + "] " + f), l()
                                })
                            }
                        }
                    })]
                })
            })
        }, e.prototype.draw = function() {
            var n, r, i = this,
                s = this,
                o = s.config,
                a = s.ctx,
                l = s._defaultConfig,
                c = s._defaultStyle,
                u = s._activeStyle;
            (n = o.beforeDraw) === null || n === void 0 || n.call(this, a), a.clearRect(0, 0, this.boxWidth, this.boxHeight), this.cells = Ha(Ha([], this.prizes), this.buttons), this.button && this.cells.push(this.button), this.cells.forEach(function(d) {
                d.col = d.col || 1, d.row = d.row || 1
            }), this.prizeArea = this.blocks.reduce(function(d, f, h) {
                var p = d.x,
                    b = d.y,
                    y = d.w,
                    m = d.h,
                    g = vB(f, i.getLength.bind(i)),
                    v = g[0],
                    _ = g[1],
                    x = g[2],
                    w = g[3],
                    S = f.borderRadius ? i.getLength(f.borderRadius) : 0,
                    C = f.background;
                return bs(C) && (a.fillStyle = i.handleBackground(p, b, y, m, C), xh(a, p, b, y, m, S), a.fill()), f.imgs && f.imgs.forEach(function(A, T) {
                    var E = i.ImageCache.get(A.src);
                    if (E) {
                        var P = i.computedWidthAndHeight(E, A, y, m),
                            B = P[0],
                            F = P[1],
                            H = [i.getOffsetX(B, y) + i.getLength(A.left, y), i.getLength(A.top, m)],
                            k = H[0],
                            N = H[1];
                        i.drawImage(a, E, p + k, b + N, B, F)
                    }
                }), {
                    x: p + x,
                    y: b + v,
                    w: y - x - w,
                    h: m - v - _
                }
            }, {
                x: 0,
                y: 0,
                w: this.boxWidth,
                h: this.boxHeight
            }), this.cellWidth = (this.prizeArea.w - l.gutter * (this.cols - 1)) / this.cols, this.cellHeight = (this.prizeArea.h - l.gutter * (this.rows - 1)) / this.rows, this.cells.forEach(function(d, f) {
                var h = i.getGeometricProperty([d.x, d.y, d.col, d.row]),
                    p = h[0],
                    b = h[1],
                    y = h[2],
                    m = h[3],
                    g = !1;
                (i.prizeFlag === void 0 || i.prizeFlag > -1) && (g = f === i.currIndex % i.prizes.length >> 0);
                var v = g ? u.background : d.background || c.background;
                if (bs(v)) {
                    var _ = (g ? u.shadow : d.shadow || c.shadow).replace(/px/g, "").split(",")[0].split(" ").map(function(w, S) {
                        return S < 3 ? Number(w) : w
                    });
                    _.length === 4 && (a.shadowColor = _[3], a.shadowOffsetX = _[0] * o.dpr, a.shadowOffsetY = _[1] * o.dpr, a.shadowBlur = _[2], _[0] > 0 ? y -= _[0] : (y += _[0], p -= _[0]), _[1] > 0 ? m -= _[1] : (m += _[1], b -= _[1])), a.fillStyle = i.handleBackground(p, b, y, m, v);
                    var x = i.getLength(d.borderRadius ? d.borderRadius : c.borderRadius);
                    xh(a, p, b, y, m, x), a.fill(), a.shadowColor = "rgba(0, 0, 0, 0)", a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0
                }
                f >= i.prizes.length && (f -= i.prizes.length), d.imgs && d.imgs.forEach(function(w, S) {
                    var C = i.ImageCache.get(w.src),
                        A = i.ImageCache.get(w.activeSrc);
                    if (C) {
                        var T = g && A || C;
                        if (T) {
                            var E = i.computedWidthAndHeight(T, w, y, m),
                                P = E[0],
                                B = E[1],
                                F = [p + i.getOffsetX(P, y) + i.getLength(w.left, y), b + i.getLength(w.top, m)],
                                H = F[0],
                                k = F[1];
                            i.drawImage(a, T, H, k, P, B)
                        }
                    }
                }), d.fonts && d.fonts.forEach(function(w) {
                    var S = g && u.fontStyle ? u.fontStyle : w.fontStyle || c.fontStyle,
                        C = g && u.fontWeight ? u.fontWeight : w.fontWeight || c.fontWeight,
                        A = g && u.fontSize ? i.getLength(u.fontSize) : i.getLength(w.fontSize || c.fontSize),
                        T = g && u.lineHeight ? u.lineHeight : w.lineHeight || c.lineHeight || w.fontSize || c.fontSize,
                        E = _l(w, "wordWrap") ? w.wordWrap : c.wordWrap,
                        P = w.lengthLimit || c.lengthLimit,
                        B = w.lineClamp || c.lineClamp;
                    a.font = C + " " + (A >> 0) + "px " + S, a.fillStyle = g && u.fontColor ? u.fontColor : w.fontColor || c.fontColor;
                    var F = [],
                        H = String(w.text);
                    if (E) {
                        var k = i.getLength(P, y);
                        F = bx(a, _x(H), function() {
                            return k
                        }, B)
                    } else F = H.split(`
`);
                    F.forEach(function(N, V) {
                        a.fillText(N, p + i.getOffsetX(a.measureText(N).width, y) + i.getLength(w.left, y), b + i.getLength(w.top, m) + (V + 1) * i.getLength(T))
                    })
                })
            }), (r = o.afterDraw) === null || r === void 0 || r.call(this, a)
        }, e.prototype.handleBackground = function(n, r, i, s, o) {
            var a = this.ctx;
            return o.includes("linear-gradient") && (o = function(l, c, u, d, f, h) {
                var p = /linear-gradient\((.+)\)/.exec(h)[1].split(",").map(function(v) {
                        return v.trim()
                    }),
                    b = p.shift(),
                    y = [0, 0, 0, 0];
                if (b.includes("deg")) {
                    var m = function(v) {
                        return Math.tan(v / 180 * Math.PI)
                    };
                    (b = b.slice(0, -3) % 360) >= 0 && b < 45 ? y = [c, u + f, c + d, u + f - d * m(b - 0)] : b >= 45 && b < 90 ? y = [c, u + f, c + d - f * m(b - 45), u] : b >= 90 && b < 135 ? y = [c + d, u + f, c + d - f * m(b - 90), u] : b >= 135 && b < 180 ? y = [c + d, u + f, c, u + d * m(b - 135)] : b >= 180 && b < 225 ? y = [c + d, u, c, u + d * m(b - 180)] : b >= 225 && b < 270 ? y = [c + d, u, c + f * m(b - 225), u + f] : b >= 270 && b < 315 ? y = [c, u, c + f * m(b - 270), u + f] : b >= 315 && b < 360 && (y = [c, u, c + d, u + f - d * m(b - 315)])
                } else b.includes("top") ? y = [c, u + f, c, u] : b.includes("bottom") ? y = [c, u, c, u + f] : b.includes("left") ? y = [c + d, u, c, u] : b.includes("right") && (y = [c, u, c + d, u]);
                var g = l.createLinearGradient.apply(l, y.map(function(v) {
                    return v >> 0
                }));
                return p.reduce(function(v, _, x) {
                    var w = _.split(" ");
                    return w.length === 1 ? v.addColorStop(x, w[0]) : w.length === 2 && v.addColorStop.apply(v, w), v
                }, g)
            }(a, n, r, i, s, o)), o
        }, e.prototype.carveOnGunwaleOfAMovingBoat = function() {
            var n = this,
                r = n._defaultConfig,
                i = n.prizeFlag,
                s = n.currIndex;
            this.endTime = Date.now();
            for (var o = this.stopIndex = s, a = r.speed, l = 0, c = 0, u = 0; ++l;) {
                var d = this.prizes.length * l + i - o,
                    f = bl(this.FPS, o, d, r.decelerationTime) - o;
                if (f > a) {
                    this.endIndex = a - c > f - a ? d : u;
                    break
                }
                u = d, c = f
            }
        }, e.prototype.play = function() {
            var n, r;
            this.step === 0 && (this.startTime = Date.now(), this.prizeFlag = void 0, this.step = 1, (r = (n = this.config).afterStart) === null || r === void 0 || r.call(n), this.run())
        }, e.prototype.stop = function(n) {
            if (this.step !== 0 && this.step !== 3) {
                if (!n && n !== 0) {
                    var r = this.prizes.map(function(i) {
                        return i.range
                    });
                    n = yB(r)
                }
                n < 0 ? (this.step = 0, this.prizeFlag = -1) : (this.step = 2, this.prizeFlag = n % this.prizes.length)
            }
        }, e.prototype.run = function(n) {
            var r;
            n === void 0 && (n = 0);
            var i = this,
                s = i.rAF,
                o = i.step,
                a = i.prizes,
                l = i.prizeFlag,
                c = i._defaultConfig,
                u = c.accelerationTime,
                d = c.decelerationTime,
                f = c.speed;
            if (o !== 0) {
                if (l !== -1) {
                    o !== 3 || this.endIndex || this.carveOnGunwaleOfAMovingBoat();
                    var h = Date.now() - this.startTime,
                        p = Date.now() - this.endTime,
                        b = this.currIndex;
                    if (o === 1 || h < u) {
                        this.FPS = h / n;
                        var y = wx(h, .1, f - .1, u);
                        y === f && (this.step = 2), b += y % a.length
                    } else o === 2 ? (b += f % a.length, l !== void 0 && l >= 0 && (this.step = 3, this.stopIndex = 0, this.endIndex = 0)) : o === 3 ? (b = bl(p, this.stopIndex, this.endIndex, d), p >= d && (this.step = 0)) : this.stop(-1);
                    this.currIndex = b, this.draw(), s(this.run.bind(this, n + 1))
                }
            } else(r = this.endCallback) === null || r === void 0 || r.call(this, this.prizes.find(function(m, g) {
                return g === l
            }) || {})
        }, e.prototype.getGeometricProperty = function(n) {
            var r = n[0],
                i = n[1],
                s = n[2],
                o = s === void 0 ? 1 : s,
                a = n[3],
                l = a === void 0 ? 1 : a,
                c = this.cellWidth,
                u = this.cellHeight,
                d = this._defaultConfig.gutter,
                f = [this.prizeArea.x + (c + d) * r, this.prizeArea.y + (u + d) * i];
            return o && l && f.push(c * o + d * (o - 1), u * l + d * (l - 1)), f
        }, e.prototype.conversionAxis = function(n, r) {
            var i = this.config;
            return [n / i.dpr, r / i.dpr]
        }, e
    }(xx),
    $le = function(t) {
        function e(n, r) {
            var i, s = t.call(this, n, {
                width: r.width,
                height: r.height
            }) || this;
            return s.blocks = [], s.prizes = [], s.slots = [], s.defaultConfig = {}, s._defaultConfig = {}, s.defaultStyle = {}, s._defaultStyle = {}, s.endCallback = function() {}, s.cellWidth = 0, s.cellHeight = 0, s.cellAndSpacing = 0, s.widthAndSpacing = 0, s.heightAndSpacing = 0, s.FPS = 16.6, s.scroll = [], s.stopScroll = [], s.endScroll = [], s.startTime = 0, s.endTime = 0, s.step = 0, s.prizeFlag = void 0, s.ImageCache = new Map, s.initData(r), s.initWatch(), s.initComputed(), (i = n.beforeCreate) === null || i === void 0 || i.call(s), s.init(), s
        }
        return yx(e, t), e.prototype.resize = function() {
            var n, r;
            t.prototype.resize.call(this), this.draw(), (r = (n = this.config).afterResize) === null || r === void 0 || r.call(n)
        }, e.prototype.initLucky = function() {
            this.cellWidth = 0, this.cellHeight = 0, this.cellAndSpacing = 0, this.widthAndSpacing = 0, this.heightAndSpacing = 0, this.FPS = 16.6, this.scroll = [], this.stopScroll = [], this.endScroll = [], this.startTime = 0, this.endTime = 0, this.prizeFlag = void 0, this.step = 0, t.prototype.initLucky.call(this)
        }, e.prototype.initData = function(n) {
            this.$set(this, "width", n.width || "300px"), this.$set(this, "height", n.height || "300px"), this.$set(this, "blocks", n.blocks || []), this.$set(this, "prizes", n.prizes || []), this.$set(this, "slots", n.slots || []), this.$set(this, "defaultConfig", n.defaultConfig || {}), this.$set(this, "defaultStyle", n.defaultStyle || {}), this.$set(this, "endCallback", n.end)
        }, e.prototype.initComputed = function() {
            var n = this;
            this.$computed(this, "_defaultConfig", function() {
                var r = ki({
                    mode: "vertical",
                    rowSpacing: 0,
                    colSpacing: 5,
                    speed: 20,
                    direction: 1,
                    accelerationTime: 2500,
                    decelerationTime: 2500
                }, n.defaultConfig);
                return r.rowSpacing = n.getLength(r.rowSpacing), r.colSpacing = n.getLength(r.colSpacing), r
            }), this.$computed(this, "_defaultStyle", function() {
                return ki({
                    borderRadius: 0,
                    fontColor: "#000",
                    fontSize: "18px",
                    fontStyle: "sans-serif",
                    fontWeight: "400",
                    background: "rgba(0,0,0,0)",
                    wordWrap: !0,
                    lengthLimit: "90%"
                }, n.defaultStyle)
            })
        }, e.prototype.initWatch = function() {
            var n = this;
            this.$watch("width", function(r) {
                n.data.width = r, n.resize()
            }), this.$watch("height", function(r) {
                n.data.height = r, n.resize()
            }), this.$watch("blocks", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("prizes", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("slots", function(r) {
                n.drawOffscreenCanvas(), n.draw()
            }, {
                deep: !0
            }), this.$watch("defaultConfig", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("defaultStyle", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("endCallback", function() {
                return n.init()
            })
        }, e.prototype.init = function() {
            var n, r;
            return Bi(this, void 0, void 0, function() {
                var i;
                return Di(this, function(s) {
                    switch (s.label) {
                        case 0:
                            return this.initLucky(), i = this.config, (n = i.beforeInit) === null || n === void 0 || n.call(this), this.drawOffscreenCanvas(), this.draw(), [4, this.initImageCache()];
                        case 1:
                            return s.sent(), (r = i.afterInit) === null || r === void 0 || r.call(this), [2]
                    }
                })
            })
        }, e.prototype.initImageCache = function() {
            var n = this;
            return new Promise(function(r) {
                var i = {
                    blocks: n.blocks.map(function(s) {
                        return s.imgs
                    }),
                    prizes: n.prizes.map(function(s) {
                        return s.imgs
                    })
                };
                Object.keys(i).forEach(function(s) {
                    var o = i[s],
                        a = [];
                    o && o.forEach(function(l, c) {
                        l && l.forEach(function(u, d) {
                            a.push(n.loadAndCacheImg(s, c, d))
                        })
                    }), Promise.all(a).then(function() {
                        n.drawOffscreenCanvas(), n.draw(), r()
                    })
                })
            })
        }, e.prototype.loadAndCacheImg = function(n, r, i) {
            return Bi(this, void 0, void 0, function() {
                var s = this;
                return Di(this, function(o) {
                    return [2, new Promise(function(a, l) {
                        var c = s[n][r];
                        if (c && c.imgs) {
                            var u = c.imgs[i];
                            u && s.loadImg(u.src, u).then(function(d) {
                                return Bi(s, void 0, void 0, function() {
                                    return Di(this, function(f) {
                                        switch (f.label) {
                                            case 0:
                                                return typeof u.formatter != "function" ? [3, 2] : [4, Promise.resolve(u.formatter.call(this, d))];
                                            case 1:
                                                d = f.sent(), f.label = 2;
                                            case 2:
                                                return this.ImageCache.set(u.src, d), a(), [2]
                                        }
                                    })
                                })
                            }).catch(function(d) {
                                console.error(n + "[" + r + "].imgs[" + i + "] " + d), l()
                            })
                        }
                    })]
                })
            })
        }, e.prototype.drawOffscreenCanvas = function() {
            var n = this,
                r = this._defaultConfig,
                i = this._defaultStyle,
                s = this.drawBlocks(),
                o = s.w,
                a = s.h,
                l = this.prizes.length,
                c = this.displacementWidthOrHeight(),
                u = c.cellWidth,
                d = c.cellHeight,
                f = c.widthAndSpacing,
                h = c.heightAndSpacing,
                p = new Array(l).fill(void 0).map(function(_, x) {
                    return x
                }),
                b = 0,
                y = 0;
            this.slots.forEach(function(_, x) {
                n.scroll[x] === void 0 && (n.scroll[x] = 0), _.order = _.order || p;
                var w = _.order.length;
                b = Math.max(b, o + f * w), y = Math.max(y, a + h * w)
            });
            var m = this.getOffscreenCanvas(b, y),
                g = m._offscreenCanvas,
                v = m._ctx;
            this._offscreenCanvas = g, this.slots.forEach(function(_, x) {
                var w = u * x,
                    S = d * x,
                    C = 0,
                    A = function(Y, le) {
                        for (var ae = {}, W = [], Q = 0; Q < Y.length; Q++) ae[Q] = Y[Q];
                        for (Q = 0; Q < le.length; Q++) {
                            var fe = ae[le[Q]];
                            fe && (W[Q] = fe)
                        }
                        return W
                    }(n.prizes, _.order);
                if (A.length) {
                    A.forEach(function(Y, le) {
                        if (Y) {
                            _.order[le];
                            var ae = f * le + r.colSpacing / 2,
                                W = h * le + r.rowSpacing / 2,
                                Q = n.displacement([w, W, h], [ae, S, f]),
                                fe = Q[0],
                                D = Q[1],
                                X = Q[2];
                            C += X;
                            var $ = Y.background || i.background;
                            if (bs($)) {
                                var Z = n.getLength(_l(Y, "borderRadius") ? Y.borderRadius : i.borderRadius);
                                xh(v, fe, D, u, u, Z), v.fillStyle = $, v.fill()
                            }
                            Y.imgs && Y.imgs.forEach(function(K, ce) {
                                var de = n.ImageCache.get(K.src);
                                if (de) {
                                    var ge = n.computedWidthAndHeight(de, K, u, d),
                                        O = ge[0],
                                        L = ge[1],
                                        j = [fe + n.getOffsetX(O, u) + n.getLength(K.left, u), D + n.getLength(K.top, d)],
                                        ie = j[0],
                                        oe = j[1];
                                    n.drawImage(v, de, ie, oe, O, L)
                                }
                            }), Y.fonts && Y.fonts.forEach(function(K) {
                                var ce = K.fontStyle || i.fontStyle,
                                    de = K.fontWeight || i.fontWeight,
                                    ge = n.getLength(K.fontSize || i.fontSize),
                                    O = K.lineHeight || i.lineHeight || K.fontSize || i.fontSize,
                                    L = _l(K, "wordWrap") ? K.wordWrap : i.wordWrap,
                                    j = K.lengthLimit || i.lengthLimit,
                                    ie = K.lineClamp || i.lineClamp;
                                v.font = de + " " + (ge >> 0) + "px " + ce, v.fillStyle = K.fontColor || i.fontColor;
                                var oe = [],
                                    R = String(K.text);
                                if (L) {
                                    var M = n.getLength(j, u);
                                    oe = bx(v, _x(R), function() {
                                        return M
                                    }, ie)
                                } else oe = R.split(`
`);
                                oe.forEach(function(U, q) {
                                    v.fillText(U, fe + n.getOffsetX(v.measureText(U).width, u) + n.getLength(K.left, u), D + n.getLength(K.top, d) + (q + 1) * n.getLength(O))
                                })
                            })
                        }
                    });
                    for (var T = n.displacement([w, 0, u, C], [0, S, C, d]), E = T[0], P = T[1], B = T[2], F = T[3], H = C; H < y + C;) {
                        var k = n.displacement([E, H], [H, P]),
                            N = k[0],
                            V = k[1];
                        n.drawImage(v, g, E, P, B, F, N, V, B, F), H += C
                    }
                }
            })
        }, e.prototype.drawBlocks = function() {
            var n = this,
                r = this;
            r.config;
            var i = r.ctx;
            r._defaultConfig;
            var s = r._defaultStyle;
            return this.prizeArea = this.blocks.reduce(function(o, a, l) {
                var c = o.x,
                    u = o.y,
                    d = o.w,
                    f = o.h,
                    h = vB(a, n.getLength.bind(n)),
                    p = h[0],
                    b = h[1],
                    y = h[2],
                    m = h[3],
                    g = a.borderRadius ? n.getLength(a.borderRadius) : 0,
                    v = a.background || s.background;
                return bs(v) && (xh(i, c, u, d, f, g), i.fillStyle = v, i.fill()), a.imgs && a.imgs.forEach(function(_, x) {
                    var w = n.ImageCache.get(_.src);
                    if (w) {
                        var S = n.computedWidthAndHeight(w, _, d, f),
                            C = S[0],
                            A = S[1],
                            T = [n.getOffsetX(C, d) + n.getLength(_.left, d), n.getLength(_.top, f)],
                            E = T[0],
                            P = T[1];
                        n.drawImage(i, w, c + E, u + P, C, A)
                    }
                }), {
                    x: c + y,
                    y: u + p,
                    w: d - y - m,
                    h: f - p - b
                }
            }, {
                x: 0,
                y: 0,
                w: this.boxWidth,
                h: this.boxHeight
            })
        }, e.prototype.draw = function() {
            var n, r = this,
                i = this,
                s = i.config,
                o = i.ctx;
            i._defaultConfig, i._defaultStyle, (n = s.beforeDraw) === null || n === void 0 || n.call(this, o), o.clearRect(0, 0, this.boxWidth, this.boxHeight);
            var a = this.drawBlocks(),
                l = a.x,
                c = a.y,
                u = a.w,
                d = a.h;
            if (this._offscreenCanvas) {
                var f = this,
                    h = f.cellWidth,
                    p = f.cellHeight,
                    b = f.cellAndSpacing,
                    y = f.widthAndSpacing,
                    m = f.heightAndSpacing;
                this.slots.forEach(function(g, v) {
                    var _ = b * g.order.length,
                        x = r.displacement(-(d - m) / 2, -(u - y) / 2),
                        w = r.scroll[v] + x;
                    w < 0 && (w = w % _ + _), w > _ && (w %= _);
                    var S = r.displacement([h * v, w, h, d], [w, p * v, u, p]),
                        C = S[0],
                        A = S[1],
                        T = S[2],
                        E = S[3],
                        P = r.displacement([l + y * v, c, h, d], [l, c + m * v, u, p]),
                        B = P[0],
                        F = P[1],
                        H = P[2],
                        k = P[3];
                    r.drawImage(o, r._offscreenCanvas, C, A, T, E, B, F, H, k)
                })
            }
        }, e.prototype.carveOnGunwaleOfAMovingBoat = function() {
            var n = this,
                r = this,
                i = r._defaultConfig,
                s = r.prizeFlag,
                o = r.cellAndSpacing;
            this.endTime = Date.now(), this.slots.forEach(function(a, l) {
                var c = a.order;
                if (c.length)
                    for (var u = a.speed || i.speed, d = a.direction || i.direction, f = c.findIndex(function(g) {
                            return g === s[l]
                        }), h = o * c.length, p = n.stopScroll[l] = n.scroll[l], b = 0; ++b;) {
                        var y = o * f + h * b * d - p,
                            m = bl(n.FPS, p, y, i.decelerationTime) - p;
                        if (Math.abs(m) > u) {
                            n.endScroll[l] = y;
                            break
                        }
                    }
            })
        }, e.prototype.play = function() {
            var n, r;
            this.step === 0 && (this.startTime = Date.now(), this.prizeFlag = void 0, this.step = 1, (r = (n = this.config).afterStart) === null || r === void 0 || r.call(n), this.run())
        }, e.prototype.stop = function(n) {
            var r;
            if (this.step !== 0 && this.step !== 3) {
                if (typeof n == "number") this.prizeFlag = new Array(this.slots.length).fill(n);
                else {
                    if (!Su(n, "array")) return this.stop(-1), console.error("stop() 无法识别的参数类型 " + typeof n);
                    if (n.length !== this.slots.length) return this.stop(-1), console.error("stop([" + n + "]) 参数长度的不正确");
                    this.prizeFlag = n
                }!((r = this.prizeFlag) === null || r === void 0) && r.includes(-1) ? (this.prizeFlag = [], this.step = 0) : this.step = 2
            }
        }, e.prototype.run = function(n) {
            var r, i, s = this;
            n === void 0 && (n = 0);
            var o = this,
                a = o.rAF,
                l = o.step,
                c = o.prizeFlag,
                u = o._defaultConfig,
                d = o.cellAndSpacing,
                f = o.slots,
                h = u.accelerationTime,
                p = u.decelerationTime;
            if (this.step !== 0 || (c == null ? void 0 : c.length) !== f.length) {
                if (c === void 0 || c.length) {
                    this.step !== 3 || this.endScroll.length || this.carveOnGunwaleOfAMovingBoat();
                    var b = Date.now() - this.startTime,
                        y = Date.now() - this.endTime;
                    f.forEach(function(x, w) {
                        var S = x.order;
                        if (S && S.length) {
                            var C = d * S.length,
                                A = Math.abs(x.speed || u.speed),
                                T = x.direction || u.direction,
                                E = 0,
                                P = s.scroll[w];
                            if (l === 1 || b < h) {
                                s.FPS = b / n;
                                var B = wx(b, 0, A, h);
                                B === A && (s.step = 2), E = (P + B * T) % C
                            } else if (l === 2) E = (P + A * T) % C, (c == null ? void 0 : c.length) === f.length && (s.step = 3, s.stopScroll = [], s.endScroll = []);
                            else if (l === 3 && y) {
                                var F = s.stopScroll[w],
                                    H = s.endScroll[w];
                                E = bl(y, F, H, p), y >= p && (s.step = 0)
                            }
                            s.scroll[w] = E
                        }
                    }), this.draw(), a(this.run.bind(this, n + 1))
                }
            } else {
                for (var m = c[0], g = 0; g < f.length; g++) {
                    var v = f[g],
                        _ = c[g];
                    if (!(!((r = v.order) === null || r === void 0) && r.includes(_)) || m !== _) {
                        m = -1;
                        break
                    }
                }(i = this.endCallback) === null || i === void 0 || i.call(this, this.prizes.find(function(x, w) {
                    return w === m
                }) || void 0)
            }
        }, e.prototype.displacement = function(n, r) {
            return this._defaultConfig.mode === "horizontal" ? r : n
        }, e.prototype.displacementWidthOrHeight = function() {
            var n = this._defaultConfig.mode,
                r = this.slots.length,
                i = this._defaultConfig,
                s = i.colSpacing,
                o = i.rowSpacing,
                a = this.prizeArea || this.drawBlocks();
            a.x, a.y;
            var l, c, u = a.w,
                d = a.h,
                f = 0,
                h = 0;
            return n === "horizontal" ? (h = this.cellHeight = (d - o * (r - 1)) / r, f = this.cellWidth = h) : (f = this.cellWidth = (u - s * (r - 1)) / r, h = this.cellHeight = f), l = this.widthAndSpacing = this.cellWidth + s, c = this.heightAndSpacing = this.cellHeight + o, this.cellAndSpacing = n === "horizontal" ? l : c, {
                cellWidth: f,
                cellHeight: h,
                widthAndSpacing: l,
                heightAndSpacing: c
            }
        }, e
    }(xx),
    Ex = function(t, e, n) {
        e === void 0 && (e = {});
        var r = e.props,
            i = e.domProps,
            s = e.on,
            o = function(c, u) {
                var d = {};
                for (var f in c) Object.prototype.hasOwnProperty.call(c, f) && u.indexOf(f) < 0 && (d[f] = c[f]);
                if (c != null && typeof Object.getOwnPropertySymbols == "function") {
                    var h = 0;
                    for (f = Object.getOwnPropertySymbols(c); h < f.length; h++) u.indexOf(f[h]) < 0 && Object.prototype.propertyIsEnumerable.call(c, f[h]) && (d[f[h]] = c[f[h]])
                }
                return d
            }(e, ["props", "domProps", "on"]),
            a = function(c) {
                return c ? Object.entries(c).reduce(function(u, d) {
                    var f, h = d[0],
                        p = d[1];
                    return h = "on" + (h = h.charAt(0).toUpperCase() + h.slice(1)), Mn(Mn({}, u), ((f = {})[h] = p, f))
                }, {}) : null
            }(s),
            l = Mn(Mn(Mn(Mn({}, o), r), i), a);
        return qt(t, l, n)
    },
    Sx = "@lucky-canvas/vue",
    Fle = ye({
        name: "LuckyWheel",
        props: {
            width: {
                type: [String, Number]
            },
            height: {
                type: [String, Number]
            },
            blocks: {
                type: Array,
                default: function() {
                    return []
                }
            },
            prizes: {
                type: Array,
                default: function() {
                    return []
                }
            },
            buttons: {
                type: Array,
                default: function() {
                    return []
                }
            },
            defaultStyle: {
                type: Object,
                default: function() {
                    return {}
                }
            },
            defaultConfig: {
                type: Object,
                default: function() {
                    return {}
                }
            }
        },
        emits: ["start", "end", "success", "error", "finally"],
        watch: {
            blocks: function(t, e) {
                this.lucky && (this.lucky.blocks = t)
            },
            prizes: function(t, e) {
                this.lucky && (this.lucky.prizes = t)
            },
            buttons: function(t, e) {
                this.lucky && (this.lucky.buttons = t)
            }
        },
        data: function() {
            return {
                lucky: null
            }
        },
        mounted: function() {
            this.$refs.myLucky && this.$refs.myLucky.setAttribute("package", Sx + "@0.1.11");
            try {
                this.initLucky(), this.$emit("success")
            } catch (t) {
                this.$emit("error", t)
            } finally {
                this.$emit("finally")
            }
        },
        methods: {
            initLucky: function() {
                var t = this;
                this.lucky = new Ble({
                    flag: "WEB",
                    width: String(this.width),
                    height: String(this.height),
                    divElement: this.$refs.myLucky,
                    rAF: window.requestAnimationFrame,
                    setTimeout: window.setTimeout,
                    setInterval: window.setInterval,
                    clearTimeout: window.clearTimeout,
                    clearInterval: window.clearInterval
                }, Mn(Mn({}, this.$props), {
                    start: function(e) {
                        t.$emit("start", e)
                    },
                    end: function(e) {
                        t.$emit("end", e)
                    }
                }))
            },
            init: function() {
                this.lucky && this.lucky.init()
            },
            play: function() {
                var t;
                (t = this.lucky) === null || t === void 0 || t.play()
            },
            stop: function(t) {
                var e;
                (e = this.lucky) === null || e === void 0 || e.stop(t)
            }
        },
        render: function() {
            return Ex("div", {
                ref: "myLucky"
            })
        }
    }),
    Lle = ye({
        name: "LuckyGrid",
        props: {
            width: {
                type: [String, Number]
            },
            height: {
                type: [String, Number]
            },
            cols: {
                type: [String, Number],
                default: 3
            },
            rows: {
                type: [String, Number],
                default: 3
            },
            blocks: {
                type: Array,
                default: function() {
                    return []
                }
            },
            prizes: {
                type: Array,
                default: function() {
                    return []
                }
            },
            buttons: {
                type: Array,
                default: function() {
                    return []
                }
            },
            button: {
                type: Object
            },
            defaultStyle: {
                type: Object,
                default: function() {
                    return {}
                }
            },
            activeStyle: {
                type: Object,
                default: function() {
                    return {}
                }
            },
            defaultConfig: {
                type: Object,
                default: function() {
                    return {}
                }
            }
        },
        emits: ["start", "end", "success", "error", "finally"],
        watch: {
            cols: function(t, e) {
                this.lucky && (this.lucky.cols = t)
            },
            rows: function(t, e) {
                this.lucky && (this.lucky.rows = t)
            },
            blocks: function(t, e) {
                this.lucky && (this.lucky.blocks = t)
            },
            prizes: function(t, e) {
                this.lucky && (this.lucky.prizes = t)
            },
            buttons: function(t, e) {
                this.lucky && (this.lucky.buttons = t)
            },
            button: function(t, e) {
                this.lucky && (this.lucky.button = t)
            }
        },
        data: function() {
            return {
                lucky: null
            }
        },
        mounted: function() {
            this.$refs.myLucky && this.$refs.myLucky.setAttribute("package", Sx + "@0.1.11");
            try {
                this.initLucky(), this.$emit("success")
            } catch (t) {
                this.$emit("error", t)
            } finally {
                this.$emit("finally")
            }
        },
        methods: {
            initLucky: function() {
                var t = this;
                this.lucky = new Dle({
                    flag: "WEB",
                    width: String(this.width),
                    height: String(this.height),
                    divElement: this.$refs.myLucky,
                    rAF: window.requestAnimationFrame,
                    setTimeout: window.setTimeout,
                    setInterval: window.setInterval,
                    clearTimeout: window.clearTimeout,
                    clearInterval: window.clearInterval
                }, Mn(Mn({}, this.$props), {
                    start: function(e, n) {
                        t.$emit("start", e, n)
                    },
                    end: function(e) {
                        t.$emit("end", e)
                    }
                }))
            },
            init: function() {
                this.lucky && this.lucky.init()
            },
            play: function() {
                var t;
                (t = this.lucky) === null || t === void 0 || t.play()
            },
            stop: function(t) {
                var e;
                (e = this.lucky) === null || e === void 0 || e.stop(t)
            }
        },
        render: function() {
            return Ex("div", {
                ref: "myLucky"
            })
        }
    }),
    Nle = ye({
        name: "SlotMachine",
        props: {
            width: {
                type: [String, Number]
            },
            height: {
                type: [String, Number]
            },
            blocks: {
                type: Array,
                default: function() {
                    return []
                }
            },
            prizes: {
                type: Array,
                default: function() {
                    return []
                }
            },
            slots: {
                type: Array,
                default: function() {
                    return []
                }
            },
            defaultStyle: {
                type: Object,
                default: function() {
                    return {}
                }
            },
            defaultConfig: {
                type: Object,
                default: function() {
                    return {}
                }
            }
        },
        watch: {
            blocks: function(t, e) {
                this.lucky && (this.lucky.blocks = t)
            },
            slots: function(t, e) {
                this.lucky && (this.lucky.slots = t)
            },
            prizes: function(t, e) {
                this.lucky && (this.lucky.prizes = t)
            }
        },
        data: function() {
            return {
                lucky: null
            }
        },
        mounted: function() {
            this.$refs.myLucky && this.$refs.myLucky.setAttribute("package", Sx + "@0.1.11");
            try {
                this.initLucky(), this.$emit("success")
            } catch (t) {
                this.$emit("error", t)
            } finally {
                this.$emit("finally")
            }
        },
        methods: {
            initLucky: function() {
                var t = this;
                this.lucky = new $le({
                    flag: "WEB",
                    width: String(this.width),
                    height: String(this.height),
                    divElement: this.$refs.myLucky,
                    rAF: window.requestAnimationFrame,
                    setTimeout: window.setTimeout,
                    setInterval: window.setInterval,
                    clearTimeout: window.clearTimeout,
                    clearInterval: window.clearInterval
                }, Mn(Mn({}, this.$props), {
                    start: function(e) {
                        t.$emit("start", e)
                    },
                    end: function(e) {
                        t.$emit("end", e)
                    }
                }))
            },
            init: function() {
                this.lucky && this.lucky.init()
            },
            play: function() {
                var t;
                (t = this.lucky) === null || t === void 0 || t.play()
            },
            stop: function(t) {
                var e;
                (e = this.lucky) === null || e === void 0 || e.stop(t)
            }
        },
        render: function() {
            return Ex("div", {
                ref: "myLucky"
            })
        }
    }),
    Ule = function(t) {
        t.component("LuckyWheel", Fle), t.component("LuckyGrid", Lle), t.component("SlotMachine", Nle)
    };
typeof window < "u" && window.Vue && gB && Ule(window.Vue);
const xB = new Set,
    Kn = new WeakMap,
    Za = new WeakMap,
    Qo = new WeakMap,
    a0 = new WeakMap,
    Gle = new WeakMap,
    xl = new WeakMap,
    wh = new WeakMap;
let Us;
const Co = "__aa_tgt",
    l0 = "__aa_del",
    Hle = t => {
        const e = Yle(t);
        e && e.forEach(n => Xle(n))
    },
    zle = t => {
        t.forEach(e => {
            e.target === Us && Vle(), Kn.has(e.target) && pa(e.target)
        })
    };

function jle(t) {
    const e = a0.get(t);
    e == null || e.disconnect();
    let n = Kn.get(t),
        r = 0;
    const i = 5;
    n || (n = wl(t), Kn.set(t, n));
    const {
        offsetWidth: s,
        offsetHeight: o
    } = Us, l = [n.top - i, s - (n.left + i + n.width), o - (n.top + i + n.height), n.left - i].map(u => `${-1*Math.floor(u)}px`).join(" "), c = new IntersectionObserver(() => {
        ++r > 1 && pa(t)
    }, {
        root: Us,
        threshold: 1,
        rootMargin: l
    });
    c.observe(t), a0.set(t, c)
}

function pa(t) {
    clearTimeout(wh.get(t));
    const e = Wp(t),
        n = typeof e == "function" ? 500 : e.duration;
    wh.set(t, setTimeout(() => {
        const r = Qo.get(t);
        (!r || r.finished) && (Kn.set(t, wl(t)), jle(t))
    }, n))
}

function Vle() {
    clearTimeout(wh.get(Us)), wh.set(Us, setTimeout(() => {
        xB.forEach(t => SB(t, e => wB(() => pa(e))))
    }, 100))
}

function Wle(t) {
    setTimeout(() => {
        Gle.set(t, setInterval(() => wB(pa.bind(null, t)), 2e3))
    }, Math.round(2e3 * Math.random()))
}

function wB(t) {
    typeof requestIdleCallback == "function" ? requestIdleCallback(() => t()) : requestAnimationFrame(() => t())
}
let c0, za;
typeof window < "u" && (Us = document.documentElement, c0 = new MutationObserver(Hle), za = new ResizeObserver(zle), za.observe(Us));

function Yle(t) {
    return t.reduce((e, n) => {
        if (e === !1) return !1;
        if (n.target instanceof Element) {
            if (gg(n.target), !e.has(n.target)) {
                e.add(n.target);
                for (let r = 0; r < n.target.children.length; r++) {
                    const i = n.target.children.item(r);
                    if (i) {
                        if (l0 in i) return !1;
                        gg(n.target, i), e.add(i)
                    }
                }
            }
            if (n.removedNodes.length)
                for (let r = 0; r < n.removedNodes.length; r++) {
                    const i = n.removedNodes[r];
                    if (l0 in i) return !1;
                    i instanceof Element && (e.add(i), gg(n.target, i), Za.set(i, [n.previousSibling, n.nextSibling]))
                }
        }
        return e
    }, new Set)
}

function gg(t, e) {
    !e && !(Co in t) ? Object.defineProperty(t, Co, {
        value: t
    }) : e && !(Co in e) && Object.defineProperty(e, Co, {
        value: t
    })
}

function Xle(t) {
    var e;
    const n = Us.contains(t),
        r = Kn.has(t);
    n && Za.has(t) && Za.delete(t), Qo.has(t) && ((e = Qo.get(t)) === null || e === void 0 || e.cancel()), r && n ? Kle(t) : r && !n ? Jle(t) : qle(t)
}

function Vr(t) {
    return Number(t.replace(/[^0-9.\-]/g, ""))
}

function wl(t) {
    const e = t.getBoundingClientRect();
    return {
        top: e.top + window.scrollY,
        left: e.left + window.scrollX,
        width: e.width,
        height: e.height
    }
}

function EB(t, e, n) {
    let r = e.width,
        i = e.height,
        s = n.width,
        o = n.height;
    const a = getComputedStyle(t);
    if (a.getPropertyValue("box-sizing") === "content-box") {
        const c = Vr(a.paddingTop) + Vr(a.paddingBottom) + Vr(a.borderTopWidth) + Vr(a.borderBottomWidth),
            u = Vr(a.paddingLeft) + Vr(a.paddingRight) + Vr(a.borderRightWidth) + Vr(a.borderLeftWidth);
        r -= u, s -= u, i -= c, o -= c
    }
    return [r, s, i, o].map(Math.round)
}

function Wp(t) {
    return Co in t && xl.has(t[Co]) ? xl.get(t[Co]) : {
        duration: 250,
        easing: "ease-in-out"
    }
}

function SB(t, ...e) {
    e.forEach(n => n(t, xl.has(t)));
    for (let n = 0; n < t.children.length; n++) {
        const r = t.children.item(n);
        r && e.forEach(i => i(r, xl.has(r)))
    }
}

function Kle(t) {
    const e = Kn.get(t),
        n = wl(t);
    let r;
    if (!e) return;
    const i = Wp(t);
    if (typeof i != "function") {
        const s = e.left - n.left,
            o = e.top - n.top,
            [a, l, c, u] = EB(t, e, n),
            d = {
                transform: `translate(${s}px, ${o}px)`
            },
            f = {
                transform: "translate(0, 0)"
            };
        a !== l && (d.width = `${a}px`, f.width = `${l}px`), c !== u && (d.height = `${c}px`, f.height = `${u}px`), r = t.animate([d, f], i)
    } else r = new Animation(i(t, "remain", e, n)), r.play();
    Qo.set(t, r), Kn.set(t, n), r.addEventListener("finish", pa.bind(null, t))
}

function qle(t) {
    const e = wl(t);
    Kn.set(t, e);
    const n = Wp(t);
    let r;
    typeof n != "function" ? r = t.animate([{
        transform: "scale(.98)",
        opacity: 0
    }, {
        transform: "scale(0.98)",
        opacity: 0,
        offset: .5
    }, {
        transform: "scale(1)",
        opacity: 1
    }], {
        duration: n.duration * 1.5,
        easing: "ease-in"
    }) : (r = new Animation(n(t, "add", e)), r.play()), Qo.set(t, r), r.addEventListener("finish", pa.bind(null, t))
}

function Jle(t) {
    if (!Za.has(t) || !Kn.has(t)) return;
    const [e, n] = Za.get(t);
    Object.defineProperty(t, l0, {
        value: !0
    }), n && n.parentNode && n.parentNode instanceof Element ? n.parentNode.insertBefore(t, n) : e && e.parentNode && e.parentNode.appendChild(t);
    const [r, i, s, o] = Zle(t), a = Wp(t), l = Kn.get(t);
    let c;
    Object.assign(t.style, {
        position: "absolute",
        top: `${r}px`,
        left: `${i}px`,
        width: `${s}px`,
        height: `${o}px`,
        margin: 0,
        pointerEvents: "none",
        transformOrigin: "center",
        zIndex: 100
    }), typeof a != "function" ? c = t.animate([{
        transform: "scale(1)",
        opacity: 1
    }, {
        transform: "scale(.98)",
        opacity: 0
    }], {
        duration: a.duration,
        easing: "ease-out"
    }) : (c = new Animation(a(t, "remove", l)), c.play()), Qo.set(t, c), c.addEventListener("finish", () => {
        var u;
        t.remove(), Kn.delete(t), Za.delete(t), Qo.delete(t), (u = a0.get(t)) === null || u === void 0 || u.disconnect()
    })
}

function Zle(t) {
    const e = Kn.get(t),
        [n, , r] = EB(t, e, wl(t));
    let i = t.parentElement;
    for (; i && (getComputedStyle(i).position === "static" || i instanceof HTMLBodyElement);) i = i.parentElement;
    i || (i = document.body);
    const s = getComputedStyle(i),
        o = Kn.get(i) || wl(i),
        a = Math.round(e.top - o.top) - Vr(s.borderTopWidth),
        l = Math.round(e.left - o.left) - Vr(s.borderLeftWidth);
    return [a, l, n, r]
}

function xbe(t, e = {}) {
    c0 && za && (getComputedStyle(t).position === "static" && Object.assign(t.style, {
        position: "relative"
    }), SB(t, pa, Wle, n => za == null ? void 0 : za.observe(n)), typeof e == "function" ? xl.set(t, e) : xl.set(t, {
        duration: 250,
        easing: "ease-in-out",
        ...e
    }), c0.observe(t, {
        childList: !0
    }), xB.add(t))
}
var Gl = TypeError;
const Qle = new Proxy({}, {
        get(t, e) {
            throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${e}" in client code.  See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)
        }
    }),
    ece = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Qle
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    tce = $_(ece);
var Tx = typeof Map == "function" && Map.prototype,
    vg = Object.getOwnPropertyDescriptor && Tx ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
    Eh = Tx && vg && typeof vg.get == "function" ? vg.get : null,
    xT = Tx && Map.prototype.forEach,
    Cx = typeof Set == "function" && Set.prototype,
    yg = Object.getOwnPropertyDescriptor && Cx ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
    Sh = Cx && yg && typeof yg.get == "function" ? yg.get : null,
    wT = Cx && Set.prototype.forEach,
    nce = typeof WeakMap == "function" && WeakMap.prototype,
    Lc = nce ? WeakMap.prototype.has : null,
    rce = typeof WeakSet == "function" && WeakSet.prototype,
    Nc = rce ? WeakSet.prototype.has : null,
    ice = typeof WeakRef == "function" && WeakRef.prototype,
    ET = ice ? WeakRef.prototype.deref : null,
    sce = Boolean.prototype.valueOf,
    oce = Object.prototype.toString,
    ace = Function.prototype.toString,
    lce = String.prototype.match,
    Px = String.prototype.slice,
    xs = String.prototype.replace,
    cce = String.prototype.toUpperCase,
    ST = String.prototype.toLowerCase,
    TB = RegExp.prototype.test,
    TT = Array.prototype.concat,
    Xr = Array.prototype.join,
    uce = Array.prototype.slice,
    CT = Math.floor,
    u0 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
    _g = Object.getOwnPropertySymbols,
    d0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null,
    El = typeof Symbol == "function" && typeof Symbol.iterator == "object",
    Uc = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === El || "symbol") ? Symbol.toStringTag : null,
    CB = Object.prototype.propertyIsEnumerable,
    PT = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
        return t.__proto__
    } : null);

function AT(t, e) {
    if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || TB.call(/e/, e)) return e;
    var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof t == "number") {
        var r = t < 0 ? -CT(-t) : CT(t);
        if (r !== t) {
            var i = String(r),
                s = Px.call(e, i.length + 1);
            return xs.call(i, n, "$&_") + "." + xs.call(xs.call(s, /([0-9]{3})/g, "$&_"), /_$/, "")
        }
    }
    return xs.call(e, n, "$&_")
}
var f0 = tce,
    OT = f0.custom,
    IT = OB(OT) ? OT : null,
    PB = {
        __proto__: null,
        double: '"',
        single: "'"
    },
    dce = {
        __proto__: null,
        double: /(["\\])/g,
        single: /(['\\])/g
    },
    Yp = function t(e, n, r, i) {
        var s = n || {};
        if (Ei(s, "quoteStyle") && !Ei(PB, s.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (Ei(s, "maxStringLength") && (typeof s.maxStringLength == "number" ? s.maxStringLength < 0 && s.maxStringLength !== 1 / 0 : s.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var o = Ei(s, "customInspect") ? s.customInspect : !0;
        if (typeof o != "boolean" && o !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (Ei(s, "indent") && s.indent !== null && s.indent !== "	" && !(parseInt(s.indent, 10) === s.indent && s.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (Ei(s, "numericSeparator") && typeof s.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var a = s.numericSeparator;
        if (typeof e > "u") return "undefined";
        if (e === null) return "null";
        if (typeof e == "boolean") return e ? "true" : "false";
        if (typeof e == "string") return RB(e, s);
        if (typeof e == "number") {
            if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
            var l = String(e);
            return a ? AT(e, l) : l
        }
        if (typeof e == "bigint") {
            var c = String(e) + "n";
            return a ? AT(e, c) : c
        }
        var u = typeof s.depth > "u" ? 5 : s.depth;
        if (typeof r > "u" && (r = 0), r >= u && u > 0 && typeof e == "object") return h0(e) ? "[Array]" : "[Object]";
        var d = Oce(s, r);
        if (typeof i > "u") i = [];
        else if (IB(i, e) >= 0) return "[Circular]";

        function f(B, F, H) {
            if (F && (i = uce.call(i), i.push(F)), H) {
                var k = {
                    depth: s.depth
                };
                return Ei(s, "quoteStyle") && (k.quoteStyle = s.quoteStyle), t(B, k, r + 1, i)
            }
            return t(B, s, r + 1, i)
        }
        if (typeof e == "function" && !RT(e)) {
            var h = bce(e),
                p = Jd(e, f);
            return "[Function" + (h ? ": " + h : " (anonymous)") + "]" + (p.length > 0 ? " { " + Xr.call(p, ", ") + " }" : "")
        }
        if (OB(e)) {
            var b = El ? xs.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : d0.call(e);
            return typeof e == "object" && !El ? lc(b) : b
        }
        if (Cce(e)) {
            for (var y = "<" + ST.call(String(e.nodeName)), m = e.attributes || [], g = 0; g < m.length; g++) y += " " + m[g].name + "=" + AB(fce(m[g].value), "double", s);
            return y += ">", e.childNodes && e.childNodes.length && (y += "..."), y += "</" + ST.call(String(e.nodeName)) + ">", y
        }
        if (h0(e)) {
            if (e.length === 0) return "[]";
            var v = Jd(e, f);
            return d && !Ace(v) ? "[" + p0(v, d) + "]" : "[ " + Xr.call(v, ", ") + " ]"
        }
        if (pce(e)) {
            var _ = Jd(e, f);
            return !("cause" in Error.prototype) && "cause" in e && !CB.call(e, "cause") ? "{ [" + String(e) + "] " + Xr.call(TT.call("[cause]: " + f(e.cause), _), ", ") + " }" : _.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + Xr.call(_, ", ") + " }"
        }
        if (typeof e == "object" && o) {
            if (IT && typeof e[IT] == "function" && f0) return f0(e, {
                depth: u - r
            });
            if (o !== "symbol" && typeof e.inspect == "function") return e.inspect()
        }
        if (xce(e)) {
            var x = [];
            return xT && xT.call(e, function(B, F) {
                x.push(f(F, e, !0) + " => " + f(B, e))
            }), MT("Map", Eh.call(e), x, d)
        }
        if (Sce(e)) {
            var w = [];
            return wT && wT.call(e, function(B) {
                w.push(f(B, e))
            }), MT("Set", Sh.call(e), w, d)
        }
        if (wce(e)) return bg("WeakMap");
        if (Tce(e)) return bg("WeakSet");
        if (Ece(e)) return bg("WeakRef");
        if (gce(e)) return lc(f(Number(e)));
        if (yce(e)) return lc(f(u0.call(e)));
        if (vce(e)) return lc(sce.call(e));
        if (mce(e)) return lc(f(String(e)));
        if (typeof window < "u" && e === window) return "{ [object Window] }";
        if (typeof globalThis < "u" && e === globalThis || typeof zo < "u" && e === zo) return "{ [object globalThis] }";
        if (!hce(e) && !RT(e)) {
            var S = Jd(e, f),
                C = PT ? PT(e) === Object.prototype : e instanceof Object || e.constructor === Object,
                A = e instanceof Object ? "" : "null prototype",
                T = !C && Uc && Object(e) === e && Uc in e ? Px.call(Js(e), 8, -1) : A ? "Object" : "",
                E = C || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "",
                P = E + (T || A ? "[" + Xr.call(TT.call([], T || [], A || []), ": ") + "] " : "");
            return S.length === 0 ? P + "{}" : d ? P + "{" + p0(S, d) + "}" : P + "{ " + Xr.call(S, ", ") + " }"
        }
        return String(e)
    };

function AB(t, e, n) {
    var r = n.quoteStyle || e,
        i = PB[r];
    return i + t + i
}

function fce(t) {
    return xs.call(String(t), /"/g, "&quot;")
}

function ma(t) {
    return !Uc || !(typeof t == "object" && (Uc in t || typeof t[Uc] < "u"))
}

function h0(t) {
    return Js(t) === "[object Array]" && ma(t)
}

function hce(t) {
    return Js(t) === "[object Date]" && ma(t)
}

function RT(t) {
    return Js(t) === "[object RegExp]" && ma(t)
}

function pce(t) {
    return Js(t) === "[object Error]" && ma(t)
}

function mce(t) {
    return Js(t) === "[object String]" && ma(t)
}

function gce(t) {
    return Js(t) === "[object Number]" && ma(t)
}

function vce(t) {
    return Js(t) === "[object Boolean]" && ma(t)
}

function OB(t) {
    if (El) return t && typeof t == "object" && t instanceof Symbol;
    if (typeof t == "symbol") return !0;
    if (!t || typeof t != "object" || !d0) return !1;
    try {
        return d0.call(t), !0
    } catch {}
    return !1
}

function yce(t) {
    if (!t || typeof t != "object" || !u0) return !1;
    try {
        return u0.call(t), !0
    } catch {}
    return !1
}
var _ce = Object.prototype.hasOwnProperty || function(t) {
    return t in this
};

function Ei(t, e) {
    return _ce.call(t, e)
}

function Js(t) {
    return oce.call(t)
}

function bce(t) {
    if (t.name) return t.name;
    var e = lce.call(ace.call(t), /^function\s*([\w$]+)/);
    return e ? e[1] : null
}

function IB(t, e) {
    if (t.indexOf) return t.indexOf(e);
    for (var n = 0, r = t.length; n < r; n++)
        if (t[n] === e) return n;
    return -1
}

function xce(t) {
    if (!Eh || !t || typeof t != "object") return !1;
    try {
        Eh.call(t);
        try {
            Sh.call(t)
        } catch {
            return !0
        }
        return t instanceof Map
    } catch {}
    return !1
}

function wce(t) {
    if (!Lc || !t || typeof t != "object") return !1;
    try {
        Lc.call(t, Lc);
        try {
            Nc.call(t, Nc)
        } catch {
            return !0
        }
        return t instanceof WeakMap
    } catch {}
    return !1
}

function Ece(t) {
    if (!ET || !t || typeof t != "object") return !1;
    try {
        return ET.call(t), !0
    } catch {}
    return !1
}

function Sce(t) {
    if (!Sh || !t || typeof t != "object") return !1;
    try {
        Sh.call(t);
        try {
            Eh.call(t)
        } catch {
            return !0
        }
        return t instanceof Set
    } catch {}
    return !1
}

function Tce(t) {
    if (!Nc || !t || typeof t != "object") return !1;
    try {
        Nc.call(t, Nc);
        try {
            Lc.call(t, Lc)
        } catch {
            return !0
        }
        return t instanceof WeakSet
    } catch {}
    return !1
}

function Cce(t) {
    return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function"
}

function RB(t, e) {
    if (t.length > e.maxStringLength) {
        var n = t.length - e.maxStringLength,
            r = "... " + n + " more character" + (n > 1 ? "s" : "");
        return RB(Px.call(t, 0, e.maxStringLength), e) + r
    }
    var i = dce[e.quoteStyle || "single"];
    i.lastIndex = 0;
    var s = xs.call(xs.call(t, i, "\\$1"), /[\x00-\x1f]/g, Pce);
    return AB(s, "single", e)
}

function Pce(t) {
    var e = t.charCodeAt(0),
        n = {
            8: "b",
            9: "t",
            10: "n",
            12: "f",
            13: "r"
        }[e];
    return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + cce.call(e.toString(16))
}

function lc(t) {
    return "Object(" + t + ")"
}

function bg(t) {
    return t + " { ? }"
}

function MT(t, e, n, r) {
    var i = r ? p0(n, r) : Xr.call(n, ", ");
    return t + " (" + e + ") {" + i + "}"
}

function Ace(t) {
    for (var e = 0; e < t.length; e++)
        if (IB(t[e], `
`) >= 0) return !1;
    return !0
}

function Oce(t, e) {
    var n;
    if (t.indent === "	") n = "	";
    else if (typeof t.indent == "number" && t.indent > 0) n = Xr.call(Array(t.indent + 1), " ");
    else return null;
    return {
        base: n,
        prev: Xr.call(Array(e + 1), n)
    }
}

function p0(t, e) {
    if (t.length === 0) return "";
    var n = `
` + e.prev + e.base;
    return n + Xr.call(t, "," + n) + `
` + e.prev
}

function Jd(t, e) {
    var n = h0(t),
        r = [];
    if (n) {
        r.length = t.length;
        for (var i = 0; i < t.length; i++) r[i] = Ei(t, i) ? e(t[i], t) : ""
    }
    var s = typeof _g == "function" ? _g(t) : [],
        o;
    if (El) {
        o = {};
        for (var a = 0; a < s.length; a++) o["$" + s[a]] = s[a]
    }
    for (var l in t) Ei(t, l) && (n && String(Number(l)) === l && l < t.length || El && o["$" + l] instanceof Symbol || (TB.call(/[^\w$]/, l) ? r.push(e(l, t) + ": " + e(t[l], t)) : r.push(l + ": " + e(t[l], t))));
    if (typeof _g == "function")
        for (var c = 0; c < s.length; c++) CB.call(t, s[c]) && r.push("[" + e(s[c]) + "]: " + e(t[s[c]], t));
    return r
}
var Ice = Yp,
    Rce = Gl,
    Xp = function(t, e, n) {
        for (var r = t, i;
            (i = r.next) != null; r = i)
            if (i.key === e) return r.next = i.next, n || (i.next = t.next, t.next = i), i
    },
    Mce = function(t, e) {
        if (t) {
            var n = Xp(t, e);
            return n && n.value
        }
    },
    kce = function(t, e, n) {
        var r = Xp(t, e);
        r ? r.value = n : t.next = {
            key: e,
            next: t.next,
            value: n
        }
    },
    Bce = function(t, e) {
        return t ? !!Xp(t, e) : !1
    },
    Dce = function(t, e) {
        if (t) return Xp(t, e, !0)
    },
    $ce = function() {
        var e, n = {
            assert: function(r) {
                if (!n.has(r)) throw new Rce("Side channel does not contain " + Ice(r))
            },
            delete: function(r) {
                var i = e && e.next,
                    s = Dce(e, r);
                return s && i && i === s && (e = void 0), !!s
            },
            get: function(r) {
                return Mce(e, r)
            },
            has: function(r) {
                return Bce(e, r)
            },
            set: function(r, i) {
                e || (e = {
                    next: void 0
                }), kce(e, r, i)
            }
        };
        return n
    },
    MB = Object,
    Fce = Error,
    Lce = EvalError,
    Nce = RangeError,
    Uce = ReferenceError,
    Gce = SyntaxError,
    Hce = URIError,
    zce = Math.abs,
    jce = Math.floor,
    Vce = Math.max,
    Wce = Math.min,
    Yce = Math.pow,
    Xce = Math.round,
    Kce = Number.isNaN || function(e) {
        return e !== e
    },
    qce = Kce,
    Jce = function(e) {
        return qce(e) || e === 0 ? e : e < 0 ? -1 : 1
    },
    Zce = Object.getOwnPropertyDescriptor,
    Ff = Zce;
if (Ff) try {
    Ff([], "length")
} catch {
    Ff = null
}
var kB = Ff,
    Lf = Object.defineProperty || !1;
if (Lf) try {
    Lf({}, "a", {
        value: 1
    })
} catch {
    Lf = !1
}
var Qce = Lf,
    xg, kT;

function eue() {
    return kT || (kT = 1, xg = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var e = {},
            n = Symbol("test"),
            r = Object(n);
        if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]") return !1;
        var i = 42;
        e[n] = i;
        for (var s in e) return !1;
        if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
        var o = Object.getOwnPropertySymbols(e);
        if (o.length !== 1 || o[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var a = Object.getOwnPropertyDescriptor(e, n);
            if (a.value !== i || a.enumerable !== !0) return !1
        }
        return !0
    }), xg
}
var wg, BT;

function tue() {
    if (BT) return wg;
    BT = 1;
    var t = typeof Symbol < "u" && Symbol,
        e = eue();
    return wg = function() {
        return typeof t != "function" || typeof Symbol != "function" || typeof t("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : e()
    }, wg
}
var Eg, DT;

function BB() {
    return DT || (DT = 1, Eg = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Eg
}
var Sg, $T;

function DB() {
    if ($T) return Sg;
    $T = 1;
    var t = MB;
    return Sg = t.getPrototypeOf || null, Sg
}
var Tg, FT;

function nue() {
    if (FT) return Tg;
    FT = 1;
    var t = "Function.prototype.bind called on incompatible ",
        e = Object.prototype.toString,
        n = Math.max,
        r = "[object Function]",
        i = function(l, c) {
            for (var u = [], d = 0; d < l.length; d += 1) u[d] = l[d];
            for (var f = 0; f < c.length; f += 1) u[f + l.length] = c[f];
            return u
        },
        s = function(l, c) {
            for (var u = [], d = c || 0, f = 0; d < l.length; d += 1, f += 1) u[f] = l[d];
            return u
        },
        o = function(a, l) {
            for (var c = "", u = 0; u < a.length; u += 1) c += a[u], u + 1 < a.length && (c += l);
            return c
        };
    return Tg = function(l) {
        var c = this;
        if (typeof c != "function" || e.apply(c) !== r) throw new TypeError(t + c);
        for (var u = s(arguments, 1), d, f = function() {
                if (this instanceof d) {
                    var m = c.apply(this, i(u, arguments));
                    return Object(m) === m ? m : this
                }
                return c.apply(l, i(u, arguments))
            }, h = n(0, c.length - u.length), p = [], b = 0; b < h; b++) p[b] = "$" + b;
        if (d = Function("binder", "return function (" + o(p, ",") + "){ return binder.apply(this,arguments); }")(f), c.prototype) {
            var y = function() {};
            y.prototype = c.prototype, d.prototype = new y, y.prototype = null
        }
        return d
    }, Tg
}
var Cg, LT;

function Kp() {
    if (LT) return Cg;
    LT = 1;
    var t = nue();
    return Cg = Function.prototype.bind || t, Cg
}
var Pg, NT;

function Ax() {
    return NT || (NT = 1, Pg = Function.prototype.call), Pg
}
var Ag, UT;

function $B() {
    return UT || (UT = 1, Ag = Function.prototype.apply), Ag
}
var rue = typeof Reflect < "u" && Reflect && Reflect.apply,
    iue = Kp(),
    sue = $B(),
    oue = Ax(),
    aue = rue,
    lue = aue || iue.call(oue, sue),
    cue = Kp(),
    uue = Gl,
    due = Ax(),
    fue = lue,
    FB = function(e) {
        if (e.length < 1 || typeof e[0] != "function") throw new uue("a function is required");
        return fue(cue, due, e)
    },
    Og, GT;

function hue() {
    if (GT) return Og;
    GT = 1;
    var t = FB,
        e = kB,
        n;
    try {
        n = [].__proto__ === Array.prototype
    } catch (o) {
        if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS") throw o
    }
    var r = !!n && e && e(Object.prototype, "__proto__"),
        i = Object,
        s = i.getPrototypeOf;
    return Og = r && typeof r.get == "function" ? t([r.get]) : typeof s == "function" ? function(a) {
        return s(a == null ? a : i(a))
    } : !1, Og
}
var Ig, HT;

function pue() {
    if (HT) return Ig;
    HT = 1;
    var t = BB(),
        e = DB(),
        n = hue();
    return Ig = t ? function(i) {
        return t(i)
    } : e ? function(i) {
        if (!i || typeof i != "object" && typeof i != "function") throw new TypeError("getProto: not an object");
        return e(i)
    } : n ? function(i) {
        return n(i)
    } : null, Ig
}
var Rg, zT;

function mue() {
    if (zT) return Rg;
    zT = 1;
    var t = Function.prototype.call,
        e = Object.prototype.hasOwnProperty,
        n = Kp();
    return Rg = n.call(t, e), Rg
}
var ze, gue = MB,
    vue = Fce,
    yue = Lce,
    _ue = Nce,
    bue = Uce,
    Sl = Gce,
    Qa = Gl,
    xue = Hce,
    wue = zce,
    Eue = jce,
    Sue = Vce,
    Tue = Wce,
    Cue = Yce,
    Pue = Xce,
    Aue = Jce,
    LB = Function,
    Mg = function(t) {
        try {
            return LB('"use strict"; return (' + t + ").constructor;")()
        } catch {}
    },
    Tu = kB,
    Oue = Qce,
    kg = function() {
        throw new Qa
    },
    Iue = Tu ? function() {
        try {
            return arguments.callee, kg
        } catch {
            try {
                return Tu(arguments, "callee").get
            } catch {
                return kg
            }
        }
    }() : kg,
    Ia = tue()(),
    Yt = pue(),
    Rue = DB(),
    Mue = BB(),
    NB = $B(),
    sd = Ax(),
    La = {},
    kue = typeof Uint8Array > "u" || !Yt ? ze : Yt(Uint8Array),
    Fo = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? ze : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? ze : ArrayBuffer,
        "%ArrayIteratorPrototype%": Ia && Yt ? Yt([][Symbol.iterator]()) : ze,
        "%AsyncFromSyncIteratorPrototype%": ze,
        "%AsyncFunction%": La,
        "%AsyncGenerator%": La,
        "%AsyncGeneratorFunction%": La,
        "%AsyncIteratorPrototype%": La,
        "%Atomics%": typeof Atomics > "u" ? ze : Atomics,
        "%BigInt%": typeof BigInt > "u" ? ze : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? ze : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? ze : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? ze : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": vue,
        "%eval%": eval,
        "%EvalError%": yue,
        "%Float16Array%": typeof Float16Array > "u" ? ze : Float16Array,
        "%Float32Array%": typeof Float32Array > "u" ? ze : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? ze : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? ze : FinalizationRegistry,
        "%Function%": LB,
        "%GeneratorFunction%": La,
        "%Int8Array%": typeof Int8Array > "u" ? ze : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? ze : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? ze : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": Ia && Yt ? Yt(Yt([][Symbol.iterator]())) : ze,
        "%JSON%": typeof JSON == "object" ? JSON : ze,
        "%Map%": typeof Map > "u" ? ze : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !Ia || !Yt ? ze : Yt(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": gue,
        "%Object.getOwnPropertyDescriptor%": Tu,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? ze : Promise,
        "%Proxy%": typeof Proxy > "u" ? ze : Proxy,
        "%RangeError%": _ue,
        "%ReferenceError%": bue,
        "%Reflect%": typeof Reflect > "u" ? ze : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? ze : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !Ia || !Yt ? ze : Yt(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? ze : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": Ia && Yt ? Yt("" [Symbol.iterator]()) : ze,
        "%Symbol%": Ia ? Symbol : ze,
        "%SyntaxError%": Sl,
        "%ThrowTypeError%": Iue,
        "%TypedArray%": kue,
        "%TypeError%": Qa,
        "%Uint8Array%": typeof Uint8Array > "u" ? ze : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? ze : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? ze : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? ze : Uint32Array,
        "%URIError%": xue,
        "%WeakMap%": typeof WeakMap > "u" ? ze : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? ze : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? ze : WeakSet,
        "%Function.prototype.call%": sd,
        "%Function.prototype.apply%": NB,
        "%Object.defineProperty%": Oue,
        "%Object.getPrototypeOf%": Rue,
        "%Math.abs%": wue,
        "%Math.floor%": Eue,
        "%Math.max%": Sue,
        "%Math.min%": Tue,
        "%Math.pow%": Cue,
        "%Math.round%": Pue,
        "%Math.sign%": Aue,
        "%Reflect.getPrototypeOf%": Mue
    };
if (Yt) try {
    null.error
} catch (t) {
    var Bue = Yt(Yt(t));
    Fo["%Error.prototype%"] = Bue
}
var Due = function t(e) {
        var n;
        if (e === "%AsyncFunction%") n = Mg("async function () {}");
        else if (e === "%GeneratorFunction%") n = Mg("function* () {}");
        else if (e === "%AsyncGeneratorFunction%") n = Mg("async function* () {}");
        else if (e === "%AsyncGenerator%") {
            var r = t("%AsyncGeneratorFunction%");
            r && (n = r.prototype)
        } else if (e === "%AsyncIteratorPrototype%") {
            var i = t("%AsyncGenerator%");
            i && Yt && (n = Yt(i.prototype))
        }
        return Fo[e] = n, n
    },
    jT = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    },
    od = Kp(),
    Th = mue(),
    $ue = od.call(sd, Array.prototype.concat),
    Fue = od.call(NB, Array.prototype.splice),
    VT = od.call(sd, String.prototype.replace),
    Ch = od.call(sd, String.prototype.slice),
    Lue = od.call(sd, RegExp.prototype.exec),
    Nue = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    Uue = /\\(\\)?/g,
    Gue = function(e) {
        var n = Ch(e, 0, 1),
            r = Ch(e, -1);
        if (n === "%" && r !== "%") throw new Sl("invalid intrinsic syntax, expected closing `%`");
        if (r === "%" && n !== "%") throw new Sl("invalid intrinsic syntax, expected opening `%`");
        var i = [];
        return VT(e, Nue, function(s, o, a, l) {
            i[i.length] = a ? VT(l, Uue, "$1") : o || s
        }), i
    },
    Hue = function(e, n) {
        var r = e,
            i;
        if (Th(jT, r) && (i = jT[r], r = "%" + i[0] + "%"), Th(Fo, r)) {
            var s = Fo[r];
            if (s === La && (s = Due(r)), typeof s > "u" && !n) throw new Qa("intrinsic " + e + " exists, but is not available. Please file an issue!");
            return {
                alias: i,
                name: r,
                value: s
            }
        }
        throw new Sl("intrinsic " + e + " does not exist!")
    },
    Ox = function(e, n) {
        if (typeof e != "string" || e.length === 0) throw new Qa("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof n != "boolean") throw new Qa('"allowMissing" argument must be a boolean');
        if (Lue(/^%?[^%]*%?$/, e) === null) throw new Sl("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var r = Gue(e),
            i = r.length > 0 ? r[0] : "",
            s = Hue("%" + i + "%", n),
            o = s.name,
            a = s.value,
            l = !1,
            c = s.alias;
        c && (i = c[0], Fue(r, $ue([0, 1], c)));
        for (var u = 1, d = !0; u < r.length; u += 1) {
            var f = r[u],
                h = Ch(f, 0, 1),
                p = Ch(f, -1);
            if ((h === '"' || h === "'" || h === "`" || p === '"' || p === "'" || p === "`") && h !== p) throw new Sl("property names with quotes must have matching quotes");
            if ((f === "constructor" || !d) && (l = !0), i += "." + f, o = "%" + i + "%", Th(Fo, o)) a = Fo[o];
            else if (a != null) {
                if (!(f in a)) {
                    if (!n) throw new Qa("base intrinsic for " + e + " exists, but the property is not available.");
                    return
                }
                if (Tu && u + 1 >= r.length) {
                    var b = Tu(a, f);
                    d = !!b, d && "get" in b && !("originalValue" in b.get) ? a = b.get : a = a[f]
                } else d = Th(a, f), a = a[f];
                d && !l && (Fo[o] = a)
            }
        }
        return a
    },
    UB = Ox,
    GB = FB,
    zue = GB([UB("%String.prototype.indexOf%")]),
    HB = function(e, n) {
        var r = UB(e, !!n);
        return typeof r == "function" && zue(e, ".prototype.") > -1 ? GB([r]) : r
    },
    jue = Ox,
    ad = HB,
    Vue = Yp,
    Wue = Gl,
    WT = jue("%Map%", !0),
    Yue = ad("Map.prototype.get", !0),
    Xue = ad("Map.prototype.set", !0),
    Kue = ad("Map.prototype.has", !0),
    que = ad("Map.prototype.delete", !0),
    Jue = ad("Map.prototype.size", !0),
    zB = !!WT && function() {
        var e, n = {
            assert: function(r) {
                if (!n.has(r)) throw new Wue("Side channel does not contain " + Vue(r))
            },
            delete: function(r) {
                if (e) {
                    var i = que(e, r);
                    return Jue(e) === 0 && (e = void 0), i
                }
                return !1
            },
            get: function(r) {
                if (e) return Yue(e, r)
            },
            has: function(r) {
                return e ? Kue(e, r) : !1
            },
            set: function(r, i) {
                e || (e = new WT), Xue(e, r, i)
            }
        };
        return n
    },
    Zue = Ox,
    qp = HB,
    Que = Yp,
    Zd = zB,
    ede = Gl,
    Ra = Zue("%WeakMap%", !0),
    tde = qp("WeakMap.prototype.get", !0),
    nde = qp("WeakMap.prototype.set", !0),
    rde = qp("WeakMap.prototype.has", !0),
    ide = qp("WeakMap.prototype.delete", !0),
    sde = Ra ? function() {
        var e, n, r = {
            assert: function(i) {
                if (!r.has(i)) throw new ede("Side channel does not contain " + Que(i))
            },
            delete: function(i) {
                if (Ra && i && (typeof i == "object" || typeof i == "function")) {
                    if (e) return ide(e, i)
                } else if (Zd && n) return n.delete(i);
                return !1
            },
            get: function(i) {
                return Ra && i && (typeof i == "object" || typeof i == "function") && e ? tde(e, i) : n && n.get(i)
            },
            has: function(i) {
                return Ra && i && (typeof i == "object" || typeof i == "function") && e ? rde(e, i) : !!n && n.has(i)
            },
            set: function(i, s) {
                Ra && i && (typeof i == "object" || typeof i == "function") ? (e || (e = new Ra), nde(e, i, s)) : Zd && (n || (n = Zd()), n.set(i, s))
            }
        };
        return r
    } : Zd,
    ode = Gl,
    ade = Yp,
    lde = $ce,
    cde = zB,
    ude = sde,
    dde = ude || cde || lde,
    fde = function() {
        var e, n = {
            assert: function(r) {
                if (!n.has(r)) throw new ode("Side channel does not contain " + ade(r))
            },
            delete: function(r) {
                return !!e && e.delete(r)
            },
            get: function(r) {
                return e && e.get(r)
            },
            has: function(r) {
                return !!e && e.has(r)
            },
            set: function(r, i) {
                e || (e = dde()), e.set(r, i)
            }
        };
        return n
    },
    hde = String.prototype.replace,
    pde = /%20/g,
    Bg = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
    },
    Ix = {
        default: Bg.RFC3986,
        formatters: {
            RFC1738: function(t) {
                return hde.call(t, pde, "+")
            },
            RFC3986: function(t) {
                return String(t)
            }
        },
        RFC1738: Bg.RFC1738,
        RFC3986: Bg.RFC3986
    },
    mde = Ix,
    Dg = Object.prototype.hasOwnProperty,
    yo = Array.isArray,
    Gr = function() {
        for (var t = [], e = 0; e < 256; ++e) t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
        return t
    }(),
    gde = function(e) {
        for (; e.length > 1;) {
            var n = e.pop(),
                r = n.obj[n.prop];
            if (yo(r)) {
                for (var i = [], s = 0; s < r.length; ++s) typeof r[s] < "u" && i.push(r[s]);
                n.obj[n.prop] = i
            }
        }
    },
    jB = function(e, n) {
        for (var r = n && n.plainObjects ? {
                __proto__: null
            } : {}, i = 0; i < e.length; ++i) typeof e[i] < "u" && (r[i] = e[i]);
        return r
    },
    vde = function t(e, n, r) {
        if (!n) return e;
        if (typeof n != "object" && typeof n != "function") {
            if (yo(e)) e.push(n);
            else if (e && typeof e == "object")(r && (r.plainObjects || r.allowPrototypes) || !Dg.call(Object.prototype, n)) && (e[n] = !0);
            else return [e, n];
            return e
        }
        if (!e || typeof e != "object") return [e].concat(n);
        var i = e;
        return yo(e) && !yo(n) && (i = jB(e, r)), yo(e) && yo(n) ? (n.forEach(function(s, o) {
            if (Dg.call(e, o)) {
                var a = e[o];
                a && typeof a == "object" && s && typeof s == "object" ? e[o] = t(a, s, r) : e.push(s)
            } else e[o] = s
        }), e) : Object.keys(n).reduce(function(s, o) {
            var a = n[o];
            return Dg.call(s, o) ? s[o] = t(s[o], a, r) : s[o] = a, s
        }, i)
    },
    yde = function(e, n) {
        return Object.keys(n).reduce(function(r, i) {
            return r[i] = n[i], r
        }, e)
    },
    _de = function(t, e, n) {
        var r = t.replace(/\+/g, " ");
        if (n === "iso-8859-1") return r.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
            return decodeURIComponent(r)
        } catch {
            return r
        }
    },
    $g = 1024,
    bde = function(e, n, r, i, s) {
        if (e.length === 0) return e;
        var o = e;
        if (typeof e == "symbol" ? o = Symbol.prototype.toString.call(e) : typeof e != "string" && (o = String(e)), r === "iso-8859-1") return escape(o).replace(/%u[0-9a-f]{4}/gi, function(h) {
            return "%26%23" + parseInt(h.slice(2), 16) + "%3B"
        });
        for (var a = "", l = 0; l < o.length; l += $g) {
            for (var c = o.length >= $g ? o.slice(l, l + $g) : o, u = [], d = 0; d < c.length; ++d) {
                var f = c.charCodeAt(d);
                if (f === 45 || f === 46 || f === 95 || f === 126 || f >= 48 && f <= 57 || f >= 65 && f <= 90 || f >= 97 && f <= 122 || s === mde.RFC1738 && (f === 40 || f === 41)) {
                    u[u.length] = c.charAt(d);
                    continue
                }
                if (f < 128) {
                    u[u.length] = Gr[f];
                    continue
                }
                if (f < 2048) {
                    u[u.length] = Gr[192 | f >> 6] + Gr[128 | f & 63];
                    continue
                }
                if (f < 55296 || f >= 57344) {
                    u[u.length] = Gr[224 | f >> 12] + Gr[128 | f >> 6 & 63] + Gr[128 | f & 63];
                    continue
                }
                d += 1, f = 65536 + ((f & 1023) << 10 | c.charCodeAt(d) & 1023), u[u.length] = Gr[240 | f >> 18] + Gr[128 | f >> 12 & 63] + Gr[128 | f >> 6 & 63] + Gr[128 | f & 63]
            }
            a += u.join("")
        }
        return a
    },
    xde = function(e) {
        for (var n = [{
                obj: {
                    o: e
                },
                prop: "o"
            }], r = [], i = 0; i < n.length; ++i)
            for (var s = n[i], o = s.obj[s.prop], a = Object.keys(o), l = 0; l < a.length; ++l) {
                var c = a[l],
                    u = o[c];
                typeof u == "object" && u !== null && r.indexOf(u) === -1 && (n.push({
                    obj: o,
                    prop: c
                }), r.push(u))
            }
        return gde(n), e
    },
    wde = function(e) {
        return Object.prototype.toString.call(e) === "[object RegExp]"
    },
    Ede = function(e) {
        return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
    },
    Sde = function(e, n) {
        return [].concat(e, n)
    },
    Tde = function(e, n) {
        if (yo(e)) {
            for (var r = [], i = 0; i < e.length; i += 1) r.push(n(e[i]));
            return r
        }
        return n(e)
    },
    VB = {
        arrayToObject: jB,
        assign: yde,
        combine: Sde,
        compact: xde,
        decode: _de,
        encode: bde,
        isBuffer: Ede,
        isRegExp: wde,
        maybeMap: Tde,
        merge: vde
    },
    WB = fde,
    Nf = VB,
    Gc = Ix,
    Cde = Object.prototype.hasOwnProperty,
    YB = {
        brackets: function(e) {
            return e + "[]"
        },
        comma: "comma",
        indices: function(e, n) {
            return e + "[" + n + "]"
        },
        repeat: function(e) {
            return e
        }
    },
    Yr = Array.isArray,
    Pde = Array.prototype.push,
    XB = function(t, e) {
        Pde.apply(t, Yr(e) ? e : [e])
    },
    Ade = Date.prototype.toISOString,
    YT = Gc.default,
    Ht = {
        addQueryPrefix: !1,
        allowDots: !1,
        allowEmptyArrays: !1,
        arrayFormat: "indices",
        charset: "utf-8",
        charsetSentinel: !1,
        commaRoundTrip: !1,
        delimiter: "&",
        encode: !0,
        encodeDotInKeys: !1,
        encoder: Nf.encode,
        encodeValuesOnly: !1,
        filter: void 0,
        format: YT,
        formatter: Gc.formatters[YT],
        indices: !1,
        serializeDate: function(e) {
            return Ade.call(e)
        },
        skipNulls: !1,
        strictNullHandling: !1
    },
    Ode = function(e) {
        return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint"
    },
    Fg = {},
    Ide = function t(e, n, r, i, s, o, a, l, c, u, d, f, h, p, b, y, m, g) {
        for (var v = e, _ = g, x = 0, w = !1;
            (_ = _.get(Fg)) !== void 0 && !w;) {
            var S = _.get(e);
            if (x += 1, typeof S < "u") {
                if (S === x) throw new RangeError("Cyclic object value");
                w = !0
            }
            typeof _.get(Fg) > "u" && (x = 0)
        }
        if (typeof u == "function" ? v = u(n, v) : v instanceof Date ? v = h(v) : r === "comma" && Yr(v) && (v = Nf.maybeMap(v, function(le) {
                return le instanceof Date ? h(le) : le
            })), v === null) {
            if (o) return c && !y ? c(n, Ht.encoder, m, "key", p) : n;
            v = ""
        }
        if (Ode(v) || Nf.isBuffer(v)) {
            if (c) {
                var C = y ? n : c(n, Ht.encoder, m, "key", p);
                return [b(C) + "=" + b(c(v, Ht.encoder, m, "value", p))]
            }
            return [b(n) + "=" + b(String(v))]
        }
        var A = [];
        if (typeof v > "u") return A;
        var T;
        if (r === "comma" && Yr(v)) y && c && (v = Nf.maybeMap(v, c)), T = [{
            value: v.length > 0 ? v.join(",") || null : void 0
        }];
        else if (Yr(u)) T = u;
        else {
            var E = Object.keys(v);
            T = d ? E.sort(d) : E
        }
        var P = l ? String(n).replace(/\./g, "%2E") : String(n),
            B = i && Yr(v) && v.length === 1 ? P + "[]" : P;
        if (s && Yr(v) && v.length === 0) return B + "[]";
        for (var F = 0; F < T.length; ++F) {
            var H = T[F],
                k = typeof H == "object" && H && typeof H.value < "u" ? H.value : v[H];
            if (!(a && k === null)) {
                var N = f && l ? String(H).replace(/\./g, "%2E") : String(H),
                    V = Yr(v) ? typeof r == "function" ? r(B, N) : B : B + (f ? "." + N : "[" + N + "]");
                g.set(e, x);
                var Y = WB();
                Y.set(Fg, g), XB(A, t(k, V, r, i, s, o, a, l, r === "comma" && y && Yr(v) ? null : c, u, d, f, h, p, b, y, m, Y))
            }
        }
        return A
    },
    Rde = function(e) {
        if (!e) return Ht;
        if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.encodeDotInKeys < "u" && typeof e.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function") throw new TypeError("Encoder has to be a function.");
        var n = e.charset || Ht.charset;
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var r = Gc.default;
        if (typeof e.format < "u") {
            if (!Cde.call(Gc.formatters, e.format)) throw new TypeError("Unknown format option provided.");
            r = e.format
        }
        var i = Gc.formatters[r],
            s = Ht.filter;
        (typeof e.filter == "function" || Yr(e.filter)) && (s = e.filter);
        var o;
        if (e.arrayFormat in YB ? o = e.arrayFormat : "indices" in e ? o = e.indices ? "indices" : "repeat" : o = Ht.arrayFormat, "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var a = typeof e.allowDots > "u" ? e.encodeDotInKeys === !0 ? !0 : Ht.allowDots : !!e.allowDots;
        return {
            addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : Ht.addQueryPrefix,
            allowDots: a,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : Ht.allowEmptyArrays,
            arrayFormat: o,
            charset: n,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Ht.charsetSentinel,
            commaRoundTrip: !!e.commaRoundTrip,
            delimiter: typeof e.delimiter > "u" ? Ht.delimiter : e.delimiter,
            encode: typeof e.encode == "boolean" ? e.encode : Ht.encode,
            encodeDotInKeys: typeof e.encodeDotInKeys == "boolean" ? e.encodeDotInKeys : Ht.encodeDotInKeys,
            encoder: typeof e.encoder == "function" ? e.encoder : Ht.encoder,
            encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : Ht.encodeValuesOnly,
            filter: s,
            format: r,
            formatter: i,
            serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : Ht.serializeDate,
            skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : Ht.skipNulls,
            sort: typeof e.sort == "function" ? e.sort : null,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Ht.strictNullHandling
        }
    },
    Mde = function(t, e) {
        var n = t,
            r = Rde(e),
            i, s;
        typeof r.filter == "function" ? (s = r.filter, n = s("", n)) : Yr(r.filter) && (s = r.filter, i = s);
        var o = [];
        if (typeof n != "object" || n === null) return "";
        var a = YB[r.arrayFormat],
            l = a === "comma" && r.commaRoundTrip;
        i || (i = Object.keys(n)), r.sort && i.sort(r.sort);
        for (var c = WB(), u = 0; u < i.length; ++u) {
            var d = i[u],
                f = n[d];
            r.skipNulls && f === null || XB(o, Ide(f, d, a, l, r.allowEmptyArrays, r.strictNullHandling, r.skipNulls, r.encodeDotInKeys, r.encode ? r.encoder : null, r.filter, r.sort, r.allowDots, r.serializeDate, r.format, r.formatter, r.encodeValuesOnly, r.charset, c))
        }
        var h = o.join(r.delimiter),
            p = r.addQueryPrefix === !0 ? "?" : "";
        return r.charsetSentinel && (r.charset === "iso-8859-1" ? p += "utf8=%26%2310003%3B&" : p += "utf8=%E2%9C%93&"), h.length > 0 ? p + h : ""
    },
    ea = VB,
    m0 = Object.prototype.hasOwnProperty,
    XT = Array.isArray,
    Ct = {
        allowDots: !1,
        allowEmptyArrays: !1,
        allowPrototypes: !1,
        allowSparse: !1,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: !1,
        comma: !1,
        decodeDotInKeys: !1,
        decoder: ea.decode,
        delimiter: "&",
        depth: 5,
        duplicates: "combine",
        ignoreQueryPrefix: !1,
        interpretNumericEntities: !1,
        parameterLimit: 1e3,
        parseArrays: !0,
        plainObjects: !1,
        strictDepth: !1,
        strictNullHandling: !1,
        throwOnLimitExceeded: !1
    },
    kde = function(t) {
        return t.replace(/&#(\d+);/g, function(e, n) {
            return String.fromCharCode(parseInt(n, 10))
        })
    },
    KB = function(t, e, n) {
        if (t && typeof t == "string" && e.comma && t.indexOf(",") > -1) return t.split(",");
        if (e.throwOnLimitExceeded && n >= e.arrayLimit) throw new RangeError("Array limit exceeded. Only " + e.arrayLimit + " element" + (e.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
        return t
    },
    Bde = "utf8=%26%2310003%3B",
    Dde = "utf8=%E2%9C%93",
    $de = function(e, n) {
        var r = {
                __proto__: null
            },
            i = n.ignoreQueryPrefix ? e.replace(/^\?/, "") : e;
        i = i.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        var s = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit,
            o = i.split(n.delimiter, n.throwOnLimitExceeded ? s + 1 : s);
        if (n.throwOnLimitExceeded && o.length > s) throw new RangeError("Parameter limit exceeded. Only " + s + " parameter" + (s === 1 ? "" : "s") + " allowed.");
        var a = -1,
            l, c = n.charset;
        if (n.charsetSentinel)
            for (l = 0; l < o.length; ++l) o[l].indexOf("utf8=") === 0 && (o[l] === Dde ? c = "utf-8" : o[l] === Bde && (c = "iso-8859-1"), a = l, l = o.length);
        for (l = 0; l < o.length; ++l)
            if (l !== a) {
                var u = o[l],
                    d = u.indexOf("]="),
                    f = d === -1 ? u.indexOf("=") : d + 1,
                    h, p;
                f === -1 ? (h = n.decoder(u, Ct.decoder, c, "key"), p = n.strictNullHandling ? null : "") : (h = n.decoder(u.slice(0, f), Ct.decoder, c, "key"), p = ea.maybeMap(KB(u.slice(f + 1), n, XT(r[h]) ? r[h].length : 0), function(y) {
                    return n.decoder(y, Ct.decoder, c, "value")
                })), p && n.interpretNumericEntities && c === "iso-8859-1" && (p = kde(String(p))), u.indexOf("[]=") > -1 && (p = XT(p) ? [p] : p);
                var b = m0.call(r, h);
                b && n.duplicates === "combine" ? r[h] = ea.combine(r[h], p) : (!b || n.duplicates === "last") && (r[h] = p)
            }
        return r
    },
    Fde = function(t, e, n, r) {
        var i = 0;
        if (t.length > 0 && t[t.length - 1] === "[]") {
            var s = t.slice(0, -1).join("");
            i = Array.isArray(e) && e[s] ? e[s].length : 0
        }
        for (var o = r ? e : KB(e, n, i), a = t.length - 1; a >= 0; --a) {
            var l, c = t[a];
            if (c === "[]" && n.parseArrays) l = n.allowEmptyArrays && (o === "" || n.strictNullHandling && o === null) ? [] : ea.combine([], o);
            else {
                l = n.plainObjects ? {
                    __proto__: null
                } : {};
                var u = c.charAt(0) === "[" && c.charAt(c.length - 1) === "]" ? c.slice(1, -1) : c,
                    d = n.decodeDotInKeys ? u.replace(/%2E/g, ".") : u,
                    f = parseInt(d, 10);
                !n.parseArrays && d === "" ? l = {
                    0: o
                } : !isNaN(f) && c !== d && String(f) === d && f >= 0 && n.parseArrays && f <= n.arrayLimit ? (l = [], l[f] = o) : d !== "__proto__" && (l[d] = o)
            }
            o = l
        }
        return o
    },
    Lde = function(e, n, r, i) {
        if (e) {
            var s = r.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
                o = /(\[[^[\]]*])/,
                a = /(\[[^[\]]*])/g,
                l = r.depth > 0 && o.exec(s),
                c = l ? s.slice(0, l.index) : s,
                u = [];
            if (c) {
                if (!r.plainObjects && m0.call(Object.prototype, c) && !r.allowPrototypes) return;
                u.push(c)
            }
            for (var d = 0; r.depth > 0 && (l = a.exec(s)) !== null && d < r.depth;) {
                if (d += 1, !r.plainObjects && m0.call(Object.prototype, l[1].slice(1, -1)) && !r.allowPrototypes) return;
                u.push(l[1])
            }
            if (l) {
                if (r.strictDepth === !0) throw new RangeError("Input depth exceeded depth option of " + r.depth + " and strictDepth is true");
                u.push("[" + s.slice(l.index) + "]")
            }
            return Fde(u, n, r, i)
        }
    },
    Nde = function(e) {
        if (!e) return Ct;
        if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.decodeDotInKeys < "u" && typeof e.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.decoder !== null && typeof e.decoder < "u" && typeof e.decoder != "function") throw new TypeError("Decoder has to be a function.");
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        if (typeof e.throwOnLimitExceeded < "u" && typeof e.throwOnLimitExceeded != "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
        var n = typeof e.charset > "u" ? Ct.charset : e.charset,
            r = typeof e.duplicates > "u" ? Ct.duplicates : e.duplicates;
        if (r !== "combine" && r !== "first" && r !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
        var i = typeof e.allowDots > "u" ? e.decodeDotInKeys === !0 ? !0 : Ct.allowDots : !!e.allowDots;
        return {
            allowDots: i,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : Ct.allowEmptyArrays,
            allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : Ct.allowPrototypes,
            allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : Ct.allowSparse,
            arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : Ct.arrayLimit,
            charset: n,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Ct.charsetSentinel,
            comma: typeof e.comma == "boolean" ? e.comma : Ct.comma,
            decodeDotInKeys: typeof e.decodeDotInKeys == "boolean" ? e.decodeDotInKeys : Ct.decodeDotInKeys,
            decoder: typeof e.decoder == "function" ? e.decoder : Ct.decoder,
            delimiter: typeof e.delimiter == "string" || ea.isRegExp(e.delimiter) ? e.delimiter : Ct.delimiter,
            depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : Ct.depth,
            duplicates: r,
            ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
            interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : Ct.interpretNumericEntities,
            parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : Ct.parameterLimit,
            parseArrays: e.parseArrays !== !1,
            plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : Ct.plainObjects,
            strictDepth: typeof e.strictDepth == "boolean" ? !!e.strictDepth : Ct.strictDepth,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Ct.strictNullHandling,
            throwOnLimitExceeded: typeof e.throwOnLimitExceeded == "boolean" ? e.throwOnLimitExceeded : !1
        }
    },
    Ude = function(t, e) {
        var n = Nde(e);
        if (t === "" || t === null || typeof t > "u") return n.plainObjects ? {
            __proto__: null
        } : {};
        for (var r = typeof t == "string" ? $de(t, n) : t, i = n.plainObjects ? {
                __proto__: null
            } : {}, s = Object.keys(r), o = 0; o < s.length; ++o) {
            var a = s[o],
                l = Lde(a, r[a], n, typeof t == "string");
            i = ea.merge(i, l, n)
        }
        return n.allowSparse === !0 ? i : ea.compact(i)
    },
    Gde = Mde,
    Hde = Ude,
    zde = Ix,
    jde = {
        formats: zde,
        parse: Hde,
        stringify: Gde
    };
const wbe = ua(jde);
var G = (t => (t.Application = "application", t.WebGLPipes = "webgl-pipes", t.WebGLPipesAdaptor = "webgl-pipes-adaptor", t.WebGLSystem = "webgl-system", t.WebGPUPipes = "webgpu-pipes", t.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", t.WebGPUSystem = "webgpu-system", t.CanvasSystem = "canvas-system", t.CanvasPipesAdaptor = "canvas-pipes-adaptor", t.CanvasPipes = "canvas-pipes", t.Asset = "asset", t.LoadParser = "load-parser", t.ResolveParser = "resolve-parser", t.CacheParser = "cache-parser", t.DetectionParser = "detection-parser", t.MaskEffect = "mask-effect", t.BlendMode = "blend-mode", t.TextureSource = "texture-source", t.Environment = "environment", t.ShapeBuilder = "shape-builder", t.Batcher = "batcher", t))(G || {});
const g0 = t => {
        if (typeof t == "function" || typeof t == "object" && t.extension) {
            if (!t.extension) throw new Error("Extension class must have an extension object");
            t = { ...typeof t.extension != "object" ? {
                    type: t.extension
                } : t.extension,
                ref: t
            }
        }
        if (typeof t == "object") t = { ...t
        };
        else throw new Error("Invalid extension type");
        return typeof t.type == "string" && (t.type = [t.type]), t
    },
    Qd = (t, e) => g0(t).priority ? ? e,
    Ie = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...t) {
            return t.map(g0).forEach(e => {
                e.type.forEach(n => {
                    var r, i;
                    return (i = (r = this._removeHandlers)[n]) == null ? void 0 : i.call(r, e)
                })
            }), this
        },
        add(...t) {
            return t.map(g0).forEach(e => {
                e.type.forEach(n => {
                    var s, o;
                    const r = this._addHandlers,
                        i = this._queue;
                    r[n] ? (o = r[n]) == null || o.call(r, e) : (i[n] = i[n] || [], (s = i[n]) == null || s.push(e))
                })
            }), this
        },
        handle(t, e, n) {
            var o;
            const r = this._addHandlers,
                i = this._removeHandlers;
            if (r[t] || i[t]) throw new Error(`Extension type ${t} already has a handler`);
            r[t] = e, i[t] = n;
            const s = this._queue;
            return s[t] && ((o = s[t]) == null || o.forEach(a => e(a)), delete s[t]), this
        },
        handleByMap(t, e) {
            return this.handle(t, n => {
                n.name && (e[n.name] = n.ref)
            }, n => {
                n.name && delete e[n.name]
            })
        },
        handleByNamedList(t, e, n = -1) {
            return this.handle(t, r => {
                e.findIndex(s => s.name === r.name) >= 0 || (e.push({
                    name: r.name,
                    value: r.ref
                }), e.sort((s, o) => Qd(o.value, n) - Qd(s.value, n)))
            }, r => {
                const i = e.findIndex(s => s.name === r.name);
                i !== -1 && e.splice(i, 1)
            })
        },
        handleByList(t, e, n = -1) {
            return this.handle(t, r => {
                e.includes(r.ref) || (e.push(r.ref), e.sort((i, s) => Qd(s, n) - Qd(i, n)))
            }, r => {
                const i = e.indexOf(r.ref);
                i !== -1 && e.splice(i, 1)
            })
        },
        mixin(t, ...e) {
            for (const n of e) Object.defineProperties(t.prototype, Object.getOwnPropertyDescriptors(n))
        }
    },
    Vde = {
        extension: {
            type: G.Environment,
            name: "browser",
            priority: -1
        },
        test: () => !0,
        load: async () => {
            await Vf(() => Promise.resolve().then(() => k0e), void 0)
        }
    },
    Wde = {
        extension: {
            type: G.Environment,
            name: "webworker",
            priority: 0
        },
        test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
        load: async () => {
            await Vf(() => Promise.resolve().then(() => B0e), void 0)
        }
    };
class jt {
    constructor(e, n, r) {
        this._x = n || 0, this._y = r || 0, this._observer = e
    }
    clone(e) {
        return new jt(e ? ? this._observer, this._x, this._y)
    }
    set(e = 0, n = e) {
        return (this._x !== e || this._y !== n) && (this._x = e, this._y = n, this._observer._onUpdate(this)), this
    }
    copyFrom(e) {
        return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this._observer._onUpdate(this)), this
    }
    copyTo(e) {
        return e.set(this._x, this._y), e
    }
    equals(e) {
        return e.x === this._x && e.y === this._y
    }
    toString() {
        return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x !== e && (this._x = e, this._observer._onUpdate(this))
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y !== e && (this._y = e, this._observer._onUpdate(this))
    }
}
var qB = {
    exports: {}
};
(function(t) {
    var e = Object.prototype.hasOwnProperty,
        n = "~";

    function r() {}
    Object.create && (r.prototype = Object.create(null), new r().__proto__ || (n = !1));

    function i(l, c, u) {
        this.fn = l, this.context = c, this.once = u || !1
    }

    function s(l, c, u, d, f) {
        if (typeof u != "function") throw new TypeError("The listener must be a function");
        var h = new i(u, d || l, f),
            p = n ? n + c : c;
        return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], h] : l._events[p].push(h) : (l._events[p] = h, l._eventsCount++), l
    }

    function o(l, c) {
        --l._eventsCount === 0 ? l._events = new r : delete l._events[c]
    }

    function a() {
        this._events = new r, this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var c = [],
            u, d;
        if (this._eventsCount === 0) return c;
        for (d in u = this._events) e.call(u, d) && c.push(n ? d.slice(1) : d);
        return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c
    }, a.prototype.listeners = function(c) {
        var u = n ? n + c : c,
            d = this._events[u];
        if (!d) return [];
        if (d.fn) return [d.fn];
        for (var f = 0, h = d.length, p = new Array(h); f < h; f++) p[f] = d[f].fn;
        return p
    }, a.prototype.listenerCount = function(c) {
        var u = n ? n + c : c,
            d = this._events[u];
        return d ? d.fn ? 1 : d.length : 0
    }, a.prototype.emit = function(c, u, d, f, h, p) {
        var b = n ? n + c : c;
        if (!this._events[b]) return !1;
        var y = this._events[b],
            m = arguments.length,
            g, v;
        if (y.fn) {
            switch (y.once && this.removeListener(c, y.fn, void 0, !0), m) {
                case 1:
                    return y.fn.call(y.context), !0;
                case 2:
                    return y.fn.call(y.context, u), !0;
                case 3:
                    return y.fn.call(y.context, u, d), !0;
                case 4:
                    return y.fn.call(y.context, u, d, f), !0;
                case 5:
                    return y.fn.call(y.context, u, d, f, h), !0;
                case 6:
                    return y.fn.call(y.context, u, d, f, h, p), !0
            }
            for (v = 1, g = new Array(m - 1); v < m; v++) g[v - 1] = arguments[v];
            y.fn.apply(y.context, g)
        } else {
            var _ = y.length,
                x;
            for (v = 0; v < _; v++) switch (y[v].once && this.removeListener(c, y[v].fn, void 0, !0), m) {
                case 1:
                    y[v].fn.call(y[v].context);
                    break;
                case 2:
                    y[v].fn.call(y[v].context, u);
                    break;
                case 3:
                    y[v].fn.call(y[v].context, u, d);
                    break;
                case 4:
                    y[v].fn.call(y[v].context, u, d, f);
                    break;
                default:
                    if (!g)
                        for (x = 1, g = new Array(m - 1); x < m; x++) g[x - 1] = arguments[x];
                    y[v].fn.apply(y[v].context, g)
            }
        }
        return !0
    }, a.prototype.on = function(c, u, d) {
        return s(this, c, u, d, !1)
    }, a.prototype.once = function(c, u, d) {
        return s(this, c, u, d, !0)
    }, a.prototype.removeListener = function(c, u, d, f) {
        var h = n ? n + c : c;
        if (!this._events[h]) return this;
        if (!u) return o(this, h), this;
        var p = this._events[h];
        if (p.fn) p.fn === u && (!f || p.once) && (!d || p.context === d) && o(this, h);
        else {
            for (var b = 0, y = [], m = p.length; b < m; b++)(p[b].fn !== u || f && !p[b].once || d && p[b].context !== d) && y.push(p[b]);
            y.length ? this._events[h] = y.length === 1 ? y[0] : y : o(this, h)
        }
        return this
    }, a.prototype.removeAllListeners = function(c) {
        var u;
        return c ? (u = n ? n + c : c, this._events[u] && o(this, u)) : (this._events = new r, this._eventsCount = 0), this
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = n, a.EventEmitter = a, t.exports = a
})(qB);
var Yde = qB.exports;
const rr = ua(Yde),
    Xde = Math.PI * 2,
    Kde = 180 / Math.PI,
    qde = Math.PI / 180;
class ct {
    constructor(e = 0, n = 0) {
        this.x = 0, this.y = 0, this.x = e, this.y = n
    }
    clone() {
        return new ct(this.x, this.y)
    }
    copyFrom(e) {
        return this.set(e.x, e.y), this
    }
    copyTo(e) {
        return e.set(this.x, this.y), e
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    set(e = 0, n = e) {
        return this.x = e, this.y = n, this
    }
    toString() {
        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`
    }
    static get shared() {
        return Lg.x = 0, Lg.y = 0, Lg
    }
}
const Lg = new ct;
class Ce {
    constructor(e = 1, n = 0, r = 0, i = 1, s = 0, o = 0) {
        this.array = null, this.a = e, this.b = n, this.c = r, this.d = i, this.tx = s, this.ty = o
    }
    fromArray(e) {
        this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5]
    }
    set(e, n, r, i, s, o) {
        return this.a = e, this.b = n, this.c = r, this.d = i, this.tx = s, this.ty = o, this
    }
    toArray(e, n) {
        this.array || (this.array = new Float32Array(9));
        const r = n || this.array;
        return e ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r
    }
    apply(e, n) {
        n = n || new ct;
        const r = e.x,
            i = e.y;
        return n.x = this.a * r + this.c * i + this.tx, n.y = this.b * r + this.d * i + this.ty, n
    }
    applyInverse(e, n) {
        n = n || new ct;
        const r = this.a,
            i = this.b,
            s = this.c,
            o = this.d,
            a = this.tx,
            l = this.ty,
            c = 1 / (r * o + s * -i),
            u = e.x,
            d = e.y;
        return n.x = o * c * u + -s * c * d + (l * s - a * o) * c, n.y = r * c * d + -i * c * u + (-l * r + a * i) * c, n
    }
    translate(e, n) {
        return this.tx += e, this.ty += n, this
    }
    scale(e, n) {
        return this.a *= e, this.d *= n, this.c *= e, this.b *= n, this.tx *= e, this.ty *= n, this
    }
    rotate(e) {
        const n = Math.cos(e),
            r = Math.sin(e),
            i = this.a,
            s = this.c,
            o = this.tx;
        return this.a = i * n - this.b * r, this.b = i * r + this.b * n, this.c = s * n - this.d * r, this.d = s * r + this.d * n, this.tx = o * n - this.ty * r, this.ty = o * r + this.ty * n, this
    }
    append(e) {
        const n = this.a,
            r = this.b,
            i = this.c,
            s = this.d;
        return this.a = e.a * n + e.b * i, this.b = e.a * r + e.b * s, this.c = e.c * n + e.d * i, this.d = e.c * r + e.d * s, this.tx = e.tx * n + e.ty * i + this.tx, this.ty = e.tx * r + e.ty * s + this.ty, this
    }
    appendFrom(e, n) {
        const r = e.a,
            i = e.b,
            s = e.c,
            o = e.d,
            a = e.tx,
            l = e.ty,
            c = n.a,
            u = n.b,
            d = n.c,
            f = n.d;
        return this.a = r * c + i * d, this.b = r * u + i * f, this.c = s * c + o * d, this.d = s * u + o * f, this.tx = a * c + l * d + n.tx, this.ty = a * u + l * f + n.ty, this
    }
    setTransform(e, n, r, i, s, o, a, l, c) {
        return this.a = Math.cos(a + c) * s, this.b = Math.sin(a + c) * s, this.c = -Math.sin(a - l) * o, this.d = Math.cos(a - l) * o, this.tx = e - (r * this.a + i * this.c), this.ty = n - (r * this.b + i * this.d), this
    }
    prepend(e) {
        const n = this.tx;
        if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
            const r = this.a,
                i = this.c;
            this.a = r * e.a + this.b * e.c, this.b = r * e.b + this.b * e.d, this.c = i * e.a + this.d * e.c, this.d = i * e.b + this.d * e.d
        }
        return this.tx = n * e.a + this.ty * e.c + e.tx, this.ty = n * e.b + this.ty * e.d + e.ty, this
    }
    decompose(e) {
        const n = this.a,
            r = this.b,
            i = this.c,
            s = this.d,
            o = e.pivot,
            a = -Math.atan2(-i, s),
            l = Math.atan2(r, n),
            c = Math.abs(a + l);
        return c < 1e-5 || Math.abs(Xde - c) < 1e-5 ? (e.rotation = l, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = a, e.skew.y = l), e.scale.x = Math.sqrt(n * n + r * r), e.scale.y = Math.sqrt(i * i + s * s), e.position.x = this.tx + (o.x * n + o.y * i), e.position.y = this.ty + (o.x * r + o.y * s), e
    }
    invert() {
        const e = this.a,
            n = this.b,
            r = this.c,
            i = this.d,
            s = this.tx,
            o = e * i - n * r;
        return this.a = i / o, this.b = -n / o, this.c = -r / o, this.d = e / o, this.tx = (r * this.ty - i * s) / o, this.ty = -(e * this.ty - n * s) / o, this
    }
    isIdentity() {
        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0
    }
    identity() {
        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
    }
    clone() {
        const e = new Ce;
        return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e
    }
    copyTo(e) {
        return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e
    }
    copyFrom(e) {
        return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this
    }
    equals(e) {
        return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty
    }
    toString() {
        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
    }
    static get IDENTITY() {
        return Zde.identity()
    }
    static get shared() {
        return Jde.identity()
    }
}
const Jde = new Ce,
    Zde = new Ce,
    uo = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
    fo = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
    ho = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
    po = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
    v0 = [],
    JB = [],
    ef = Math.sign;

function Qde() {
    for (let t = 0; t < 16; t++) {
        const e = [];
        v0.push(e);
        for (let n = 0; n < 16; n++) {
            const r = ef(uo[t] * uo[n] + ho[t] * fo[n]),
                i = ef(fo[t] * uo[n] + po[t] * fo[n]),
                s = ef(uo[t] * ho[n] + ho[t] * po[n]),
                o = ef(fo[t] * ho[n] + po[t] * po[n]);
            for (let a = 0; a < 16; a++)
                if (uo[a] === r && fo[a] === i && ho[a] === s && po[a] === o) {
                    e.push(a);
                    break
                }
        }
    }
    for (let t = 0; t < 16; t++) {
        const e = new Ce;
        e.set(uo[t], fo[t], ho[t], po[t], 0, 0), JB.push(e)
    }
}
Qde();
const bt = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: t => uo[t],
        uY: t => fo[t],
        vX: t => ho[t],
        vY: t => po[t],
        inv: t => t & 8 ? t & 15 : -t & 7,
        add: (t, e) => v0[t][e],
        sub: (t, e) => v0[t][bt.inv(e)],
        rotate180: t => t ^ 4,
        isVertical: t => (t & 3) === 2,
        byDirection: (t, e) => Math.abs(t) * 2 <= Math.abs(e) ? e >= 0 ? bt.S : bt.N : Math.abs(e) * 2 <= Math.abs(t) ? t > 0 ? bt.E : bt.W : e > 0 ? t > 0 ? bt.SE : bt.SW : t > 0 ? bt.NE : bt.NW,
        matrixAppendRotationInv: (t, e, n = 0, r = 0) => {
            const i = JB[bt.inv(e)];
            i.tx = n, i.ty = r, t.append(i)
        }
    },
    tf = [new ct, new ct, new ct, new ct];
class at {
    constructor(e = 0, n = 0, r = 0, i = 0) {
        this.type = "rectangle", this.x = Number(e), this.y = Number(n), this.width = Number(r), this.height = Number(i)
    }
    get left() {
        return this.x
    }
    get right() {
        return this.x + this.width
    }
    get top() {
        return this.y
    }
    get bottom() {
        return this.y + this.height
    }
    isEmpty() {
        return this.left === this.right || this.top === this.bottom
    }
    static get EMPTY() {
        return new at(0, 0, 0, 0)
    }
    clone() {
        return new at(this.x, this.y, this.width, this.height)
    }
    copyFromBounds(e) {
        return this.x = e.minX, this.y = e.minY, this.width = e.maxX - e.minX, this.height = e.maxY - e.minY, this
    }
    copyFrom(e) {
        return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this
    }
    copyTo(e) {
        return e.copyFrom(this), e
    }
    contains(e, n) {
        return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && n >= this.y && n < this.y + this.height
    }
    strokeContains(e, n, r, i = .5) {
        const {
            width: s,
            height: o
        } = this;
        if (s <= 0 || o <= 0) return !1;
        const a = this.x,
            l = this.y,
            c = r * (1 - i),
            u = r - c,
            d = a - c,
            f = a + s + c,
            h = l - c,
            p = l + o + c,
            b = a + u,
            y = a + s - u,
            m = l + u,
            g = l + o - u;
        return e >= d && e <= f && n >= h && n <= p && !(e > b && e < y && n > m && n < g)
    }
    intersects(e, n) {
        if (!n) {
            const C = this.x < e.x ? e.x : this.x;
            if ((this.right > e.right ? e.right : this.right) <= C) return !1;
            const T = this.y < e.y ? e.y : this.y;
            return (this.bottom > e.bottom ? e.bottom : this.bottom) > T
        }
        const r = this.left,
            i = this.right,
            s = this.top,
            o = this.bottom;
        if (i <= r || o <= s) return !1;
        const a = tf[0].set(e.left, e.top),
            l = tf[1].set(e.left, e.bottom),
            c = tf[2].set(e.right, e.top),
            u = tf[3].set(e.right, e.bottom);
        if (c.x <= a.x || l.y <= a.y) return !1;
        const d = Math.sign(n.a * n.d - n.b * n.c);
        if (d === 0 || (n.apply(a, a), n.apply(l, l), n.apply(c, c), n.apply(u, u), Math.max(a.x, l.x, c.x, u.x) <= r || Math.min(a.x, l.x, c.x, u.x) >= i || Math.max(a.y, l.y, c.y, u.y) <= s || Math.min(a.y, l.y, c.y, u.y) >= o)) return !1;
        const f = d * (l.y - a.y),
            h = d * (a.x - l.x),
            p = f * r + h * s,
            b = f * i + h * s,
            y = f * r + h * o,
            m = f * i + h * o;
        if (Math.max(p, b, y, m) <= f * a.x + h * a.y || Math.min(p, b, y, m) >= f * u.x + h * u.y) return !1;
        const g = d * (a.y - c.y),
            v = d * (c.x - a.x),
            _ = g * r + v * s,
            x = g * i + v * s,
            w = g * r + v * o,
            S = g * i + v * o;
        return !(Math.max(_, x, w, S) <= g * a.x + v * a.y || Math.min(_, x, w, S) >= g * u.x + v * u.y)
    }
    pad(e = 0, n = e) {
        return this.x -= e, this.y -= n, this.width += e * 2, this.height += n * 2, this
    }
    fit(e) {
        const n = Math.max(this.x, e.x),
            r = Math.min(this.x + this.width, e.x + e.width),
            i = Math.max(this.y, e.y),
            s = Math.min(this.y + this.height, e.y + e.height);
        return this.x = n, this.width = Math.max(r - n, 0), this.y = i, this.height = Math.max(s - i, 0), this
    }
    ceil(e = 1, n = .001) {
        const r = Math.ceil((this.x + this.width - n) * e) / e,
            i = Math.ceil((this.y + this.height - n) * e) / e;
        return this.x = Math.floor((this.x + n) * e) / e, this.y = Math.floor((this.y + n) * e) / e, this.width = r - this.x, this.height = i - this.y, this
    }
    enlarge(e) {
        const n = Math.min(this.x, e.x),
            r = Math.max(this.x + this.width, e.x + e.width),
            i = Math.min(this.y, e.y),
            s = Math.max(this.y + this.height, e.y + e.height);
        return this.x = n, this.width = r - n, this.y = i, this.height = s - i, this
    }
    getBounds(e) {
        return e || (e = new at), e.copyFrom(this), e
    }
    containsRect(e) {
        if (this.width <= 0 || this.height <= 0) return !1;
        const n = e.x,
            r = e.y,
            i = e.x + e.width,
            s = e.y + e.height;
        return n >= this.x && n < this.x + this.width && r >= this.y && r < this.y + this.height && i >= this.x && i < this.x + this.width && s >= this.y && s < this.y + this.height
    }
    toString() {
        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
    }
}
const Ng = {
    default: -1
};

function yt(t = "default") {
    return Ng[t] === void 0 && (Ng[t] = -1), ++Ng[t]
}
const KT = {},
    Ye = "8.0.0",
    efe = "8.3.4";

function $e(t, e, n = 3) {
    if (KT[e]) return;
    let r = new Error().stack;
    typeof r > "u" ? console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${t}`) : (r = r.split(`
`).splice(n).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${e}
Deprecated since v${t}`), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${t}`), console.warn(r))), KT[e] = !0
}
const ZB = () => {};

function Tl(t) {
    return t += t === 0 ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t + 1
}

function qT(t) {
    return !(t & t - 1) && !!t
}

function QB(t) {
    const e = {};
    for (const n in t) t[n] !== void 0 && (e[n] = t[n]);
    return e
}
const JT = Object.create(null);

function tfe(t) {
    const e = JT[t];
    return e === void 0 && (JT[t] = yt("resource")), e
}
const eD = class tD extends rr {
    constructor(e = {}) {
        super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = !1, e = { ...tD.defaultOptions,
            ...e
        }, this.addressMode = e.addressMode, this.addressModeU = e.addressModeU ? ? this.addressModeU, this.addressModeV = e.addressModeV ? ? this.addressModeV, this.addressModeW = e.addressModeW ? ? this.addressModeW, this.scaleMode = e.scaleMode, this.magFilter = e.magFilter ? ? this.magFilter, this.minFilter = e.minFilter ? ? this.minFilter, this.mipmapFilter = e.mipmapFilter ? ? this.mipmapFilter, this.lodMinClamp = e.lodMinClamp, this.lodMaxClamp = e.lodMaxClamp, this.compare = e.compare, this.maxAnisotropy = e.maxAnisotropy ? ? 1
    }
    set addressMode(e) {
        this.addressModeU = e, this.addressModeV = e, this.addressModeW = e
    }
    get addressMode() {
        return this.addressModeU
    }
    set wrapMode(e) {
        $e(Ye, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = e
    }
    get wrapMode() {
        return this.addressMode
    }
    set scaleMode(e) {
        this.magFilter = e, this.minFilter = e, this.mipmapFilter = e
    }
    get scaleMode() {
        return this.magFilter
    }
    set maxAnisotropy(e) {
        this._maxAnisotropy = Math.min(e, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear")
    }
    get maxAnisotropy() {
        return this._maxAnisotropy
    }
    get _resourceId() {
        return this._sharedResourceId || this._generateResourceId()
    }
    update() {
        this.emit("change", this), this._sharedResourceId = null
    }
    _generateResourceId() {
        const e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
        return this._sharedResourceId = tfe(e), this._resourceId
    }
    destroy() {
        this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners()
    }
};
eD.defaultOptions = {
    addressMode: "clamp-to-edge",
    scaleMode: "linear"
};
let nD = eD;
const rD = class iD extends rr {
    constructor(e = {}) {
        super(), this.options = e, this.uid = yt("textureSource"), this._resourceType = "textureSource", this._resourceId = yt("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, e = { ...iD.defaultOptions,
            ...e
        }, this.label = e.label ? ? "", this.resource = e.resource, this.autoGarbageCollect = e.autoGarbageCollect, this._resolution = e.resolution, e.width ? this.pixelWidth = e.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ? ? 1 : 1, e.height ? this.pixelHeight = e.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ? ? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = e.format, this.dimension = e.dimensions, this.mipLevelCount = e.mipLevelCount, this.autoGenerateMipmaps = e.autoGenerateMipmaps, this.sampleCount = e.sampleCount, this.antialias = e.antialias, this.alphaMode = e.alphaMode, this.style = new nD(QB(e)), this.destroyed = !1, this._refreshPOT()
    }
    get source() {
        return this
    }
    get style() {
        return this._style
    }
    set style(e) {
        var n, r;
        this.style !== e && ((n = this._style) == null || n.off("change", this._onStyleChange, this), this._style = e, (r = this._style) == null || r.on("change", this._onStyleChange, this), this._onStyleChange())
    }
    get addressMode() {
        return this._style.addressMode
    }
    set addressMode(e) {
        this._style.addressMode = e
    }
    get repeatMode() {
        return this._style.addressMode
    }
    set repeatMode(e) {
        this._style.addressMode = e
    }
    get magFilter() {
        return this._style.magFilter
    }
    set magFilter(e) {
        this._style.magFilter = e
    }
    get minFilter() {
        return this._style.minFilter
    }
    set minFilter(e) {
        this._style.minFilter = e
    }
    get mipmapFilter() {
        return this._style.mipmapFilter
    }
    set mipmapFilter(e) {
        this._style.mipmapFilter = e
    }
    get lodMinClamp() {
        return this._style.lodMinClamp
    }
    set lodMinClamp(e) {
        this._style.lodMinClamp = e
    }
    get lodMaxClamp() {
        return this._style.lodMaxClamp
    }
    set lodMaxClamp(e) {
        this._style.lodMaxClamp = e
    }
    _onStyleChange() {
        this.emit("styleChange", this)
    }
    update() {
        if (this.resource) {
            const e = this._resolution;
            if (this.resize(this.resourceWidth / e, this.resourceHeight / e)) return
        }
        this.emit("update", this)
    }
    destroy() {
        this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners()
    }
    unload() {
        this._resourceId = yt("resource"), this.emit("change", this), this.emit("unload", this)
    }
    get resourceWidth() {
        const {
            resource: e
        } = this;
        return e.naturalWidth || e.videoWidth || e.displayWidth || e.width
    }
    get resourceHeight() {
        const {
            resource: e
        } = this;
        return e.naturalHeight || e.videoHeight || e.displayHeight || e.height
    }
    get resolution() {
        return this._resolution
    }
    set resolution(e) {
        this._resolution !== e && (this._resolution = e, this.width = this.pixelWidth / e, this.height = this.pixelHeight / e)
    }
    resize(e, n, r) {
        r || (r = this._resolution), e || (e = this.width), n || (n = this.height);
        const i = Math.round(e * r),
            s = Math.round(n * r);
        return this.width = i / r, this.height = s / r, this._resolution = r, this.pixelWidth === i && this.pixelHeight === s ? !1 : (this._refreshPOT(), this.pixelWidth = i, this.pixelHeight = s, this.emit("resize", this), this._resourceId = yt("resource"), this.emit("change", this), !0)
    }
    updateMipmaps() {
        this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this)
    }
    set wrapMode(e) {
        this._style.wrapMode = e
    }
    get wrapMode() {
        return this._style.wrapMode
    }
    set scaleMode(e) {
        this._style.scaleMode = e
    }
    get scaleMode() {
        return this._style.scaleMode
    }
    _refreshPOT() {
        this.isPowerOfTwo = qT(this.pixelWidth) && qT(this.pixelHeight)
    }
    static test(e) {
        throw new Error("Unimplemented")
    }
};
rD.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: !1,
    sampleCount: 1,
    antialias: !1,
    autoGarbageCollect: !1
};
let Qt = rD;
class Rx extends Qt {
    constructor(e) {
        const n = e.resource || new Float32Array(e.width * e.height * 4);
        let r = e.format;
        r || (n instanceof Float32Array ? r = "rgba32float" : n instanceof Int32Array || n instanceof Uint32Array ? r = "rgba32uint" : n instanceof Int16Array || n instanceof Uint16Array ? r = "rgba16uint" : (n instanceof Int8Array, r = "bgra8unorm")), super({ ...e,
            resource: n,
            format: r
        }), this.uploadMethodId = "buffer"
    }
    static test(e) {
        return e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array
    }
}
Rx.extension = G.TextureSource;
const ZT = new Ce;
class sD {
    constructor(e, n) {
        this.mapCoord = new Ce, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof n > "u" ? this.clampMargin = e.width < 10 ? 0 : .5 : this.clampMargin = n, this.isSimple = !1, this.texture = e
    }
    get texture() {
        return this._texture
    }
    set texture(e) {
        var n;
        this.texture !== e && ((n = this._texture) == null || n.removeListener("update", this.update, this), this._texture = e, this._texture.addListener("update", this.update, this), this.update())
    }
    multiplyUvs(e, n) {
        n === void 0 && (n = e);
        const r = this.mapCoord;
        for (let i = 0; i < e.length; i += 2) {
            const s = e[i],
                o = e[i + 1];
            n[i] = s * r.a + o * r.c + r.tx, n[i + 1] = s * r.b + o * r.d + r.ty
        }
        return n
    }
    update() {
        const e = this._texture;
        this._updateID++;
        const n = e.uvs;
        this.mapCoord.set(n.x1 - n.x0, n.y1 - n.y0, n.x3 - n.x0, n.y3 - n.y0, n.x0, n.y0);
        const r = e.orig,
            i = e.trim;
        i && (ZT.set(r.width / i.width, 0, 0, r.height / i.height, -i.x / i.width, -i.y / i.height), this.mapCoord.append(ZT));
        const s = e.source,
            o = this.uClampFrame,
            a = this.clampMargin / s._resolution,
            l = this.clampOffset / s._resolution;
        return o[0] = (e.frame.x + a + l) / s.width, o[1] = (e.frame.y + a + l) / s.height, o[2] = (e.frame.x + e.frame.width - a + l) / s.width, o[3] = (e.frame.y + e.frame.height - a + l) / s.height, this.uClampOffset[0] = this.clampOffset / s.pixelWidth, this.uClampOffset[1] = this.clampOffset / s.pixelHeight, this.isSimple = e.frame.width === s.width && e.frame.height === s.height && e.rotate === 0, !0
    }
}
class we extends rr {
    constructor({
        source: e,
        label: n,
        frame: r,
        orig: i,
        trim: s,
        defaultAnchor: o,
        defaultBorders: a,
        rotate: l,
        dynamic: c
    } = {}) {
        if (super(), this.uid = yt("texture"), this.uvs = {
                x0: 0,
                y0: 0,
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                x3: 0,
                y3: 0
            }, this.frame = new at, this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = n, this.source = (e == null ? void 0 : e.source) ? ? new Qt, this.noFrame = !r, r) this.frame.copyFrom(r);
        else {
            const {
                width: u,
                height: d
            } = this._source;
            this.frame.width = u, this.frame.height = d
        }
        this.orig = i || this.frame, this.trim = s, this.rotate = l ? ? 0, this.defaultAnchor = o, this.defaultBorders = a, this.destroyed = !1, this.dynamic = c || !1, this.updateUvs()
    }
    set source(e) {
        this._source && this._source.off("resize", this.update, this), this._source = e, e.on("resize", this.update, this), this.emit("update", this)
    }
    get source() {
        return this._source
    }
    get textureMatrix() {
        return this._textureMatrix || (this._textureMatrix = new sD(this)), this._textureMatrix
    }
    get width() {
        return this.orig.width
    }
    get height() {
        return this.orig.height
    }
    updateUvs() {
        const {
            uvs: e,
            frame: n
        } = this, {
            width: r,
            height: i
        } = this._source, s = n.x / r, o = n.y / i, a = n.width / r, l = n.height / i;
        let c = this.rotate;
        if (c) {
            const u = a / 2,
                d = l / 2,
                f = s + u,
                h = o + d;
            c = bt.add(c, bt.NW), e.x0 = f + u * bt.uX(c), e.y0 = h + d * bt.uY(c), c = bt.add(c, 2), e.x1 = f + u * bt.uX(c), e.y1 = h + d * bt.uY(c), c = bt.add(c, 2), e.x2 = f + u * bt.uX(c), e.y2 = h + d * bt.uY(c), c = bt.add(c, 2), e.x3 = f + u * bt.uX(c), e.y3 = h + d * bt.uY(c)
        } else e.x0 = s, e.y0 = o, e.x1 = s + a, e.y1 = o, e.x2 = s + a, e.y2 = o + l, e.x3 = s, e.y3 = o + l
    }
    destroy(e = !1) {
        this._source && e && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners()
    }
    update() {
        this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this)
    }
    get baseTexture() {
        return $e(Ye, "Texture.baseTexture is now Texture.source"), this._source
    }
}
we.EMPTY = new we({
    label: "EMPTY",
    source: new Qt({
        label: "EMPTY"
    })
});
we.EMPTY.destroy = ZB;
we.WHITE = new we({
    source: new Rx({
        resource: new Uint8Array([255, 255, 255, 255]),
        width: 1,
        height: 1,
        alphaMode: "premultiply-alpha-on-upload",
        label: "WHITE"
    }),
    label: "WHITE"
});
we.WHITE.destroy = ZB;

function oD(t, e, n) {
    const {
        width: r,
        height: i
    } = n.orig, s = n.trim;
    if (s) {
        const o = s.width,
            a = s.height;
        t.minX = s.x - e._x * r, t.maxX = t.minX + o, t.minY = s.y - e._y * i, t.maxY = t.minY + a
    } else t.minX = -e._x * r, t.maxX = t.minX + r, t.minY = -e._y * i, t.maxY = t.minY + i
}
const QT = new Ce;
class rn {
    constructor(e = 1 / 0, n = 1 / 0, r = -1 / 0, i = -1 / 0) {
        this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = QT, this.minX = e, this.minY = n, this.maxX = r, this.maxY = i
    }
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY
    }
    get rectangle() {
        this._rectangle || (this._rectangle = new at);
        const e = this._rectangle;
        return this.minX > this.maxX || this.minY > this.maxY ? (e.x = 0, e.y = 0, e.width = 0, e.height = 0) : e.copyFromBounds(this), e
    }
    clear() {
        return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = QT, this
    }
    set(e, n, r, i) {
        this.minX = e, this.minY = n, this.maxX = r, this.maxY = i
    }
    addFrame(e, n, r, i, s) {
        s || (s = this.matrix);
        const o = s.a,
            a = s.b,
            l = s.c,
            c = s.d,
            u = s.tx,
            d = s.ty;
        let f = this.minX,
            h = this.minY,
            p = this.maxX,
            b = this.maxY,
            y = o * e + l * n + u,
            m = a * e + c * n + d;
        y < f && (f = y), m < h && (h = m), y > p && (p = y), m > b && (b = m), y = o * r + l * n + u, m = a * r + c * n + d, y < f && (f = y), m < h && (h = m), y > p && (p = y), m > b && (b = m), y = o * e + l * i + u, m = a * e + c * i + d, y < f && (f = y), m < h && (h = m), y > p && (p = y), m > b && (b = m), y = o * r + l * i + u, m = a * r + c * i + d, y < f && (f = y), m < h && (h = m), y > p && (p = y), m > b && (b = m), this.minX = f, this.minY = h, this.maxX = p, this.maxY = b
    }
    addRect(e, n) {
        this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, n)
    }
    addBounds(e, n) {
        this.addFrame(e.minX, e.minY, e.maxX, e.maxY, n)
    }
    addBoundsMask(e) {
        this.minX = this.minX > e.minX ? this.minX : e.minX, this.minY = this.minY > e.minY ? this.minY : e.minY, this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX, this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY
    }
    applyMatrix(e) {
        const n = this.minX,
            r = this.minY,
            i = this.maxX,
            s = this.maxY,
            {
                a: o,
                b: a,
                c: l,
                d: c,
                tx: u,
                ty: d
            } = e;
        let f = o * n + l * r + u,
            h = a * n + c * r + d;
        this.minX = f, this.minY = h, this.maxX = f, this.maxY = h, f = o * i + l * r + u, h = a * i + c * r + d, this.minX = f < this.minX ? f : this.minX, this.minY = h < this.minY ? h : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = h > this.maxY ? h : this.maxY, f = o * n + l * s + u, h = a * n + c * s + d, this.minX = f < this.minX ? f : this.minX, this.minY = h < this.minY ? h : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = h > this.maxY ? h : this.maxY, f = o * i + l * s + u, h = a * i + c * s + d, this.minX = f < this.minX ? f : this.minX, this.minY = h < this.minY ? h : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = h > this.maxY ? h : this.maxY
    }
    fit(e) {
        return this.minX < e.left && (this.minX = e.left), this.maxX > e.right && (this.maxX = e.right), this.minY < e.top && (this.minY = e.top), this.maxY > e.bottom && (this.maxY = e.bottom), this
    }
    fitBounds(e, n, r, i) {
        return this.minX < e && (this.minX = e), this.maxX > n && (this.maxX = n), this.minY < r && (this.minY = r), this.maxY > i && (this.maxY = i), this
    }
    pad(e, n = e) {
        return this.minX -= e, this.maxX += e, this.minY -= n, this.maxY += n, this
    }
    ceil() {
        return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this
    }
    clone() {
        return new rn(this.minX, this.minY, this.maxX, this.maxY)
    }
    scale(e, n = e) {
        return this.minX *= e, this.minY *= n, this.maxX *= e, this.maxY *= n, this
    }
    get x() {
        return this.minX
    }
    set x(e) {
        const n = this.maxX - this.minX;
        this.minX = e, this.maxX = e + n
    }
    get y() {
        return this.minY
    }
    set y(e) {
        const n = this.maxY - this.minY;
        this.minY = e, this.maxY = e + n
    }
    get width() {
        return this.maxX - this.minX
    }
    set width(e) {
        this.maxX = this.minX + e
    }
    get height() {
        return this.maxY - this.minY
    }
    set height(e) {
        this.maxY = this.minY + e
    }
    get left() {
        return this.minX
    }
    get right() {
        return this.maxX
    }
    get top() {
        return this.minY
    }
    get bottom() {
        return this.maxY
    }
    get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0
    }
    get isValid() {
        return this.minX + this.minY !== 1 / 0
    }
    addVertexData(e, n, r, i) {
        let s = this.minX,
            o = this.minY,
            a = this.maxX,
            l = this.maxY;
        i || (i = this.matrix);
        const c = i.a,
            u = i.b,
            d = i.c,
            f = i.d,
            h = i.tx,
            p = i.ty;
        for (let b = n; b < r; b += 2) {
            const y = e[b],
                m = e[b + 1],
                g = c * y + d * m + h,
                v = u * y + f * m + p;
            s = g < s ? g : s, o = v < o ? v : o, a = g > a ? g : a, l = v > l ? v : l
        }
        this.minX = s, this.minY = o, this.maxX = a, this.maxY = l
    }
    containsPoint(e, n) {
        return this.minX <= e && this.minY <= n && this.maxX >= e && this.maxY >= n
    }
    toString() {
        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`
    }
    copyFrom(e) {
        return this.minX = e.minX, this.minY = e.minY, this.maxX = e.maxX, this.maxY = e.maxY, this
    }
}
var nfe = {
        grad: .9,
        turn: 360,
        rad: 360 / (2 * Math.PI)
    },
    gi = function(t) {
        return typeof t == "string" ? t.length > 0 : typeof t == "number"
    },
    Xt = function(t, e, n) {
        return e === void 0 && (e = 0), n === void 0 && (n = Math.pow(10, e)), Math.round(n * t) / n + 0
    },
    fr = function(t, e, n) {
        return e === void 0 && (e = 0), n === void 0 && (n = 1), t > n ? n : t > e ? t : e
    },
    aD = function(t) {
        return (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360
    },
    eC = function(t) {
        return {
            r: fr(t.r, 0, 255),
            g: fr(t.g, 0, 255),
            b: fr(t.b, 0, 255),
            a: fr(t.a)
        }
    },
    Ug = function(t) {
        return {
            r: Xt(t.r),
            g: Xt(t.g),
            b: Xt(t.b),
            a: Xt(t.a, 3)
        }
    },
    rfe = /^#([0-9a-f]{3,8})$/i,
    nf = function(t) {
        var e = t.toString(16);
        return e.length < 2 ? "0" + e : e
    },
    lD = function(t) {
        var e = t.r,
            n = t.g,
            r = t.b,
            i = t.a,
            s = Math.max(e, n, r),
            o = s - Math.min(e, n, r),
            a = o ? s === e ? (n - r) / o : s === n ? 2 + (r - e) / o : 4 + (e - n) / o : 0;
        return {
            h: 60 * (a < 0 ? a + 6 : a),
            s: s ? o / s * 100 : 0,
            v: s / 255 * 100,
            a: i
        }
    },
    cD = function(t) {
        var e = t.h,
            n = t.s,
            r = t.v,
            i = t.a;
        e = e / 360 * 6, n /= 100, r /= 100;
        var s = Math.floor(e),
            o = r * (1 - n),
            a = r * (1 - (e - s) * n),
            l = r * (1 - (1 - e + s) * n),
            c = s % 6;
        return {
            r: 255 * [r, a, o, o, l, r][c],
            g: 255 * [l, r, r, a, o, o][c],
            b: 255 * [o, o, l, r, r, a][c],
            a: i
        }
    },
    tC = function(t) {
        return {
            h: aD(t.h),
            s: fr(t.s, 0, 100),
            l: fr(t.l, 0, 100),
            a: fr(t.a)
        }
    },
    nC = function(t) {
        return {
            h: Xt(t.h),
            s: Xt(t.s),
            l: Xt(t.l),
            a: Xt(t.a, 3)
        }
    },
    rC = function(t) {
        return cD((n = (e = t).s, {
            h: e.h,
            s: (n *= ((r = e.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * n / (r + n) * 100 : 0,
            v: r + n,
            a: e.a
        }));
        var e, n, r
    },
    Hc = function(t) {
        return {
            h: (e = lD(t)).h,
            s: (i = (200 - (n = e.s)) * (r = e.v) / 100) > 0 && i < 200 ? n * r / 100 / (i <= 100 ? i : 200 - i) * 100 : 0,
            l: i / 2,
            a: e.a
        };
        var e, n, r, i
    },
    ife = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    sfe = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    ofe = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    afe = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    y0 = {
        string: [
            [function(t) {
                var e = rfe.exec(t);
                return e ? (t = e[1]).length <= 4 ? {
                    r: parseInt(t[0] + t[0], 16),
                    g: parseInt(t[1] + t[1], 16),
                    b: parseInt(t[2] + t[2], 16),
                    a: t.length === 4 ? Xt(parseInt(t[3] + t[3], 16) / 255, 2) : 1
                } : t.length === 6 || t.length === 8 ? {
                    r: parseInt(t.substr(0, 2), 16),
                    g: parseInt(t.substr(2, 2), 16),
                    b: parseInt(t.substr(4, 2), 16),
                    a: t.length === 8 ? Xt(parseInt(t.substr(6, 2), 16) / 255, 2) : 1
                } : null : null
            }, "hex"],
            [function(t) {
                var e = ofe.exec(t) || afe.exec(t);
                return e ? e[2] !== e[4] || e[4] !== e[6] ? null : eC({
                    r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                    g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                    b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                    a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1)
                }) : null
            }, "rgb"],
            [function(t) {
                var e = ife.exec(t) || sfe.exec(t);
                if (!e) return null;
                var n, r, i = tC({
                    h: (n = e[1], r = e[2], r === void 0 && (r = "deg"), Number(n) * (nfe[r] || 1)),
                    s: Number(e[3]),
                    l: Number(e[4]),
                    a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1)
                });
                return rC(i)
            }, "hsl"]
        ],
        object: [
            [function(t) {
                var e = t.r,
                    n = t.g,
                    r = t.b,
                    i = t.a,
                    s = i === void 0 ? 1 : i;
                return gi(e) && gi(n) && gi(r) ? eC({
                    r: Number(e),
                    g: Number(n),
                    b: Number(r),
                    a: Number(s)
                }) : null
            }, "rgb"],
            [function(t) {
                var e = t.h,
                    n = t.s,
                    r = t.l,
                    i = t.a,
                    s = i === void 0 ? 1 : i;
                if (!gi(e) || !gi(n) || !gi(r)) return null;
                var o = tC({
                    h: Number(e),
                    s: Number(n),
                    l: Number(r),
                    a: Number(s)
                });
                return rC(o)
            }, "hsl"],
            [function(t) {
                var e = t.h,
                    n = t.s,
                    r = t.v,
                    i = t.a,
                    s = i === void 0 ? 1 : i;
                if (!gi(e) || !gi(n) || !gi(r)) return null;
                var o = function(a) {
                    return {
                        h: aD(a.h),
                        s: fr(a.s, 0, 100),
                        v: fr(a.v, 0, 100),
                        a: fr(a.a)
                    }
                }({
                    h: Number(e),
                    s: Number(n),
                    v: Number(r),
                    a: Number(s)
                });
                return cD(o)
            }, "hsv"]
        ]
    },
    iC = function(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n][0](t);
            if (r) return [r, e[n][1]]
        }
        return [null, void 0]
    },
    lfe = function(t) {
        return typeof t == "string" ? iC(t.trim(), y0.string) : typeof t == "object" && t !== null ? iC(t, y0.object) : [null, void 0]
    },
    Gg = function(t, e) {
        var n = Hc(t);
        return {
            h: n.h,
            s: fr(n.s + 100 * e, 0, 100),
            l: n.l,
            a: n.a
        }
    },
    Hg = function(t) {
        return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 / 255
    },
    sC = function(t, e) {
        var n = Hc(t);
        return {
            h: n.h,
            s: n.s,
            l: fr(n.l + 100 * e, 0, 100),
            a: n.a
        }
    },
    _0 = function() {
        function t(e) {
            this.parsed = lfe(e)[0], this.rgba = this.parsed || {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            }
        }
        return t.prototype.isValid = function() {
            return this.parsed !== null
        }, t.prototype.brightness = function() {
            return Xt(Hg(this.rgba), 2)
        }, t.prototype.isDark = function() {
            return Hg(this.rgba) < .5
        }, t.prototype.isLight = function() {
            return Hg(this.rgba) >= .5
        }, t.prototype.toHex = function() {
            return e = Ug(this.rgba), n = e.r, r = e.g, i = e.b, o = (s = e.a) < 1 ? nf(Xt(255 * s)) : "", "#" + nf(n) + nf(r) + nf(i) + o;
            var e, n, r, i, s, o
        }, t.prototype.toRgb = function() {
            return Ug(this.rgba)
        }, t.prototype.toRgbString = function() {
            return e = Ug(this.rgba), n = e.r, r = e.g, i = e.b, (s = e.a) < 1 ? "rgba(" + n + ", " + r + ", " + i + ", " + s + ")" : "rgb(" + n + ", " + r + ", " + i + ")";
            var e, n, r, i, s
        }, t.prototype.toHsl = function() {
            return nC(Hc(this.rgba))
        }, t.prototype.toHslString = function() {
            return e = nC(Hc(this.rgba)), n = e.h, r = e.s, i = e.l, (s = e.a) < 1 ? "hsla(" + n + ", " + r + "%, " + i + "%, " + s + ")" : "hsl(" + n + ", " + r + "%, " + i + "%)";
            var e, n, r, i, s
        }, t.prototype.toHsv = function() {
            return e = lD(this.rgba), {
                h: Xt(e.h),
                s: Xt(e.s),
                v: Xt(e.v),
                a: Xt(e.a, 3)
            };
            var e
        }, t.prototype.invert = function() {
            return Hr({
                r: 255 - (e = this.rgba).r,
                g: 255 - e.g,
                b: 255 - e.b,
                a: e.a
            });
            var e
        }, t.prototype.saturate = function(e) {
            return e === void 0 && (e = .1), Hr(Gg(this.rgba, e))
        }, t.prototype.desaturate = function(e) {
            return e === void 0 && (e = .1), Hr(Gg(this.rgba, -e))
        }, t.prototype.grayscale = function() {
            return Hr(Gg(this.rgba, -1))
        }, t.prototype.lighten = function(e) {
            return e === void 0 && (e = .1), Hr(sC(this.rgba, e))
        }, t.prototype.darken = function(e) {
            return e === void 0 && (e = .1), Hr(sC(this.rgba, -e))
        }, t.prototype.rotate = function(e) {
            return e === void 0 && (e = 15), this.hue(this.hue() + e)
        }, t.prototype.alpha = function(e) {
            return typeof e == "number" ? Hr({
                r: (n = this.rgba).r,
                g: n.g,
                b: n.b,
                a: e
            }) : Xt(this.rgba.a, 3);
            var n
        }, t.prototype.hue = function(e) {
            var n = Hc(this.rgba);
            return typeof e == "number" ? Hr({
                h: e,
                s: n.s,
                l: n.l,
                a: n.a
            }) : Xt(n.h)
        }, t.prototype.isEqual = function(e) {
            return this.toHex() === Hr(e).toHex()
        }, t
    }(),
    Hr = function(t) {
        return t instanceof _0 ? t : new _0(t)
    },
    oC = [],
    cfe = function(t) {
        t.forEach(function(e) {
            oC.indexOf(e) < 0 && (e(_0, y0), oC.push(e))
        })
    };

function ufe(t, e) {
    var n = {
            white: "#ffffff",
            bisque: "#ffe4c4",
            blue: "#0000ff",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            azure: "#f0ffff",
            whitesmoke: "#f5f5f5",
            papayawhip: "#ffefd5",
            plum: "#dda0dd",
            blanchedalmond: "#ffebcd",
            black: "#000000",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gainsboro: "#dcdcdc",
            cornsilk: "#fff8dc",
            cornflowerblue: "#6495ed",
            burlywood: "#deb887",
            aquamarine: "#7fffd4",
            beige: "#f5f5dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkkhaki: "#bdb76b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            peachpuff: "#ffdab9",
            darkmagenta: "#8b008b",
            darkred: "#8b0000",
            darkorchid: "#9932cc",
            darkorange: "#ff8c00",
            darkslateblue: "#483d8b",
            gray: "#808080",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            wheat: "#f5deb3",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            ghostwhite: "#f8f8ff",
            darkviolet: "#9400d3",
            magenta: "#ff00ff",
            green: "#008000",
            dodgerblue: "#1e90ff",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            blueviolet: "#8a2be2",
            forestgreen: "#228b22",
            lawngreen: "#7cfc00",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            fuchsia: "#ff00ff",
            brown: "#a52a2a",
            maroon: "#800000",
            mediumblue: "#0000cd",
            lightcoral: "#f08080",
            darkturquoise: "#00ced1",
            lightcyan: "#e0ffff",
            ivory: "#fffff0",
            lightyellow: "#ffffe0",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            linen: "#faf0e6",
            mediumaquamarine: "#66cdaa",
            lemonchiffon: "#fffacd",
            lime: "#00ff00",
            khaki: "#f0e68c",
            mediumseagreen: "#3cb371",
            limegreen: "#32cd32",
            mediumspringgreen: "#00fa9a",
            lightskyblue: "#87cefa",
            lightblue: "#add8e6",
            midnightblue: "#191970",
            lightpink: "#ffb6c1",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            mintcream: "#f5fffa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            navajowhite: "#ffdead",
            navy: "#000080",
            mediumvioletred: "#c71585",
            powderblue: "#b0e0e6",
            palegoldenrod: "#eee8aa",
            oldlace: "#fdf5e6",
            paleturquoise: "#afeeee",
            mediumturquoise: "#48d1cc",
            mediumorchid: "#ba55d3",
            rebeccapurple: "#663399",
            lightsteelblue: "#b0c4de",
            mediumslateblue: "#7b68ee",
            thistle: "#d8bfd8",
            tan: "#d2b48c",
            orchid: "#da70d6",
            mediumpurple: "#9370db",
            purple: "#800080",
            pink: "#ffc0cb",
            skyblue: "#87ceeb",
            springgreen: "#00ff7f",
            palegreen: "#98fb98",
            red: "#ff0000",
            yellow: "#ffff00",
            slateblue: "#6a5acd",
            lavenderblush: "#fff0f5",
            peru: "#cd853f",
            palevioletred: "#db7093",
            violet: "#ee82ee",
            teal: "#008080",
            slategray: "#708090",
            slategrey: "#708090",
            aliceblue: "#f0f8ff",
            darkseagreen: "#8fbc8f",
            darkolivegreen: "#556b2f",
            greenyellow: "#adff2f",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            tomato: "#ff6347",
            silver: "#c0c0c0",
            sienna: "#a0522d",
            lavender: "#e6e6fa",
            lightgreen: "#90ee90",
            orange: "#ffa500",
            orangered: "#ff4500",
            steelblue: "#4682b4",
            royalblue: "#4169e1",
            turquoise: "#40e0d0",
            yellowgreen: "#9acd32",
            salmon: "#fa8072",
            saddlebrown: "#8b4513",
            sandybrown: "#f4a460",
            rosybrown: "#bc8f8f",
            darksalmon: "#e9967a",
            lightgoldenrodyellow: "#fafad2",
            snow: "#fffafa",
            lightgrey: "#d3d3d3",
            lightgray: "#d3d3d3",
            dimgray: "#696969",
            dimgrey: "#696969",
            olivedrab: "#6b8e23",
            olive: "#808000"
        },
        r = {};
    for (var i in n) r[n[i]] = i;
    var s = {};
    t.prototype.toName = function(o) {
        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
        var a, l, c = r[this.toHex()];
        if (c) return c;
        if (o != null && o.closest) {
            var u = this.toRgb(),
                d = 1 / 0,
                f = "black";
            if (!s.length)
                for (var h in n) s[h] = new t(n[h]).toRgb();
            for (var p in n) {
                var b = (a = u, l = s[p], Math.pow(a.r - l.r, 2) + Math.pow(a.g - l.g, 2) + Math.pow(a.b - l.b, 2));
                b < d && (d = b, f = p)
            }
            return f
        }
    }, e.string.push([function(o) {
        var a = o.toLowerCase(),
            l = a === "transparent" ? "#0000" : n[a];
        return l ? new t(l).toRgb() : null
    }, "name"])
}
cfe([ufe]);
const Cl = class _c {
    constructor(e = 16777215) {
        this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = e
    }
    get red() {
        return this._components[0]
    }
    get green() {
        return this._components[1]
    }
    get blue() {
        return this._components[2]
    }
    get alpha() {
        return this._components[3]
    }
    setValue(e) {
        return this.value = e, this
    }
    set value(e) {
        if (e instanceof _c) this._value = this._cloneSource(e._value), this._int = e._int, this._components.set(e._components);
        else {
            if (e === null) throw new Error("Cannot set Color#value to null");
            (this._value === null || !this._isSourceEqual(this._value, e)) && (this._value = this._cloneSource(e), this._normalize(this._value))
        }
    }
    get value() {
        return this._value
    }
    _cloneSource(e) {
        return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? { ...e
        } : e
    }
    _isSourceEqual(e, n) {
        const r = typeof e;
        if (r !== typeof n) return !1;
        if (r === "number" || r === "string" || e instanceof Number) return e === n;
        if (Array.isArray(e) && Array.isArray(n) || ArrayBuffer.isView(e) && ArrayBuffer.isView(n)) return e.length !== n.length ? !1 : e.every((s, o) => s === n[o]);
        if (e !== null && n !== null) {
            const s = Object.keys(e),
                o = Object.keys(n);
            return s.length !== o.length ? !1 : s.every(a => e[a] === n[a])
        }
        return e === n
    }
    toRgba() {
        const [e, n, r, i] = this._components;
        return {
            r: e,
            g: n,
            b: r,
            a: i
        }
    }
    toRgb() {
        const [e, n, r] = this._components;
        return {
            r: e,
            g: n,
            b: r
        }
    }
    toRgbaString() {
        const [e, n, r] = this.toUint8RgbArray();
        return `rgba(${e},${n},${r},${this.alpha})`
    }
    toUint8RgbArray(e) {
        const [n, r, i] = this._components;
        return this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb), e[0] = Math.round(n * 255), e[1] = Math.round(r * 255), e[2] = Math.round(i * 255), e
    }
    toArray(e) {
        this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba);
        const [n, r, i, s] = this._components;
        return e[0] = n, e[1] = r, e[2] = i, e[3] = s, e
    }
    toRgbArray(e) {
        this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb);
        const [n, r, i] = this._components;
        return e[0] = n, e[1] = r, e[2] = i, e
    }
    toNumber() {
        return this._int
    }
    toBgrNumber() {
        const [e, n, r] = this.toUint8RgbArray();
        return (r << 16) + (n << 8) + e
    }
    toLittleEndianNumber() {
        const e = this._int;
        return (e >> 16) + (e & 65280) + ((e & 255) << 16)
    }
    multiply(e) {
        const [n, r, i, s] = _c._temp.setValue(e)._components;
        return this._components[0] *= n, this._components[1] *= r, this._components[2] *= i, this._components[3] *= s, this._refreshInt(), this._value = null, this
    }
    premultiply(e, n = !0) {
        return n && (this._components[0] *= e, this._components[1] *= e, this._components[2] *= e), this._components[3] = e, this._refreshInt(), this._value = null, this
    }
    toPremultiplied(e, n = !0) {
        if (e === 1) return (255 << 24) + this._int;
        if (e === 0) return n ? 0 : this._int;
        let r = this._int >> 16 & 255,
            i = this._int >> 8 & 255,
            s = this._int & 255;
        return n && (r = r * e + .5 | 0, i = i * e + .5 | 0, s = s * e + .5 | 0), (e * 255 << 24) + (r << 16) + (i << 8) + s
    }
    toHex() {
        const e = this._int.toString(16);
        return `#${"000000".substring(0,6-e.length)+e}`
    }
    toHexa() {
        const n = Math.round(this._components[3] * 255).toString(16);
        return this.toHex() + "00".substring(0, 2 - n.length) + n
    }
    setAlpha(e) {
        return this._components[3] = this._clamp(e), this
    }
    _normalize(e) {
        let n, r, i, s;
        if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
            const o = e;
            n = (o >> 16 & 255) / 255, r = (o >> 8 & 255) / 255, i = (o & 255) / 255, s = 1
        } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4) e = this._clamp(e), [n, r, i, s = 1] = e;
        else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4) e = this._clamp(e, 0, 255), [n, r, i, s = 255] = e, n /= 255, r /= 255, i /= 255, s /= 255;
        else if (typeof e == "string" || typeof e == "object") {
            if (typeof e == "string") {
                const a = _c.HEX_PATTERN.exec(e);
                a && (e = `#${a[2]}`)
            }
            const o = Hr(e);
            o.isValid() && ({
                r: n,
                g: r,
                b: i,
                a: s
            } = o.rgba, n /= 255, r /= 255, i /= 255)
        }
        if (n !== void 0) this._components[0] = n, this._components[1] = r, this._components[2] = i, this._components[3] = s, this._refreshInt();
        else throw new Error(`Unable to convert color ${e}`)
    }
    _refreshInt() {
        this._clamp(this._components);
        const [e, n, r] = this._components;
        this._int = (e * 255 << 16) + (n * 255 << 8) + (r * 255 | 0)
    }
    _clamp(e, n = 0, r = 1) {
        return typeof e == "number" ? Math.min(Math.max(e, n), r) : (e.forEach((i, s) => {
            e[s] = Math.min(Math.max(i, n), r)
        }), e)
    }
    static isColorLike(e) {
        return typeof e == "number" || typeof e == "string" || e instanceof Number || e instanceof _c || Array.isArray(e) || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Float32Array || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0
    }
};
Cl.shared = new Cl;
Cl._temp = new Cl;
Cl.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let rt = Cl;
const dfe = {
    cullArea: null,
    cullable: !1,
    cullableChildren: !0
};
class Mx {
    constructor(e, n) {
        this._pool = [], this._count = 0, this._index = 0, this._classType = e, n && this.prepopulate(n)
    }
    prepopulate(e) {
        for (let n = 0; n < e; n++) this._pool[this._index++] = new this._classType;
        this._count += e
    }
    get(e) {
        var r;
        let n;
        return this._index > 0 ? n = this._pool[--this._index] : n = new this._classType, (r = n.init) == null || r.call(n, e), n
    }
    return (e) {
        var n;
        (n = e.reset) == null || n.call(e), this._pool[this._index++] = e
    }
    get totalSize() {
        return this._count
    }
    get totalFree() {
        return this._index
    }
    get totalUsed() {
        return this._count - this._index
    }
    clear() {
        this._pool.length = 0, this._index = 0
    }
}
class ffe {
    constructor() {
        this._poolsByClass = new Map
    }
    prepopulate(e, n) {
        this.getPool(e).prepopulate(n)
    }
    get(e, n) {
        return this.getPool(e).get(n)
    }
    return (e) {
        this.getPool(e.constructor).return(e)
    }
    getPool(e) {
        return this._poolsByClass.has(e) || this._poolsByClass.set(e, new Mx(e)), this._poolsByClass.get(e)
    }
    stats() {
        const e = {};
        return this._poolsByClass.forEach(n => {
            const r = e[n._classType.name] ? n._classType.name + n._classType.ID : n._classType.name;
            e[r] = {
                free: n.totalFree,
                used: n.totalUsed,
                size: n.totalSize
            }
        }), e
    }
}
const We = new ffe,
    hfe = {
        get isCachedAsTexture() {
            var t;
            return !!((t = this.renderGroup) != null && t.isCachedAsTexture)
        },
        cacheAsTexture(t) {
            typeof t == "boolean" && t === !1 ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(t === !0 ? {} : t))
        },
        updateCacheTexture() {
            var t;
            (t = this.renderGroup) == null || t.updateCacheTexture()
        },
        get cacheAsBitmap() {
            return this.isCachedAsTexture
        },
        set cacheAsBitmap(t) {
            $e("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(t)
        }
    };

function uD(t, e, n) {
    const r = t.length;
    let i;
    if (e >= r || n === 0) return;
    n = e + n > r ? r - e : n;
    const s = r - n;
    for (i = e; i < s; ++i) t[i] = t[i + n];
    t.length = s
}
const pfe = {
        allowChildren: !0,
        removeChildren(t = 0, e) {
            const n = e ? ? this.children.length,
                r = n - t,
                i = [];
            if (r > 0 && r <= n) {
                for (let o = n - 1; o >= t; o--) {
                    const a = this.children[o];
                    a && (i.push(a), a.parent = null)
                }
                uD(this.children, t, n);
                const s = this.renderGroup || this.parentRenderGroup;
                s && s.removeChildren(i);
                for (let o = 0; o < i.length; ++o) this.emit("childRemoved", i[o], this, o), i[o].emit("removed", this);
                return i.length > 0 && this._didViewChangeTick++, i
            } else if (r === 0 && this.children.length === 0) return i;
            throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
        },
        removeChildAt(t) {
            const e = this.getChildAt(t);
            return this.removeChild(e)
        },
        getChildAt(t) {
            if (t < 0 || t >= this.children.length) throw new Error(`getChildAt: Index (${t}) does not exist.`);
            return this.children[t]
        },
        setChildIndex(t, e) {
            if (e < 0 || e >= this.children.length) throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
            this.getChildIndex(t), this.addChildAt(t, e)
        },
        getChildIndex(t) {
            const e = this.children.indexOf(t);
            if (e === -1) throw new Error("The supplied Container must be a child of the caller");
            return e
        },
        addChildAt(t, e) {
            this.allowChildren || $e(Ye, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
            const {
                children: n
            } = this;
            if (e < 0 || e > n.length) throw new Error(`${t}addChildAt: The index ${e} supplied is out of bounds ${n.length}`);
            if (t.parent) {
                const i = t.parent.children.indexOf(t);
                if (t.parent === this && i === e) return t;
                i !== -1 && t.parent.children.splice(i, 1)
            }
            e === n.length ? n.push(t) : n.splice(e, 0, t), t.parent = this, t.didChange = !0, t._updateFlags = 15;
            const r = this.renderGroup || this.parentRenderGroup;
            return r && r.addChild(t), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", t, this, e), t.emit("added", this), t
        },
        swapChildren(t, e) {
            if (t === e) return;
            const n = this.getChildIndex(t),
                r = this.getChildIndex(e);
            this.children[n] = e, this.children[r] = t;
            const i = this.renderGroup || this.parentRenderGroup;
            i && (i.structureDidChange = !0), this._didContainerChangeTick++
        },
        removeFromParent() {
            var t;
            (t = this.parent) == null || t.removeChild(this)
        },
        reparentChild(...t) {
            return t.length === 1 ? this.reparentChildAt(t[0], this.children.length) : (t.forEach(e => this.reparentChildAt(e, this.children.length)), t[0])
        },
        reparentChildAt(t, e) {
            if (t.parent === this) return this.setChildIndex(t, e), t;
            const n = t.worldTransform.clone();
            t.removeFromParent(), this.addChildAt(t, e);
            const r = this.worldTransform.clone();
            return r.invert(), n.prepend(r), t.setFromMatrix(n), t
        }
    },
    mfe = {
        collectRenderables(t, e, n) {
            this.parentRenderLayer && this.parentRenderLayer !== n || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(t, e, n) : this.renderGroup ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, t) : this.collectRenderablesWithEffects(t, e, n))
        },
        collectRenderablesSimple(t, e, n) {
            const r = this.children,
                i = r.length;
            for (let s = 0; s < i; s++) r[s].collectRenderables(t, e, n)
        },
        collectRenderablesWithEffects(t, e, n) {
            const {
                renderPipes: r
            } = e;
            for (let i = 0; i < this.effects.length; i++) {
                const s = this.effects[i];
                r[s.pipe].push(s, this, t)
            }
            this.collectRenderablesSimple(t, e, n);
            for (let i = this.effects.length - 1; i >= 0; i--) {
                const s = this.effects[i];
                r[s.pipe].pop(s, this, t)
            }
        }
    };
class Ph {
    constructor() {
        this.pipe = "filter", this.priority = 1
    }
    destroy() {
        for (let e = 0; e < this.filters.length; e++) this.filters[e].destroy();
        this.filters = null, this.filterArea = null
    }
}
class gfe {
    constructor() {
        this._effectClasses = [], this._tests = [], this._initialized = !1
    }
    init() {
        this._initialized || (this._initialized = !0, this._effectClasses.forEach(e => {
            this.add({
                test: e.test,
                maskClass: e
            })
        }))
    }
    add(e) {
        this._tests.push(e)
    }
    getMaskEffect(e) {
        this._initialized || this.init();
        for (let n = 0; n < this._tests.length; n++) {
            const r = this._tests[n];
            if (r.test(e)) return We.get(r.maskClass, e)
        }
        return e
    }
    returnMaskEffect(e) {
        We.return(e)
    }
}
const b0 = new gfe;
Ie.handleByList(G.MaskEffect, b0._effectClasses);
const vfe = {
        _maskEffect: null,
        _maskOptions: {
            inverse: !1
        },
        _filterEffect: null,
        effects: [],
        _markStructureAsChanged() {
            const t = this.renderGroup || this.parentRenderGroup;
            t && (t.structureDidChange = !0)
        },
        addEffect(t) {
            this.effects.indexOf(t) === -1 && (this.effects.push(t), this.effects.sort((n, r) => n.priority - r.priority), this._markStructureAsChanged(), this._updateIsSimple())
        },
        removeEffect(t) {
            const e = this.effects.indexOf(t);
            e !== -1 && (this.effects.splice(e, 1), this._markStructureAsChanged(), this._updateIsSimple())
        },
        set mask(t) {
            const e = this._maskEffect;
            (e == null ? void 0 : e.mask) !== t && (e && (this.removeEffect(e), b0.returnMaskEffect(e), this._maskEffect = null), t != null && (this._maskEffect = b0.getMaskEffect(t), this.addEffect(this._maskEffect)))
        },
        setMask(t) {
            this._maskOptions = { ...this._maskOptions,
                ...t
            }, t.mask && (this.mask = t.mask), this._markStructureAsChanged()
        },
        get mask() {
            var t;
            return (t = this._maskEffect) == null ? void 0 : t.mask
        },
        set filters(t) {
            var s;
            !Array.isArray(t) && t && (t = [t]);
            const e = this._filterEffect || (this._filterEffect = new Ph);
            t = t;
            const n = (t == null ? void 0 : t.length) > 0,
                r = ((s = e.filters) == null ? void 0 : s.length) > 0,
                i = n !== r;
            t = Array.isArray(t) ? t.slice(0) : t, e.filters = Object.freeze(t), i && (n ? this.addEffect(e) : (this.removeEffect(e), e.filters = t ? ? null))
        },
        get filters() {
            var t;
            return (t = this._filterEffect) == null ? void 0 : t.filters
        },
        set filterArea(t) {
            this._filterEffect || (this._filterEffect = new Ph), this._filterEffect.filterArea = t
        },
        get filterArea() {
            var t;
            return (t = this._filterEffect) == null ? void 0 : t.filterArea
        }
    },
    yfe = {
        label: null,
        get name() {
            return $e(Ye, "Container.name property has been removed, use Container.label instead"), this.label
        },
        set name(t) {
            $e(Ye, "Container.name property has been removed, use Container.label instead"), this.label = t
        },
        getChildByName(t, e = !1) {
            return this.getChildByLabel(t, e)
        },
        getChildByLabel(t, e = !1) {
            const n = this.children;
            for (let r = 0; r < n.length; r++) {
                const i = n[r];
                if (i.label === t || t instanceof RegExp && t.test(i.label)) return i
            }
            if (e)
                for (let r = 0; r < n.length; r++) {
                    const s = n[r].getChildByLabel(t, !0);
                    if (s) return s
                }
            return null
        },
        getChildrenByLabel(t, e = !1, n = []) {
            const r = this.children;
            for (let i = 0; i < r.length; i++) {
                const s = r[i];
                (s.label === t || t instanceof RegExp && t.test(s.label)) && n.push(s)
            }
            if (e)
                for (let i = 0; i < r.length; i++) r[i].getChildrenByLabel(t, !0, n);
            return n
        }
    },
    wn = new Mx(Ce),
    $i = new Mx(rn),
    _fe = new Ce,
    bfe = {
        getFastGlobalBounds(t, e) {
            e || (e = new rn), e.clear(), this._getGlobalBoundsRecursive(!!t, e, this.parentRenderLayer), e.isValid || e.set(0, 0, 0, 0);
            const n = this.renderGroup || this.parentRenderGroup;
            return e.applyMatrix(n.worldTransform), e
        },
        _getGlobalBoundsRecursive(t, e, n) {
            let r = e;
            if (t && this.parentRenderLayer && this.parentRenderLayer !== n || this.localDisplayStatus !== 7 || !this.measurable) return;
            const i = !!this.effects.length;
            if ((this.renderGroup || i) && (r = $i.get().clear()), this.boundsArea) e.addRect(this.boundsArea, this.worldTransform);
            else {
                if (this.renderPipeId) {
                    const o = this.bounds;
                    r.addFrame(o.minX, o.minY, o.maxX, o.maxY, this.groupTransform)
                }
                const s = this.children;
                for (let o = 0; o < s.length; o++) s[o]._getGlobalBoundsRecursive(t, r, n)
            }
            if (i) {
                let s = !1;
                const o = this.renderGroup || this.parentRenderGroup;
                for (let a = 0; a < this.effects.length; a++) this.effects[a].addBounds && (s || (s = !0, r.applyMatrix(o.worldTransform)), this.effects[a].addBounds(r, !0));
                s && (r.applyMatrix(o.worldTransform.copyTo(_fe).invert()), e.addBounds(r, this.relativeGroupTransform)), e.addBounds(r), $i.return(r)
            } else this.renderGroup && (e.addBounds(r, this.relativeGroupTransform), $i.return(r))
        }
    };

function kx(t, e, n) {
    n.clear();
    let r, i;
    return t.parent ? e ? r = t.parent.worldTransform : (i = wn.get().identity(), r = Bx(t, i)) : r = Ce.IDENTITY, dD(t, n, r, e), i && wn.return(i), n.isValid || n.set(0, 0, 0, 0), n
}

function dD(t, e, n, r) {
    var a, l;
    if (!t.visible || !t.measurable) return;
    let i;
    r ? i = t.worldTransform : (t.updateLocalTransform(), i = wn.get(), i.appendFrom(t.localTransform, n));
    const s = e,
        o = !!t.effects.length;
    if (o && (e = $i.get().clear()), t.boundsArea) e.addRect(t.boundsArea, i);
    else {
        t.bounds && (e.matrix = i, e.addBounds(t.bounds));
        for (let c = 0; c < t.children.length; c++) dD(t.children[c], e, i, r)
    }
    if (o) {
        for (let c = 0; c < t.effects.length; c++)(l = (a = t.effects[c]).addBounds) == null || l.call(a, e);
        s.addBounds(e, Ce.IDENTITY), $i.return(e)
    }
    r || wn.return(i)
}

function Bx(t, e) {
    const n = t.parent;
    return n && (Bx(n, e), n.updateLocalTransform(), e.append(n.localTransform)), e
}

function fD(t, e) {
    if (t === 16777215 || !e) return e;
    if (e === 16777215 || !t) return t;
    const n = t >> 16 & 255,
        r = t >> 8 & 255,
        i = t & 255,
        s = e >> 16 & 255,
        o = e >> 8 & 255,
        a = e & 255,
        l = n * s / 255 | 0,
        c = r * o / 255 | 0,
        u = i * a / 255 | 0;
    return (l << 16) + (c << 8) + u
}
const aC = 16777215;

function Ah(t, e) {
    return t === aC ? e : e === aC ? t : fD(t, e)
}

function zc(t) {
    return ((t & 255) << 16) + (t & 65280) + (t >> 16 & 255)
}
const xfe = {
    getGlobalAlpha(t) {
        if (t) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
        let e = this.alpha,
            n = this.parent;
        for (; n;) e *= n.alpha, n = n.parent;
        return e
    },
    getGlobalTransform(t, e) {
        if (e) return t.copyFrom(this.worldTransform);
        this.updateLocalTransform();
        const n = Bx(this, wn.get().identity());
        return t.appendFrom(this.localTransform, n), wn.return(n), t
    },
    getGlobalTint(t) {
        if (t) return this.renderGroup ? zc(this.renderGroup.worldColor) : this.parentRenderGroup ? zc(Ah(this.localColor, this.parentRenderGroup.worldColor)) : this.tint;
        let e = this.localColor,
            n = this.parent;
        for (; n;) e = Ah(e, n.localColor), n = n.parent;
        return zc(e)
    }
};
let zg = 0;
const lC = 500;

function Me(...t) {
    zg !== lC && (zg++, zg === lC ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...t))
}

function Dx(t, e, n) {
    return e.clear(), n || (n = Ce.IDENTITY), hD(t, e, n, t, !0), e.isValid || e.set(0, 0, 0, 0), e
}

function hD(t, e, n, r, i) {
    var l, c;
    let s;
    if (i) s = wn.get(), s = n.copyTo(s);
    else {
        if (!t.visible || !t.measurable) return;
        t.updateLocalTransform();
        const u = t.localTransform;
        s = wn.get(), s.appendFrom(u, n)
    }
    const o = e,
        a = !!t.effects.length;
    if (a && (e = $i.get().clear()), t.boundsArea) e.addRect(t.boundsArea, s);
    else {
        t.renderPipeId && (e.matrix = s, e.addBounds(t.bounds));
        const u = t.children;
        for (let d = 0; d < u.length; d++) hD(u[d], e, s, r, !1)
    }
    if (a) {
        for (let u = 0; u < t.effects.length; u++)(c = (l = t.effects[u]).addLocalBounds) == null || c.call(l, e, r);
        o.addBounds(e, Ce.IDENTITY), $i.return(e)
    }
    wn.return(s)
}

function pD(t, e) {
    const n = t.children;
    for (let r = 0; r < n.length; r++) {
        const i = n[r],
            s = i.uid,
            o = (i._didViewChangeTick & 65535) << 16 | i._didContainerChangeTick & 65535,
            a = e.index;
        (e.data[a] !== s || e.data[a + 1] !== o) && (e.data[e.index] = s, e.data[e.index + 1] = o, e.didChange = !0), e.index = a + 2, i.children.length && pD(i, e)
    }
    return e.didChange
}
const wfe = new Ce,
    Efe = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth(t, e) {
            const n = Math.sign(this.scale.x) || 1;
            e !== 0 ? this.scale.x = t / e * n : this.scale.x = n
        },
        _setHeight(t, e) {
            const n = Math.sign(this.scale.y) || 1;
            e !== 0 ? this.scale.y = t / e * n : this.scale.y = n
        },
        getLocalBounds() {
            this._localBoundsCacheData || (this._localBoundsCacheData = {
                data: [],
                index: 1,
                didChange: !1,
                localBounds: new rn
            });
            const t = this._localBoundsCacheData;
            return t.index = 1, t.didChange = !1, t.data[0] !== this._didViewChangeTick && (t.didChange = !0, t.data[0] = this._didViewChangeTick), pD(this, t), t.didChange && Dx(this, t.localBounds, wfe), t.localBounds
        },
        getBounds(t, e) {
            return kx(this, t, e || new rn)
        }
    },
    Sfe = {
        _onRender: null,
        set onRender(t) {
            const e = this.renderGroup || this.parentRenderGroup;
            if (!t) {
                this._onRender && (e == null || e.removeOnRender(this)), this._onRender = null;
                return
            }
            this._onRender || e == null || e.addOnRender(this), this._onRender = t
        },
        get onRender() {
            return this._onRender
        }
    },
    Tfe = {
        _zIndex: 0,
        sortDirty: !1,
        sortableChildren: !1,
        get zIndex() {
            return this._zIndex
        },
        set zIndex(t) {
            this._zIndex !== t && (this._zIndex = t, this.depthOfChildModified())
        },
        depthOfChildModified() {
            this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0)
        },
        sortChildren() {
            this.sortDirty && (this.sortDirty = !1, this.children.sort(Cfe))
        }
    };

function Cfe(t, e) {
    return t._zIndex - e._zIndex
}
const Pfe = {
    getGlobalPosition(t = new ct, e = !1) {
        return this.parent ? this.parent.toGlobal(this._position, t, e) : (t.x = this._position.x, t.y = this._position.y), t
    },
    toGlobal(t, e, n = !1) {
        const r = this.getGlobalTransform(wn.get(), n);
        return e = r.apply(t, e), wn.return(r), e
    },
    toLocal(t, e, n, r) {
        e && (t = e.toGlobal(t, n, r));
        const i = this.getGlobalTransform(wn.get(), r);
        return n = i.applyInverse(t, n), wn.return(i), n
    }
};
class mD {
    constructor() {
        this.uid = yt("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0
    }
    reset() {
        this.instructionSize = 0
    }
    add(e) {
        this.instructions[this.instructionSize++] = e
    }
    log() {
        this.instructions.length = this.instructionSize, console.table(this.instructions, ["type", "action"])
    }
}
let Afe = 0;
class Ofe {
    constructor(e) {
        this._poolKeyHash = Object.create(null), this._texturePool = {}, this.textureOptions = e || {}, this.enableFullScreen = !1
    }
    createTexture(e, n, r) {
        const i = new Qt({ ...this.textureOptions,
            width: e,
            height: n,
            resolution: 1,
            antialias: r,
            autoGarbageCollect: !1
        });
        return new we({
            source: i,
            label: `texturePool_${Afe++}`
        })
    }
    getOptimalTexture(e, n, r = 1, i) {
        let s = Math.ceil(e * r - 1e-6),
            o = Math.ceil(n * r - 1e-6);
        s = Tl(s), o = Tl(o);
        const a = (s << 17) + (o << 1) + (i ? 1 : 0);
        this._texturePool[a] || (this._texturePool[a] = []);
        let l = this._texturePool[a].pop();
        return l || (l = this.createTexture(s, o, i)), l.source._resolution = r, l.source.width = s / r, l.source.height = o / r, l.source.pixelWidth = s, l.source.pixelHeight = o, l.frame.x = 0, l.frame.y = 0, l.frame.width = e, l.frame.height = n, l.updateUvs(), this._poolKeyHash[l.uid] = a, l
    }
    getSameSizeTexture(e, n = !1) {
        const r = e.source;
        return this.getOptimalTexture(e.width, e.height, r._resolution, n)
    }
    returnTexture(e) {
        const n = this._poolKeyHash[e.uid];
        this._texturePool[n].push(e)
    }
    clear(e) {
        if (e = e !== !1, e)
            for (const n in this._texturePool) {
                const r = this._texturePool[n];
                if (r)
                    for (let i = 0; i < r.length; i++) r[i].destroy(!0)
            }
        this._texturePool = {}
    }
}
const Ft = new Ofe;
class Ife {
    constructor() {
        this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new Ce, this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = {
            list: [],
            index: 0
        }, this.structureDidChange = !0, this.instructionSet = new mD, this._onRenderContainers = [], this.textureNeedsUpdate = !0, this.isCachedAsTexture = !1, this._matrixDirty = 7
    }
    init(e) {
        this.root = e, e._onRender && this.addOnRender(e), e.didChange = !0;
        const n = e.children;
        for (let r = 0; r < n.length; r++) {
            const i = n[r];
            i._updateFlags = 15, this.addChild(i)
        }
    }
    enableCacheAsTexture(e = {}) {
        this.textureOptions = e, this.isCachedAsTexture = !0, this.textureNeedsUpdate = !0
    }
    disableCacheAsTexture() {
        this.isCachedAsTexture = !1, this.texture && (Ft.returnTexture(this.texture), this.texture = null)
    }
    updateCacheTexture() {
        this.textureNeedsUpdate = !0
    }
    reset() {
        this.renderGroupChildren.length = 0;
        for (const e in this.childrenToUpdate) {
            const n = this.childrenToUpdate[e];
            n.list.fill(null), n.index = 0
        }
        this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture()
    }
    get localTransform() {
        return this.root.localTransform
    }
    addRenderGroupChild(e) {
        e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e), e.renderGroupParent = this, this.renderGroupChildren.push(e)
    }
    _removeRenderGroupChild(e) {
        const n = this.renderGroupChildren.indexOf(e);
        n > -1 && this.renderGroupChildren.splice(n, 1), e.renderGroupParent = null
    }
    addChild(e) {
        if (this.structureDidChange = !0, e.parentRenderGroup = this, e.updateTick = -1, e.parent === this.root ? e.relativeRenderGroupDepth = 1 : e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1, e.didChange = !0, this.onChildUpdate(e), e.renderGroup) {
            this.addRenderGroupChild(e.renderGroup);
            return
        }
        e._onRender && this.addOnRender(e);
        const n = e.children;
        for (let r = 0; r < n.length; r++) this.addChild(n[r])
    }
    removeChild(e) {
        if (this.structureDidChange = !0, e._onRender && (e.renderGroup || this.removeOnRender(e)), e.parentRenderGroup = null, e.renderGroup) {
            this._removeRenderGroupChild(e.renderGroup);
            return
        }
        const n = e.children;
        for (let r = 0; r < n.length; r++) this.removeChild(n[r])
    }
    removeChildren(e) {
        for (let n = 0; n < e.length; n++) this.removeChild(e[n])
    }
    onChildUpdate(e) {
        let n = this.childrenToUpdate[e.relativeRenderGroupDepth];
        n || (n = this.childrenToUpdate[e.relativeRenderGroupDepth] = {
            index: 0,
            list: []
        }), n.list[n.index++] = e
    }
    updateRenderable(e) {
        e.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e), e.didViewUpdate = !1)
    }
    onChildViewUpdate(e) {
        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e
    }
    get isRenderable() {
        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0
    }
    addOnRender(e) {
        this._onRenderContainers.push(e)
    }
    removeOnRender(e) {
        this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1)
    }
    runOnRender(e) {
        for (let n = 0; n < this._onRenderContainers.length; n++) this._onRenderContainers[n]._onRender(e)
    }
    destroy() {
        this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null
    }
    getChildren(e = []) {
        const n = this.root.children;
        for (let r = 0; r < n.length; r++) this._getChildren(n[r], e);
        return e
    }
    _getChildren(e, n = []) {
        if (n.push(e), e.renderGroup) return n;
        const r = e.children;
        for (let i = 0; i < r.length; i++) this._getChildren(r[i], n);
        return n
    }
    invalidateMatrices() {
        this._matrixDirty = 7
    }
    get inverseWorldTransform() {
        return this._matrixDirty & 1 ? (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new Ce), this._inverseWorldTransform.copyFrom(this.worldTransform).invert()) : this._inverseWorldTransform
    }
    get textureOffsetInverseTransform() {
        return this._matrixDirty & 2 ? (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Ce), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y)) : this._textureOffsetInverseTransform
    }
    get inverseParentTextureTransform() {
        if (!(this._matrixDirty & 4)) return this._inverseParentTextureTransform;
        this._matrixDirty &= -5;
        const e = this._parentCacheAsTextureRenderGroup;
        return e ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Ce), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(e.inverseWorldTransform).translate(-e._textureBounds.x, -e._textureBounds.y)) : this.worldTransform
    }
    get cacheToLocalTransform() {
        return this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null
    }
}

function x0(t, e, n = {}) {
    for (const r in e) !n[r] && e[r] !== void 0 && (t[r] = e[r])
}
const jg = new jt(null),
    Vg = new jt(null),
    Wg = new jt(null, 1, 1),
    Oh = 1,
    $x = 2,
    jc = 4;
class Zn extends rr {
    constructor(e = {}) {
        var n, r;
        super(), this.uid = yt("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.updateTick = -1, this.localTransform = new Ce, this.relativeGroupTransform = new Ce, this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this._position = new jt(this, 0, 0), this._scale = Wg, this._pivot = Vg, this._skew = jg, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], x0(this, e, {
            children: !0,
            parent: !0,
            effects: !0
        }), (n = e.children) == null || n.forEach(i => this.addChild(i)), (r = e.parent) == null || r.addChild(this)
    }
    static mixin(e) {
        $e("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), Ie.mixin(Zn, e)
    }
    set _didChangeId(e) {
        this._didViewChangeTick = e >> 12 & 4095, this._didContainerChangeTick = e & 4095
    }
    get _didChangeId() {
        return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12
    }
    addChild(...e) {
        if (this.allowChildren || $e(Ye, "addChild: Only Containers will be allowed to add children in v8.0.0"), e.length > 1) {
            for (let i = 0; i < e.length; i++) this.addChild(e[i]);
            return e[0]
        }
        const n = e[0],
            r = this.renderGroup || this.parentRenderGroup;
        return n.parent === this ? (this.children.splice(this.children.indexOf(n), 1), this.children.push(n), r && (r.structureDidChange = !0), n) : (n.parent && n.parent.removeChild(n), this.children.push(n), this.sortableChildren && (this.sortDirty = !0), n.parent = this, n.didChange = !0, n._updateFlags = 15, r && r.addChild(n), this.emit("childAdded", n, this, this.children.length - 1), n.emit("added", this), this._didViewChangeTick++, n._zIndex !== 0 && n.depthOfChildModified(), n)
    }
    removeChild(...e) {
        if (e.length > 1) {
            for (let i = 0; i < e.length; i++) this.removeChild(e[i]);
            return e[0]
        }
        const n = e[0],
            r = this.children.indexOf(n);
        return r > -1 && (this._didViewChangeTick++, this.children.splice(r, 1), this.renderGroup ? this.renderGroup.removeChild(n) : this.parentRenderGroup && this.parentRenderGroup.removeChild(n), n.parentRenderLayer && n.parentRenderLayer.detach(n), n.parent = null, this.emit("childRemoved", n, this, r), n.emit("removed", this)), n
    }
    _onUpdate(e) {
        e && e === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this))
    }
    set isRenderGroup(e) {
        !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup())
    }
    get isRenderGroup() {
        return !!this.renderGroup
    }
    enableRenderGroup() {
        if (this.renderGroup) return;
        const e = this.parentRenderGroup;
        e == null || e.removeChild(this), this.renderGroup = We.get(Ife, this), this.groupTransform = Ce.IDENTITY, e == null || e.addChild(this), this._updateIsSimple()
    }
    disableRenderGroup() {
        if (!this.renderGroup) return;
        const e = this.parentRenderGroup;
        e == null || e.removeChild(this), We.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, e == null || e.addChild(this), this._updateIsSimple()
    }
    _updateIsSimple() {
        this.isSimple = !this.renderGroup && this.effects.length === 0
    }
    get worldTransform() {
        return this._worldTransform || (this._worldTransform = new Ce), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform
    }
    get x() {
        return this._position.x
    }
    set x(e) {
        this._position.x = e
    }
    get y() {
        return this._position.y
    }
    set y(e) {
        this._position.y = e
    }
    get position() {
        return this._position
    }
    set position(e) {
        this._position.copyFrom(e)
    }
    get rotation() {
        return this._rotation
    }
    set rotation(e) {
        this._rotation !== e && (this._rotation = e, this._onUpdate(this._skew))
    }
    get angle() {
        return this.rotation * Kde
    }
    set angle(e) {
        this.rotation = e * qde
    }
    get pivot() {
        return this._pivot === Vg && (this._pivot = new jt(this, 0, 0)), this._pivot
    }
    set pivot(e) {
        this._pivot === Vg && (this._pivot = new jt(this, 0, 0)), typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e)
    }
    get skew() {
        return this._skew === jg && (this._skew = new jt(this, 0, 0)), this._skew
    }
    set skew(e) {
        this._skew === jg && (this._skew = new jt(this, 0, 0)), this._skew.copyFrom(e)
    }
    get scale() {
        return this._scale === Wg && (this._scale = new jt(this, 1, 1)), this._scale
    }
    set scale(e) {
        this._scale === Wg && (this._scale = new jt(this, 0, 0)), typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e)
    }
    get width() {
        return Math.abs(this.scale.x * this.getLocalBounds().width)
    }
    set width(e) {
        const n = this.getLocalBounds().width;
        this._setWidth(e, n)
    }
    get height() {
        return Math.abs(this.scale.y * this.getLocalBounds().height)
    }
    set height(e) {
        const n = this.getLocalBounds().height;
        this._setHeight(e, n)
    }
    getSize(e) {
        e || (e = {});
        const n = this.getLocalBounds();
        return e.width = Math.abs(this.scale.x * n.width), e.height = Math.abs(this.scale.y * n.height), e
    }
    setSize(e, n) {
        const r = this.getLocalBounds();
        typeof e == "object" ? (n = e.height ? ? e.width, e = e.width) : n ? ? (n = e), e !== void 0 && this._setWidth(e, r.width), n !== void 0 && this._setHeight(n, r.height)
    }
    _updateSkew() {
        const e = this._rotation,
            n = this._skew;
        this._cx = Math.cos(e + n._y), this._sx = Math.sin(e + n._y), this._cy = -Math.sin(e - n._x), this._sy = Math.cos(e - n._x)
    }
    updateTransform(e) {
        return this.position.set(typeof e.x == "number" ? e.x : this.position.x, typeof e.y == "number" ? e.y : this.position.y), this.scale.set(typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x, typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y), this.rotation = typeof e.rotation == "number" ? e.rotation : this.rotation, this.skew.set(typeof e.skewX == "number" ? e.skewX : this.skew.x, typeof e.skewY == "number" ? e.skewY : this.skew.y), this.pivot.set(typeof e.pivotX == "number" ? e.pivotX : this.pivot.x, typeof e.pivotY == "number" ? e.pivotY : this.pivot.y), this
    }
    setFromMatrix(e) {
        e.decompose(this)
    }
    updateLocalTransform() {
        const e = this._didContainerChangeTick;
        if (this._didLocalTransformChangeId === e) return;
        this._didLocalTransformChangeId = e;
        const n = this.localTransform,
            r = this._scale,
            i = this._pivot,
            s = this._position,
            o = r._x,
            a = r._y,
            l = i._x,
            c = i._y;
        n.a = this._cx * o, n.b = this._sx * o, n.c = this._cy * a, n.d = this._sy * a, n.tx = s._x - (l * n.a + c * n.c), n.ty = s._y - (l * n.b + c * n.d)
    }
    set alpha(e) {
        e !== this.localAlpha && (this.localAlpha = e, this._updateFlags |= Oh, this._onUpdate())
    }
    get alpha() {
        return this.localAlpha
    }
    set tint(e) {
        const r = rt.shared.setValue(e ? ? 16777215).toBgrNumber();
        r !== this.localColor && (this.localColor = r, this._updateFlags |= Oh, this._onUpdate())
    }
    get tint() {
        return zc(this.localColor)
    }
    set blendMode(e) {
        this.localBlendMode !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= $x, this.localBlendMode = e, this._onUpdate())
    }
    get blendMode() {
        return this.localBlendMode
    }
    get visible() {
        return !!(this.localDisplayStatus & 2)
    }
    set visible(e) {
        const n = e ? 2 : 0;
        (this.localDisplayStatus & 2) !== n && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= jc, this.localDisplayStatus ^= 2, this._onUpdate())
    }
    get culled() {
        return !(this.localDisplayStatus & 4)
    }
    set culled(e) {
        const n = e ? 0 : 4;
        (this.localDisplayStatus & 4) !== n && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= jc, this.localDisplayStatus ^= 4, this._onUpdate())
    }
    get renderable() {
        return !!(this.localDisplayStatus & 1)
    }
    set renderable(e) {
        const n = e ? 1 : 0;
        (this.localDisplayStatus & 1) !== n && (this._updateFlags |= jc, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._onUpdate())
    }
    get isRenderable() {
        return this.localDisplayStatus === 7 && this.groupAlpha > 0
    }
    destroy(e = !1) {
        var i;
        if (this.destroyed) return;
        this.destroyed = !0;
        let n;
        if (this.children.length && (n = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof e == "boolean" ? e : e == null ? void 0 : e.children) && n)
            for (let s = 0; s < n.length; ++s) n[s].destroy(e);
        (i = this.renderGroup) == null || i.destroy(), this.renderGroup = null
    }
}
Ie.mixin(Zn, pfe, bfe, Pfe, Sfe, Efe, vfe, yfe, Tfe, dfe, hfe, xfe, mfe);
class ld extends Zn {
    constructor(e) {
        super(e), this.canBundle = !0, this.allowChildren = !1, this._roundPixels = 0, this._lastUsed = -1, this._bounds = new rn(0, 1, 0, 0), this._boundsDirty = !0
    }
    get bounds() {
        return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = !1, this._bounds) : this._bounds
    }
    get roundPixels() {
        return !!this._roundPixels
    }
    set roundPixels(e) {
        this._roundPixels = e ? 1 : 0
    }
    containsPoint(e) {
        const n = this.bounds,
            {
                x: r,
                y: i
            } = e;
        return r >= n.minX && r <= n.maxX && i >= n.minY && i <= n.maxY
    }
    onViewUpdate() {
        if (this._didViewChangeTick++, this._boundsDirty = !0, this.didViewUpdate) return;
        this.didViewUpdate = !0;
        const e = this.renderGroup || this.parentRenderGroup;
        e && e.onChildViewUpdate(this)
    }
    destroy(e) {
        super.destroy(e), this._bounds = null
    }
    collectRenderablesSimple(e, n, r) {
        const {
            renderPipes: i,
            renderableGC: s
        } = n;
        i.blendMode.setBlendMode(this, this.groupBlendMode, e), i[this.renderPipeId].addRenderable(this, e), s.addRenderable(this), this.didViewUpdate = !1;
        const a = this.children,
            l = a.length;
        for (let c = 0; c < l; c++) a[c].collectRenderables(e, n, r)
    }
}
class ta extends ld {
    constructor(e = we.EMPTY) {
        e instanceof we && (e = {
            texture: e
        });
        const {
            texture: n = we.EMPTY,
            anchor: r,
            roundPixels: i,
            width: s,
            height: o,
            ...a
        } = e;
        super({
            label: "Sprite",
            ...a
        }), this.renderPipeId = "sprite", this.batched = !0, this._visualBounds = {
            minX: 0,
            maxX: 1,
            minY: 0,
            maxY: 0
        }, this._anchor = new jt({
            _onUpdate: () => {
                this.onViewUpdate()
            }
        }), r ? this.anchor = r : n.defaultAnchor && (this.anchor = n.defaultAnchor), this.texture = n, this.allowChildren = !1, this.roundPixels = i ? ? !1, s !== void 0 && (this.width = s), o !== void 0 && (this.height = o)
    }
    static from(e, n = !1) {
        return e instanceof we ? new ta(e) : new ta(we.from(e, n))
    }
    set texture(e) {
        e || (e = we.EMPTY);
        const n = this._texture;
        n !== e && (n && n.dynamic && n.off("update", this.onViewUpdate, this), e.dynamic && e.on("update", this.onViewUpdate, this), this._texture = e, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate())
    }
    get texture() {
        return this._texture
    }
    get visualBounds() {
        return oD(this._visualBounds, this._anchor, this._texture), this._visualBounds
    }
    get sourceBounds() {
        return $e("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds
    }
    updateBounds() {
        const e = this._anchor,
            n = this._texture,
            r = this._bounds,
            {
                width: i,
                height: s
            } = n.orig;
        r.minX = -e._x * i, r.maxX = r.minX + i, r.minY = -e._y * s, r.maxY = r.minY + s
    }
    destroy(e = !1) {
        if (super.destroy(e), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
            const r = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
            this._texture.destroy(r)
        }
        this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null
    }
    get anchor() {
        return this._anchor
    }
    set anchor(e) {
        typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
    }
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(e) {
        this._setWidth(e, this._texture.orig.width), this._width = e
    }
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(e) {
        this._setHeight(e, this._texture.orig.height), this._height = e
    }
    getSize(e) {
        return e || (e = {}), e.width = Math.abs(this.scale.x) * this._texture.orig.width, e.height = Math.abs(this.scale.y) * this._texture.orig.height, e
    }
    setSize(e, n) {
        typeof e == "object" ? (n = e.height ? ? e.width, e = e.width) : n ? ? (n = e), e !== void 0 && this._setWidth(e, this._texture.orig.width), n !== void 0 && this._setHeight(n, this._texture.orig.height)
    }
}
const Rfe = new rn;

function gD(t, e, n) {
    const r = Rfe;
    t.measurable = !0, kx(t, n, r), e.addBoundsMask(r), t.measurable = !1
}

function vD(t, e, n) {
    const r = $i.get();
    t.measurable = !0;
    const i = wn.get().identity(),
        s = yD(t, n, i);
    Dx(t, r, s), t.measurable = !1, e.addBoundsMask(r), wn.return(i), $i.return(r)
}

function yD(t, e, n) {
    return t ? (t !== e && (yD(t.parent, e, n), t.updateLocalTransform(), n.append(t.localTransform)), n) : (Me("Mask bounds, renderable is not inside the root container"), n)
}
class _D {
    constructor(e) {
        this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", e != null && e.mask && this.init(e.mask)
    }
    init(e) {
        this.mask = e, this.renderMaskToTexture = !(e instanceof ta), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1
    }
    reset() {
        this.mask.measurable = !0, this.mask = null
    }
    addBounds(e, n) {
        this.inverse || gD(this.mask, e, n)
    }
    addLocalBounds(e, n) {
        vD(this.mask, e, n)
    }
    containsPoint(e, n) {
        const r = this.mask;
        return n(r, e)
    }
    destroy() {
        this.reset()
    }
    static test(e) {
        return e instanceof ta
    }
}
_D.extension = G.MaskEffect;
class bD {
    constructor(e) {
        this.priority = 0, this.pipe = "colorMask", e != null && e.mask && this.init(e.mask)
    }
    init(e) {
        this.mask = e
    }
    destroy() {}
    static test(e) {
        return typeof e == "number"
    }
}
bD.extension = G.MaskEffect;
class xD {
    constructor(e) {
        this.priority = 0, this.pipe = "stencilMask", e != null && e.mask && this.init(e.mask)
    }
    init(e) {
        this.mask = e, this.mask.includeInBuild = !1, this.mask.measurable = !1
    }
    reset() {
        this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null
    }
    addBounds(e, n) {
        gD(this.mask, e, n)
    }
    addLocalBounds(e, n) {
        vD(this.mask, e, n)
    }
    containsPoint(e, n) {
        const r = this.mask;
        return n(r, e)
    }
    destroy() {
        this.reset()
    }
    static test(e) {
        return e instanceof Zn
    }
}
xD.extension = G.MaskEffect;
const Mfe = {
    createCanvas: (t, e) => {
        const n = document.createElement("canvas");
        return n.width = t, n.height = e, n
    },
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ? ? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (t, e) => fetch(t, e),
    parseXML: t => new DOMParser().parseFromString(t, "text/xml")
};
let cC = Mfe;
const He = {
    get() {
        return cC
    },
    set(t) {
        cC = t
    }
};
class ni extends Qt {
    constructor(e) {
        e.resource || (e.resource = He.get().createCanvas()), e.width || (e.width = e.resource.width, e.autoDensity || (e.width /= e.resolution)), e.height || (e.height = e.resource.height, e.autoDensity || (e.height /= e.resolution)), super(e), this.uploadMethodId = "image", this.autoDensity = e.autoDensity, this.resizeCanvas(), this.transparent = !!e.transparent
    }
    resizeCanvas() {
        this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight)
    }
    resize(e = this.width, n = this.height, r = this._resolution) {
        const i = super.resize(e, n, r);
        return i && this.resizeCanvas(), i
    }
    static test(e) {
        return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && e instanceof OffscreenCanvas
    }
    get context2D() {
        return this._context2D || (this._context2D = this.resource.getContext("2d"))
    }
}
ni.extension = G.TextureSource;
class na extends Qt {
    constructor(e) {
        if (e.resource && globalThis.HTMLImageElement && e.resource instanceof HTMLImageElement) {
            const n = He.get().createCanvas(e.resource.width, e.resource.height);
            n.getContext("2d").drawImage(e.resource, 0, 0, e.resource.width, e.resource.height), e.resource = n, Me("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.")
        }
        super(e), this.uploadMethodId = "image", this.autoGarbageCollect = !0
    }
    static test(e) {
        return globalThis.HTMLImageElement && e instanceof HTMLImageElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || globalThis.VideoFrame && e instanceof VideoFrame
    }
}
na.extension = G.TextureSource;
var Pl = (t => (t[t.INTERACTION = 50] = "INTERACTION", t[t.HIGH = 25] = "HIGH", t[t.NORMAL = 0] = "NORMAL", t[t.LOW = -25] = "LOW", t[t.UTILITY = -50] = "UTILITY", t))(Pl || {});
class Yg {
    constructor(e, n = null, r = 0, i = !1) {
        this.next = null, this.previous = null, this._destroyed = !1, this._fn = e, this._context = n, this.priority = r, this._once = i
    }
    match(e, n = null) {
        return this._fn === e && this._context === n
    }
    emit(e) {
        this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e));
        const n = this.next;
        return this._once && this.destroy(!0), this._destroyed && (this.next = null), n
    }
    connect(e) {
        this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this
    }
    destroy(e = !1) {
        this._destroyed = !0, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
        const n = this.next;
        return this.next = e ? null : n, this.previous = null, n
    }
}
const wD = class Un {
    constructor() {
        this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new Yg(null, null, 1 / 0), this.deltaMS = 1 / Un.targetFPMS, this.elapsedMS = 1 / Un.targetFPMS, this._tick = e => {
            this._requestId = null, this.started && (this.update(e), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
        }
    }
    _requestIfNeeded() {
        this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
    }
    _cancelIfNeeded() {
        this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null)
    }
    _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
    }
    add(e, n, r = Pl.NORMAL) {
        return this._addListener(new Yg(e, n, r))
    }
    addOnce(e, n, r = Pl.NORMAL) {
        return this._addListener(new Yg(e, n, r, !0))
    }
    _addListener(e) {
        let n = this._head.next,
            r = this._head;
        if (!n) e.connect(r);
        else {
            for (; n;) {
                if (e.priority > n.priority) {
                    e.connect(r);
                    break
                }
                r = n, n = n.next
            }
            e.previous || e.connect(r)
        }
        return this._startIfPossible(), this
    }
    remove(e, n) {
        let r = this._head.next;
        for (; r;) r.match(e, n) ? r = r.destroy() : r = r.next;
        return this._head.next || this._cancelIfNeeded(), this
    }
    get count() {
        if (!this._head) return 0;
        let e = 0,
            n = this._head;
        for (; n = n.next;) e++;
        return e
    }
    start() {
        this.started || (this.started = !0, this._requestIfNeeded())
    }
    stop() {
        this.started && (this.started = !1, this._cancelIfNeeded())
    }
    destroy() {
        if (!this._protected) {
            this.stop();
            let e = this._head.next;
            for (; e;) e = e.destroy(!0);
            this._head.destroy(), this._head = null
        }
    }
    update(e = performance.now()) {
        let n;
        if (e > this.lastTime) {
            if (n = this.elapsedMS = e - this.lastTime, n > this._maxElapsedMS && (n = this._maxElapsedMS), n *= this.speed, this._minElapsedMS) {
                const s = e - this._lastFrame | 0;
                if (s < this._minElapsedMS) return;
                this._lastFrame = e - s % this._minElapsedMS
            }
            this.deltaMS = n, this.deltaTime = this.deltaMS * Un.targetFPMS;
            const r = this._head;
            let i = r.next;
            for (; i;) i = i.emit(this);
            r.next || this._cancelIfNeeded()
        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = e
    }
    get FPS() {
        return 1e3 / this.elapsedMS
    }
    get minFPS() {
        return 1e3 / this._maxElapsedMS
    }
    set minFPS(e) {
        const n = Math.min(this.maxFPS, e),
            r = Math.min(Math.max(0, n) / 1e3, Un.targetFPMS);
        this._maxElapsedMS = 1 / r
    }
    get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
    }
    set maxFPS(e) {
        if (e === 0) this._minElapsedMS = 0;
        else {
            const n = Math.max(this.minFPS, e);
            this._minElapsedMS = 1 / (n / 1e3)
        }
    }
    static get shared() {
        if (!Un._shared) {
            const e = Un._shared = new Un;
            e.autoStart = !0, e._protected = !0
        }
        return Un._shared
    }
    static get system() {
        if (!Un._system) {
            const e = Un._system = new Un;
            e.autoStart = !0, e._protected = !0
        }
        return Un._system
    }
};
wD.targetFPMS = .06;
let bn = wD,
    Xg;
async function ED() {
    return Xg ? ? (Xg = (async () => {
        var o;
        const e = document.createElement("canvas").getContext("webgl");
        if (!e) return "premultiply-alpha-on-upload";
        const n = await new Promise(a => {
            const l = document.createElement("video");
            l.onloadeddata = () => a(l), l.onerror = () => a(null), l.autoplay = !1, l.crossOrigin = "anonymous", l.preload = "auto", l.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", l.load()
        });
        if (!n) return "premultiply-alpha-on-upload";
        const r = e.createTexture();
        e.bindTexture(e.TEXTURE_2D, r);
        const i = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, i), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n);
        const s = new Uint8Array(4);
        return e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, s), e.deleteFramebuffer(i), e.deleteTexture(r), (o = e.getExtension("WEBGL_lose_context")) == null || o.loseContext(), s[0] <= s[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload"
    })()), Xg
}
const Jp = class SD extends Qt {
    constructor(e) {
        super(e), this.isReady = !1, this.uploadMethodId = "video", e = { ...SD.defaultOptions,
            ...e
        }, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = e.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = e.autoPlay !== !1, this.alphaMode = e.alphaMode ? ? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), e.autoLoad !== !1 && this.load()
    }
    updateFrame() {
        if (!this.destroyed) {
            if (this._updateFPS) {
                const e = bn.shared.elapsedMS * this.resource.playbackRate;
                this._msToNextUpdate = Math.floor(this._msToNextUpdate - e)
            }(!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update()
        }
    }
    _videoFrameRequestCallback() {
        this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback)
    }
    get isValid() {
        return !!this.resource.videoWidth && !!this.resource.videoHeight
    }
    async load() {
        if (this._load) return this._load;
        const e = this.resource,
            n = this.options;
        return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart), e.addEventListener("pause", this._onPlayStop), e.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (n.preload || e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlayThrough), e.addEventListener("error", this._onError, !0)), this.alphaMode = await ED(), this._load = new Promise((r, i) => {
            this.isValid ? r(this) : (this._resolve = r, this._reject = i, n.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
                this._onError(new ErrorEvent(`Preload exceeded timeout of ${n.preloadTimeoutMs}ms`))
            })), e.load())
        }), this._load
    }
    _onError(e) {
        this.resource.removeEventListener("error", this._onError, !0), this.emit("error", e), this._reject && (this._reject(e), this._reject = null, this._resolve = null)
    }
    _isSourcePlaying() {
        const e = this.resource;
        return !e.paused && !e.ended
    }
    _isSourceReady() {
        return this.resource.readyState > 2
    }
    _onPlayStart() {
        this.isValid || this._mediaReady(), this._configureAutoUpdate()
    }
    _onPlayStop() {
        this._configureAutoUpdate()
    }
    _onSeeked() {
        this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0)
    }
    _onCanPlay() {
        this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady()
    }
    _onCanPlayThrough() {
        this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady()
    }
    _mediaReady() {
        const e = this.resource;
        this.isValid && (this.isReady = !0, this.resize(e.videoWidth, e.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play()
    }
    destroy() {
        this._configureAutoUpdate();
        const e = this.resource;
        e && (e.removeEventListener("play", this._onPlayStart), e.removeEventListener("pause", this._onPlayStop), e.removeEventListener("seeked", this._onSeeked), e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlayThrough), e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), super.destroy()
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, this._configureAutoUpdate())
    }
    get updateFPS() {
        return this._updateFPS
    }
    set updateFPS(e) {
        e !== this._updateFPS && (this._updateFPS = e, this._configureAutoUpdate())
    }
    _configureAutoUpdate() {
        this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (bn.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (bn.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (bn.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0))
    }
    static test(e) {
        return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement
    }
};
Jp.extension = G.TextureSource;
Jp.defaultOptions = { ...Qt.defaultOptions,
    autoLoad: !0,
    autoPlay: !0,
    updateFPS: 0,
    crossorigin: !0,
    loop: !1,
    muted: !0,
    playsinline: !0,
    preload: !1
};
Jp.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
};
let Uf = Jp;
const Er = (t, e, n = !1) => (Array.isArray(t) || (t = [t]), e ? t.map(r => typeof r == "string" || n ? e(r) : r) : t);
class kfe {
    constructor() {
        this._parsers = [], this._cache = new Map, this._cacheMap = new Map
    }
    reset() {
        this._cacheMap.clear(), this._cache.clear()
    }
    has(e) {
        return this._cache.has(e)
    }
    get(e) {
        const n = this._cache.get(e);
        return n || Me(`[Assets] Asset id ${e} was not found in the Cache`), n
    }
    set(e, n) {
        const r = Er(e);
        let i;
        for (let l = 0; l < this.parsers.length; l++) {
            const c = this.parsers[l];
            if (c.test(n)) {
                i = c.getCacheableAssets(r, n);
                break
            }
        }
        const s = new Map(Object.entries(i || {}));
        i || r.forEach(l => {
            s.set(l, n)
        });
        const o = [...s.keys()],
            a = {
                cacheKeys: o,
                keys: r
            };
        r.forEach(l => {
            this._cacheMap.set(l, a)
        }), o.forEach(l => {
            const c = i ? i[l] : n;
            this._cache.has(l) && this._cache.get(l) !== c && Me("[Cache] already has key:", l), this._cache.set(l, s.get(l))
        })
    }
    remove(e) {
        if (!this._cacheMap.has(e)) {
            Me(`[Assets] Asset id ${e} was not found in the Cache`);
            return
        }
        const n = this._cacheMap.get(e);
        n.cacheKeys.forEach(i => {
            this._cache.delete(i)
        }), n.keys.forEach(i => {
            this._cacheMap.delete(i)
        })
    }
    get parsers() {
        return this._parsers
    }
}
const ft = new kfe,
    w0 = [];
Ie.handleByList(G.TextureSource, w0);

function TD(t = {}) {
    const e = t && t.resource,
        n = e ? t.resource : t,
        r = e ? t : {
            resource: t
        };
    for (let i = 0; i < w0.length; i++) {
        const s = w0[i];
        if (s.test(n)) return new s(r)
    }
    throw new Error(`Could not find a source type for resource: ${r.resource}`)
}

function Bfe(t = {}, e = !1) {
    const n = t && t.resource,
        r = n ? t.resource : t,
        i = n ? t : {
            resource: t
        };
    if (!e && ft.has(r)) return ft.get(r);
    const s = new we({
        source: TD(i)
    });
    return s.on("destroy", () => {
        ft.has(r) && ft.remove(r)
    }), e || ft.set(r, s), s
}

function Dfe(t, e = !1) {
    return typeof t == "string" ? ft.get(t) : t instanceof Qt ? new we({
        source: t
    }) : Bfe(t, e)
}
we.from = Dfe;
Qt.from = TD;
Ie.add(_D, bD, xD, Uf, na, ni, Rx);
var Zs = (t => (t[t.Low = 0] = "Low", t[t.Normal = 1] = "Normal", t[t.High = 2] = "High", t))(Zs || {});

function vr(t) {
    if (typeof t != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(t)}`)
}

function cc(t) {
    return t.split("?")[0].split("#")[0]
}

function $fe(t) {
    return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}

function Ffe(t, e, n) {
    return t.replace(new RegExp($fe(e), "g"), n)
}

function Lfe(t, e) {
    let n = "",
        r = 0,
        i = -1,
        s = 0,
        o = -1;
    for (let a = 0; a <= t.length; ++a) {
        if (a < t.length) o = t.charCodeAt(a);
        else {
            if (o === 47) break;
            o = 47
        }
        if (o === 47) {
            if (!(i === a - 1 || s === 1))
                if (i !== a - 1 && s === 2) {
                    if (n.length < 2 || r !== 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
                        if (n.length > 2) {
                            const l = n.lastIndexOf("/");
                            if (l !== n.length - 1) {
                                l === -1 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), i = a, s = 0;
                                continue
                            }
                        } else if (n.length === 2 || n.length === 1) {
                            n = "", r = 0, i = a, s = 0;
                            continue
                        }
                    }
                    e && (n.length > 0 ? n += "/.." : n = "..", r = 2)
                } else n.length > 0 ? n += `/${t.slice(i+1,a)}` : n = t.slice(i + 1, a), r = a - i - 1;
            i = a, s = 0
        } else o === 46 && s !== -1 ? ++s : s = -1
    }
    return n
}
const Dn = {
    toPosix(t) {
        return Ffe(t, "\\", "/")
    },
    isUrl(t) {
        return /^https?:/.test(this.toPosix(t))
    },
    isDataUrl(t) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(t)
    },
    isBlobUrl(t) {
        return t.startsWith("blob:")
    },
    hasProtocol(t) {
        return /^[^/:]+:/.test(this.toPosix(t))
    },
    getProtocol(t) {
        vr(t), t = this.toPosix(t);
        const e = /^file:\/\/\//.exec(t);
        if (e) return e[0];
        const n = /^[^/:]+:\/{0,2}/.exec(t);
        return n ? n[0] : ""
    },
    toAbsolute(t, e, n) {
        if (vr(t), this.isDataUrl(t) || this.isBlobUrl(t)) return t;
        const r = cc(this.toPosix(e ? ? He.get().getBaseUrl())),
            i = cc(this.toPosix(n ? ? this.rootname(r)));
        return t = this.toPosix(t), t.startsWith("/") ? Dn.join(i, t.slice(1)) : this.isAbsolute(t) ? t : this.join(r, t)
    },
    normalize(t) {
        if (vr(t), t.length === 0) return ".";
        if (this.isDataUrl(t) || this.isBlobUrl(t)) return t;
        t = this.toPosix(t);
        let e = "";
        const n = t.startsWith("/");
        this.hasProtocol(t) && (e = this.rootname(t), t = t.slice(e.length));
        const r = t.endsWith("/");
        return t = Lfe(t, !1), t.length > 0 && r && (t += "/"), n ? `/${t}` : e + t
    },
    isAbsolute(t) {
        return vr(t), t = this.toPosix(t), this.hasProtocol(t) ? !0 : t.startsWith("/")
    },
    join(...t) {
        if (t.length === 0) return ".";
        let e;
        for (let n = 0; n < t.length; ++n) {
            const r = t[n];
            if (vr(r), r.length > 0)
                if (e === void 0) e = r;
                else {
                    const i = t[n - 1] ? ? "";
                    this.joinExtensions.includes(this.extname(i).toLowerCase()) ? e += `/../${r}` : e += `/${r}`
                }
        }
        return e === void 0 ? "." : this.normalize(e)
    },
    dirname(t) {
        if (vr(t), t.length === 0) return ".";
        t = this.toPosix(t);
        let e = t.charCodeAt(0);
        const n = e === 47;
        let r = -1,
            i = !0;
        const s = this.getProtocol(t),
            o = t;
        t = t.slice(s.length);
        for (let a = t.length - 1; a >= 1; --a)
            if (e = t.charCodeAt(a), e === 47) {
                if (!i) {
                    r = a;
                    break
                }
            } else i = !1;
        return r === -1 ? n ? "/" : this.isUrl(o) ? s + t : s : n && r === 1 ? "//" : s + t.slice(0, r)
    },
    rootname(t) {
        vr(t), t = this.toPosix(t);
        let e = "";
        if (t.startsWith("/") ? e = "/" : e = this.getProtocol(t), this.isUrl(t)) {
            const n = t.indexOf("/", e.length);
            n !== -1 ? e = t.slice(0, n) : e = t, e.endsWith("/") || (e += "/")
        }
        return e
    },
    basename(t, e) {
        vr(t), e && vr(e), t = cc(this.toPosix(t));
        let n = 0,
            r = -1,
            i = !0,
            s;
        if (e !== void 0 && e.length > 0 && e.length <= t.length) {
            if (e.length === t.length && e === t) return "";
            let o = e.length - 1,
                a = -1;
            for (s = t.length - 1; s >= 0; --s) {
                const l = t.charCodeAt(s);
                if (l === 47) {
                    if (!i) {
                        n = s + 1;
                        break
                    }
                } else a === -1 && (i = !1, a = s + 1), o >= 0 && (l === e.charCodeAt(o) ? --o === -1 && (r = s) : (o = -1, r = a))
            }
            return n === r ? r = a : r === -1 && (r = t.length), t.slice(n, r)
        }
        for (s = t.length - 1; s >= 0; --s)
            if (t.charCodeAt(s) === 47) {
                if (!i) {
                    n = s + 1;
                    break
                }
            } else r === -1 && (i = !1, r = s + 1);
        return r === -1 ? "" : t.slice(n, r)
    },
    extname(t) {
        vr(t), t = cc(this.toPosix(t));
        let e = -1,
            n = 0,
            r = -1,
            i = !0,
            s = 0;
        for (let o = t.length - 1; o >= 0; --o) {
            const a = t.charCodeAt(o);
            if (a === 47) {
                if (!i) {
                    n = o + 1;
                    break
                }
                continue
            }
            r === -1 && (i = !1, r = o + 1), a === 46 ? e === -1 ? e = o : s !== 1 && (s = 1) : e !== -1 && (s = -1)
        }
        return e === -1 || r === -1 || s === 0 || s === 1 && e === r - 1 && e === n + 1 ? "" : t.slice(e, r)
    },
    parse(t) {
        vr(t);
        const e = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (t.length === 0) return e;
        t = cc(this.toPosix(t));
        let n = t.charCodeAt(0);
        const r = this.isAbsolute(t);
        let i;
        e.root = this.rootname(t), r || this.hasProtocol(t) ? i = 1 : i = 0;
        let s = -1,
            o = 0,
            a = -1,
            l = !0,
            c = t.length - 1,
            u = 0;
        for (; c >= i; --c) {
            if (n = t.charCodeAt(c), n === 47) {
                if (!l) {
                    o = c + 1;
                    break
                }
                continue
            }
            a === -1 && (l = !1, a = c + 1), n === 46 ? s === -1 ? s = c : u !== 1 && (u = 1) : s !== -1 && (u = -1)
        }
        return s === -1 || a === -1 || u === 0 || u === 1 && s === a - 1 && s === o + 1 ? a !== -1 && (o === 0 && r ? e.base = e.name = t.slice(1, a) : e.base = e.name = t.slice(o, a)) : (o === 0 && r ? (e.name = t.slice(1, s), e.base = t.slice(1, a)) : (e.name = t.slice(o, s), e.base = t.slice(o, a)), e.ext = t.slice(s, a)), e.dir = this.dirname(t), e
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [".html"]
};

function CD(t, e, n, r, i) {
    const s = e[n];
    for (let o = 0; o < s.length; o++) {
        const a = s[o];
        n < e.length - 1 ? CD(t.replace(r[n], a), e, n + 1, r, i) : i.push(t.replace(r[n], a))
    }
}

function Nfe(t) {
    const e = /\{(.*?)\}/g,
        n = t.match(e),
        r = [];
    if (n) {
        const i = [];
        n.forEach(s => {
            const o = s.substring(1, s.length - 1).split(",");
            i.push(o)
        }), CD(t, i, 0, n, r)
    } else r.push(t);
    return r
}
const Ih = t => !Array.isArray(t);
class Hl {
    constructor() {
        this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (e, n) => `${e}${this._bundleIdConnector}${n}`,
            extractAssetIdFromBundle: (e, n) => n.replace(`${e}${this._bundleIdConnector}`, "")
        }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {}
    }
    setBundleIdentifier(e) {
        if (this._bundleIdConnector = e.connector ? ? this._bundleIdConnector, this._createBundleAssetId = e.createBundleAssetId ? ? this._createBundleAssetId, this._extractAssetIdFromBundle = e.extractAssetIdFromBundle ? ? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
    }
    prefer(...e) {
        e.forEach(n => {
            this._preferredOrder.push(n), n.priority || (n.priority = Object.keys(n.params))
        }), this._resolverHash = {}
    }
    set basePath(e) {
        this._basePath = e
    }
    get basePath() {
        return this._basePath
    }
    set rootPath(e) {
        this._rootPath = e
    }
    get rootPath() {
        return this._rootPath
    }
    get parsers() {
        return this._parsers
    }
    reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null
    }
    setDefaultSearchParams(e) {
        if (typeof e == "string") this._defaultSearchParams = e;
        else {
            const n = e;
            this._defaultSearchParams = Object.keys(n).map(r => `${encodeURIComponent(r)}=${encodeURIComponent(n[r])}`).join("&")
        }
    }
    getAlias(e) {
        const {
            alias: n,
            src: r
        } = e;
        return Er(n || r, s => typeof s == "string" ? s : Array.isArray(s) ? s.map(o => (o == null ? void 0 : o.src) ? ? o) : s != null && s.src ? s.src : s, !0)
    }
    addManifest(e) {
        this._manifest && Me("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = e, e.bundles.forEach(n => {
            this.addBundle(n.name, n.assets)
        })
    }
    addBundle(e, n) {
        const r = [];
        let i = n;
        Array.isArray(n) || (i = Object.entries(n).map(([s, o]) => typeof o == "string" || Array.isArray(o) ? {
            alias: s,
            src: o
        } : {
            alias: s,
            ...o
        })), i.forEach(s => {
            const o = s.src,
                a = s.alias;
            let l;
            if (typeof a == "string") {
                const c = this._createBundleAssetId(e, a);
                r.push(c), l = [a, c]
            } else {
                const c = a.map(u => this._createBundleAssetId(e, u));
                r.push(...c), l = [...a, ...c]
            }
            this.add({ ...s,
                alias: l,
                src: o
            })
        }), this._bundles[e] = r
    }
    add(e) {
        const n = [];
        Array.isArray(e) ? n.push(...e) : n.push(e);
        let r;
        r = s => {
            this.hasKey(s) && Me(`[Resolver] already has key: ${s} overwriting`)
        }, Er(n).forEach(s => {
            const {
                src: o
            } = s;
            let {
                data: a,
                format: l,
                loadParser: c
            } = s;
            const u = Er(o).map(h => typeof h == "string" ? Nfe(h) : Array.isArray(h) ? h : [h]),
                d = this.getAlias(s);
            Array.isArray(d) ? d.forEach(r) : r(d);
            const f = [];
            u.forEach(h => {
                h.forEach(p => {
                    let b = {};
                    if (typeof p != "object") {
                        b.src = p;
                        for (let y = 0; y < this._parsers.length; y++) {
                            const m = this._parsers[y];
                            if (m.test(p)) {
                                b = m.parse(p);
                                break
                            }
                        }
                    } else a = p.data ? ? a, l = p.format ? ? l, c = p.loadParser ? ? c, b = { ...b,
                        ...p
                    };
                    if (!d) throw new Error(`[Resolver] alias is undefined for this asset: ${b.src}`);
                    b = this._buildResolvedAsset(b, {
                        aliases: d,
                        data: a,
                        format: l,
                        loadParser: c
                    }), f.push(b)
                })
            }), d.forEach(h => {
                this._assetMap[h] = f
            })
        })
    }
    resolveBundle(e) {
        const n = Ih(e);
        e = Er(e);
        const r = {};
        return e.forEach(i => {
            const s = this._bundles[i];
            if (s) {
                const o = this.resolve(s),
                    a = {};
                for (const l in o) {
                    const c = o[l];
                    a[this._extractAssetIdFromBundle(i, l)] = c
                }
                r[i] = a
            }
        }), n ? r[e[0]] : r
    }
    resolveUrl(e) {
        const n = this.resolve(e);
        if (typeof e != "string") {
            const r = {};
            for (const i in n) r[i] = n[i].src;
            return r
        }
        return n.src
    }
    resolve(e) {
        const n = Ih(e);
        e = Er(e);
        const r = {};
        return e.forEach(i => {
            if (!this._resolverHash[i])
                if (this._assetMap[i]) {
                    let s = this._assetMap[i];
                    const o = this._getPreferredOrder(s);
                    o == null || o.priority.forEach(a => {
                        o.params[a].forEach(l => {
                            const c = s.filter(u => u[a] ? u[a] === l : !1);
                            c.length && (s = c)
                        })
                    }), this._resolverHash[i] = s[0]
                } else this._resolverHash[i] = this._buildResolvedAsset({
                    alias: [i],
                    src: i
                }, {});
            r[i] = this._resolverHash[i]
        }), n ? r[e[0]] : r
    }
    hasKey(e) {
        return !!this._assetMap[e]
    }
    hasBundle(e) {
        return !!this._bundles[e]
    }
    _getPreferredOrder(e) {
        for (let n = 0; n < e.length; n++) {
            const r = e[n],
                i = this._preferredOrder.find(s => s.params.format.includes(r.format));
            if (i) return i
        }
        return this._preferredOrder[0]
    }
    _appendDefaultSearchParams(e) {
        if (!this._defaultSearchParams) return e;
        const n = /\?/.test(e) ? "&" : "?";
        return `${e}${n}${this._defaultSearchParams}`
    }
    _buildResolvedAsset(e, n) {
        const {
            aliases: r,
            data: i,
            loadParser: s,
            format: o
        } = n;
        return (this._basePath || this._rootPath) && (e.src = Dn.toAbsolute(e.src, this._basePath, this._rootPath)), e.alias = r ? ? e.alias ? ? [e.src], e.src = this._appendDefaultSearchParams(e.src), e.data = { ...i || {},
            ...e.data
        }, e.loadParser = s ? ? e.loadParser, e.format = o ? ? e.format ? ? Ufe(e.src), e
    }
}
Hl.RETINA_PREFIX = /@([0-9\.]+)x/;

function Ufe(t) {
    return t.split(".").pop().split("?").shift().split("#").shift()
}
const E0 = (t, e) => {
        const n = e.split("?")[1];
        return n && (t += `?${n}`), t
    },
    PD = class bc {
        constructor(e, n) {
            this.linkedSheets = [], this._texture = e instanceof we ? e : null, this.textureSource = e.source, this.textures = {}, this.animations = {}, this.data = n;
            const r = parseFloat(n.meta.scale);
            r ? (this.resolution = r, e.source.resolution = this.resolution) : this.resolution = e.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null
        }
        parse() {
            return new Promise(e => {
                this._callback = e, this._batchIndex = 0, this._frameKeys.length <= bc.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch()
            })
        }
        _processFrames(e) {
            let n = e;
            const r = bc.BATCH_SIZE;
            for (; n - e < r && n < this._frameKeys.length;) {
                const i = this._frameKeys[n],
                    s = this._frames[i],
                    o = s.frame;
                if (o) {
                    let a = null,
                        l = null;
                    const c = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame,
                        u = new at(0, 0, Math.floor(c.w) / this.resolution, Math.floor(c.h) / this.resolution);
                    s.rotated ? a = new at(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.h) / this.resolution, Math.floor(o.w) / this.resolution) : a = new at(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution), s.trimmed !== !1 && s.spriteSourceSize && (l = new at(Math.floor(s.spriteSourceSize.x) / this.resolution, Math.floor(s.spriteSourceSize.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution)), this.textures[i] = new we({
                        source: this.textureSource,
                        frame: a,
                        orig: u,
                        trim: l,
                        rotate: s.rotated ? 2 : 0,
                        defaultAnchor: s.anchor,
                        defaultBorders: s.borders,
                        label: i.toString()
                    })
                }
                n++
            }
        }
        _processAnimations() {
            const e = this.data.animations || {};
            for (const n in e) {
                this.animations[n] = [];
                for (let r = 0; r < e[n].length; r++) {
                    const i = e[n][r];
                    this.animations[n].push(this.textures[i])
                }
            }
        }
        _parseComplete() {
            const e = this._callback;
            this._callback = null, this._batchIndex = 0, e.call(this, this.textures)
        }
        _nextBatch() {
            this._processFrames(this._batchIndex * bc.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
                this._batchIndex * bc.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete())
            }, 0)
        }
        destroy(e = !1) {
            var n;
            for (const r in this.textures) this.textures[r].destroy();
            this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && ((n = this._texture) == null || n.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = []
        }
    };
PD.BATCH_SIZE = 1e3;
let uC = PD;
const Gfe = ["jpg", "png", "jpeg", "avif", "webp", "basis", "etc2", "bc7", "bc6h", "bc5", "bc4", "bc3", "bc2", "bc1", "eac", "astc"];

function AD(t, e, n) {
    const r = {};
    if (t.forEach(i => {
            r[i] = e
        }), Object.keys(e.textures).forEach(i => {
            r[i] = e.textures[i]
        }), !n) {
        const i = Dn.dirname(t[0]);
        e.linkedSheets.forEach((s, o) => {
            const a = AD([`${i}/${e.data.meta.related_multi_packs[o]}`], s, !0);
            Object.assign(r, a)
        })
    }
    return r
}
const Hfe = {
    extension: G.Asset,
    cache: {
        test: t => t instanceof uC,
        getCacheableAssets: (t, e) => AD(t, e, !1)
    },
    resolver: {
        extension: {
            type: G.ResolveParser,
            name: "resolveSpritesheet"
        },
        test: t => {
            const n = t.split("?")[0].split("."),
                r = n.pop(),
                i = n.pop();
            return r === "json" && Gfe.includes(i)
        },
        parse: t => {
            var n;
            const e = t.split(".");
            return {
                resolution: parseFloat(((n = Hl.RETINA_PREFIX.exec(t)) == null ? void 0 : n[1]) ? ? "1"),
                format: e[e.length - 2],
                src: t
            }
        }
    },
    loader: {
        name: "spritesheetLoader",
        extension: {
            type: G.LoadParser,
            priority: Zs.Normal,
            name: "spritesheetLoader"
        },
        async testParse(t, e) {
            return Dn.extname(e.src).toLowerCase() === ".json" && !!t.frames
        },
        async parse(t, e, n) {
            var u, d;
            const {
                texture: r,
                imageFilename: i,
                textureOptions: s
            } = (e == null ? void 0 : e.data) ? ? {};
            let o = Dn.dirname(e.src);
            o && o.lastIndexOf("/") !== o.length - 1 && (o += "/");
            let a;
            if (r instanceof we) a = r;
            else {
                const f = E0(o + (i ? ? t.meta.image), e.src);
                a = (await n.load([{
                    src: f,
                    data: s
                }]))[f]
            }
            const l = new uC(a.source, t);
            await l.parse();
            const c = (u = t == null ? void 0 : t.meta) == null ? void 0 : u.related_multi_packs;
            if (Array.isArray(c)) {
                const f = [];
                for (const p of c) {
                    if (typeof p != "string") continue;
                    let b = o + p;
                    (d = e.data) != null && d.ignoreMultiPack || (b = E0(b, e.src), f.push(n.load({
                        src: b,
                        data: {
                            textureOptions: s,
                            ignoreMultiPack: !0
                        }
                    })))
                }
                const h = await Promise.all(f);
                l.linkedSheets = h, h.forEach(p => {
                    p.linkedSheets = [l].concat(l.linkedSheets.filter(b => b !== p))
                })
            }
            return l
        },
        async unload(t, e, n) {
            await n.unload(t.textureSource._sourceOrigin), t.destroy(!1)
        }
    }
};
Ie.add(Hfe);
class cd {
    constructor(e) {
        this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = cd.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new ct, this.page = new ct, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = e
    }
    get layerX() {
        return this.layer.x
    }
    get layerY() {
        return this.layer.y
    }
    get pageX() {
        return this.page.x
    }
    get pageY() {
        return this.page.y
    }
    get data() {
        return this
    }
    composedPath() {
        return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path
    }
    initEvent(e, n, r) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    initUIEvent(e, n, r, i, s) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0
    }
    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0
    }
    stopPropagation() {
        this.propagationStopped = !0
    }
}
var Kg = /iPhone/i,
    dC = /iPod/i,
    fC = /iPad/i,
    hC = /\biOS-universal(?:.+)Mac\b/i,
    qg = /\bAndroid(?:.+)Mobile\b/i,
    pC = /Android/i,
    Ma = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
    rf = /Silk/i,
    vi = /Windows Phone/i,
    mC = /\bWindows(?:.+)ARM\b/i,
    gC = /BlackBerry/i,
    vC = /BB10/i,
    yC = /Opera Mini/i,
    _C = /\b(CriOS|Chrome)(?:.+)Mobile/i,
    bC = /Mobile(?:.+)Firefox\b/i,
    xC = function(t) {
        return typeof t < "u" && t.platform === "MacIntel" && typeof t.maxTouchPoints == "number" && t.maxTouchPoints > 1 && typeof MSStream > "u"
    };

function zfe(t) {
    return function(e) {
        return e.test(t)
    }
}

function wC(t) {
    var e = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
    };
    !t && typeof navigator < "u" ? e = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
    } : typeof t == "string" ? e.userAgent = t : t && t.userAgent && (e = {
        userAgent: t.userAgent,
        platform: t.platform,
        maxTouchPoints: t.maxTouchPoints || 0
    });
    var n = e.userAgent,
        r = n.split("[FBAN");
    typeof r[1] < "u" && (n = r[0]), r = n.split("Twitter"), typeof r[1] < "u" && (n = r[0]);
    var i = zfe(n),
        s = {
            apple: {
                phone: i(Kg) && !i(vi),
                ipod: i(dC),
                tablet: !i(Kg) && (i(fC) || xC(e)) && !i(vi),
                universal: i(hC),
                device: (i(Kg) || i(dC) || i(fC) || i(hC) || xC(e)) && !i(vi)
            },
            amazon: {
                phone: i(Ma),
                tablet: !i(Ma) && i(rf),
                device: i(Ma) || i(rf)
            },
            android: {
                phone: !i(vi) && i(Ma) || !i(vi) && i(qg),
                tablet: !i(vi) && !i(Ma) && !i(qg) && (i(rf) || i(pC)),
                device: !i(vi) && (i(Ma) || i(rf) || i(qg) || i(pC)) || i(/\bokhttp\b/i)
            },
            windows: {
                phone: i(vi),
                tablet: i(mC),
                device: i(vi) || i(mC)
            },
            other: {
                blackberry: i(gC),
                blackberry10: i(vC),
                opera: i(yC),
                firefox: i(bC),
                chrome: i(_C),
                device: i(gC) || i(vC) || i(yC) || i(bC) || i(_C)
            },
            any: !1,
            phone: !1,
            tablet: !1
        };
    return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device, s.phone = s.apple.phone || s.android.phone || s.windows.phone, s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet, s
}
const jfe = wC.default ? ? wC,
    Vfe = jfe(globalThis.navigator),
    Wfe = 9,
    sf = 100,
    Yfe = 0,
    Xfe = 0,
    EC = 2,
    SC = 1,
    Kfe = -1e3,
    qfe = -1e3,
    Jfe = 2,
    Fx = class OD {
        constructor(e, n = Vfe) {
            this._mobileInfo = n, this.debug = !1, this._activateOnTab = !0, this._deactivateOnMouseMove = !0, this._isActive = !1, this._isMobileAccessibility = !1, this._div = null, this._pool = [], this._renderId = 0, this._children = [], this._androidUpdateCount = 0, this._androidUpdateFrequency = 500, this._hookDiv = null, (n.tablet || n.phone) && this._createTouchHook(), this._renderer = e
        }
        get isActive() {
            return this._isActive
        }
        get isMobileAccessibility() {
            return this._isMobileAccessibility
        }
        get hookDiv() {
            return this._hookDiv
        }
        _createTouchHook() {
            const e = document.createElement("button");
            e.style.width = `${SC}px`, e.style.height = `${SC}px`, e.style.position = "absolute", e.style.top = `${Kfe}px`, e.style.left = `${qfe}px`, e.style.zIndex = Jfe.toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", () => {
                this._isMobileAccessibility = !0, this._activate(), this._destroyTouchHook()
            }), document.body.appendChild(e), this._hookDiv = e
        }
        _destroyTouchHook() {
            this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null)
        }
        _activate() {
            if (this._isActive) return;
            this._isActive = !0, this._div || (this._div = document.createElement("div"), this._div.style.width = `${sf}px`, this._div.style.height = `${sf}px`, this._div.style.position = "absolute", this._div.style.top = `${Yfe}px`, this._div.style.left = `${Xfe}px`, this._div.style.zIndex = EC.toString(), this._div.style.pointerEvents = "none"), this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)), this._deactivateOnMouseMove && (this._onMouseMove = this._onMouseMove.bind(this), globalThis.document.addEventListener("mousemove", this._onMouseMove, !0));
            const e = this._renderer.view.canvas;
            if (e.parentNode) e.parentNode.appendChild(this._div), this._initAccessibilitySetup();
            else {
                const n = new MutationObserver(() => {
                    e.parentNode && (e.parentNode.appendChild(this._div), n.disconnect(), this._initAccessibilitySetup())
                });
                n.observe(document.body, {
                    childList: !0,
                    subtree: !0
                })
            }
        }
        _initAccessibilitySetup() {
            this._renderer.runners.postrender.add(this), this._renderer.lastObjectRendered && this._updateAccessibleObjects(this._renderer.lastObjectRendered)
        }
        _deactivate() {
            if (!(!this._isActive || this._isMobileAccessibility)) {
                this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), this._activateOnTab && globalThis.addEventListener("keydown", this._onKeyDown, !1), this._renderer.runners.postrender.remove(this);
                for (const e of this._children) e._accessibleDiv && e._accessibleDiv.parentNode && (e._accessibleDiv.parentNode.removeChild(e._accessibleDiv), e._accessibleDiv = null), e._accessibleActive = !1;
                this._pool.forEach(e => {
                    e.parentNode && e.parentNode.removeChild(e)
                }), this._div && this._div.parentNode && this._div.parentNode.removeChild(this._div), this._pool = [], this._children = []
            }
        }
        _updateAccessibleObjects(e) {
            if (!e.visible || !e.accessibleChildren) return;
            e.accessible && (e._accessibleActive || this._addChild(e), e._renderId = this._renderId);
            const n = e.children;
            if (n)
                for (let r = 0; r < n.length; r++) this._updateAccessibleObjects(n[r])
        }
        init(e) {
            const r = {
                accessibilityOptions: { ...OD.defaultOptions,
                    ...(e == null ? void 0 : e.accessibilityOptions) || {}
                }
            };
            this.debug = r.accessibilityOptions.debug, this._activateOnTab = r.accessibilityOptions.activateOnTab, this._deactivateOnMouseMove = r.accessibilityOptions.deactivateOnMouseMove, r.accessibilityOptions.enabledByDefault ? this._activate() : this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)), this._renderer.runners.postrender.remove(this)
        }
        postrender() {
            const e = performance.now();
            if (this._mobileInfo.android.device && e < this._androidUpdateCount || (this._androidUpdateCount = e + this._androidUpdateFrequency, !this._renderer.renderingToScreen || !this._renderer.view.canvas)) return;
            const n = new Set;
            if (this._renderer.lastObjectRendered) {
                this._updateAccessibleObjects(this._renderer.lastObjectRendered);
                for (const r of this._children) r._renderId === this._renderId && n.add(this._children.indexOf(r))
            }
            for (let r = this._children.length - 1; r >= 0; r--) {
                const i = this._children[r];
                n.has(r) || (i._accessibleDiv && i._accessibleDiv.parentNode && (i._accessibleDiv.parentNode.removeChild(i._accessibleDiv), this._pool.push(i._accessibleDiv), i._accessibleDiv = null), i._accessibleActive = !1, uD(this._children, r, 1))
            }
            if (this._renderer.renderingToScreen) {
                const {
                    x: r,
                    y: i,
                    width: s,
                    height: o
                } = this._renderer.screen, a = this._div;
                a.style.left = `${r}px`, a.style.top = `${i}px`, a.style.width = `${s}px`, a.style.height = `${o}px`
            }
            for (let r = 0; r < this._children.length; r++) {
                const i = this._children[r];
                if (!i._accessibleActive || !i._accessibleDiv) continue;
                const s = i._accessibleDiv,
                    o = i.hitArea || i.getBounds().rectangle;
                if (i.hitArea) {
                    const a = i.worldTransform,
                        l = this._renderer.resolution,
                        c = this._renderer.resolution;
                    s.style.left = `${(a.tx+o.x*a.a)*l}px`, s.style.top = `${(a.ty+o.y*a.d)*c}px`, s.style.width = `${o.width*a.a*l}px`, s.style.height = `${o.height*a.d*c}px`
                } else {
                    this._capHitArea(o);
                    const a = this._renderer.resolution,
                        l = this._renderer.resolution;
                    s.style.left = `${o.x*a}px`, s.style.top = `${o.y*l}px`, s.style.width = `${o.width*a}px`, s.style.height = `${o.height*l}px`
                }
            }
            this._renderId++
        }
        _updateDebugHTML(e) {
            e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`
        }
        _capHitArea(e) {
            e.x < 0 && (e.width += e.x, e.x = 0), e.y < 0 && (e.height += e.y, e.y = 0);
            const {
                width: n,
                height: r
            } = this._renderer;
            e.x + e.width > n && (e.width = n - e.x), e.y + e.height > r && (e.height = r - e.y)
        }
        _addChild(e) {
            let n = this._pool.pop();
            n || (e.accessibleType === "button" ? n = document.createElement("button") : (n = document.createElement(e.accessibleType), n.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `, e.accessibleText && (n.innerText = e.accessibleText)), n.style.width = `${sf}px`, n.style.height = `${sf}px`, n.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", n.style.position = "absolute", n.style.zIndex = EC.toString(), n.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? n.setAttribute("aria-live", "off") : n.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? n.setAttribute("aria-relevant", "additions") : n.setAttribute("aria-relevant", "text"), n.addEventListener("click", this._onClick.bind(this)), n.addEventListener("focus", this._onFocus.bind(this)), n.addEventListener("focusout", this._onFocusOut.bind(this))), n.style.pointerEvents = e.accessiblePointerEvents, n.type = e.accessibleType, e.accessibleTitle && e.accessibleTitle !== null ? n.title = e.accessibleTitle : (!e.accessibleHint || e.accessibleHint === null) && (n.title = `container ${e.tabIndex}`), e.accessibleHint && e.accessibleHint !== null && n.setAttribute("aria-label", e.accessibleHint), this.debug && this._updateDebugHTML(n), e._accessibleActive = !0, e._accessibleDiv = n, n.container = e, this._children.push(e), this._div.appendChild(e._accessibleDiv), e.interactive && (e._accessibleDiv.tabIndex = e.tabIndex)
        }
        _dispatchEvent(e, n) {
            const {
                container: r
            } = e.target, i = this._renderer.events.rootBoundary, s = Object.assign(new cd(i), {
                target: r
            });
            i.rootTarget = this._renderer.lastObjectRendered, n.forEach(o => i.dispatchEvent(s, o))
        }
        _onClick(e) {
            this._dispatchEvent(e, ["click", "pointertap", "tap"])
        }
        _onFocus(e) {
            e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(e, ["mouseover"])
        }
        _onFocusOut(e) {
            e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "polite"), this._dispatchEvent(e, ["mouseout"])
        }
        _onKeyDown(e) {
            e.keyCode !== Wfe || !this._activateOnTab || this._activate()
        }
        _onMouseMove(e) {
            e.movementX === 0 && e.movementY === 0 || this._deactivate()
        }
        destroy() {
            this._deactivate(), this._destroyTouchHook(), this._div = null, this._pool = null, this._children = null, this._renderer = null, this._activateOnTab && globalThis.removeEventListener("keydown", this._onKeyDown)
        }
        setAccessibilityEnabled(e) {
            e ? this._activate() : this._deactivate()
        }
    };
Fx.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "accessibility"
};
Fx.defaultOptions = {
    enabledByDefault: !1,
    debug: !1,
    activateOnTab: !0,
    deactivateOnMouseMove: !0
};
let Zfe = Fx;
const Qfe = {
        accessible: !1,
        accessibleTitle: null,
        accessibleHint: null,
        tabIndex: 0,
        _accessibleActive: !1,
        _accessibleDiv: null,
        accessibleType: "button",
        accessibleText: null,
        accessiblePointerEvents: "auto",
        accessibleChildren: !0,
        _renderId: -1
    },
    Jg = Object.create(null),
    TC = Object.create(null);

function Cu(t, e) {
    let n = TC[t];
    return n === void 0 && (Jg[e] === void 0 && (Jg[e] = 1), TC[t] = n = Jg[e]++), n
}
let ka;

function ID() {
    return (!ka || ka != null && ka.isContextLost()) && (ka = He.get().createCanvas().getContext("webgl", {})), ka
}
let of ;

function ehe() {
    if (! of ) { of = "mediump";
        const t = ID();
        t && t.getShaderPrecisionFormat && ( of = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision ? "highp" : "mediump")
    }
    return of
}

function the(t, e, n) {
    return e ? t : n ? (t = t.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${t}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${t}
        `
}

function nhe(t, e, n) {
    const r = n ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision;
    if (t.substring(0, 9) !== "precision") {
        let i = n ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
        return i === "highp" && r !== "highp" && (i = "mediump"), `precision ${i} float;
${t}`
    } else if (r !== "highp" && t.substring(0, 15) === "precision highp") return t.replace("precision highp", "precision mediump");
    return t
}

function rhe(t, e) {
    return e ? `#version 300 es
${t}` : t
}
const ihe = {},
    she = {};

function ohe(t, {
    name: e = "pixi-program"
}, n = !0) {
    e = e.replace(/\s+/g, "-"), e += n ? "-fragment" : "-vertex";
    const r = n ? ihe : she;
    return r[e] ? (r[e]++, e += `-${r[e]}`) : r[e] = 1, t.indexOf("#define SHADER_NAME") !== -1 ? t : `${`#define SHADER_NAME ${e}`}
${t}`
}

function ahe(t, e) {
    return e ? t.replace("#version 300 es", "") : t
}
const Zg = {
        stripVersion: ahe,
        ensurePrecision: nhe,
        addProgramDefines: the,
        setProgramName: ohe,
        insertVersion: rhe
    },
    Qg = Object.create(null),
    RD = class S0 {
        constructor(e) {
            e = { ...S0.defaultOptions,
                ...e
            };
            const n = e.fragment.indexOf("#version 300 es") !== -1,
                r = {
                    stripVersion: n,
                    ensurePrecision: {
                        requestedFragmentPrecision: e.preferredFragmentPrecision,
                        requestedVertexPrecision: e.preferredVertexPrecision,
                        maxSupportedVertexPrecision: "highp",
                        maxSupportedFragmentPrecision: ehe()
                    },
                    setProgramName: {
                        name: e.name
                    },
                    addProgramDefines: n,
                    insertVersion: n
                };
            let i = e.fragment,
                s = e.vertex;
            Object.keys(Zg).forEach(o => {
                const a = r[o];
                i = Zg[o](i, a, !0), s = Zg[o](s, a, !1)
            }), this.fragment = i, this.vertex = s, this.transformFeedbackVaryings = e.transformFeedbackVaryings, this._key = Cu(`${this.vertex}:${this.fragment}`, "gl-program")
        }
        destroy() {
            this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null
        }
        static from(e) {
            const n = `${e.vertex}:${e.fragment}`;
            return Qg[n] || (Qg[n] = new S0(e)), Qg[n]
        }
    };
RD.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump"
};
let ga = RD;
const CC = {
    uint8x2: {
        size: 2,
        stride: 2,
        normalised: !1
    },
    uint8x4: {
        size: 4,
        stride: 4,
        normalised: !1
    },
    sint8x2: {
        size: 2,
        stride: 2,
        normalised: !1
    },
    sint8x4: {
        size: 4,
        stride: 4,
        normalised: !1
    },
    unorm8x2: {
        size: 2,
        stride: 2,
        normalised: !0
    },
    unorm8x4: {
        size: 4,
        stride: 4,
        normalised: !0
    },
    snorm8x2: {
        size: 2,
        stride: 2,
        normalised: !0
    },
    snorm8x4: {
        size: 4,
        stride: 4,
        normalised: !0
    },
    uint16x2: {
        size: 2,
        stride: 4,
        normalised: !1
    },
    uint16x4: {
        size: 4,
        stride: 8,
        normalised: !1
    },
    sint16x2: {
        size: 2,
        stride: 4,
        normalised: !1
    },
    sint16x4: {
        size: 4,
        stride: 8,
        normalised: !1
    },
    unorm16x2: {
        size: 2,
        stride: 4,
        normalised: !0
    },
    unorm16x4: {
        size: 4,
        stride: 8,
        normalised: !0
    },
    snorm16x2: {
        size: 2,
        stride: 4,
        normalised: !0
    },
    snorm16x4: {
        size: 4,
        stride: 8,
        normalised: !0
    },
    float16x2: {
        size: 2,
        stride: 4,
        normalised: !1
    },
    float16x4: {
        size: 4,
        stride: 8,
        normalised: !1
    },
    float32: {
        size: 1,
        stride: 4,
        normalised: !1
    },
    float32x2: {
        size: 2,
        stride: 8,
        normalised: !1
    },
    float32x3: {
        size: 3,
        stride: 12,
        normalised: !1
    },
    float32x4: {
        size: 4,
        stride: 16,
        normalised: !1
    },
    uint32: {
        size: 1,
        stride: 4,
        normalised: !1
    },
    uint32x2: {
        size: 2,
        stride: 8,
        normalised: !1
    },
    uint32x3: {
        size: 3,
        stride: 12,
        normalised: !1
    },
    uint32x4: {
        size: 4,
        stride: 16,
        normalised: !1
    },
    sint32: {
        size: 1,
        stride: 4,
        normalised: !1
    },
    sint32x2: {
        size: 2,
        stride: 8,
        normalised: !1
    },
    sint32x3: {
        size: 3,
        stride: 12,
        normalised: !1
    },
    sint32x4: {
        size: 4,
        stride: 16,
        normalised: !1
    }
};

function Gs(t) {
    return CC[t] ? ? CC.float32
}
const lhe = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4"
};

function che({
    source: t,
    entryPoint: e
}) {
    const n = {},
        r = t.indexOf(`fn ${e}`);
    if (r !== -1) {
        const i = t.indexOf("->", r);
        if (i !== -1) {
            const s = t.substring(r, i),
                o = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
            let a;
            for (;
                (a = o.exec(s)) !== null;) {
                const l = lhe[a[3]] ? ? "float32";
                n[a[2]] = {
                    location: parseInt(a[1], 10),
                    format: l,
                    stride: Gs(l).stride,
                    offset: 0,
                    instance: !1,
                    start: 0
                }
            }
        }
    }
    return n
}

function ev(t) {
    var d, f;
    const e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,
        n = /@group\((\d+)\)/,
        r = /@binding\((\d+)\)/,
        i = /var(<[^>]+>)? (\w+)/,
        s = /:\s*(\w+)/,
        o = /struct\s+(\w+)\s*{([^}]+)}/g,
        a = /(\w+)\s*:\s*([\w\<\>]+)/g,
        l = /struct\s+(\w+)/,
        c = (d = t.match(e)) == null ? void 0 : d.map(h => ({
            group: parseInt(h.match(n)[1], 10),
            binding: parseInt(h.match(r)[1], 10),
            name: h.match(i)[2],
            isUniform: h.match(i)[1] === "<uniform>",
            type: h.match(s)[1]
        }));
    if (!c) return {
        groups: [],
        structs: []
    };
    const u = ((f = t.match(o)) == null ? void 0 : f.map(h => {
        const p = h.match(l)[1],
            b = h.match(a).reduce((y, m) => {
                const [g, v] = m.split(":");
                return y[g.trim()] = v.trim(), y
            }, {});
        return b ? {
            name: p,
            members: b
        } : null
    }).filter(({
        name: h
    }) => c.some(p => p.type === h))) ? ? [];
    return {
        groups: c,
        structs: u
    }
}
var xc = (t => (t[t.VERTEX = 1] = "VERTEX", t[t.FRAGMENT = 2] = "FRAGMENT", t[t.COMPUTE = 4] = "COMPUTE", t))(xc || {});

function uhe({
    groups: t
}) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        e[r.group] || (e[r.group] = []), r.isUniform ? e[r.group].push({
            binding: r.binding,
            visibility: xc.VERTEX | xc.FRAGMENT,
            buffer: {
                type: "uniform"
            }
        }) : r.type === "sampler" ? e[r.group].push({
            binding: r.binding,
            visibility: xc.FRAGMENT,
            sampler: {
                type: "filtering"
            }
        }) : r.type === "texture_2d" && e[r.group].push({
            binding: r.binding,
            visibility: xc.FRAGMENT,
            texture: {
                sampleType: "float",
                viewDimension: "2d",
                multisampled: !1
            }
        })
    }
    return e
}

function dhe({
    groups: t
}) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        e[r.group] || (e[r.group] = {}), e[r.group][r.name] = r.binding
    }
    return e
}

function fhe(t, e) {
    const n = new Set,
        r = new Set,
        i = [...t.structs, ...e.structs].filter(o => n.has(o.name) ? !1 : (n.add(o.name), !0)),
        s = [...t.groups, ...e.groups].filter(o => {
            const a = `${o.name}-${o.binding}`;
            return r.has(a) ? !1 : (r.add(a), !0)
        });
    return {
        structs: i,
        groups: s
    }
}
const tv = Object.create(null);
class Qs {
    constructor(e) {
        var a, l;
        this._layoutKey = 0, this._attributeLocationsKey = 0;
        const {
            fragment: n,
            vertex: r,
            layout: i,
            gpuLayout: s,
            name: o
        } = e;
        if (this.name = o, this.fragment = n, this.vertex = r, n.source === r.source) {
            const c = ev(n.source);
            this.structsAndGroups = c
        } else {
            const c = ev(r.source),
                u = ev(n.source);
            this.structsAndGroups = fhe(c, u)
        }
        this.layout = i ? ? dhe(this.structsAndGroups), this.gpuLayout = s ? ? uhe(this.structsAndGroups), this.autoAssignGlobalUniforms = ((a = this.layout[0]) == null ? void 0 : a.globalUniforms) !== void 0, this.autoAssignLocalUniforms = ((l = this.layout[1]) == null ? void 0 : l.localUniforms) !== void 0, this._generateProgramKey()
    }
    _generateProgramKey() {
        const {
            vertex: e,
            fragment: n
        } = this, r = e.source + n.source + e.entryPoint + n.entryPoint;
        this._layoutKey = Cu(r, "program")
    }
    get attributeData() {
        return this._attributeData ? ? (this._attributeData = che(this.vertex)), this._attributeData
    }
    destroy() {
        this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null
    }
    static from(e) {
        const n = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
        return tv[n] || (tv[n] = new Qs(e)), tv[n]
    }
}
const MD = ["f32", "i32", "vec2<f32>", "vec3<f32>", "vec4<f32>", "mat2x2<f32>", "mat3x3<f32>", "mat4x4<f32>", "mat3x2<f32>", "mat4x2<f32>", "mat2x3<f32>", "mat4x3<f32>", "mat2x4<f32>", "mat3x4<f32>", "vec2<i32>", "vec3<i32>", "vec4<i32>"],
    hhe = MD.reduce((t, e) => (t[e] = !0, t), {});

function phe(t, e) {
    switch (t) {
        case "f32":
            return 0;
        case "vec2<f32>":
            return new Float32Array(2 * e);
        case "vec3<f32>":
            return new Float32Array(3 * e);
        case "vec4<f32>":
            return new Float32Array(4 * e);
        case "mat2x2<f32>":
            return new Float32Array([1, 0, 0, 1]);
        case "mat3x3<f32>":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4x4<f32>":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
}
const kD = class BD {
    constructor(e, n) {
        this._touched = 0, this.uid = yt("uniform"), this._resourceType = "uniformGroup", this._resourceId = yt("resource"), this.isUniformGroup = !0, this._dirtyId = 0, this.destroyed = !1, n = { ...BD.defaultOptions,
            ...n
        }, this.uniformStructures = e;
        const r = {};
        for (const i in e) {
            const s = e[i];
            if (s.name = i, s.size = s.size ? ? 1, !hhe[s.type]) throw new Error(`Uniform type ${s.type} is not supported. Supported uniform types are: ${MD.join(", ")}`);
            s.value ? ? (s.value = phe(s.type, s.size)), r[i] = s.value
        }
        this.uniforms = r, this._dirtyId = 1, this.ubo = n.ubo, this.isStatic = n.isStatic, this._signature = Cu(Object.keys(r).map(i => `${i}-${e[i].type}`).join("-"), "uniform-group")
    }
    update() {
        this._dirtyId++
    }
};
kD.defaultOptions = {
    ubo: !1,
    isStatic: !1
};
let Cn = kD;
class Fi {
    constructor(e) {
        this.resources = Object.create(null), this._dirty = !0;
        let n = 0;
        for (const r in e) {
            const i = e[r];
            this.setResource(i, n++)
        }
        this._updateKey()
    }
    _updateKey() {
        if (!this._dirty) return;
        this._dirty = !1;
        const e = [];
        let n = 0;
        for (const r in this.resources) e[n++] = this.resources[r]._resourceId;
        this._key = e.join("|")
    }
    setResource(e, n) {
        var i, s;
        const r = this.resources[n];
        e !== r && (r && ((i = e.off) == null || i.call(e, "change", this.onResourceChange, this)), (s = e.on) == null || s.call(e, "change", this.onResourceChange, this), this.resources[n] = e, this._dirty = !0)
    }
    getResource(e) {
        return this.resources[e]
    }
    _touch(e) {
        const n = this.resources;
        for (const r in n) n[r]._touched = e
    }
    destroy() {
        var n;
        const e = this.resources;
        for (const r in e) {
            const i = e[r];
            (n = i.off) == null || n.call(i, "change", this.onResourceChange, this)
        }
        this.resources = null
    }
    onResourceChange(e) {
        if (this._dirty = !0, e.destroyed) {
            const n = this.resources;
            for (const r in n) n[r] === e && (n[r] = null)
        } else this._updateKey()
    }
}
var Qn = (t => (t[t.WEBGL = 1] = "WEBGL", t[t.WEBGPU = 2] = "WEBGPU", t[t.BOTH = 3] = "BOTH", t))(Qn || {});
class pr extends rr {
    constructor(e) {
        super(), this.uid = yt("shader"), this._uniformBindMap = Object.create(null), this._ownedBindGroups = [];
        let {
            gpuProgram: n,
            glProgram: r,
            groups: i,
            resources: s,
            compatibleRenderers: o,
            groupMap: a
        } = e;
        this.gpuProgram = n, this.glProgram = r, o === void 0 && (o = 0, n && (o |= Qn.WEBGPU), r && (o |= Qn.WEBGL)), this.compatibleRenderers = o;
        const l = {};
        if (!s && !i && (s = {}), s && i) throw new Error("[Shader] Cannot have both resources and groups");
        if (!n && i && !a) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
        if (!n && i && a)
            for (const c in a)
                for (const u in a[c]) {
                    const d = a[c][u];
                    l[d] = {
                        group: c,
                        binding: u,
                        name: d
                    }
                } else if (n && i && !a) {
                    const c = n.structsAndGroups.groups;
                    a = {}, c.forEach(u => {
                        a[u.group] = a[u.group] || {}, a[u.group][u.binding] = u.name, l[u.name] = u
                    })
                } else if (s) {
            i = {}, a = {}, n && n.structsAndGroups.groups.forEach(d => {
                a[d.group] = a[d.group] || {}, a[d.group][d.binding] = d.name, l[d.name] = d
            });
            let c = 0;
            for (const u in s) l[u] || (i[99] || (i[99] = new Fi, this._ownedBindGroups.push(i[99])), l[u] = {
                group: 99,
                binding: c,
                name: u
            }, a[99] = a[99] || {}, a[99][c] = u, c++);
            for (const u in s) {
                const d = u;
                let f = s[u];
                !f.source && !f._resourceType && (f = new Cn(f));
                const h = l[d];
                h && (i[h.group] || (i[h.group] = new Fi, this._ownedBindGroups.push(i[h.group])), i[h.group].setResource(f, h.binding))
            }
        }
        this.groups = i, this._uniformBindMap = a, this.resources = this._buildResourceAccessor(i, l)
    }
    addResource(e, n, r) {
        var i, s;
        (i = this._uniformBindMap)[n] || (i[n] = {}), (s = this._uniformBindMap[n])[r] || (s[r] = e), this.groups[n] || (this.groups[n] = new Fi, this._ownedBindGroups.push(this.groups[n]))
    }
    _buildResourceAccessor(e, n) {
        const r = {};
        for (const i in n) {
            const s = n[i];
            Object.defineProperty(r, s.name, {
                get() {
                    return e[s.group].getResource(s.binding)
                },
                set(o) {
                    e[s.group].setResource(o, s.binding)
                }
            })
        }
        return r
    }
    destroy(e = !1) {
        var n, r;
        this.emit("destroy", this), e && ((n = this.gpuProgram) == null || n.destroy(), (r = this.glProgram) == null || r.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach(i => {
            i.destroy()
        }), this._ownedBindGroups = null, this.resources = null, this.groups = null
    }
    static from(e) {
        const {
            gpu: n,
            gl: r,
            ...i
        } = e;
        let s, o;
        return n && (s = Qs.from(n)), r && (o = ga.from(r)), new pr({
            gpuProgram: s,
            glProgram: o,
            ...i
        })
    }
}
const mhe = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10
    },
    nv = 0,
    rv = 1,
    iv = 2,
    sv = 3,
    ov = 4,
    av = 5,
    T0 = class DD {
        constructor() {
            this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = !0, this.depthMask = !0
        }
        get blend() {
            return !!(this.data & 1 << nv)
        }
        set blend(e) {
            !!(this.data & 1 << nv) !== e && (this.data ^= 1 << nv)
        }
        get offsets() {
            return !!(this.data & 1 << rv)
        }
        set offsets(e) {
            !!(this.data & 1 << rv) !== e && (this.data ^= 1 << rv)
        }
        set cullMode(e) {
            if (e === "none") {
                this.culling = !1;
                return
            }
            this.culling = !0, this.clockwiseFrontFace = e === "front"
        }
        get cullMode() {
            return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none"
        }
        get culling() {
            return !!(this.data & 1 << iv)
        }
        set culling(e) {
            !!(this.data & 1 << iv) !== e && (this.data ^= 1 << iv)
        }
        get depthTest() {
            return !!(this.data & 1 << sv)
        }
        set depthTest(e) {
            !!(this.data & 1 << sv) !== e && (this.data ^= 1 << sv)
        }
        get depthMask() {
            return !!(this.data & 1 << av)
        }
        set depthMask(e) {
            !!(this.data & 1 << av) !== e && (this.data ^= 1 << av)
        }
        get clockwiseFrontFace() {
            return !!(this.data & 1 << ov)
        }
        set clockwiseFrontFace(e) {
            !!(this.data & 1 << ov) !== e && (this.data ^= 1 << ov)
        }
        get blendMode() {
            return this._blendMode
        }
        set blendMode(e) {
            this.blend = e !== "none", this._blendMode = e, this._blendModeId = mhe[e] || 0
        }
        get polygonOffset() {
            return this._polygonOffset
        }
        set polygonOffset(e) {
            this.offsets = !!e, this._polygonOffset = e
        }
        toString() {
            return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
        }
        static for2d() {
            const e = new DD;
            return e.depthTest = !1, e.blend = !0, e
        }
    };
T0.default2d = T0.for2d();
let kr = T0;
const $D = class C0 extends pr {
    constructor(e) {
        e = { ...C0.defaultOptions,
            ...e
        }, super(e), this.enabled = !0, this._state = kr.for2d(), this.blendMode = e.blendMode, this.padding = e.padding, typeof e.antialias == "boolean" ? this.antialias = e.antialias ? "on" : "off" : this.antialias = e.antialias, this.resolution = e.resolution, this.blendRequired = e.blendRequired, this.clipToViewport = e.clipToViewport, this.addResource("uTexture", 0, 1)
    }
    apply(e, n, r, i) {
        e.applyFilter(this, n, r, i)
    }
    get blendMode() {
        return this._state.blendMode
    }
    set blendMode(e) {
        this._state.blendMode = e
    }
    static from(e) {
        const {
            gpu: n,
            gl: r,
            ...i
        } = e;
        let s, o;
        return n && (s = Qs.from(n)), r && (o = ga.from(r)), new C0({
            gpuProgram: s,
            glProgram: o,
            ...i
        })
    }
};
$D.defaultOptions = {
    blendMode: "normal",
    resolution: 1,
    padding: 0,
    antialias: "off",
    blendRequired: !1,
    clipToViewport: !0
};
let Lx = $D;
const P0 = [];
Ie.handleByNamedList(G.Environment, P0);
async function ghe(t) {
    if (!t)
        for (let e = 0; e < P0.length; e++) {
            const n = P0[e];
            if (n.value.test()) {
                await n.value.load();
                return
            }
        }
}
let uc;

function FD() {
    if (typeof uc == "boolean") return uc;
    try {
        uc = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
            a: "b"
        }, "a", "b") === !0
    } catch {
        uc = !1
    }
    return uc
}
var Nx = {
    exports: {}
};
Nx.exports = Zp;
Nx.exports.default = Zp;

function Zp(t, e, n) {
    n = n || 2;
    var r = e && e.length,
        i = r ? e[0] * n : t.length,
        s = LD(t, 0, i, n, !0),
        o = [];
    if (!s || s.next === s.prev) return o;
    var a, l, c, u, d, f, h;
    if (r && (s = xhe(t, e, s, n)), t.length > 80 * n) {
        a = c = t[0], l = u = t[1];
        for (var p = n; p < i; p += n) d = t[p], f = t[p + 1], d < a && (a = d), f < l && (l = f), d > c && (c = d), f > u && (u = f);
        h = Math.max(c - a, u - l), h = h !== 0 ? 32767 / h : 0
    }
    return Pu(s, o, n, a, l, h, 0), o
}

function LD(t, e, n, r, i) {
    var s, o;
    if (i === I0(t, e, n, r) > 0)
        for (s = e; s < n; s += r) o = PC(s, t[s], t[s + 1], o);
    else
        for (s = n - r; s >= e; s -= r) o = PC(s, t[s], t[s + 1], o);
    return o && Qp(o, o.next) && (Ou(o), o = o.next), o
}

function ra(t, e) {
    if (!t) return t;
    e || (e = t);
    var n = t,
        r;
    do
        if (r = !1, !n.steiner && (Qp(n, n.next) || xt(n.prev, n, n.next) === 0)) {
            if (Ou(n), n = e = n.prev, n === n.next) break;
            r = !0
        } else n = n.next; while (r || n !== e);
    return e
}

function Pu(t, e, n, r, i, s, o) {
    if (t) {
        !o && s && Che(t, r, i, s);
        for (var a = t, l, c; t.prev !== t.next;) {
            if (l = t.prev, c = t.next, s ? yhe(t, r, i, s) : vhe(t)) {
                e.push(l.i / n | 0), e.push(t.i / n | 0), e.push(c.i / n | 0), Ou(t), t = c.next, a = c.next;
                continue
            }
            if (t = c, t === a) {
                o ? o === 1 ? (t = _he(ra(t), e, n), Pu(t, e, n, r, i, s, 2)) : o === 2 && bhe(t, e, n, r, i, s) : Pu(ra(t), e, n, r, i, s, 1);
                break
            }
        }
    }
}

function vhe(t) {
    var e = t.prev,
        n = t,
        r = t.next;
    if (xt(e, n, r) >= 0) return !1;
    for (var i = e.x, s = n.x, o = r.x, a = e.y, l = n.y, c = r.y, u = i < s ? i < o ? i : o : s < o ? s : o, d = a < l ? a < c ? a : c : l < c ? l : c, f = i > s ? i > o ? i : o : s > o ? s : o, h = a > l ? a > c ? a : c : l > c ? l : c, p = r.next; p !== e;) {
        if (p.x >= u && p.x <= f && p.y >= d && p.y <= h && ja(i, a, s, l, o, c, p.x, p.y) && xt(p.prev, p, p.next) >= 0) return !1;
        p = p.next
    }
    return !0
}

function yhe(t, e, n, r) {
    var i = t.prev,
        s = t,
        o = t.next;
    if (xt(i, s, o) >= 0) return !1;
    for (var a = i.x, l = s.x, c = o.x, u = i.y, d = s.y, f = o.y, h = a < l ? a < c ? a : c : l < c ? l : c, p = u < d ? u < f ? u : f : d < f ? d : f, b = a > l ? a > c ? a : c : l > c ? l : c, y = u > d ? u > f ? u : f : d > f ? d : f, m = A0(h, p, e, n, r), g = A0(b, y, e, n, r), v = t.prevZ, _ = t.nextZ; v && v.z >= m && _ && _.z <= g;) {
        if (v.x >= h && v.x <= b && v.y >= p && v.y <= y && v !== i && v !== o && ja(a, u, l, d, c, f, v.x, v.y) && xt(v.prev, v, v.next) >= 0 || (v = v.prevZ, _.x >= h && _.x <= b && _.y >= p && _.y <= y && _ !== i && _ !== o && ja(a, u, l, d, c, f, _.x, _.y) && xt(_.prev, _, _.next) >= 0)) return !1;
        _ = _.nextZ
    }
    for (; v && v.z >= m;) {
        if (v.x >= h && v.x <= b && v.y >= p && v.y <= y && v !== i && v !== o && ja(a, u, l, d, c, f, v.x, v.y) && xt(v.prev, v, v.next) >= 0) return !1;
        v = v.prevZ
    }
    for (; _ && _.z <= g;) {
        if (_.x >= h && _.x <= b && _.y >= p && _.y <= y && _ !== i && _ !== o && ja(a, u, l, d, c, f, _.x, _.y) && xt(_.prev, _, _.next) >= 0) return !1;
        _ = _.nextZ
    }
    return !0
}

function _he(t, e, n) {
    var r = t;
    do {
        var i = r.prev,
            s = r.next.next;
        !Qp(i, s) && ND(i, r, r.next, s) && Au(i, s) && Au(s, i) && (e.push(i.i / n | 0), e.push(r.i / n | 0), e.push(s.i / n | 0), Ou(r), Ou(r.next), r = t = s), r = r.next
    } while (r !== t);
    return ra(r)
}

function bhe(t, e, n, r, i, s) {
    var o = t;
    do {
        for (var a = o.next.next; a !== o.prev;) {
            if (o.i !== a.i && Ohe(o, a)) {
                var l = UD(o, a);
                o = ra(o, o.next), l = ra(l, l.next), Pu(o, e, n, r, i, s, 0), Pu(l, e, n, r, i, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== t)
}

function xhe(t, e, n, r) {
    var i = [],
        s, o, a, l, c;
    for (s = 0, o = e.length; s < o; s++) a = e[s] * r, l = s < o - 1 ? e[s + 1] * r : t.length, c = LD(t, a, l, r, !1), c === c.next && (c.steiner = !0), i.push(Ahe(c));
    for (i.sort(whe), s = 0; s < i.length; s++) n = Ehe(i[s], n);
    return n
}

function whe(t, e) {
    return t.x - e.x
}

function Ehe(t, e) {
    var n = She(t, e);
    if (!n) return e;
    var r = UD(n, t);
    return ra(r, r.next), ra(n, n.next)
}

function She(t, e) {
    var n = e,
        r = t.x,
        i = t.y,
        s = -1 / 0,
        o;
    do {
        if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
            var a = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
            if (a <= r && a > s && (s = a, o = n.x < n.next.x ? n : n.next, a === r)) return o
        }
        n = n.next
    } while (n !== e);
    if (!o) return null;
    var l = o,
        c = o.x,
        u = o.y,
        d = 1 / 0,
        f;
    n = o;
    do r >= n.x && n.x >= c && r !== n.x && ja(i < u ? r : s, i, c, u, i < u ? s : r, i, n.x, n.y) && (f = Math.abs(i - n.y) / (r - n.x), Au(n, t) && (f < d || f === d && (n.x > o.x || n.x === o.x && The(o, n))) && (o = n, d = f)), n = n.next; while (n !== l);
    return o
}

function The(t, e) {
    return xt(t.prev, t, e.prev) < 0 && xt(e.next, t, t.next) < 0
}

function Che(t, e, n, r) {
    var i = t;
    do i.z === 0 && (i.z = A0(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== t);
    i.prevZ.nextZ = null, i.prevZ = null, Phe(i)
}

function Phe(t) {
    var e, n, r, i, s, o, a, l, c = 1;
    do {
        for (n = t, t = null, s = null, o = 0; n;) {
            for (o++, r = n, a = 0, e = 0; e < c && (a++, r = r.nextZ, !!r); e++);
            for (l = c; a > 0 || l > 0 && r;) a !== 0 && (l === 0 || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;
            n = r
        }
        s.nextZ = null, c *= 2
    } while (o > 1);
    return t
}

function A0(t, e, n, r, i) {
    return t = (t - n) * i | 0, e = (e - r) * i | 0, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t | e << 1
}

function Ahe(t) {
    var e = t,
        n = t;
    do(e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next; while (e !== t);
    return n
}

function ja(t, e, n, r, i, s, o, a) {
    return (i - o) * (e - a) >= (t - o) * (s - a) && (t - o) * (r - a) >= (n - o) * (e - a) && (n - o) * (s - a) >= (i - o) * (r - a)
}

function Ohe(t, e) {
    return t.next.i !== e.i && t.prev.i !== e.i && !Ihe(t, e) && (Au(t, e) && Au(e, t) && Rhe(t, e) && (xt(t.prev, t, e.prev) || xt(t, e.prev, e)) || Qp(t, e) && xt(t.prev, t, t.next) > 0 && xt(e.prev, e, e.next) > 0)
}

function xt(t, e, n) {
    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
}

function Qp(t, e) {
    return t.x === e.x && t.y === e.y
}

function ND(t, e, n, r) {
    var i = lf(xt(t, e, n)),
        s = lf(xt(t, e, r)),
        o = lf(xt(n, r, t)),
        a = lf(xt(n, r, e));
    return !!(i !== s && o !== a || i === 0 && af(t, n, e) || s === 0 && af(t, r, e) || o === 0 && af(n, t, r) || a === 0 && af(n, e, r))
}

function af(t, e, n) {
    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
}

function lf(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0
}

function Ihe(t, e) {
    var n = t;
    do {
        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && ND(n, n.next, t, e)) return !0;
        n = n.next
    } while (n !== t);
    return !1
}

function Au(t, e) {
    return xt(t.prev, t, t.next) < 0 ? xt(t, e, t.next) >= 0 && xt(t, t.prev, e) >= 0 : xt(t, e, t.prev) < 0 || xt(t, t.next, e) < 0
}

function Rhe(t, e) {
    var n = t,
        r = !1,
        i = (t.x + e.x) / 2,
        s = (t.y + e.y) / 2;
    do n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next; while (n !== t);
    return r
}

function UD(t, e) {
    var n = new O0(t.i, t.x, t.y),
        r = new O0(e.i, e.x, e.y),
        i = t.next,
        s = e.prev;
    return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, s.next = r, r.prev = s, r
}

function PC(t, e, n, r) {
    var i = new O0(t, e, n);
    return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
}

function Ou(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
}

function O0(t, e, n) {
    this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
}
Zp.deviation = function(t, e, n, r) {
    var i = e && e.length,
        s = i ? e[0] * n : t.length,
        o = Math.abs(I0(t, 0, s, n));
    if (i)
        for (var a = 0, l = e.length; a < l; a++) {
            var c = e[a] * n,
                u = a < l - 1 ? e[a + 1] * n : t.length;
            o -= Math.abs(I0(t, c, u, n))
        }
    var d = 0;
    for (a = 0; a < r.length; a += 3) {
        var f = r[a] * n,
            h = r[a + 1] * n,
            p = r[a + 2] * n;
        d += Math.abs((t[f] - t[p]) * (t[h + 1] - t[f + 1]) - (t[f] - t[h]) * (t[p + 1] - t[f + 1]))
    }
    return o === 0 && d === 0 ? 0 : Math.abs((d - o) / o)
};

function I0(t, e, n, r) {
    for (var i = 0, s = e, o = n - r; s < n; s += r) i += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s;
    return i
}
Zp.flatten = function(t) {
    for (var e = t[0][0].length, n = {
            vertices: [],
            holes: [],
            dimensions: e
        }, r = 0, i = 0; i < t.length; i++) {
        for (var s = 0; s < t[i].length; s++)
            for (var o = 0; o < e; o++) n.vertices.push(t[i][s][o]);
        i > 0 && (r += t[i - 1].length, n.holes.push(r))
    }
    return n
};
var Mhe = Nx.exports;
const khe = ua(Mhe);
var jn = (t => (t[t.NONE = 0] = "NONE", t[t.COLOR = 16384] = "COLOR", t[t.STENCIL = 1024] = "STENCIL", t[t.DEPTH = 256] = "DEPTH", t[t.COLOR_DEPTH = 16640] = "COLOR_DEPTH", t[t.COLOR_STENCIL = 17408] = "COLOR_STENCIL", t[t.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", t[t.ALL = 17664] = "ALL", t))(jn || {});
class GD {
    constructor(e) {
        this.items = [], this._name = e
    }
    emit(e, n, r, i, s, o, a, l) {
        const {
            name: c,
            items: u
        } = this;
        for (let d = 0, f = u.length; d < f; d++) u[d][c](e, n, r, i, s, o, a, l);
        return this
    }
    add(e) {
        return e[this._name] && (this.remove(e), this.items.push(e)), this
    }
    remove(e) {
        const n = this.items.indexOf(e);
        return n !== -1 && this.items.splice(n, 1), this
    }
    contains(e) {
        return this.items.indexOf(e) !== -1
    }
    removeAll() {
        return this.items.length = 0, this
    }
    destroy() {
        this.removeAll(), this.items = null, this._name = null
    }
    get empty() {
        return this.items.length === 0
    }
    get name() {
        return this._name
    }
}
const Bhe = ["init", "destroy", "contextChange", "resolutionChange", "resetState", "renderEnd", "renderStart", "render", "update", "postrender", "prerender"],
    HD = class zD extends rr {
        constructor(e) {
            super(), this.runners = Object.create(null), this.renderPipes = Object.create(null), this._initOptions = {}, this._systemsHash = Object.create(null), this.type = e.type, this.name = e.name, this.config = e;
            const n = [...Bhe, ...this.config.runners ? ? []];
            this._addRunners(...n), this._unsafeEvalCheck()
        }
        async init(e = {}) {
            const n = e.skipExtensionImports === !0 ? !0 : e.manageImports === !1;
            await ghe(n), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
            for (const r in this._systemsHash) e = { ...this._systemsHash[r].constructor.defaultOptions,
                ...e
            };
            e = { ...zD.defaultOptions,
                ...e
            }, this._roundPixels = e.roundPixels ? 1 : 0;
            for (let r = 0; r < this.runners.init.items.length; r++) await this.runners.init.items[r].init(e);
            this._initOptions = e
        }
        render(e, n) {
            let r = e;
            if (r instanceof Zn && (r = {
                    container: r
                }, n && ($e(Ye, "passing a second argument is deprecated, please use render options instead"), r.target = n.renderTexture)), r.target || (r.target = this.view.renderTarget), r.target === this.view.renderTarget && (this._lastObjectRendered = r.container, r.clearColor ? ? (r.clearColor = this.background.colorRgba), r.clear ? ? (r.clear = this.background.clearBeforeRender)), r.clearColor) {
                const i = Array.isArray(r.clearColor) && r.clearColor.length === 4;
                r.clearColor = i ? r.clearColor : rt.shared.setValue(r.clearColor).toArray()
            }
            r.transform || (r.container.updateLocalTransform(), r.transform = r.container.localTransform), r.container.enableRenderGroup(), this.runners.prerender.emit(r), this.runners.renderStart.emit(r), this.runners.render.emit(r), this.runners.renderEnd.emit(r), this.runners.postrender.emit(r)
        }
        resize(e, n, r) {
            const i = this.view.resolution;
            this.view.resize(e, n, r), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), r !== void 0 && r !== i && this.runners.resolutionChange.emit(r)
        }
        clear(e = {}) {
            const n = this;
            e.target || (e.target = n.renderTarget.renderTarget), e.clearColor || (e.clearColor = this.background.colorRgba), e.clear ? ? (e.clear = jn.ALL);
            const {
                clear: r,
                clearColor: i,
                target: s
            } = e;
            rt.shared.setValue(i ? ? this.background.colorRgba), n.renderTarget.clear(s, r, rt.shared.toArray())
        }
        get resolution() {
            return this.view.resolution
        }
        set resolution(e) {
            this.view.resolution = e, this.runners.resolutionChange.emit(e)
        }
        get width() {
            return this.view.texture.frame.width
        }
        get height() {
            return this.view.texture.frame.height
        }
        get canvas() {
            return this.view.canvas
        }
        get lastObjectRendered() {
            return this._lastObjectRendered
        }
        get renderingToScreen() {
            return this.renderTarget.renderingToScreen
        }
        get screen() {
            return this.view.screen
        }
        _addRunners(...e) {
            e.forEach(n => {
                this.runners[n] = new GD(n)
            })
        }
        _addSystems(e) {
            let n;
            for (n in e) {
                const r = e[n];
                this._addSystem(r.value, r.name)
            }
        }
        _addSystem(e, n) {
            const r = new e(this);
            if (this[n]) throw new Error(`Whoops! The name "${n}" is already in use`);
            this[n] = r, this._systemsHash[n] = r;
            for (const i in this.runners) this.runners[i].add(r);
            return this
        }
        _addPipes(e, n) {
            const r = n.reduce((i, s) => (i[s.name] = s.value, i), {});
            e.forEach(i => {
                const s = i.value,
                    o = i.name,
                    a = r[o];
                this.renderPipes[o] = new s(this, a ? new a : null)
            })
        }
        destroy(e = !1) {
            this.runners.destroy.items.reverse(), this.runners.destroy.emit(e), Object.values(this.runners).forEach(n => {
                n.destroy()
            }), this._systemsHash = null, this.renderPipes = null
        }
        generateTexture(e) {
            return this.textureGenerator.generateTexture(e)
        }
        get roundPixels() {
            return !!this._roundPixels
        }
        _unsafeEvalCheck() {
            if (!FD()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")
        }
        resetState() {
            this.runners.resetState.emit()
        }
    };
HD.defaultOptions = {
    resolution: 1,
    failIfMajorPerformanceCaveat: !1,
    roundPixels: !1
};
let em = HD,
    cf;

function Dhe(t) {
    return cf !== void 0 || (cf = (() => {
        var n;
        const e = {
            stencil: !0,
            failIfMajorPerformanceCaveat: t ? ? em.defaultOptions.failIfMajorPerformanceCaveat
        };
        try {
            if (!He.get().getWebGLRenderingContext()) return !1;
            let i = He.get().createCanvas().getContext("webgl", e);
            const s = !!((n = i == null ? void 0 : i.getContextAttributes()) != null && n.stencil);
            if (i) {
                const o = i.getExtension("WEBGL_lose_context");
                o && o.loseContext()
            }
            return i = null, s
        } catch {
            return !1
        }
    })()), cf
}
let uf;
async function $he(t = {}) {
    return uf !== void 0 || (uf = await (async () => {
        const e = He.get().getNavigator().gpu;
        if (!e) return !1;
        try {
            return await (await e.requestAdapter(t)).requestDevice(), !0
        } catch {
            return !1
        }
    })()), uf
}
const AC = ["webgl", "webgpu", "canvas"];
async function Fhe(t) {
    let e = [];
    t.preference ? (e.push(t.preference), AC.forEach(s => {
        s !== t.preference && e.push(s)
    })) : e = AC.slice();
    let n, r = {};
    for (let s = 0; s < e.length; s++) {
        const o = e[s];
        if (o === "webgpu" && await $he()) {
            const {
                WebGPURenderer: a
            } = await Vf(() => Promise.resolve().then(() => Rye), void 0);
            n = a, r = { ...t,
                ...t.webgpu
            };
            break
        } else if (o === "webgl" && Dhe(t.failIfMajorPerformanceCaveat ? ? em.defaultOptions.failIfMajorPerformanceCaveat)) {
            const {
                WebGLRenderer: a
            } = await Vf(() => Promise.resolve().then(() => fye), void 0);
            n = a, r = { ...t,
                ...t.webgl
            };
            break
        } else if (o === "canvas") throw r = { ...t
        }, new Error("CanvasRenderer is not yet implemented")
    }
    if (delete r.webgpu, delete r.webgl, !n) throw new Error("No available renderer for the current environment");
    const i = new n;
    return await i.init(r), i
}
const Rh = "8.9.1";
class jD {
    static init() {
        var e;
        (e = globalThis.__PIXI_APP_INIT__) == null || e.call(globalThis, this, Rh)
    }
    static destroy() {}
}
jD.extension = G.Application;
class VD {
    constructor(e) {
        this._renderer = e
    }
    init() {
        var e;
        (e = globalThis.__PIXI_RENDERER_INIT__) == null || e.call(globalThis, this._renderer, Rh)
    }
    destroy() {
        this._renderer = null
    }
}
VD.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "initHook",
    priority: -10
};
const WD = class R0 {
    constructor(...e) {
        this.stage = new Zn, e[0] !== void 0 && $e(Ye, "Application constructor options are deprecated, please use Application.init() instead.")
    }
    async init(e) {
        e = { ...e
        }, this.renderer = await Fhe(e), R0._plugins.forEach(n => {
            n.init.call(this, e)
        })
    }
    render() {
        this.renderer.render({
            container: this.stage
        })
    }
    get canvas() {
        return this.renderer.canvas
    }
    get view() {
        return $e(Ye, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas
    }
    get screen() {
        return this.renderer.screen
    }
    destroy(e = !1, n = !1) {
        const r = R0._plugins.slice(0);
        r.reverse(), r.forEach(i => {
            i.destroy.call(this)
        }), this.stage.destroy(n), this.stage = null, this.renderer.destroy(e), this.renderer = null
    }
};
WD._plugins = [];
let Lhe = WD;
Ie.handleByList(G.Application, Lhe._plugins);
Ie.add(jD);
class YD {
    static init(e) {
        Object.defineProperty(this, "resizeTo", {
            set(n) {
                globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = n, n && (globalThis.addEventListener("resize", this.queueResize), this.resize())
            },
            get() {
                return this._resizeTo
            }
        }), this.queueResize = () => {
            this._resizeTo && (this._cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()))
        }, this._cancelResize = () => {
            this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null)
        }, this.resize = () => {
            if (!this._resizeTo) return;
            this._cancelResize();
            let n, r;
            if (this._resizeTo === globalThis.window) n = globalThis.innerWidth, r = globalThis.innerHeight;
            else {
                const {
                    clientWidth: i,
                    clientHeight: s
                } = this._resizeTo;
                n = i, r = s
            }
            this.renderer.resize(n, r), this.render()
        }, this._resizeId = null, this._resizeTo = null, this.resizeTo = e.resizeTo || null
    }
    static destroy() {
        globalThis.removeEventListener("resize", this.queueResize), this._cancelResize(), this._cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null
    }
}
YD.extension = G.Application;
class XD {
    static init(e) {
        e = Object.assign({
            autoStart: !0,
            sharedTicker: !1
        }, e), Object.defineProperty(this, "ticker", {
            set(n) {
                this._ticker && this._ticker.remove(this.render, this), this._ticker = n, n && n.add(this.render, this, Pl.LOW)
            },
            get() {
                return this._ticker
            }
        }), this.stop = () => {
            this._ticker.stop()
        }, this.start = () => {
            this._ticker.start()
        }, this._ticker = null, this.ticker = e.sharedTicker ? bn.shared : new bn, e.autoStart && this.start()
    }
    static destroy() {
        if (this._ticker) {
            const e = this._ticker;
            this.ticker = null, e.destroy()
        }
    }
}
XD.extension = G.Application;
class KD extends rr {
    constructor() {
        super(...arguments), this.chars = Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = {
            fontSize: 0,
            ascent: 0,
            descent: 0
        }, this.baseLineOffset = 0, this.distanceField = {
            type: "none",
            range: 0
        }, this.pages = [], this.applyFillAsTint = !0, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100
    }
    get font() {
        return $e(Ye, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily
    }
    get pageTextures() {
        return $e(Ye, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages
    }
    get size() {
        return $e(Ye, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize
    }
    get distanceFieldRange() {
        return $e(Ye, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range
    }
    get distanceFieldType() {
        return $e(Ye, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type
    }
    destroy(e = !1) {
        var n;
        this.emit("destroy", this), this.removeAllListeners();
        for (const r in this.chars)(n = this.chars[r].texture) == null || n.destroy();
        this.chars = null, e && (this.pages.forEach(r => r.texture.destroy(!0)), this.pages = null)
    }
}
const OC = [{
        offset: 0,
        color: "white"
    }, {
        offset: 1,
        color: "black"
    }],
    Ux = class M0 {
        constructor(...e) {
            this.uid = yt("fillGradient"), this.type = "linear", this.colorStops = [];
            let n = Nhe(e);
            n = { ...n.type === "radial" ? M0.defaultRadialOptions : M0.defaultLinearOptions,
                ...QB(n)
            }, this._textureSize = n.textureSize, n.type === "radial" ? (this.center = n.center, this.outerCenter = n.outerCenter ? ? this.center, this.innerRadius = n.innerRadius, this.outerRadius = n.outerRadius, this.scale = n.scale, this.rotation = n.rotation) : (this.start = n.start, this.end = n.end), this.textureSpace = n.textureSpace, this.type = n.type, n.colorStops.forEach(i => {
                this.addColorStop(i.offset, i.color)
            })
        }
        addColorStop(e, n) {
            return this.colorStops.push({
                offset: e,
                color: rt.shared.setValue(n).toHexa()
            }), this
        }
        buildLinearGradient() {
            if (this.texture) return;
            const e = this.colorStops.length ? this.colorStops : OC,
                n = this._textureSize,
                {
                    canvas: r,
                    context: i
                } = RC(n, 1),
                s = i.createLinearGradient(0, 0, this._textureSize, 0);
            IC(s, e), i.fillStyle = s, i.fillRect(0, 0, n, 1), this.texture = new we({
                source: new na({
                    resource: r
                })
            });
            const {
                x: o,
                y: a
            } = this.start, {
                x: l,
                y: c
            } = this.end, u = new Ce, d = l - o, f = c - a, h = Math.sqrt(d * d + f * f), p = Math.atan2(f, d);
            u.scale(h / n, 1), u.rotate(p), u.translate(o, a), this.textureSpace === "local" && u.scale(n, n), this.transform = u
        }
        buildGradient() {
            this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient()
        }
        buildRadialGradient() {
            if (this.texture) return;
            const e = this.colorStops.length ? this.colorStops : OC,
                n = this._textureSize,
                {
                    canvas: r,
                    context: i
                } = RC(n, n),
                {
                    x: s,
                    y: o
                } = this.center,
                {
                    x: a,
                    y: l
                } = this.outerCenter,
                c = this.innerRadius,
                u = this.outerRadius,
                d = a - u,
                f = l - u,
                h = n / (u * 2),
                p = (s - d) * h,
                b = (o - f) * h,
                y = i.createRadialGradient(p, b, c * h, (a - d) * h, (l - f) * h, u * h);
            IC(y, e), i.fillStyle = e[e.length - 1].color, i.fillRect(0, 0, n, n), i.fillStyle = y, i.translate(p, b), i.rotate(this.rotation), i.scale(1, this.scale), i.translate(-p, -b), i.fillRect(0, 0, n, n), this.texture = new we({
                source: new na({
                    resource: r,
                    addressModeU: "clamp-to-edge",
                    addressModeV: "clamp-to-edge"
                })
            });
            const m = new Ce;
            m.scale(1 / h, 1 / h), m.translate(d, f), this.textureSpace === "local" && m.scale(n, n), this.transform = m
        }
        get styleKey() {
            return this.uid
        }
        destroy() {
            var e;
            (e = this.texture) == null || e.destroy(!0), this.texture = null
        }
    };
Ux.defaultLinearOptions = {
    start: {
        x: 0,
        y: 0
    },
    end: {
        x: 0,
        y: 1
    },
    colorStops: [],
    textureSpace: "local",
    type: "linear",
    textureSize: 256
};
Ux.defaultRadialOptions = {
    center: {
        x: .5,
        y: .5
    },
    innerRadius: 0,
    outerRadius: .5,
    colorStops: [],
    scale: 1,
    textureSpace: "local",
    type: "radial",
    textureSize: 256
};
let Hs = Ux;

function IC(t, e) {
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        t.addColorStop(r.offset, r.color)
    }
}

function RC(t, e) {
    const n = He.get().createCanvas(t, e),
        r = n.getContext("2d");
    return {
        canvas: n,
        context: r
    }
}

function Nhe(t) {
    let e = t[0] ? ? {};
    return (typeof e == "number" || t[1]) && ($e("8.5.2", "use options object instead"), e = {
        type: "linear",
        start: {
            x: t[0],
            y: t[1]
        },
        end: {
            x: t[2],
            y: t[3]
        },
        textureSpace: t[4],
        textureSize: t[5] ? ? Hs.defaultLinearOptions.textureSize
    }), e
}
const MC = {
    repeat: {
        addressModeU: "repeat",
        addressModeV: "repeat"
    },
    "repeat-x": {
        addressModeU: "repeat",
        addressModeV: "clamp-to-edge"
    },
    "repeat-y": {
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
    },
    "no-repeat": {
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
    }
};
class tm {
    constructor(e, n) {
        this.uid = yt("fillPattern"), this.transform = new Ce, this._styleKey = null, this.texture = e, this.transform.scale(1 / e.frame.width, 1 / e.frame.height), n && (e.source.style.addressModeU = MC[n].addressModeU, e.source.style.addressModeV = MC[n].addressModeV)
    }
    setTransform(e) {
        const n = this.texture;
        this.transform.copyFrom(e), this.transform.invert(), this.transform.scale(1 / n.frame.width, 1 / n.frame.height), this._styleKey = null
    }
    get styleKey() {
        return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey)
    }
}
var Uhe = Hhe,
    lv = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0
    },
    Ghe = /([astvzqmhlc])([^astvzqmhlc]*)/ig;

function Hhe(t) {
    var e = [];
    return t.replace(Ghe, function(n, r, i) {
        var s = r.toLowerCase();
        for (i = jhe(i), s == "m" && i.length > 2 && (e.push([r].concat(i.splice(0, 2))), s = "l", r = r == "m" ? "l" : "L");;) {
            if (i.length == lv[s]) return i.unshift(r), e.push(i);
            if (i.length < lv[s]) throw new Error("malformed path data");
            e.push([r].concat(i.splice(0, lv[s])))
        }
    }), e
}
var zhe = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;

function jhe(t) {
    var e = t.match(zhe);
    return e ? e.map(Number) : []
}
const Vhe = ua(Uhe);

function Whe(t, e) {
    const n = Vhe(t),
        r = [];
    let i = null,
        s = 0,
        o = 0;
    for (let a = 0; a < n.length; a++) {
        const l = n[a],
            c = l[0],
            u = l;
        switch (c) {
            case "M":
                s = u[1], o = u[2], e.moveTo(s, o);
                break;
            case "m":
                s += u[1], o += u[2], e.moveTo(s, o);
                break;
            case "H":
                s = u[1], e.lineTo(s, o);
                break;
            case "h":
                s += u[1], e.lineTo(s, o);
                break;
            case "V":
                o = u[1], e.lineTo(s, o);
                break;
            case "v":
                o += u[1], e.lineTo(s, o);
                break;
            case "L":
                s = u[1], o = u[2], e.lineTo(s, o);
                break;
            case "l":
                s += u[1], o += u[2], e.lineTo(s, o);
                break;
            case "C":
                s = u[5], o = u[6], e.bezierCurveTo(u[1], u[2], u[3], u[4], s, o);
                break;
            case "c":
                e.bezierCurveTo(s + u[1], o + u[2], s + u[3], o + u[4], s + u[5], o + u[6]), s += u[5], o += u[6];
                break;
            case "S":
                s = u[3], o = u[4], e.bezierCurveToShort(u[1], u[2], s, o);
                break;
            case "s":
                e.bezierCurveToShort(s + u[1], o + u[2], s + u[3], o + u[4]), s += u[3], o += u[4];
                break;
            case "Q":
                s = u[3], o = u[4], e.quadraticCurveTo(u[1], u[2], s, o);
                break;
            case "q":
                e.quadraticCurveTo(s + u[1], o + u[2], s + u[3], o + u[4]), s += u[3], o += u[4];
                break;
            case "T":
                s = u[1], o = u[2], e.quadraticCurveToShort(s, o);
                break;
            case "t":
                s += u[1], o += u[2], e.quadraticCurveToShort(s, o);
                break;
            case "A":
                s = u[6], o = u[7], e.arcToSvg(u[1], u[2], u[3], u[4], u[5], s, o);
                break;
            case "a":
                s += u[6], o += u[7], e.arcToSvg(u[1], u[2], u[3], u[4], u[5], s, o);
                break;
            case "Z":
            case "z":
                e.closePath(), r.length > 0 && (i = r.pop(), i ? (s = i.startX, o = i.startY) : (s = 0, o = 0)), i = null;
                break;
            default:
                Me(`Unknown SVG path command: ${c}`)
        }
        c !== "Z" && c !== "z" && i === null && (i = {
            startX: s,
            startY: o
        }, r.push(i))
    }
    return e
}
class Gx {
    constructor(e = 0, n = 0, r = 0) {
        this.type = "circle", this.x = e, this.y = n, this.radius = r
    }
    clone() {
        return new Gx(this.x, this.y, this.radius)
    }
    contains(e, n) {
        if (this.radius <= 0) return !1;
        const r = this.radius * this.radius;
        let i = this.x - e,
            s = this.y - n;
        return i *= i, s *= s, i + s <= r
    }
    strokeContains(e, n, r, i = .5) {
        if (this.radius === 0) return !1;
        const s = this.x - e,
            o = this.y - n,
            a = this.radius,
            l = (1 - i) * r,
            c = Math.sqrt(s * s + o * o);
        return c <= a + l && c > a - (r - l)
    }
    getBounds(e) {
        return e || (e = new at), e.x = this.x - this.radius, e.y = this.y - this.radius, e.width = this.radius * 2, e.height = this.radius * 2, e
    }
    copyFrom(e) {
        return this.x = e.x, this.y = e.y, this.radius = e.radius, this
    }
    copyTo(e) {
        return e.copyFrom(this), e
    }
    toString() {
        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
    }
}
class Hx {
    constructor(e = 0, n = 0, r = 0, i = 0) {
        this.type = "ellipse", this.x = e, this.y = n, this.halfWidth = r, this.halfHeight = i
    }
    clone() {
        return new Hx(this.x, this.y, this.halfWidth, this.halfHeight)
    }
    contains(e, n) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1;
        let r = (e - this.x) / this.halfWidth,
            i = (n - this.y) / this.halfHeight;
        return r *= r, i *= i, r + i <= 1
    }
    strokeContains(e, n, r, i = .5) {
        const {
            halfWidth: s,
            halfHeight: o
        } = this;
        if (s <= 0 || o <= 0) return !1;
        const a = r * (1 - i),
            l = r - a,
            c = s - l,
            u = o - l,
            d = s + a,
            f = o + a,
            h = e - this.x,
            p = n - this.y,
            b = h * h / (c * c) + p * p / (u * u),
            y = h * h / (d * d) + p * p / (f * f);
        return b > 1 && y <= 1
    }
    getBounds(e) {
        return e || (e = new at), e.x = this.x - this.halfWidth, e.y = this.y - this.halfHeight, e.width = this.halfWidth * 2, e.height = this.halfHeight * 2, e
    }
    copyFrom(e) {
        return this.x = e.x, this.y = e.y, this.halfWidth = e.halfWidth, this.halfHeight = e.halfHeight, this
    }
    copyTo(e) {
        return e.copyFrom(this), e
    }
    toString() {
        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`
    }
}

function Yhe(t, e, n, r, i, s) {
    const o = t - n,
        a = e - r,
        l = i - n,
        c = s - r,
        u = o * l + a * c,
        d = l * l + c * c;
    let f = -1;
    d !== 0 && (f = u / d);
    let h, p;
    f < 0 ? (h = n, p = r) : f > 1 ? (h = i, p = s) : (h = n + f * l, p = r + f * c);
    const b = t - h,
        y = e - p;
    return b * b + y * y
}
let Xhe, Khe;
class Vc {
    constructor(...e) {
        this.type = "polygon";
        let n = Array.isArray(e[0]) ? e[0] : e;
        if (typeof n[0] != "number") {
            const r = [];
            for (let i = 0, s = n.length; i < s; i++) r.push(n[i].x, n[i].y);
            n = r
        }
        this.points = n, this.closePath = !0
    }
    isClockwise() {
        let e = 0;
        const n = this.points,
            r = n.length;
        for (let i = 0; i < r; i += 2) {
            const s = n[i],
                o = n[i + 1],
                a = n[(i + 2) % r],
                l = n[(i + 3) % r];
            e += (a - s) * (l + o)
        }
        return e < 0
    }
    containsPolygon(e) {
        const n = this.getBounds(Xhe),
            r = e.getBounds(Khe);
        if (!n.containsRect(r)) return !1;
        const i = e.points;
        for (let s = 0; s < i.length; s += 2) {
            const o = i[s],
                a = i[s + 1];
            if (!this.contains(o, a)) return !1
        }
        return !0
    }
    clone() {
        const e = this.points.slice(),
            n = new Vc(e);
        return n.closePath = this.closePath, n
    }
    contains(e, n) {
        let r = !1;
        const i = this.points.length / 2;
        for (let s = 0, o = i - 1; s < i; o = s++) {
            const a = this.points[s * 2],
                l = this.points[s * 2 + 1],
                c = this.points[o * 2],
                u = this.points[o * 2 + 1];
            l > n != u > n && e < (c - a) * ((n - l) / (u - l)) + a && (r = !r)
        }
        return r
    }
    strokeContains(e, n, r, i = .5) {
        const s = r * r,
            o = s * (1 - i),
            a = s - o,
            {
                points: l
            } = this,
            c = l.length - (this.closePath ? 0 : 2);
        for (let u = 0; u < c; u += 2) {
            const d = l[u],
                f = l[u + 1],
                h = l[(u + 2) % l.length],
                p = l[(u + 3) % l.length],
                b = Yhe(e, n, d, f, h, p),
                y = Math.sign((h - d) * (n - f) - (p - f) * (e - d));
            if (b <= (y < 0 ? a : o)) return !0
        }
        return !1
    }
    getBounds(e) {
        e || (e = new at);
        const n = this.points;
        let r = 1 / 0,
            i = -1 / 0,
            s = 1 / 0,
            o = -1 / 0;
        for (let a = 0, l = n.length; a < l; a += 2) {
            const c = n[a],
                u = n[a + 1];
            r = c < r ? c : r, i = c > i ? c : i, s = u < s ? u : s, o = u > o ? u : o
        }
        return e.x = r, e.width = i - r, e.y = s, e.height = o - s, e
    }
    copyFrom(e) {
        return this.points = e.points.slice(), this.closePath = e.closePath, this
    }
    copyTo(e) {
        return e.copyFrom(this), e
    }
    toString() {
        return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e,n)=>`${e}, ${n}`,"")}]`
    }
    get lastX() {
        return this.points[this.points.length - 2]
    }
    get lastY() {
        return this.points[this.points.length - 1]
    }
    get x() {
        return this.points[this.points.length - 2]
    }
    get y() {
        return this.points[this.points.length - 1]
    }
}
const df = (t, e, n, r, i, s, o) => {
    const a = t - n,
        l = e - r,
        c = Math.sqrt(a * a + l * l);
    return c >= i - s && c <= i + o
};
class zx {
    constructor(e = 0, n = 0, r = 0, i = 0, s = 20) {
        this.type = "roundedRectangle", this.x = e, this.y = n, this.width = r, this.height = i, this.radius = s
    }
    getBounds(e) {
        return e || (e = new at), e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e
    }
    clone() {
        return new zx(this.x, this.y, this.width, this.height, this.radius)
    }
    copyFrom(e) {
        return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this
    }
    copyTo(e) {
        return e.copyFrom(this), e
    }
    contains(e, n) {
        if (this.width <= 0 || this.height <= 0) return !1;
        if (e >= this.x && e <= this.x + this.width && n >= this.y && n <= this.y + this.height) {
            const r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (n >= this.y + r && n <= this.y + this.height - r || e >= this.x + r && e <= this.x + this.width - r) return !0;
            let i = e - (this.x + r),
                s = n - (this.y + r);
            const o = r * r;
            if (i * i + s * s <= o || (i = e - (this.x + this.width - r), i * i + s * s <= o) || (s = n - (this.y + this.height - r), i * i + s * s <= o) || (i = e - (this.x + r), i * i + s * s <= o)) return !0
        }
        return !1
    }
    strokeContains(e, n, r, i = .5) {
        const {
            x: s,
            y: o,
            width: a,
            height: l,
            radius: c
        } = this, u = r * (1 - i), d = r - u, f = s + c, h = o + c, p = a - c * 2, b = l - c * 2, y = s + a, m = o + l;
        return (e >= s - u && e <= s + d || e >= y - d && e <= y + u) && n >= h && n <= h + b || (n >= o - u && n <= o + d || n >= m - d && n <= m + u) && e >= f && e <= f + p ? !0 : e < f && n < h && df(e, n, f, h, c, d, u) || e > y - c && n < h && df(e, n, y - c, h, c, d, u) || e > y - c && n > m - c && df(e, n, y - c, m - c, c, d, u) || e < f && n > m - c && df(e, n, f, m - c, c, d, u)
    }
    toString() {
        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
    }
}
const qhe = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);

function Jhe(t) {
    let e = "";
    for (let n = 0; n < t; ++n) n > 0 && (e += `
else `), n < t - 1 && (e += `if(test == ${n}.0){}`);
    return e
}

function Zhe(t, e) {
    if (t === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const n = e.createShader(e.FRAGMENT_SHADER);
    try {
        for (;;) {
            const r = qhe.replace(/%forloop%/gi, Jhe(t));
            if (e.shaderSource(n, r), e.compileShader(n), !e.getShaderParameter(n, e.COMPILE_STATUS)) t = t / 2 | 0;
            else break
        }
    } finally {
        e.deleteShader(n)
    }
    return t
}
let Ba = null;

function zl() {
    var e;
    if (Ba) return Ba;
    const t = ID();
    return Ba = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), Ba = Zhe(Ba, t), (e = t.getExtension("WEBGL_lose_context")) == null || e.loseContext(), Ba
}
const qD = {};

function jx(t, e) {
    let n = 2166136261;
    for (let r = 0; r < e; r++) n ^= t[r].uid, n = Math.imul(n, 16777619), n >>>= 0;
    return qD[n] || Qhe(t, e, n)
}
let cv = 0;

function Qhe(t, e, n) {
    const r = {};
    let i = 0;
    cv || (cv = zl());
    for (let o = 0; o < cv; o++) {
        const a = o < e ? t[o] : we.EMPTY.source;
        r[i++] = a.source, r[i++] = a.style
    }
    const s = new Fi(r);
    return qD[n] = s, s
}
class Va {
    constructor(e) {
        typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength
    }
    get int8View() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
    }
    get uint8View() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
    }
    get int16View() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
    }
    get int32View() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
    }
    get float64View() {
        return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array
    }
    get bigUint64View() {
        return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array
    }
    view(e) {
        return this[`${e}View`]
    }
    destroy() {
        this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
    }
    static sizeOf(e) {
        switch (e) {
            case "int8":
            case "uint8":
                return 1;
            case "int16":
            case "uint16":
                return 2;
            case "int32":
            case "uint32":
            case "float32":
                return 4;
            default:
                throw new Error(`${e} isn't a valid view type`)
        }
    }
}

function k0(t, e) {
    const n = t.byteLength / 8 | 0,
        r = new Float64Array(t, 0, n);
    new Float64Array(e, 0, n).set(r);
    const s = t.byteLength - n * 8;
    if (s > 0) {
        const o = new Uint8Array(t, n * 8, s);
        new Uint8Array(e, n * 8, s).set(o)
    }
}
const epe = {
    normal: "normal-npm",
    add: "add-npm",
    screen: "screen-npm"
};
var Mt = (t => (t[t.DISABLED = 0] = "DISABLED", t[t.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", t[t.MASK_ACTIVE = 2] = "MASK_ACTIVE", t[t.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", t[t.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", t[t.NONE = 5] = "NONE", t))(Mt || {});

function Iu(t, e) {
    return e.alphaMode === "no-premultiply-alpha" && epe[t] || t
}
class tpe {
    constructor() {
        this.ids = Object.create(null), this.textures = [], this.count = 0
    }
    clear() {
        for (let e = 0; e < this.count; e++) {
            const n = this.textures[e];
            this.textures[e] = null, this.ids[n.uid] = null
        }
        this.count = 0
    }
}
class npe {
    constructor() {
        this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new tpe, this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = !0
    }
    destroy() {
        this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null
    }
}
const JD = [];
let B0 = 0;

function kC() {
    return B0 > 0 ? JD[--B0] : new npe
}

function BC(t) {
    JD[B0++] = t
}
let dc = 0;
const ZD = class Gf {
    constructor(e = {}) {
        this.uid = yt("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this._elements = [], Gf.defaultOptions.maxTextures = Gf.defaultOptions.maxTextures ? ? zl(), e = { ...Gf.defaultOptions,
            ...e
        };
        const {
            maxTextures: n,
            attributesInitialSize: r,
            indicesInitialSize: i
        } = e;
        this.attributeBuffer = new Va(r * 4), this.indexBuffer = new Uint16Array(i), this.maxTextures = n
    }
    begin() {
        this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
        for (let e = 0; e < this.batchIndex; e++) BC(this.batches[e]);
        this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = !0
    }
    add(e) {
        this._elements[this.elementSize++] = e, e._indexStart = this.indexSize, e._attributeStart = this.attributeSize, e._batcher = this, this.indexSize += e.indexSize, this.attributeSize += e.attributeSize * this.vertexSize
    }
    checkAndUpdateTexture(e, n) {
        const r = e._batch.textures.ids[n._source.uid];
        return !r && r !== 0 ? !1 : (e._textureId = r, e.texture = n, !0)
    }
    updateElement(e) {
        this.dirty = !0;
        const n = this.attributeBuffer;
        e.packAsQuad ? this.packQuadAttributes(e, n.float32View, n.uint32View, e._attributeStart, e._textureId) : this.packAttributes(e, n.float32View, n.uint32View, e._attributeStart, e._textureId)
    }
    break (e) {
        const n = this._elements;
        if (!n[this.elementStart]) return;
        let r = kC(),
            i = r.textures;
        i.clear();
        const s = n[this.elementStart];
        let o = Iu(s.blendMode, s.texture._source),
            a = s.topology;
        this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
        const l = this.attributeBuffer.float32View,
            c = this.attributeBuffer.uint32View,
            u = this.indexBuffer;
        let d = this._batchIndexSize,
            f = this._batchIndexStart,
            h = "startBatch";
        const p = this.maxTextures;
        for (let b = this.elementStart; b < this.elementSize; ++b) {
            const y = n[b];
            n[b] = null;
            const g = y.texture._source,
                v = Iu(y.blendMode, g),
                _ = o !== v || a !== y.topology;
            if (g._batchTick === dc && !_) {
                y._textureId = g._textureBindLocation, d += y.indexSize, y.packAsQuad ? (this.packQuadAttributes(y, l, c, y._attributeStart, y._textureId), this.packQuadIndex(u, y._indexStart, y._attributeStart / this.vertexSize)) : (this.packAttributes(y, l, c, y._attributeStart, y._textureId), this.packIndex(y, u, y._indexStart, y._attributeStart / this.vertexSize)), y._batch = r;
                continue
            }
            g._batchTick = dc, (i.count >= p || _) && (this._finishBatch(r, f, d - f, i, o, a, e, h), h = "renderBatch", f = d, o = v, a = y.topology, r = kC(), i = r.textures, i.clear(), ++dc), y._textureId = g._textureBindLocation = i.count, i.ids[g.uid] = i.count, i.textures[i.count++] = g, y._batch = r, d += y.indexSize, y.packAsQuad ? (this.packQuadAttributes(y, l, c, y._attributeStart, y._textureId), this.packQuadIndex(u, y._indexStart, y._attributeStart / this.vertexSize)) : (this.packAttributes(y, l, c, y._attributeStart, y._textureId), this.packIndex(y, u, y._indexStart, y._attributeStart / this.vertexSize))
        }
        i.count > 0 && (this._finishBatch(r, f, d - f, i, o, a, e, h), f = d, ++dc), this.elementStart = this.elementSize, this._batchIndexStart = f, this._batchIndexSize = d
    }
    _finishBatch(e, n, r, i, s, o, a, l) {
        e.gpuBindGroup = null, e.bindGroup = null, e.action = l, e.batcher = this, e.textures = i, e.blendMode = s, e.topology = o, e.start = n, e.size = r, ++dc, this.batches[this.batchIndex++] = e, a.add(e)
    }
    finish(e) {
        this.break(e)
    }
    ensureAttributeBuffer(e) {
        e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4)
    }
    ensureIndexBuffer(e) {
        e <= this.indexBuffer.length || this._resizeIndexBuffer(e)
    }
    _resizeAttributeBuffer(e) {
        const n = Math.max(e, this.attributeBuffer.size * 2),
            r = new Va(n);
        k0(this.attributeBuffer.rawBinaryData, r.rawBinaryData), this.attributeBuffer = r
    }
    _resizeIndexBuffer(e) {
        const n = this.indexBuffer;
        let r = Math.max(e, n.length * 1.5);
        r += r % 2;
        const i = r > 65535 ? new Uint32Array(r) : new Uint16Array(r);
        if (i.BYTES_PER_ELEMENT !== n.BYTES_PER_ELEMENT)
            for (let s = 0; s < n.length; s++) i[s] = n[s];
        else k0(n.buffer, i.buffer);
        this.indexBuffer = i
    }
    packQuadIndex(e, n, r) {
        e[n] = r + 0, e[n + 1] = r + 1, e[n + 2] = r + 2, e[n + 3] = r + 0, e[n + 4] = r + 2, e[n + 5] = r + 3
    }
    packIndex(e, n, r, i) {
        const s = e.indices,
            o = e.indexSize,
            a = e.indexOffset,
            l = e.attributeOffset;
        for (let c = 0; c < o; c++) n[r++] = i + s[c + a] - l
    }
    destroy() {
        for (let e = 0; e < this.batches.length; e++) BC(this.batches[e]);
        this.batches = null;
        for (let e = 0; e < this._elements.length; e++) this._elements[e]._batch = null;
        this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null
    }
};
ZD.defaultOptions = {
    maxTextures: null,
    attributesInitialSize: 4,
    indicesInitialSize: 6
};
let rpe = ZD;
var Xe = (t => (t[t.MAP_READ = 1] = "MAP_READ", t[t.MAP_WRITE = 2] = "MAP_WRITE", t[t.COPY_SRC = 4] = "COPY_SRC", t[t.COPY_DST = 8] = "COPY_DST", t[t.INDEX = 16] = "INDEX", t[t.VERTEX = 32] = "VERTEX", t[t.UNIFORM = 64] = "UNIFORM", t[t.STORAGE = 128] = "STORAGE", t[t.INDIRECT = 256] = "INDIRECT", t[t.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", t[t.STATIC = 1024] = "STATIC", t))(Xe || {});
let qn = class extends rr {
    constructor(e) {
        let {
            data: n,
            size: r
        } = e;
        const {
            usage: i,
            label: s,
            shrinkToFit: o
        } = e;
        super(), this.uid = yt("buffer"), this._resourceType = "buffer", this._resourceId = yt("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = !0, this.destroyed = !1, n instanceof Array && (n = new Float32Array(n)), this._data = n, r ? ? (r = n == null ? void 0 : n.byteLength);
        const a = !!n;
        this.descriptor = {
            size: r,
            usage: i,
            mappedAtCreation: a,
            label: s
        }, this.shrinkToFit = o ? ? !0
    }
    get data() {
        return this._data
    }
    set data(e) {
        this.setDataWithSize(e, e.length, !0)
    }
    get dataInt32() {
        return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32
    }
    get static() {
        return !!(this.descriptor.usage & Xe.STATIC)
    }
    set static(e) {
        e ? this.descriptor.usage |= Xe.STATIC : this.descriptor.usage &= ~Xe.STATIC
    }
    setDataWithSize(e, n, r) {
        if (this._updateID++, this._updateSize = n * e.BYTES_PER_ELEMENT, this._data === e) {
            r && this.emit("update", this);
            return
        }
        const i = this._data;
        if (this._data = e, this._dataInt32 = null, !i || i.length !== e.length) {
            !this.shrinkToFit && i && e.byteLength < i.byteLength ? r && this.emit("update", this) : (this.descriptor.size = e.byteLength, this._resourceId = yt("resource"), this.emit("change", this));
            return
        }
        r && this.emit("update", this)
    }
    update(e) {
        this._updateSize = e ? ? this._updateSize, this._updateID++, this.emit("update", this)
    }
    destroy() {
        this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners()
    }
};

function QD(t, e) {
    if (!(t instanceof qn)) {
        let n = e ? Xe.INDEX : Xe.VERTEX;
        t instanceof Array && (e ? (t = new Uint32Array(t), n = Xe.INDEX | Xe.COPY_DST) : (t = new Float32Array(t), n = Xe.VERTEX | Xe.COPY_DST)), t = new qn({
            data: t,
            label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
            usage: n
        })
    }
    return t
}

function ipe(t, e, n) {
    const r = t.getAttribute(e);
    if (!r) return n.minX = 0, n.minY = 0, n.maxX = 0, n.maxY = 0, n;
    const i = r.buffer.data;
    let s = 1 / 0,
        o = 1 / 0,
        a = -1 / 0,
        l = -1 / 0;
    const c = i.BYTES_PER_ELEMENT,
        u = (r.offset || 0) / c,
        d = (r.stride || 2 * 4) / c;
    for (let f = u; f < i.length; f += d) {
        const h = i[f],
            p = i[f + 1];
        h > a && (a = h), p > l && (l = p), h < s && (s = h), p < o && (o = p)
    }
    return n.minX = s, n.minY = o, n.maxX = a, n.maxY = l, n
}

function spe(t) {
    return (t instanceof qn || Array.isArray(t) || t.BYTES_PER_ELEMENT) && (t = {
        buffer: t
    }), t.buffer = QD(t.buffer, !1), t
}
class ud extends rr {
    constructor(e = {}) {
        super(), this.uid = yt("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new rn, this._boundsDirty = !0;
        const {
            attributes: n,
            indexBuffer: r,
            topology: i
        } = e;
        if (this.buffers = [], this.attributes = {}, n)
            for (const s in n) this.addAttribute(s, n[s]);
        this.instanceCount = e.instanceCount ? ? 1, r && this.addIndex(r), this.topology = i || "triangle-list"
    }
    onBufferUpdate() {
        this._boundsDirty = !0, this.emit("update", this)
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    getIndex() {
        return this.indexBuffer
    }
    getBuffer(e) {
        return this.getAttribute(e).buffer
    }
    getSize() {
        for (const e in this.attributes) {
            const n = this.attributes[e];
            return n.buffer.data.length / (n.stride / 4 || n.size)
        }
        return 0
    }
    addAttribute(e, n) {
        const r = spe(n);
        this.buffers.indexOf(r.buffer) === -1 && (this.buffers.push(r.buffer), r.buffer.on("update", this.onBufferUpdate, this), r.buffer.on("change", this.onBufferUpdate, this)), this.attributes[e] = r
    }
    addIndex(e) {
        this.indexBuffer = QD(e, !0), this.buffers.push(this.indexBuffer)
    }
    get bounds() {
        return this._boundsDirty ? (this._boundsDirty = !1, ipe(this, "aPosition", this._bounds)) : this._bounds
    }
    destroy(e = !1) {
        this.emit("destroy", this), this.removeAllListeners(), e && this.buffers.forEach(n => n.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null
    }
}
const ope = new Float32Array(1),
    ape = new Uint32Array(1);
class lpe extends ud {
    constructor() {
        const n = new qn({
                data: ope,
                label: "attribute-batch-buffer",
                usage: Xe.VERTEX | Xe.COPY_DST,
                shrinkToFit: !1
            }),
            r = new qn({
                data: ape,
                label: "index-batch-buffer",
                usage: Xe.INDEX | Xe.COPY_DST,
                shrinkToFit: !1
            }),
            i = 6 * 4;
        super({
            attributes: {
                aPosition: {
                    buffer: n,
                    format: "float32x2",
                    stride: i,
                    offset: 0
                },
                aUV: {
                    buffer: n,
                    format: "float32x2",
                    stride: i,
                    offset: 2 * 4
                },
                aColor: {
                    buffer: n,
                    format: "unorm8x4",
                    stride: i,
                    offset: 4 * 4
                },
                aTextureIdAndRound: {
                    buffer: n,
                    format: "uint16x2",
                    stride: i,
                    offset: 5 * 4
                }
            },
            indexBuffer: r
        })
    }
}

function DC(t, e, n) {
    if (t)
        for (const r in t) {
            const i = r.toLocaleLowerCase(),
                s = e[i];
            if (s) {
                let o = t[r];
                r === "header" && (o = o.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), n && s.push(`//----${n}----//`), s.push(o)
            } else Me(`${r} placement hook does not exist in shader`)
        }
}
const cpe = /\{\{(.*?)\}\}/g;

function $C(t) {
    var r;
    const e = {};
    return (((r = t.match(cpe)) == null ? void 0 : r.map(i => i.replace(/[{()}]/g, ""))) ? ? []).forEach(i => {
        e[i] = []
    }), e
}

function FC(t, e) {
    let n;
    const r = /@in\s+([^;]+);/g;
    for (;
        (n = r.exec(t)) !== null;) e.push(n[1])
}

function LC(t, e, n = !1) {
    const r = [];
    FC(e, r), t.forEach(a => {
        a.header && FC(a.header, r)
    });
    const i = r;
    n && i.sort();
    const s = i.map((a, l) => `       @location(${l}) ${a},`).join(`
`);
    let o = e.replace(/@in\s+[^;]+;\s*/g, "");
    return o = o.replace("{{in}}", `
${s}
`), o
}

function NC(t, e) {
    let n;
    const r = /@out\s+([^;]+);/g;
    for (;
        (n = r.exec(t)) !== null;) e.push(n[1])
}

function upe(t) {
    const n = /\b(\w+)\s*:/g.exec(t);
    return n ? n[1] : ""
}

function dpe(t) {
    const e = /@.*?\s+/g;
    return t.replace(e, "")
}

function fpe(t, e) {
    const n = [];
    NC(e, n), t.forEach(l => {
        l.header && NC(l.header, n)
    });
    let r = 0;
    const i = n.sort().map(l => l.indexOf("builtin") > -1 ? l : `@location(${r++}) ${l}`).join(`,
`),
        s = n.sort().map(l => `       var ${dpe(l)};`).join(`
`),
        o = `return VSOutput(
            ${n.sort().map(l=>` ${upe(l)}`).join(`,
`)});`;
    let a = e.replace(/@out\s+[^;]+;\s*/g, "");
    return a = a.replace("{{struct}}", `
${i}
`), a = a.replace("{{start}}", `
${s}
`), a = a.replace("{{return}}", `
${o}
`), a
}

function UC(t, e) {
    let n = t;
    for (const r in e) {
        const i = e[r];
        i.join(`
`).length ? n = n.replace(`{{${r}}}`, `//-----${r} START-----//
${i.join(`
`)}
//----${r} FINISH----//`) : n = n.replace(`{{${r}}}`, "")
    }
    return n
}
const ws = Object.create(null),
    uv = new Map;
let hpe = 0;

function ppe({
    template: t,
    bits: e
}) {
    const n = e$(t, e);
    if (ws[n]) return ws[n];
    const {
        vertex: r,
        fragment: i
    } = gpe(t, e);
    return ws[n] = t$(r, i, e), ws[n]
}

function mpe({
    template: t,
    bits: e
}) {
    const n = e$(t, e);
    return ws[n] || (ws[n] = t$(t.vertex, t.fragment, e)), ws[n]
}

function gpe(t, e) {
    const n = e.map(o => o.vertex).filter(o => !!o),
        r = e.map(o => o.fragment).filter(o => !!o);
    let i = LC(n, t.vertex, !0);
    i = fpe(n, i);
    const s = LC(r, t.fragment, !0);
    return {
        vertex: i,
        fragment: s
    }
}

function e$(t, e) {
    return e.map(n => (uv.has(n) || uv.set(n, hpe++), uv.get(n))).sort((n, r) => n - r).join("-") + t.vertex + t.fragment
}

function t$(t, e, n) {
    const r = $C(t),
        i = $C(e);
    return n.forEach(s => {
        DC(s.vertex, r, s.name), DC(s.fragment, i, s.name)
    }), {
        vertex: UC(t, r),
        fragment: UC(e, i)
    }
}
const vpe = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`,
    ype = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`,
    _pe = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`,
    bpe = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`,
    xpe = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        }
    },
    wpe = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
        }
    };

function dd({
    bits: t,
    name: e
}) {
    const n = ppe({
        template: {
            fragment: ype,
            vertex: vpe
        },
        bits: [xpe, ...t]
    });
    return Qs.from({
        name: e,
        vertex: {
            source: n.vertex,
            entryPoint: "main"
        },
        fragment: {
            source: n.fragment,
            entryPoint: "main"
        }
    })
}

function fd({
    bits: t,
    name: e
}) {
    return new ga({
        name: e,
        ...mpe({
            template: {
                vertex: _pe,
                fragment: bpe
            },
            bits: [wpe, ...t]
        })
    })
}
const Vx = {
        name: "color-bit",
        vertex: {
            header: `
            @in aColor: vec4<f32>;
        `,
            main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        }
    },
    Wx = {
        name: "color-bit",
        vertex: {
            header: `
            in vec4 aColor;
        `,
            main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        }
    },
    dv = {};

function Epe(t) {
    const e = [];
    if (t === 1) e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), e.push("@group(1) @binding(1) var textureSampler1: sampler;");
    else {
        let n = 0;
        for (let r = 0; r < t; r++) e.push(`@group(1) @binding(${n++}) var textureSource${r+1}: texture_2d<f32>;`), e.push(`@group(1) @binding(${n++}) var textureSampler${r+1}: sampler;`)
    }
    return e.join(`
`)
}

function Spe(t) {
    const e = [];
    if (t === 1) e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    else {
        e.push("switch vTextureId {");
        for (let n = 0; n < t; n++) n === t - 1 ? e.push("  default:{") : e.push(`  case ${n}:{`), e.push(`      outColor = textureSampleGrad(textureSource${n+1}, textureSampler${n+1}, vUV, uvDx, uvDy);`), e.push("      break;}");
        e.push("}")
    }
    return e.join(`
`)
}

function Yx(t) {
    return dv[t] || (dv[t] = {
        name: "texture-batch-bit",
        vertex: {
            header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
            main: `
                vTextureId = aTextureIdAndRound.y;
            `,
            end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
        },
        fragment: {
            header: `
                @in @interpolate(flat) vTextureId: u32;

                ${Epe(t)}
            `,
            main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${Spe(t)}
            `
        }
    }), dv[t]
}
const fv = {};

function Tpe(t) {
    const e = [];
    for (let n = 0; n < t; n++) n > 0 && e.push("else"), n < t - 1 && e.push(`if(vTextureId < ${n}.5)`), e.push("{"), e.push(`	outColor = texture(uTextures[${n}], vUV);`), e.push("}");
    return e.join(`
`)
}

function Xx(t) {
    return fv[t] || (fv[t] = {
        name: "texture-batch-bit",
        vertex: {
            header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
            main: `
                vTextureId = aTextureIdAndRound.y;
            `,
            end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
        },
        fragment: {
            header: `
                in float vTextureId;

                uniform sampler2D uTextures[${t}];

            `,
            main: `

                ${Tpe(t)}
            `
        }
    }), fv[t]
}
const hd = {
        name: "round-pixels-bit",
        vertex: {
            header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    },
    pd = {
        name: "round-pixels-bit",
        vertex: {
            header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    },
    GC = {};

function Kx(t) {
    let e = GC[t];
    if (e) return e;
    const n = new Int32Array(t);
    for (let r = 0; r < t; r++) n[r] = r;
    return e = GC[t] = new Cn({
        uTextures: {
            value: n,
            type: "i32",
            size: t
        }
    }, {
        isStatic: !0
    }), e
}
class Cpe extends pr {
    constructor(e) {
        const n = fd({
                name: "batch",
                bits: [Wx, Xx(e), pd]
            }),
            r = dd({
                name: "batch",
                bits: [Vx, Yx(e), hd]
            });
        super({
            glProgram: n,
            gpuProgram: r,
            resources: {
                batchSamplers: Kx(e)
            }
        })
    }
}
let HC = null;
const n$ = class r$ extends rpe {
    constructor() {
        super(...arguments), this.geometry = new lpe, this.shader = HC || (HC = new Cpe(this.maxTextures)), this.name = r$.extension.name, this.vertexSize = 6
    }
    packAttributes(e, n, r, i, s) {
        const o = s << 16 | e.roundPixels & 65535,
            a = e.transform,
            l = a.a,
            c = a.b,
            u = a.c,
            d = a.d,
            f = a.tx,
            h = a.ty,
            {
                positions: p,
                uvs: b
            } = e,
            y = e.color,
            m = e.attributeOffset,
            g = m + e.attributeSize;
        for (let v = m; v < g; v++) {
            const _ = v * 2,
                x = p[_],
                w = p[_ + 1];
            n[i++] = l * x + u * w + f, n[i++] = d * w + c * x + h, n[i++] = b[_], n[i++] = b[_ + 1], r[i++] = y, r[i++] = o
        }
    }
    packQuadAttributes(e, n, r, i, s) {
        const o = e.texture,
            a = e.transform,
            l = a.a,
            c = a.b,
            u = a.c,
            d = a.d,
            f = a.tx,
            h = a.ty,
            p = e.bounds,
            b = p.maxX,
            y = p.minX,
            m = p.maxY,
            g = p.minY,
            v = o.uvs,
            _ = e.color,
            x = s << 16 | e.roundPixels & 65535;
        n[i + 0] = l * y + u * g + f, n[i + 1] = d * g + c * y + h, n[i + 2] = v.x0, n[i + 3] = v.y0, r[i + 4] = _, r[i + 5] = x, n[i + 6] = l * b + u * g + f, n[i + 7] = d * g + c * b + h, n[i + 8] = v.x1, n[i + 9] = v.y1, r[i + 10] = _, r[i + 11] = x, n[i + 12] = l * b + u * m + f, n[i + 13] = d * m + c * b + h, n[i + 14] = v.x2, n[i + 15] = v.y2, r[i + 16] = _, r[i + 17] = x, n[i + 18] = l * y + u * m + f, n[i + 19] = d * m + c * y + h, n[i + 20] = v.x3, n[i + 21] = v.y3, r[i + 22] = _, r[i + 23] = x
    }
};
n$.extension = {
    type: [G.Batcher],
    name: "default"
};
let qx = n$;

function Ppe(t, e, n, r, i, s, o, a = null) {
    let l = 0;
    n *= e, i *= s;
    const c = a.a,
        u = a.b,
        d = a.c,
        f = a.d,
        h = a.tx,
        p = a.ty;
    for (; l < o;) {
        const b = t[n],
            y = t[n + 1];
        r[i] = c * b + d * y + h, r[i + 1] = u * b + f * y + p, i += s, n += e, l++
    }
}

function Ape(t, e, n, r) {
    let i = 0;
    for (e *= n; i < r;) t[e] = 0, t[e + 1] = 0, e += n, i++
}

function i$(t, e, n, r, i) {
    const s = e.a,
        o = e.b,
        a = e.c,
        l = e.d,
        c = e.tx,
        u = e.ty;
    n || (n = 0), r || (r = 2), i || (i = t.length / r - n);
    let d = n * r;
    for (let f = 0; f < i; f++) {
        const h = t[d],
            p = t[d + 1];
        t[d] = s * h + a * p + c, t[d + 1] = o * h + l * p + u, d += r
    }
}
const Ope = new Ce;
class Jx {
    constructor() {
        this.packAsQuad = !1, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = !0, this.roundPixels = 0, this._batcher = null, this._batch = null
    }
    get uvs() {
        return this.geometryData.uvs
    }
    get positions() {
        return this.geometryData.vertices
    }
    get indices() {
        return this.geometryData.indices
    }
    get blendMode() {
        return this.applyTransform ? this.renderable.groupBlendMode : "normal"
    }
    get color() {
        const e = this.baseColor,
            n = e >> 16 | e & 65280 | (e & 255) << 16,
            r = this.renderable;
        return r ? fD(n, r.groupColor) + (this.alpha * r.groupAlpha * 255 << 24) : n + (this.alpha * 255 << 24)
    }
    get transform() {
        var e;
        return ((e = this.renderable) == null ? void 0 : e.groupTransform) || Ope
    }
    copyTo(e) {
        e.indexOffset = this.indexOffset, e.indexSize = this.indexSize, e.attributeOffset = this.attributeOffset, e.attributeSize = this.attributeSize, e.baseColor = this.baseColor, e.alpha = this.alpha, e.texture = this.texture, e.geometryData = this.geometryData, e.topology = this.topology
    }
    reset() {
        this.applyTransform = !0, this.renderable = null, this.topology = "triangle-list"
    }
}
const Ru = {
        extension: {
            type: G.ShapeBuilder,
            name: "circle"
        },
        build(t, e) {
            let n, r, i, s, o, a;
            if (t.type === "circle") {
                const _ = t;
                n = _.x, r = _.y, o = a = _.radius, i = s = 0
            } else if (t.type === "ellipse") {
                const _ = t;
                n = _.x, r = _.y, o = _.halfWidth, a = _.halfHeight, i = s = 0
            } else {
                const _ = t,
                    x = _.width / 2,
                    w = _.height / 2;
                n = _.x + x, r = _.y + w, o = a = Math.max(0, Math.min(_.radius, Math.min(x, w))), i = x - o, s = w - a
            }
            if (!(o >= 0 && a >= 0 && i >= 0 && s >= 0)) return e;
            const l = Math.ceil(2.3 * Math.sqrt(o + a)),
                c = l * 8 + (i ? 4 : 0) + (s ? 4 : 0);
            if (c === 0) return e;
            if (l === 0) return e[0] = e[6] = n + i, e[1] = e[3] = r + s, e[2] = e[4] = n - i, e[5] = e[7] = r - s, e;
            let u = 0,
                d = l * 4 + (i ? 2 : 0) + 2,
                f = d,
                h = c,
                p = i + o,
                b = s,
                y = n + p,
                m = n - p,
                g = r + b;
            if (e[u++] = y, e[u++] = g, e[--d] = g, e[--d] = m, s) {
                const _ = r - b;
                e[f++] = m, e[f++] = _, e[--h] = _, e[--h] = y
            }
            for (let _ = 1; _ < l; _++) {
                const x = Math.PI / 2 * (_ / l),
                    w = i + Math.cos(x) * o,
                    S = s + Math.sin(x) * a,
                    C = n + w,
                    A = n - w,
                    T = r + S,
                    E = r - S;
                e[u++] = C, e[u++] = T, e[--d] = T, e[--d] = A, e[f++] = A, e[f++] = E, e[--h] = E, e[--h] = C
            }
            p = i, b = s + a, y = n + p, m = n - p, g = r + b;
            const v = r - b;
            return e[u++] = y, e[u++] = g, e[--h] = v, e[--h] = y, i && (e[u++] = m, e[u++] = g, e[--h] = v, e[--h] = m), e
        },
        triangulate(t, e, n, r, i, s) {
            if (t.length === 0) return;
            let o = 0,
                a = 0;
            for (let u = 0; u < t.length; u += 2) o += t[u], a += t[u + 1];
            o /= t.length / 2, a /= t.length / 2;
            let l = r;
            e[l * n] = o, e[l * n + 1] = a;
            const c = l++;
            for (let u = 0; u < t.length; u += 2) e[l * n] = t[u], e[l * n + 1] = t[u + 1], u > 0 && (i[s++] = l, i[s++] = c, i[s++] = l - 1), l++;
            i[s++] = c + 1, i[s++] = c, i[s++] = l - 1
        }
    },
    Ipe = { ...Ru,
        extension: { ...Ru.extension,
            name: "ellipse"
        }
    },
    Rpe = { ...Ru,
        extension: { ...Ru.extension,
            name: "roundedRectangle"
        }
    },
    s$ = 1e-4,
    zC = 1e-4;

function Mpe(t) {
    const e = t.length;
    if (e < 6) return 1;
    let n = 0;
    for (let r = 0, i = t[e - 2], s = t[e - 1]; r < e; r += 2) {
        const o = t[r],
            a = t[r + 1];
        n += (o - i) * (a + s), i = o, s = a
    }
    return n < 0 ? -1 : 1
}

function jC(t, e, n, r, i, s, o, a) {
    const l = t - n * i,
        c = e - r * i,
        u = t + n * s,
        d = e + r * s;
    let f, h;
    o ? (f = r, h = -n) : (f = -r, h = n);
    const p = l + f,
        b = c + h,
        y = u + f,
        m = d + h;
    return a.push(p, b), a.push(y, m), 2
}

function ao(t, e, n, r, i, s, o, a) {
    const l = n - t,
        c = r - e;
    let u = Math.atan2(l, c),
        d = Math.atan2(i - t, s - e);
    a && u < d ? u += Math.PI * 2 : !a && u > d && (d += Math.PI * 2);
    let f = u;
    const h = d - u,
        p = Math.abs(h),
        b = Math.sqrt(l * l + c * c),
        y = (15 * p * Math.sqrt(b) / Math.PI >> 0) + 1,
        m = h / y;
    if (f += m, a) {
        o.push(t, e), o.push(n, r);
        for (let g = 1, v = f; g < y; g++, v += m) o.push(t, e), o.push(t + Math.sin(v) * b, e + Math.cos(v) * b);
        o.push(t, e), o.push(i, s)
    } else {
        o.push(n, r), o.push(t, e);
        for (let g = 1, v = f; g < y; g++, v += m) o.push(t + Math.sin(v) * b, e + Math.cos(v) * b), o.push(t, e);
        o.push(i, s), o.push(t, e)
    }
    return y * 2
}

function kpe(t, e, n, r, i, s) {
    const o = s$;
    if (t.length === 0) return;
    const a = e;
    let l = a.alignment;
    if (e.alignment !== .5) {
        let Y = Mpe(t);
        n && (Y *= -1), l = (l - .5) * Y + .5
    }
    const c = new ct(t[0], t[1]),
        u = new ct(t[t.length - 2], t[t.length - 1]),
        d = r,
        f = Math.abs(c.x - u.x) < o && Math.abs(c.y - u.y) < o;
    if (d) {
        t = t.slice(), f && (t.pop(), t.pop(), u.set(t[t.length - 2], t[t.length - 1]));
        const Y = (c.x + u.x) * .5,
            le = (u.y + c.y) * .5;
        t.unshift(Y, le), t.push(Y, le)
    }
    const h = i,
        p = t.length / 2;
    let b = t.length;
    const y = h.length / 2,
        m = a.width / 2,
        g = m * m,
        v = a.miterLimit * a.miterLimit;
    let _ = t[0],
        x = t[1],
        w = t[2],
        S = t[3],
        C = 0,
        A = 0,
        T = -(x - S),
        E = _ - w,
        P = 0,
        B = 0,
        F = Math.sqrt(T * T + E * E);
    T /= F, E /= F, T *= m, E *= m;
    const H = l,
        k = (1 - H) * 2,
        N = H * 2;
    d || (a.cap === "round" ? b += ao(_ - T * (k - N) * .5, x - E * (k - N) * .5, _ - T * k, x - E * k, _ + T * N, x + E * N, h, !0) + 2 : a.cap === "square" && (b += jC(_, x, T, E, k, N, !0, h))), h.push(_ - T * k, x - E * k), h.push(_ + T * N, x + E * N);
    for (let Y = 1; Y < p - 1; ++Y) {
        _ = t[(Y - 1) * 2], x = t[(Y - 1) * 2 + 1], w = t[Y * 2], S = t[Y * 2 + 1], C = t[(Y + 1) * 2], A = t[(Y + 1) * 2 + 1], T = -(x - S), E = _ - w, F = Math.sqrt(T * T + E * E), T /= F, E /= F, T *= m, E *= m, P = -(S - A), B = w - C, F = Math.sqrt(P * P + B * B), P /= F, B /= F, P *= m, B *= m;
        const le = w - _,
            ae = x - S,
            W = w - C,
            Q = A - S,
            fe = le * W + ae * Q,
            D = ae * W - Q * le,
            X = D < 0;
        if (Math.abs(D) < .001 * Math.abs(fe)) {
            h.push(w - T * k, S - E * k), h.push(w + T * N, S + E * N), fe >= 0 && (a.join === "round" ? b += ao(w, S, w - T * k, S - E * k, w - P * k, S - B * k, h, !1) + 4 : b += 2, h.push(w - P * N, S - B * N), h.push(w + P * k, S + B * k));
            continue
        }
        const $ = (-T + _) * (-E + S) - (-T + w) * (-E + x),
            Z = (-P + C) * (-B + S) - (-P + w) * (-B + A),
            K = (le * Z - W * $) / D,
            ce = (Q * $ - ae * Z) / D,
            de = (K - w) * (K - w) + (ce - S) * (ce - S),
            ge = w + (K - w) * k,
            O = S + (ce - S) * k,
            L = w - (K - w) * N,
            j = S - (ce - S) * N,
            ie = Math.min(le * le + ae * ae, W * W + Q * Q),
            oe = X ? k : N,
            R = ie + oe * oe * g;
        de <= R ? a.join === "bevel" || de / g > v ? (X ? (h.push(ge, O), h.push(w + T * N, S + E * N), h.push(ge, O), h.push(w + P * N, S + B * N)) : (h.push(w - T * k, S - E * k), h.push(L, j), h.push(w - P * k, S - B * k), h.push(L, j)), b += 2) : a.join === "round" ? X ? (h.push(ge, O), h.push(w + T * N, S + E * N), b += ao(w, S, w + T * N, S + E * N, w + P * N, S + B * N, h, !0) + 4, h.push(ge, O), h.push(w + P * N, S + B * N)) : (h.push(w - T * k, S - E * k), h.push(L, j), b += ao(w, S, w - T * k, S - E * k, w - P * k, S - B * k, h, !1) + 4, h.push(w - P * k, S - B * k), h.push(L, j)) : (h.push(ge, O), h.push(L, j)) : (h.push(w - T * k, S - E * k), h.push(w + T * N, S + E * N), a.join === "round" ? X ? b += ao(w, S, w + T * N, S + E * N, w + P * N, S + B * N, h, !0) + 2 : b += ao(w, S, w - T * k, S - E * k, w - P * k, S - B * k, h, !1) + 2 : a.join === "miter" && de / g <= v && (X ? (h.push(L, j), h.push(L, j)) : (h.push(ge, O), h.push(ge, O)), b += 2), h.push(w - P * k, S - B * k), h.push(w + P * N, S + B * N), b += 2)
    }
    _ = t[(p - 2) * 2], x = t[(p - 2) * 2 + 1], w = t[(p - 1) * 2], S = t[(p - 1) * 2 + 1], T = -(x - S), E = _ - w, F = Math.sqrt(T * T + E * E), T /= F, E /= F, T *= m, E *= m, h.push(w - T * k, S - E * k), h.push(w + T * N, S + E * N), d || (a.cap === "round" ? b += ao(w - T * (k - N) * .5, S - E * (k - N) * .5, w - T * k, S - E * k, w + T * N, S + E * N, h, !1) + 2 : a.cap === "square" && (b += jC(w, S, T, E, k, N, !1, h)));
    const V = zC * zC;
    for (let Y = y; Y < b + y - 2; ++Y) _ = h[Y * 2], x = h[Y * 2 + 1], w = h[(Y + 1) * 2], S = h[(Y + 1) * 2 + 1], C = h[(Y + 2) * 2], A = h[(Y + 2) * 2 + 1], !(Math.abs(_ * (S - A) + w * (A - x) + C * (x - S)) < V) && s.push(Y, Y + 1, Y + 2)
}

function Bpe(t, e, n, r) {
    const i = s$;
    if (t.length === 0) return;
    const s = t[0],
        o = t[1],
        a = t[t.length - 2],
        l = t[t.length - 1],
        c = e || Math.abs(s - a) < i && Math.abs(o - l) < i,
        u = n,
        d = t.length / 2,
        f = u.length / 2;
    for (let h = 0; h < d; h++) u.push(t[h * 2]), u.push(t[h * 2 + 1]);
    for (let h = 0; h < d - 1; h++) r.push(f + h, f + h + 1);
    c && r.push(f + d - 1, f)
}

function o$(t, e, n, r, i, s, o) {
    const a = khe(t, e, 2);
    if (!a) return;
    for (let c = 0; c < a.length; c += 3) s[o++] = a[c] + i, s[o++] = a[c + 1] + i, s[o++] = a[c + 2] + i;
    let l = i * r;
    for (let c = 0; c < t.length; c += 2) n[l] = t[c], n[l + 1] = t[c + 1], l += r
}
const Dpe = [],
    $pe = {
        extension: {
            type: G.ShapeBuilder,
            name: "polygon"
        },
        build(t, e) {
            for (let n = 0; n < t.points.length; n++) e[n] = t.points[n];
            return e
        },
        triangulate(t, e, n, r, i, s) {
            o$(t, Dpe, e, n, r, i, s)
        }
    },
    Fpe = {
        extension: {
            type: G.ShapeBuilder,
            name: "rectangle"
        },
        build(t, e) {
            const n = t,
                r = n.x,
                i = n.y,
                s = n.width,
                o = n.height;
            return s >= 0 && o >= 0 && (e[0] = r, e[1] = i, e[2] = r + s, e[3] = i, e[4] = r + s, e[5] = i + o, e[6] = r, e[7] = i + o), e
        },
        triangulate(t, e, n, r, i, s) {
            let o = 0;
            r *= n, e[r + o] = t[0], e[r + o + 1] = t[1], o += n, e[r + o] = t[2], e[r + o + 1] = t[3], o += n, e[r + o] = t[6], e[r + o + 1] = t[7], o += n, e[r + o] = t[4], e[r + o + 1] = t[5], o += n;
            const a = r / n;
            i[s++] = a, i[s++] = a + 1, i[s++] = a + 2, i[s++] = a + 1, i[s++] = a + 3, i[s++] = a + 2
        }
    },
    Lpe = {
        extension: {
            type: G.ShapeBuilder,
            name: "triangle"
        },
        build(t, e) {
            return e[0] = t.x, e[1] = t.y, e[2] = t.x2, e[3] = t.y2, e[4] = t.x3, e[5] = t.y3, e
        },
        triangulate(t, e, n, r, i, s) {
            let o = 0;
            r *= n, e[r + o] = t[0], e[r + o + 1] = t[1], o += n, e[r + o] = t[2], e[r + o + 1] = t[3], o += n, e[r + o] = t[4], e[r + o + 1] = t[5];
            const a = r / n;
            i[s++] = a, i[s++] = a + 1, i[s++] = a + 2
        }
    },
    Npe = new Ce,
    Upe = new at;

function Gpe(t, e, n, r) {
    const i = e.matrix ? t.copyFrom(e.matrix).invert() : t.identity();
    if (e.textureSpace === "local") {
        const s = n.getBounds(Upe);
        i.translate(-s.x, -s.y), i.scale(1 / s.width, 1 / s.height)
    } else {
        i.translate(e.texture.frame.x, e.texture.frame.y), i.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
        const s = e.texture.source.style;
        s.addressMode === "clamp-to-edge" && (s.addressMode = "repeat", s.update())
    }
    return r && i.append(Npe.copyFrom(r).invert()), i
}
const nm = {};
Ie.handleByMap(G.ShapeBuilder, nm);
Ie.add(Fpe, $pe, Lpe, Ru, Ipe, Rpe);
const Hpe = new at,
    zpe = new Ce;

function jpe(t, e) {
    const {
        geometryData: n,
        batches: r
    } = e;
    r.length = 0, n.indices.length = 0, n.vertices.length = 0, n.uvs.length = 0;
    for (let i = 0; i < t.instructions.length; i++) {
        const s = t.instructions[i];
        if (s.action === "texture") Vpe(s.data, r, n);
        else if (s.action === "fill" || s.action === "stroke") {
            const o = s.action === "stroke",
                a = s.data.path.shapePath,
                l = s.data.style,
                c = s.data.hole;
            o && c && VC(c.shapePath, l, !0, r, n), c && (a.shapePrimitives[a.shapePrimitives.length - 1].holes = c.shapePath.shapePrimitives), VC(a, l, o, r, n)
        }
    }
}

function Vpe(t, e, n) {
    const {
        vertices: r,
        uvs: i,
        indices: s
    } = n, o = s.length, a = r.length / 2, l = [], c = nm.rectangle, u = Hpe, d = t.image;
    u.x = t.dx, u.y = t.dy, u.width = t.dw, u.height = t.dh;
    const f = t.transform;
    c.build(u, l), f && i$(l, f), c.triangulate(l, r, 2, a, s, o);
    const h = d.uvs;
    i.push(h.x0, h.y0, h.x1, h.y1, h.x3, h.y3, h.x2, h.y2);
    const p = We.get(Jx);
    p.indexOffset = o, p.indexSize = s.length - o, p.attributeOffset = a, p.attributeSize = r.length / 2 - a, p.baseColor = t.style, p.alpha = t.alpha, p.texture = d, p.geometryData = n, e.push(p)
}

function VC(t, e, n, r, i) {
    const {
        vertices: s,
        uvs: o,
        indices: a
    } = i;
    t.shapePrimitives.forEach(({
        shape: l,
        transform: c,
        holes: u
    }) => {
        const d = a.length,
            f = s.length / 2,
            h = [],
            p = nm[l.type];
        let b = "triangle-list";
        if (p.build(l, h), c && i$(h, c), n) {
            const v = l.closePath ? ? !0,
                _ = e;
            _.pixelLine ? (Bpe(h, v, s, a), b = "line-list") : kpe(h, _, !1, v, s, a)
        } else if (u) {
            const v = [],
                _ = h.slice();
            Wpe(u).forEach(w => {
                v.push(_.length / 2), _.push(...w)
            }), o$(_, v, s, 2, f, a, d)
        } else p.triangulate(h, s, 2, f, a, d);
        const y = o.length / 2,
            m = e.texture;
        if (m !== we.WHITE) {
            const v = Gpe(zpe, e, l, c);
            Ppe(s, 2, f, o, y, 2, s.length / 2 - f, v)
        } else Ape(o, y, 2, s.length / 2 - f);
        const g = We.get(Jx);
        g.indexOffset = d, g.indexSize = a.length - d, g.attributeOffset = f, g.attributeSize = s.length / 2 - f, g.baseColor = e.color, g.alpha = e.alpha, g.texture = m, g.geometryData = i, g.topology = b, r.push(g)
    })
}

function Wpe(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
        const r = t[n].shape,
            i = [];
        nm[r.type].build(r, i), e.push(i)
    }
    return e
}
class Ype {
    constructor() {
        this.batches = [], this.geometryData = {
            vertices: [],
            uvs: [],
            indices: []
        }
    }
}
class Xpe {
    constructor() {
        this.batcher = new qx, this.instructions = new mD
    }
    init() {
        this.instructions.reset()
    }
    get geometry() {
        return $e(efe, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry
    }
}
const Zx = class D0 {
    constructor(e) {
        this._gpuContextHash = {}, this._graphicsDataContextHash = Object.create(null), e.renderableGC.addManagedHash(this, "_gpuContextHash"), e.renderableGC.addManagedHash(this, "_graphicsDataContextHash")
    }
    init(e) {
        D0.defaultOptions.bezierSmoothness = (e == null ? void 0 : e.bezierSmoothness) ? ? D0.defaultOptions.bezierSmoothness
    }
    getContextRenderData(e) {
        return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e)
    }
    updateGpuContext(e) {
        let n = this._gpuContextHash[e.uid] || this._initContext(e);
        if (e.dirty) {
            n ? this._cleanGraphicsContextData(e) : n = this._initContext(e), jpe(e, n);
            const r = e.batchMode;
            e.customShader || r === "no-batch" ? n.isBatchable = !1 : r === "auto" && (n.isBatchable = n.geometryData.vertices.length < 400), e.dirty = !1
        }
        return n
    }
    getGpuContext(e) {
        return this._gpuContextHash[e.uid] || this._initContext(e)
    }
    _initContextRenderData(e) {
        const n = We.get(Xpe),
            {
                batches: r,
                geometryData: i
            } = this._gpuContextHash[e.uid],
            s = i.vertices.length,
            o = i.indices.length;
        for (let u = 0; u < r.length; u++) r[u].applyTransform = !1;
        const a = n.batcher;
        a.ensureAttributeBuffer(s), a.ensureIndexBuffer(o), a.begin();
        for (let u = 0; u < r.length; u++) {
            const d = r[u];
            a.add(d)
        }
        a.finish(n.instructions);
        const l = a.geometry;
        l.indexBuffer.setDataWithSize(a.indexBuffer, a.indexSize, !0), l.buffers[0].setDataWithSize(a.attributeBuffer.float32View, a.attributeSize, !0);
        const c = a.batches;
        for (let u = 0; u < c.length; u++) {
            const d = c[u];
            d.bindGroup = jx(d.textures.textures, d.textures.count)
        }
        return this._graphicsDataContextHash[e.uid] = n, n
    }
    _initContext(e) {
        const n = new Ype;
        return n.context = e, this._gpuContextHash[e.uid] = n, e.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid]
    }
    onGraphicsContextDestroy(e) {
        this._cleanGraphicsContextData(e), e.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid] = null
    }
    _cleanGraphicsContextData(e) {
        const n = this._gpuContextHash[e.uid];
        n.isBatchable || this._graphicsDataContextHash[e.uid] && (We.return(this.getContextRenderData(e)), this._graphicsDataContextHash[e.uid] = null), n.batches && n.batches.forEach(r => {
            We.return(r)
        })
    }
    destroy() {
        for (const e in this._gpuContextHash) this._gpuContextHash[e] && this.onGraphicsContextDestroy(this._gpuContextHash[e].context)
    }
};
Zx.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "graphicsContext"
};
Zx.defaultOptions = {
    bezierSmoothness: .5
};
let Qx = Zx;
const Kpe = 8,
    ff = 11920929e-14,
    qpe = 1;

function a$(t, e, n, r, i, s, o, a, l, c) {
    const d = Math.min(.99, Math.max(0, c ? ? Qx.defaultOptions.bezierSmoothness));
    let f = (qpe - d) / 1;
    return f *= f, Jpe(e, n, r, i, s, o, a, l, t, f), t
}

function Jpe(t, e, n, r, i, s, o, a, l, c) {
    $0(t, e, n, r, i, s, o, a, l, c, 0), l.push(o, a)
}

function $0(t, e, n, r, i, s, o, a, l, c, u) {
    if (u > Kpe) return;
    const d = (t + n) / 2,
        f = (e + r) / 2,
        h = (n + i) / 2,
        p = (r + s) / 2,
        b = (i + o) / 2,
        y = (s + a) / 2,
        m = (d + h) / 2,
        g = (f + p) / 2,
        v = (h + b) / 2,
        _ = (p + y) / 2,
        x = (m + v) / 2,
        w = (g + _) / 2;
    if (u > 0) {
        let S = o - t,
            C = a - e;
        const A = Math.abs((n - o) * C - (r - a) * S),
            T = Math.abs((i - o) * C - (s - a) * S);
        if (A > ff && T > ff) {
            if ((A + T) * (A + T) <= c * (S * S + C * C)) {
                l.push(x, w);
                return
            }
        } else if (A > ff) {
            if (A * A <= c * (S * S + C * C)) {
                l.push(x, w);
                return
            }
        } else if (T > ff) {
            if (T * T <= c * (S * S + C * C)) {
                l.push(x, w);
                return
            }
        } else if (S = x - (t + o) / 2, C = w - (e + a) / 2, S * S + C * C <= c) {
            l.push(x, w);
            return
        }
    }
    $0(t, e, d, f, m, g, x, w, l, c, u + 1), $0(x, w, v, _, b, y, o, a, l, c, u + 1)
}
const Zpe = 8,
    Qpe = 11920929e-14,
    eme = 1;

function tme(t, e, n, r, i, s, o, a) {
    const c = Math.min(.99, Math.max(0, a ? ? Qx.defaultOptions.bezierSmoothness));
    let u = (eme - c) / 1;
    return u *= u, nme(e, n, r, i, s, o, t, u), t
}

function nme(t, e, n, r, i, s, o, a) {
    F0(o, t, e, n, r, i, s, a, 0), o.push(i, s)
}

function F0(t, e, n, r, i, s, o, a, l) {
    if (l > Zpe) return;
    const c = (e + r) / 2,
        u = (n + i) / 2,
        d = (r + s) / 2,
        f = (i + o) / 2,
        h = (c + d) / 2,
        p = (u + f) / 2;
    let b = s - e,
        y = o - n;
    const m = Math.abs((r - s) * y - (i - o) * b);
    if (m > Qpe) {
        if (m * m <= a * (b * b + y * y)) {
            t.push(h, p);
            return
        }
    } else if (b = h - (e + s) / 2, y = p - (n + o) / 2, b * b + y * y <= a) {
        t.push(h, p);
        return
    }
    F0(t, e, n, c, u, h, p, a, l + 1), F0(t, h, p, d, f, s, o, a, l + 1)
}

function l$(t, e, n, r, i, s, o, a) {
    let l = Math.abs(i - s);
    (!o && i > s || o && s > i) && (l = 2 * Math.PI - l), a || (a = Math.max(6, Math.floor(6 * Math.pow(r, 1 / 3) * (l / Math.PI)))), a = Math.max(a, 3);
    let c = l / a,
        u = i;
    c *= o ? -1 : 1;
    for (let d = 0; d < a + 1; d++) {
        const f = Math.cos(u),
            h = Math.sin(u),
            p = e + f * r,
            b = n + h * r;
        t.push(p, b), u += c
    }
}

function rme(t, e, n, r, i, s) {
    const o = t[t.length - 2],
        l = t[t.length - 1] - n,
        c = o - e,
        u = i - n,
        d = r - e,
        f = Math.abs(l * d - c * u);
    if (f < 1e-8 || s === 0) {
        (t[t.length - 2] !== e || t[t.length - 1] !== n) && t.push(e, n);
        return
    }
    const h = l * l + c * c,
        p = u * u + d * d,
        b = l * u + c * d,
        y = s * Math.sqrt(h) / f,
        m = s * Math.sqrt(p) / f,
        g = y * b / h,
        v = m * b / p,
        _ = y * d + m * c,
        x = y * u + m * l,
        w = c * (m + g),
        S = l * (m + g),
        C = d * (y + v),
        A = u * (y + v),
        T = Math.atan2(S - x, w - _),
        E = Math.atan2(A - x, C - _);
    l$(t, _ + e, x + n, s, T, E, c * u > d * l)
}
const Wc = Math.PI * 2,
    hv = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
    },
    pv = ({
        x: t,
        y: e
    }, n, r, i, s, o, a, l) => {
        t *= n, e *= r;
        const c = i * t - s * e,
            u = s * t + i * e;
        return l.x = c + o, l.y = u + a, l
    };

function ime(t, e) {
    const n = e === -1.5707963267948966 ? -.551915024494 : 1.3333333333333333 * Math.tan(e / 4),
        r = e === 1.5707963267948966 ? .551915024494 : n,
        i = Math.cos(t),
        s = Math.sin(t),
        o = Math.cos(t + e),
        a = Math.sin(t + e);
    return [{
        x: i - s * r,
        y: s + i * r
    }, {
        x: o + a * r,
        y: a - o * r
    }, {
        x: o,
        y: a
    }]
}
const WC = (t, e, n, r) => {
        const i = t * r - e * n < 0 ? -1 : 1;
        let s = t * n + e * r;
        return s > 1 && (s = 1), s < -1 && (s = -1), i * Math.acos(s)
    },
    sme = (t, e, n, r, i, s, o, a, l, c, u, d, f) => {
        const h = Math.pow(i, 2),
            p = Math.pow(s, 2),
            b = Math.pow(u, 2),
            y = Math.pow(d, 2);
        let m = h * p - h * y - p * b;
        m < 0 && (m = 0), m /= h * y + p * b, m = Math.sqrt(m) * (o === a ? -1 : 1);
        const g = m * i / s * d,
            v = m * -s / i * u,
            _ = c * g - l * v + (t + n) / 2,
            x = l * g + c * v + (e + r) / 2,
            w = (u - g) / i,
            S = (d - v) / s,
            C = (-u - g) / i,
            A = (-d - v) / s,
            T = WC(1, 0, w, S);
        let E = WC(w, S, C, A);
        a === 0 && E > 0 && (E -= Wc), a === 1 && E < 0 && (E += Wc), f.centerX = _, f.centerY = x, f.ang1 = T, f.ang2 = E
    };

function ome(t, e, n, r, i, s, o, a = 0, l = 0, c = 0) {
    if (s === 0 || o === 0) return;
    const u = Math.sin(a * Wc / 360),
        d = Math.cos(a * Wc / 360),
        f = d * (e - r) / 2 + u * (n - i) / 2,
        h = -u * (e - r) / 2 + d * (n - i) / 2;
    if (f === 0 && h === 0) return;
    s = Math.abs(s), o = Math.abs(o);
    const p = Math.pow(f, 2) / Math.pow(s, 2) + Math.pow(h, 2) / Math.pow(o, 2);
    p > 1 && (s *= Math.sqrt(p), o *= Math.sqrt(p)), sme(e, n, r, i, s, o, l, c, u, d, f, h, hv);
    let {
        ang1: b,
        ang2: y
    } = hv;
    const {
        centerX: m,
        centerY: g
    } = hv;
    let v = Math.abs(y) / (Wc / 4);
    Math.abs(1 - v) < 1e-7 && (v = 1);
    const _ = Math.max(Math.ceil(v), 1);
    y /= _;
    let x = t[t.length - 2],
        w = t[t.length - 1];
    const S = {
        x: 0,
        y: 0
    };
    for (let C = 0; C < _; C++) {
        const A = ime(b, y),
            {
                x: T,
                y: E
            } = pv(A[0], s, o, d, u, m, g, S),
            {
                x: P,
                y: B
            } = pv(A[1], s, o, d, u, m, g, S),
            {
                x: F,
                y: H
            } = pv(A[2], s, o, d, u, m, g, S);
        a$(t, x, w, T, E, P, B, F, H), x = F, w = H, b += y
    }
}

function ame(t, e, n) {
    const r = (o, a) => {
            const l = a.x - o.x,
                c = a.y - o.y,
                u = Math.sqrt(l * l + c * c),
                d = l / u,
                f = c / u;
            return {
                len: u,
                nx: d,
                ny: f
            }
        },
        i = (o, a) => {
            o === 0 ? t.moveTo(a.x, a.y) : t.lineTo(a.x, a.y)
        };
    let s = e[e.length - 1];
    for (let o = 0; o < e.length; o++) {
        const a = e[o % e.length],
            l = a.radius ? ? n;
        if (l <= 0) {
            i(o, a), s = a;
            continue
        }
        const c = e[(o + 1) % e.length],
            u = r(a, s),
            d = r(a, c);
        if (u.len < 1e-4 || d.len < 1e-4) {
            i(o, a), s = a;
            continue
        }
        let f = Math.asin(u.nx * d.ny - u.ny * d.nx),
            h = 1,
            p = !1;
        u.nx * d.nx - u.ny * -d.ny < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, h = -1, p = !0) : f > 0 && (h = -1, p = !0);
        const b = f / 2;
        let y, m = Math.abs(Math.cos(b) * l / Math.sin(b));
        m > Math.min(u.len / 2, d.len / 2) ? (m = Math.min(u.len / 2, d.len / 2), y = Math.abs(m * Math.sin(b) / Math.cos(b))) : y = l;
        const g = a.x + d.nx * m + -d.ny * y * h,
            v = a.y + d.ny * m + d.nx * y * h,
            _ = Math.atan2(u.ny, u.nx) + Math.PI / 2 * h,
            x = Math.atan2(d.ny, d.nx) - Math.PI / 2 * h;
        o === 0 && t.moveTo(g + Math.cos(_) * y, v + Math.sin(_) * y), t.arc(g, v, y, _, x, p), s = a
    }
}

function lme(t, e, n, r) {
    const i = (a, l) => Math.sqrt((a.x - l.x) ** 2 + (a.y - l.y) ** 2),
        s = (a, l, c) => ({
            x: a.x + (l.x - a.x) * c,
            y: a.y + (l.y - a.y) * c
        }),
        o = e.length;
    for (let a = 0; a < o; a++) {
        const l = e[(a + 1) % o],
            c = l.radius ? ? n;
        if (c <= 0) {
            a === 0 ? t.moveTo(l.x, l.y) : t.lineTo(l.x, l.y);
            continue
        }
        const u = e[a],
            d = e[(a + 2) % o],
            f = i(u, l);
        let h;
        if (f < 1e-4) h = l;
        else {
            const y = Math.min(f / 2, c);
            h = s(l, u, y / f)
        }
        const p = i(d, l);
        let b;
        if (p < 1e-4) b = l;
        else {
            const y = Math.min(p / 2, c);
            b = s(l, d, y / p)
        }
        a === 0 ? t.moveTo(h.x, h.y) : t.lineTo(h.x, h.y), t.quadraticCurveTo(l.x, l.y, b.x, b.y, r)
    }
}
const cme = new at;
class ume {
    constructor(e) {
        this.shapePrimitives = [], this._currentPoly = null, this._bounds = new rn, this._graphicsPath2D = e, this.signed = e.checkForHoles
    }
    moveTo(e, n) {
        return this.startPoly(e, n), this
    }
    lineTo(e, n) {
        this._ensurePoly();
        const r = this._currentPoly.points,
            i = r[r.length - 2],
            s = r[r.length - 1];
        return (i !== e || s !== n) && r.push(e, n), this
    }
    arc(e, n, r, i, s, o) {
        this._ensurePoly(!1);
        const a = this._currentPoly.points;
        return l$(a, e, n, r, i, s, o), this
    }
    arcTo(e, n, r, i, s) {
        this._ensurePoly();
        const o = this._currentPoly.points;
        return rme(o, e, n, r, i, s), this
    }
    arcToSvg(e, n, r, i, s, o, a) {
        const l = this._currentPoly.points;
        return ome(l, this._currentPoly.lastX, this._currentPoly.lastY, o, a, e, n, r, i, s), this
    }
    bezierCurveTo(e, n, r, i, s, o, a) {
        this._ensurePoly();
        const l = this._currentPoly;
        return a$(this._currentPoly.points, l.lastX, l.lastY, e, n, r, i, s, o, a), this
    }
    quadraticCurveTo(e, n, r, i, s) {
        this._ensurePoly();
        const o = this._currentPoly;
        return tme(this._currentPoly.points, o.lastX, o.lastY, e, n, r, i, s), this
    }
    closePath() {
        return this.endPoly(!0), this
    }
    addPath(e, n) {
        this.endPoly(), n && !n.isIdentity() && (e = e.clone(!0), e.transform(n));
        const r = this.shapePrimitives,
            i = r.length;
        for (let s = 0; s < e.instructions.length; s++) {
            const o = e.instructions[s];
            this[o.action](...o.data)
        }
        if (e.checkForHoles && r.length - i > 1) {
            let s = null;
            for (let o = i; o < r.length; o++) {
                const a = r[o];
                if (a.shape.type === "polygon") {
                    const l = a.shape,
                        c = s == null ? void 0 : s.shape;
                    c && c.containsPolygon(l) ? (s.holes || (s.holes = []), s.holes.push(a), r.copyWithin(o, o + 1), r.length--, o--) : s = a
                }
            }
        }
        return this
    }
    finish(e = !1) {
        this.endPoly(e)
    }
    rect(e, n, r, i, s) {
        return this.drawShape(new at(e, n, r, i), s), this
    }
    circle(e, n, r, i) {
        return this.drawShape(new Gx(e, n, r), i), this
    }
    poly(e, n, r) {
        const i = new Vc(e);
        return i.closePath = n, this.drawShape(i, r), this
    }
    regularPoly(e, n, r, i, s = 0, o) {
        i = Math.max(i | 0, 3);
        const a = -1 * Math.PI / 2 + s,
            l = Math.PI * 2 / i,
            c = [];
        for (let u = 0; u < i; u++) {
            const d = a - u * l;
            c.push(e + r * Math.cos(d), n + r * Math.sin(d))
        }
        return this.poly(c, !0, o), this
    }
    roundPoly(e, n, r, i, s, o = 0, a) {
        if (i = Math.max(i | 0, 3), s <= 0) return this.regularPoly(e, n, r, i, o);
        const l = r * Math.sin(Math.PI / i) - .001;
        s = Math.min(s, l);
        const c = -1 * Math.PI / 2 + o,
            u = Math.PI * 2 / i,
            d = (i - 2) * Math.PI / i / 2;
        for (let f = 0; f < i; f++) {
            const h = f * u + c,
                p = e + r * Math.cos(h),
                b = n + r * Math.sin(h),
                y = h + Math.PI + d,
                m = h - Math.PI - d,
                g = p + s * Math.cos(y),
                v = b + s * Math.sin(y),
                _ = p + s * Math.cos(m),
                x = b + s * Math.sin(m);
            f === 0 ? this.moveTo(g, v) : this.lineTo(g, v), this.quadraticCurveTo(p, b, _, x, a)
        }
        return this.closePath()
    }
    roundShape(e, n, r = !1, i) {
        return e.length < 3 ? this : (r ? lme(this, e, n, i) : ame(this, e, n), this.closePath())
    }
    filletRect(e, n, r, i, s) {
        if (s === 0) return this.rect(e, n, r, i);
        const o = Math.min(r, i) / 2,
            a = Math.min(o, Math.max(-o, s)),
            l = e + r,
            c = n + i,
            u = a < 0 ? -a : 0,
            d = Math.abs(a);
        return this.moveTo(e, n + d).arcTo(e + u, n + u, e + d, n, d).lineTo(l - d, n).arcTo(l - u, n + u, l, n + d, d).lineTo(l, c - d).arcTo(l - u, c - u, e + r - d, c, d).lineTo(e + d, c).arcTo(e + u, c - u, e, c - d, d).closePath()
    }
    chamferRect(e, n, r, i, s, o) {
        if (s <= 0) return this.rect(e, n, r, i);
        const a = Math.min(s, Math.min(r, i) / 2),
            l = e + r,
            c = n + i,
            u = [e + a, n, l - a, n, l, n + a, l, c - a, l - a, c, e + a, c, e, c - a, e, n + a];
        for (let d = u.length - 1; d >= 2; d -= 2) u[d] === u[d - 2] && u[d - 1] === u[d - 3] && u.splice(d - 1, 2);
        return this.poly(u, !0, o)
    }
    ellipse(e, n, r, i, s) {
        return this.drawShape(new Hx(e, n, r, i), s), this
    }
    roundRect(e, n, r, i, s, o) {
        return this.drawShape(new zx(e, n, r, i, s), o), this
    }
    drawShape(e, n) {
        return this.endPoly(), this.shapePrimitives.push({
            shape: e,
            transform: n
        }), this
    }
    startPoly(e, n) {
        let r = this._currentPoly;
        return r && this.endPoly(), r = new Vc, r.points.push(e, n), this._currentPoly = r, this
    }
    endPoly(e = !1) {
        const n = this._currentPoly;
        return n && n.points.length > 2 && (n.closePath = e, this.shapePrimitives.push({
            shape: n
        })), this._currentPoly = null, this
    }
    _ensurePoly(e = !0) {
        if (!this._currentPoly && (this._currentPoly = new Vc, e)) {
            const n = this.shapePrimitives[this.shapePrimitives.length - 1];
            if (n) {
                let r = n.shape.x,
                    i = n.shape.y;
                if (n.transform && !n.transform.isIdentity()) {
                    const s = n.transform,
                        o = r;
                    r = s.a * r + s.c * i + s.tx, i = s.b * o + s.d * i + s.ty
                }
                this._currentPoly.points.push(r, i)
            } else this._currentPoly.points.push(0, 0)
        }
    }
    buildPath() {
        const e = this._graphicsPath2D;
        this.shapePrimitives.length = 0, this._currentPoly = null;
        for (let n = 0; n < e.instructions.length; n++) {
            const r = e.instructions[n];
            this[r.action](...r.data)
        }
        this.finish()
    }
    get bounds() {
        const e = this._bounds;
        e.clear();
        const n = this.shapePrimitives;
        for (let r = 0; r < n.length; r++) {
            const i = n[r],
                s = i.shape.getBounds(cme);
            i.transform ? e.addRect(s, i.transform) : e.addRect(s)
        }
        return e
    }
}
class Al {
    constructor(e, n = !1) {
        this.instructions = [], this.uid = yt("graphicsPath"), this._dirty = !0, this.checkForHoles = n, typeof e == "string" ? Whe(e, this) : this.instructions = (e == null ? void 0 : e.slice()) ? ? []
    }
    get shapePath() {
        return this._shapePath || (this._shapePath = new ume(this)), this._dirty && (this._dirty = !1, this._shapePath.buildPath()), this._shapePath
    }
    addPath(e, n) {
        return e = e.clone(), this.instructions.push({
            action: "addPath",
            data: [e, n]
        }), this._dirty = !0, this
    }
    arc(...e) {
        return this.instructions.push({
            action: "arc",
            data: e
        }), this._dirty = !0, this
    }
    arcTo(...e) {
        return this.instructions.push({
            action: "arcTo",
            data: e
        }), this._dirty = !0, this
    }
    arcToSvg(...e) {
        return this.instructions.push({
            action: "arcToSvg",
            data: e
        }), this._dirty = !0, this
    }
    bezierCurveTo(...e) {
        return this.instructions.push({
            action: "bezierCurveTo",
            data: e
        }), this._dirty = !0, this
    }
    bezierCurveToShort(e, n, r, i, s) {
        const o = this.instructions[this.instructions.length - 1],
            a = this.getLastPoint(ct.shared);
        let l = 0,
            c = 0;
        if (!o || o.action !== "bezierCurveTo") l = a.x, c = a.y;
        else {
            l = o.data[2], c = o.data[3];
            const u = a.x,
                d = a.y;
            l = u + (u - l), c = d + (d - c)
        }
        return this.instructions.push({
            action: "bezierCurveTo",
            data: [l, c, e, n, r, i, s]
        }), this._dirty = !0, this
    }
    closePath() {
        return this.instructions.push({
            action: "closePath",
            data: []
        }), this._dirty = !0, this
    }
    ellipse(...e) {
        return this.instructions.push({
            action: "ellipse",
            data: e
        }), this._dirty = !0, this
    }
    lineTo(...e) {
        return this.instructions.push({
            action: "lineTo",
            data: e
        }), this._dirty = !0, this
    }
    moveTo(...e) {
        return this.instructions.push({
            action: "moveTo",
            data: e
        }), this
    }
    quadraticCurveTo(...e) {
        return this.instructions.push({
            action: "quadraticCurveTo",
            data: e
        }), this._dirty = !0, this
    }
    quadraticCurveToShort(e, n, r) {
        const i = this.instructions[this.instructions.length - 1],
            s = this.getLastPoint(ct.shared);
        let o = 0,
            a = 0;
        if (!i || i.action !== "quadraticCurveTo") o = s.x, a = s.y;
        else {
            o = i.data[0], a = i.data[1];
            const l = s.x,
                c = s.y;
            o = l + (l - o), a = c + (c - a)
        }
        return this.instructions.push({
            action: "quadraticCurveTo",
            data: [o, a, e, n, r]
        }), this._dirty = !0, this
    }
    rect(e, n, r, i, s) {
        return this.instructions.push({
            action: "rect",
            data: [e, n, r, i, s]
        }), this._dirty = !0, this
    }
    circle(e, n, r, i) {
        return this.instructions.push({
            action: "circle",
            data: [e, n, r, i]
        }), this._dirty = !0, this
    }
    roundRect(...e) {
        return this.instructions.push({
            action: "roundRect",
            data: e
        }), this._dirty = !0, this
    }
    poly(...e) {
        return this.instructions.push({
            action: "poly",
            data: e
        }), this._dirty = !0, this
    }
    regularPoly(...e) {
        return this.instructions.push({
            action: "regularPoly",
            data: e
        }), this._dirty = !0, this
    }
    roundPoly(...e) {
        return this.instructions.push({
            action: "roundPoly",
            data: e
        }), this._dirty = !0, this
    }
    roundShape(...e) {
        return this.instructions.push({
            action: "roundShape",
            data: e
        }), this._dirty = !0, this
    }
    filletRect(...e) {
        return this.instructions.push({
            action: "filletRect",
            data: e
        }), this._dirty = !0, this
    }
    chamferRect(...e) {
        return this.instructions.push({
            action: "chamferRect",
            data: e
        }), this._dirty = !0, this
    }
    star(e, n, r, i, s, o, a) {
        s || (s = i / 2);
        const l = -1 * Math.PI / 2 + o,
            c = r * 2,
            u = Math.PI * 2 / c,
            d = [];
        for (let f = 0; f < c; f++) {
            const h = f % 2 ? s : i,
                p = f * u + l;
            d.push(e + h * Math.cos(p), n + h * Math.sin(p))
        }
        return this.poly(d, !0, a), this
    }
    clone(e = !1) {
        const n = new Al;
        if (n.checkForHoles = this.checkForHoles, !e) n.instructions = this.instructions.slice();
        else
            for (let r = 0; r < this.instructions.length; r++) {
                const i = this.instructions[r];
                n.instructions.push({
                    action: i.action,
                    data: i.data.slice()
                })
            }
        return n
    }
    clear() {
        return this.instructions.length = 0, this._dirty = !0, this
    }
    transform(e) {
        if (e.isIdentity()) return this;
        const n = e.a,
            r = e.b,
            i = e.c,
            s = e.d,
            o = e.tx,
            a = e.ty;
        let l = 0,
            c = 0,
            u = 0,
            d = 0,
            f = 0,
            h = 0,
            p = 0,
            b = 0;
        for (let y = 0; y < this.instructions.length; y++) {
            const m = this.instructions[y],
                g = m.data;
            switch (m.action) {
                case "moveTo":
                case "lineTo":
                    l = g[0], c = g[1], g[0] = n * l + i * c + o, g[1] = r * l + s * c + a;
                    break;
                case "bezierCurveTo":
                    u = g[0], d = g[1], f = g[2], h = g[3], l = g[4], c = g[5], g[0] = n * u + i * d + o, g[1] = r * u + s * d + a, g[2] = n * f + i * h + o, g[3] = r * f + s * h + a, g[4] = n * l + i * c + o, g[5] = r * l + s * c + a;
                    break;
                case "quadraticCurveTo":
                    u = g[0], d = g[1], l = g[2], c = g[3], g[0] = n * u + i * d + o, g[1] = r * u + s * d + a, g[2] = n * l + i * c + o, g[3] = r * l + s * c + a;
                    break;
                case "arcToSvg":
                    l = g[5], c = g[6], p = g[0], b = g[1], g[0] = n * p + i * b, g[1] = r * p + s * b, g[5] = n * l + i * c + o, g[6] = r * l + s * c + a;
                    break;
                case "circle":
                    g[4] = fc(g[3], e);
                    break;
                case "rect":
                    g[4] = fc(g[4], e);
                    break;
                case "ellipse":
                    g[8] = fc(g[8], e);
                    break;
                case "roundRect":
                    g[5] = fc(g[5], e);
                    break;
                case "addPath":
                    g[0].transform(e);
                    break;
                case "poly":
                    g[2] = fc(g[2], e);
                    break;
                default:
                    Me("unknown transform action", m.action);
                    break
            }
        }
        return this._dirty = !0, this
    }
    get bounds() {
        return this.shapePath.bounds
    }
    getLastPoint(e) {
        let n = this.instructions.length - 1,
            r = this.instructions[n];
        if (!r) return e.x = 0, e.y = 0, e;
        for (; r.action === "closePath";) {
            if (n--, n < 0) return e.x = 0, e.y = 0, e;
            r = this.instructions[n]
        }
        switch (r.action) {
            case "moveTo":
            case "lineTo":
                e.x = r.data[0], e.y = r.data[1];
                break;
            case "quadraticCurveTo":
                e.x = r.data[2], e.y = r.data[3];
                break;
            case "bezierCurveTo":
                e.x = r.data[4], e.y = r.data[5];
                break;
            case "arc":
            case "arcToSvg":
                e.x = r.data[5], e.y = r.data[6];
                break;
            case "addPath":
                r.data[0].getLastPoint(e);
                break
        }
        return e
    }
}

function fc(t, e) {
    return t ? t.prepend(e) : e.clone()
}

function Pt(t, e, n) {
    const r = t.getAttribute(e);
    return r ? Number(r) : n
}

function dme(t, e) {
    const n = t.querySelectorAll("defs");
    for (let r = 0; r < n.length; r++) {
        const i = n[r];
        for (let s = 0; s < i.children.length; s++) {
            const o = i.children[s];
            switch (o.nodeName.toLowerCase()) {
                case "lineargradient":
                    e.defs[o.id] = fme(o);
                    break;
                case "radialgradient":
                    e.defs[o.id] = hme();
                    break
            }
        }
    }
}

function fme(t) {
    const e = Pt(t, "x1", 0),
        n = Pt(t, "y1", 0),
        r = Pt(t, "x2", 1),
        i = Pt(t, "y2", 0),
        s = t.getAttribute("gradientUnits") || "objectBoundingBox",
        o = new Hs(e, n, r, i, s === "objectBoundingBox" ? "local" : "global");
    for (let a = 0; a < t.children.length; a++) {
        const l = t.children[a],
            c = Pt(l, "offset", 0),
            u = rt.shared.setValue(l.getAttribute("stop-color")).toNumber();
        o.addColorStop(c, u)
    }
    return o
}

function hme(t) {
    return Me("[SVG Parser] Radial gradients are not yet supported"), new Hs(0, 0, 1, 0)
}

function YC(t) {
    const e = t.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
    return e ? e[1] : ""
}
const XC = {
    fill: {
        type: "paint",
        default: 0
    },
    "fill-opacity": {
        type: "number",
        default: 1
    },
    stroke: {
        type: "paint",
        default: 0
    },
    "stroke-width": {
        type: "number",
        default: 1
    },
    "stroke-opacity": {
        type: "number",
        default: 1
    },
    "stroke-linecap": {
        type: "string",
        default: "butt"
    },
    "stroke-linejoin": {
        type: "string",
        default: "miter"
    },
    "stroke-miterlimit": {
        type: "number",
        default: 10
    },
    "stroke-dasharray": {
        type: "string",
        default: "none"
    },
    "stroke-dashoffset": {
        type: "number",
        default: 0
    },
    opacity: {
        type: "number",
        default: 1
    }
};

function c$(t, e) {
    const n = t.getAttribute("style"),
        r = {},
        i = {},
        s = {
            strokeStyle: r,
            fillStyle: i,
            useFill: !1,
            useStroke: !1
        };
    for (const o in XC) {
        const a = t.getAttribute(o);
        a && KC(e, s, o, a.trim())
    }
    if (n) {
        const o = n.split(";");
        for (let a = 0; a < o.length; a++) {
            const l = o[a].trim(),
                [c, u] = l.split(":");
            XC[c] && KC(e, s, c, u.trim())
        }
    }
    return {
        strokeStyle: s.useStroke ? r : null,
        fillStyle: s.useFill ? i : null,
        useFill: s.useFill,
        useStroke: s.useStroke
    }
}

function KC(t, e, n, r) {
    switch (n) {
        case "stroke":
            if (r !== "none") {
                if (r.startsWith("url(")) {
                    const i = YC(r);
                    e.strokeStyle.fill = t.defs[i]
                } else e.strokeStyle.color = rt.shared.setValue(r).toNumber();
                e.useStroke = !0
            }
            break;
        case "stroke-width":
            e.strokeStyle.width = Number(r);
            break;
        case "fill":
            if (r !== "none") {
                if (r.startsWith("url(")) {
                    const i = YC(r);
                    e.fillStyle.fill = t.defs[i]
                } else e.fillStyle.color = rt.shared.setValue(r).toNumber();
                e.useFill = !0
            }
            break;
        case "fill-opacity":
            e.fillStyle.alpha = Number(r);
            break;
        case "stroke-opacity":
            e.strokeStyle.alpha = Number(r);
            break;
        case "opacity":
            e.fillStyle.alpha = Number(r), e.strokeStyle.alpha = Number(r);
            break
    }
}

function pme(t, e) {
    if (typeof t == "string") {
        const o = document.createElement("div");
        o.innerHTML = t.trim(), t = o.querySelector("svg")
    }
    const n = {
        context: e,
        defs: {},
        path: new Al
    };
    dme(t, n);
    const r = t.children,
        {
            fillStyle: i,
            strokeStyle: s
        } = c$(t, n);
    for (let o = 0; o < r.length; o++) {
        const a = r[o];
        a.nodeName.toLowerCase() !== "defs" && u$(a, n, i, s)
    }
    return e
}

function u$(t, e, n, r) {
    const i = t.children,
        {
            fillStyle: s,
            strokeStyle: o
        } = c$(t, e);
    s && n ? n = { ...n,
        ...s
    } : s && (n = s), o && r ? r = { ...r,
        ...o
    } : o && (r = o);
    const a = !n && !r;
    a && (n = {
        color: 0
    });
    let l, c, u, d, f, h, p, b, y, m, g, v, _, x, w, S, C;
    switch (t.nodeName.toLowerCase()) {
        case "path":
            x = t.getAttribute("d"), t.getAttribute("fill-rule") === "evenodd" && Me("SVG Evenodd fill rule not supported, your svg may render incorrectly"), w = new Al(x, !0), e.context.path(w), n && e.context.fill(n), r && e.context.stroke(r);
            break;
        case "circle":
            p = Pt(t, "cx", 0), b = Pt(t, "cy", 0), y = Pt(t, "r", 0), e.context.ellipse(p, b, y, y), n && e.context.fill(n), r && e.context.stroke(r);
            break;
        case "rect":
            l = Pt(t, "x", 0), c = Pt(t, "y", 0), S = Pt(t, "width", 0), C = Pt(t, "height", 0), m = Pt(t, "rx", 0), g = Pt(t, "ry", 0), m || g ? e.context.roundRect(l, c, S, C, m || g) : e.context.rect(l, c, S, C), n && e.context.fill(n), r && e.context.stroke(r);
            break;
        case "ellipse":
            p = Pt(t, "cx", 0), b = Pt(t, "cy", 0), m = Pt(t, "rx", 0), g = Pt(t, "ry", 0), e.context.beginPath(), e.context.ellipse(p, b, m, g), n && e.context.fill(n), r && e.context.stroke(r);
            break;
        case "line":
            u = Pt(t, "x1", 0), d = Pt(t, "y1", 0), f = Pt(t, "x2", 0), h = Pt(t, "y2", 0), e.context.beginPath(), e.context.moveTo(u, d), e.context.lineTo(f, h), r && e.context.stroke(r);
            break;
        case "polygon":
            _ = t.getAttribute("points"), v = _.match(/\d+/g).map(A => parseInt(A, 10)), e.context.poly(v, !0), n && e.context.fill(n), r && e.context.stroke(r);
            break;
        case "polyline":
            _ = t.getAttribute("points"), v = _.match(/\d+/g).map(A => parseInt(A, 10)), e.context.poly(v, !1), r && e.context.stroke(r);
            break;
        case "g":
        case "svg":
            break;
        default:
            {
                Me(`[SVG parser] <${t.nodeName}> elements unsupported`);
                break
            }
    }
    a && (n = null);
    for (let A = 0; A < i.length; A++) u$(i[A], e, n, r)
}

function mme(t) {
    return rt.isColorLike(t)
}

function qC(t) {
    return t instanceof tm
}

function JC(t) {
    return t instanceof Hs
}

function gme(t) {
    return t instanceof we
}

function vme(t, e, n) {
    const r = rt.shared.setValue(e ? ? 0);
    return t.color = r.toNumber(), t.alpha = r.alpha === 1 ? n.alpha : r.alpha, t.texture = we.WHITE, { ...n,
        ...t
    }
}

function yme(t, e, n) {
    return t.texture = e, { ...n,
        ...t
    }
}

function ZC(t, e, n) {
    return t.fill = e, t.color = 16777215, t.texture = e.texture, t.matrix = e.transform, { ...n,
        ...t
    }
}

function QC(t, e, n) {
    return e.buildGradient(), t.fill = e, t.color = 16777215, t.texture = e.texture, t.matrix = e.transform, t.textureSpace = e.textureSpace, { ...n,
        ...t
    }
}

function _me(t, e) {
    const n = { ...e,
            ...t
        },
        r = rt.shared.setValue(n.color);
    return n.alpha *= r.alpha, n.color = r.toNumber(), n
}

function Po(t, e) {
    if (t == null) return null;
    const n = {},
        r = t;
    return mme(t) ? vme(n, t, e) : gme(t) ? yme(n, t, e) : qC(t) ? ZC(n, t, e) : JC(t) ? QC(n, t, e) : r.fill && qC(r.fill) ? ZC(r, r.fill, e) : r.fill && JC(r.fill) ? QC(r, r.fill, e) : _me(r, e)
}

function Mh(t, e) {
    const {
        width: n,
        alignment: r,
        miterLimit: i,
        cap: s,
        join: o,
        pixelLine: a,
        ...l
    } = e, c = Po(t, l);
    return c ? {
        width: n,
        alignment: r,
        miterLimit: i,
        cap: s,
        join: o,
        pixelLine: a,
        ...c
    } : null
}
const bme = new ct,
    eP = new Ce,
    ew = class zr extends rr {
        constructor() {
            super(...arguments), this.uid = yt("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this._activePath = new Al, this._transform = new Ce, this._fillStyle = { ...zr.defaultFillStyle
            }, this._strokeStyle = { ...zr.defaultStrokeStyle
            }, this._stateStack = [], this._tick = 0, this._bounds = new rn, this._boundsDirty = !0
        }
        clone() {
            const e = new zr;
            return e.batchMode = this.batchMode, e.instructions = this.instructions.slice(), e._activePath = this._activePath.clone(), e._transform = this._transform.clone(), e._fillStyle = { ...this._fillStyle
            }, e._strokeStyle = { ...this._strokeStyle
            }, e._stateStack = this._stateStack.slice(), e._bounds = this._bounds.clone(), e._boundsDirty = !0, e
        }
        get fillStyle() {
            return this._fillStyle
        }
        set fillStyle(e) {
            this._fillStyle = Po(e, zr.defaultFillStyle)
        }
        get strokeStyle() {
            return this._strokeStyle
        }
        set strokeStyle(e) {
            this._strokeStyle = Mh(e, zr.defaultStrokeStyle)
        }
        setFillStyle(e) {
            return this._fillStyle = Po(e, zr.defaultFillStyle), this
        }
        setStrokeStyle(e) {
            return this._strokeStyle = Po(e, zr.defaultStrokeStyle), this
        }
        texture(e, n, r, i, s, o) {
            return this.instructions.push({
                action: "texture",
                data: {
                    image: e,
                    dx: r || 0,
                    dy: i || 0,
                    dw: s || e.frame.width,
                    dh: o || e.frame.height,
                    transform: this._transform.clone(),
                    alpha: this._fillStyle.alpha,
                    style: n ? rt.shared.setValue(n).toNumber() : 16777215
                }
            }), this.onUpdate(), this
        }
        beginPath() {
            return this._activePath = new Al, this
        }
        fill(e, n) {
            let r;
            const i = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && i && i.action === "stroke" ? r = i.data.path : r = this._activePath.clone(), r ? (e != null && (n !== void 0 && typeof e == "number" && ($e(Ye, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), e = {
                color: e,
                alpha: n
            }), this._fillStyle = Po(e, zr.defaultFillStyle)), this.instructions.push({
                action: "fill",
                data: {
                    style: this.fillStyle,
                    path: r
                }
            }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this
        }
        _initNextPathLocation() {
            const {
                x: e,
                y: n
            } = this._activePath.getLastPoint(ct.shared);
            this._activePath.clear(), this._activePath.moveTo(e, n)
        }
        stroke(e) {
            let n;
            const r = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && r && r.action === "fill" ? n = r.data.path : n = this._activePath.clone(), n ? (e != null && (this._strokeStyle = Mh(e, zr.defaultStrokeStyle)), this.instructions.push({
                action: "stroke",
                data: {
                    style: this.strokeStyle,
                    path: n
                }
            }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this
        }
        cut() {
            for (let e = 0; e < 2; e++) {
                const n = this.instructions[this.instructions.length - 1 - e],
                    r = this._activePath.clone();
                if (n && (n.action === "stroke" || n.action === "fill"))
                    if (n.data.hole) n.data.hole.addPath(r);
                    else {
                        n.data.hole = r;
                        break
                    }
            }
            return this._initNextPathLocation(), this
        }
        arc(e, n, r, i, s, o) {
            this._tick++;
            const a = this._transform;
            return this._activePath.arc(a.a * e + a.c * n + a.tx, a.b * e + a.d * n + a.ty, r, i, s, o), this
        }
        arcTo(e, n, r, i, s) {
            this._tick++;
            const o = this._transform;
            return this._activePath.arcTo(o.a * e + o.c * n + o.tx, o.b * e + o.d * n + o.ty, o.a * r + o.c * i + o.tx, o.b * r + o.d * i + o.ty, s), this
        }
        arcToSvg(e, n, r, i, s, o, a) {
            this._tick++;
            const l = this._transform;
            return this._activePath.arcToSvg(e, n, r, i, s, l.a * o + l.c * a + l.tx, l.b * o + l.d * a + l.ty), this
        }
        bezierCurveTo(e, n, r, i, s, o, a) {
            this._tick++;
            const l = this._transform;
            return this._activePath.bezierCurveTo(l.a * e + l.c * n + l.tx, l.b * e + l.d * n + l.ty, l.a * r + l.c * i + l.tx, l.b * r + l.d * i + l.ty, l.a * s + l.c * o + l.tx, l.b * s + l.d * o + l.ty, a), this
        }
        closePath() {
            var e;
            return this._tick++, (e = this._activePath) == null || e.closePath(), this
        }
        ellipse(e, n, r, i) {
            return this._tick++, this._activePath.ellipse(e, n, r, i, this._transform.clone()), this
        }
        circle(e, n, r) {
            return this._tick++, this._activePath.circle(e, n, r, this._transform.clone()), this
        }
        path(e) {
            return this._tick++, this._activePath.addPath(e, this._transform.clone()), this
        }
        lineTo(e, n) {
            this._tick++;
            const r = this._transform;
            return this._activePath.lineTo(r.a * e + r.c * n + r.tx, r.b * e + r.d * n + r.ty), this
        }
        moveTo(e, n) {
            this._tick++;
            const r = this._transform,
                i = this._activePath.instructions,
                s = r.a * e + r.c * n + r.tx,
                o = r.b * e + r.d * n + r.ty;
            return i.length === 1 && i[0].action === "moveTo" ? (i[0].data[0] = s, i[0].data[1] = o, this) : (this._activePath.moveTo(s, o), this)
        }
        quadraticCurveTo(e, n, r, i, s) {
            this._tick++;
            const o = this._transform;
            return this._activePath.quadraticCurveTo(o.a * e + o.c * n + o.tx, o.b * e + o.d * n + o.ty, o.a * r + o.c * i + o.tx, o.b * r + o.d * i + o.ty, s), this
        }
        rect(e, n, r, i) {
            return this._tick++, this._activePath.rect(e, n, r, i, this._transform.clone()), this
        }
        roundRect(e, n, r, i, s) {
            return this._tick++, this._activePath.roundRect(e, n, r, i, s, this._transform.clone()), this
        }
        poly(e, n) {
            return this._tick++, this._activePath.poly(e, n, this._transform.clone()), this
        }
        regularPoly(e, n, r, i, s = 0, o) {
            return this._tick++, this._activePath.regularPoly(e, n, r, i, s, o), this
        }
        roundPoly(e, n, r, i, s, o) {
            return this._tick++, this._activePath.roundPoly(e, n, r, i, s, o), this
        }
        roundShape(e, n, r, i) {
            return this._tick++, this._activePath.roundShape(e, n, r, i), this
        }
        filletRect(e, n, r, i, s) {
            return this._tick++, this._activePath.filletRect(e, n, r, i, s), this
        }
        chamferRect(e, n, r, i, s, o) {
            return this._tick++, this._activePath.chamferRect(e, n, r, i, s, o), this
        }
        star(e, n, r, i, s = 0, o = 0) {
            return this._tick++, this._activePath.star(e, n, r, i, s, o, this._transform.clone()), this
        }
        svg(e) {
            return this._tick++, pme(e, this), this
        }
        restore() {
            const e = this._stateStack.pop();
            return e && (this._transform = e.transform, this._fillStyle = e.fillStyle, this._strokeStyle = e.strokeStyle), this
        }
        save() {
            return this._stateStack.push({
                transform: this._transform.clone(),
                fillStyle: { ...this._fillStyle
                },
                strokeStyle: { ...this._strokeStyle
                }
            }), this
        }
        getTransform() {
            return this._transform
        }
        resetTransform() {
            return this._transform.identity(), this
        }
        rotate(e) {
            return this._transform.rotate(e), this
        }
        scale(e, n = e) {
            return this._transform.scale(e, n), this
        }
        setTransform(e, n, r, i, s, o) {
            return e instanceof Ce ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this) : (this._transform.set(e, n, r, i, s, o), this)
        }
        transform(e, n, r, i, s, o) {
            return e instanceof Ce ? (this._transform.append(e), this) : (eP.set(e, n, r, i, s, o), this._transform.append(eP), this)
        }
        translate(e, n = e) {
            return this._transform.translate(e, n), this
        }
        clear() {
            return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this
        }
        onUpdate() {
            this.dirty || (this.emit("update", this, 16), this.dirty = !0, this._boundsDirty = !0)
        }
        get bounds() {
            if (!this._boundsDirty) return this._bounds;
            const e = this._bounds;
            e.clear();
            for (let n = 0; n < this.instructions.length; n++) {
                const r = this.instructions[n],
                    i = r.action;
                if (i === "fill") {
                    const s = r.data;
                    e.addBounds(s.path.bounds)
                } else if (i === "texture") {
                    const s = r.data;
                    e.addFrame(s.dx, s.dy, s.dx + s.dw, s.dy + s.dh, s.transform)
                }
                if (i === "stroke") {
                    const s = r.data,
                        o = s.style.alignment,
                        a = s.style.width * (1 - o),
                        l = s.path.bounds;
                    e.addFrame(l.minX - a, l.minY - a, l.maxX + a, l.maxY + a)
                }
            }
            return e
        }
        containsPoint(e) {
            var i;
            if (!this.bounds.containsPoint(e.x, e.y)) return !1;
            const n = this.instructions;
            let r = !1;
            for (let s = 0; s < n.length; s++) {
                const o = n[s],
                    a = o.data,
                    l = a.path;
                if (!o.action || !l) continue;
                const c = a.style,
                    u = l.shapePath.shapePrimitives;
                for (let d = 0; d < u.length; d++) {
                    const f = u[d].shape;
                    if (!c || !f) continue;
                    const h = u[d].transform,
                        p = h ? h.applyInverse(e, bme) : e;
                    if (o.action === "fill") r = f.contains(p.x, p.y);
                    else {
                        const y = c;
                        r = f.strokeContains(p.x, p.y, y.width, y.alignment)
                    }
                    const b = a.hole;
                    if (b) {
                        const y = (i = b.shapePath) == null ? void 0 : i.shapePrimitives;
                        if (y)
                            for (let m = 0; m < y.length; m++) y[m].shape.contains(p.x, p.y) && (r = !1)
                    }
                    if (r) return !0
                }
            }
            return r
        }
        destroy(e = !1) {
            if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
                const r = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
                this._fillStyle.texture && this._fillStyle.texture.destroy(r), this._strokeStyle.texture && this._strokeStyle.texture.destroy(r)
            }
            this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null
        }
    };
ew.defaultFillStyle = {
    color: 16777215,
    alpha: 1,
    texture: we.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local"
};
ew.defaultStrokeStyle = {
    width: 1,
    color: 16777215,
    alpha: 1,
    alignment: .5,
    miterLimit: 10,
    cap: "butt",
    join: "miter",
    texture: we.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local",
    pixelLine: !1
};
let dr = ew;
const tP = ["align", "breakWords", "cssOverrides", "fontVariant", "fontWeight", "leading", "letterSpacing", "lineHeight", "padding", "textBaseline", "trim", "whiteSpace", "wordWrap", "wordWrapWidth", "fontFamily", "fontStyle", "fontSize"];

function d$(t) {
    const e = [];
    let n = 0;
    for (let r = 0; r < tP.length; r++) {
        const i = `_${tP[r]}`;
        e[n++] = t[i]
    }
    return n = f$(t._fill, e, n), n = xme(t._stroke, e, n), n = wme(t.dropShadow, e, n), e.join("-")
}

function f$(t, e, n) {
    var r;
    return t && (e[n++] = t.color, e[n++] = t.alpha, e[n++] = (r = t.fill) == null ? void 0 : r.styleKey), n
}

function xme(t, e, n) {
    return t && (n = f$(t, e, n), e[n++] = t.width, e[n++] = t.alignment, e[n++] = t.cap, e[n++] = t.join, e[n++] = t.miterLimit), n
}

function wme(t, e, n) {
    return t && (e[n++] = t.alpha, e[n++] = t.angle, e[n++] = t.blur, e[n++] = t.distance, e[n++] = rt.shared.setValue(t.color).toNumber()), n
}
const tw = class Na extends rr {
    constructor(e = {}) {
        super(), Eme(e);
        const n = { ...Na.defaultTextStyle,
            ...e
        };
        for (const r in n) {
            const i = r;
            this[i] = n[r]
        }
        this.update()
    }
    get align() {
        return this._align
    }
    set align(e) {
        this._align = e, this.update()
    }
    get breakWords() {
        return this._breakWords
    }
    set breakWords(e) {
        this._breakWords = e, this.update()
    }
    get dropShadow() {
        return this._dropShadow
    }
    set dropShadow(e) {
        e !== null && typeof e == "object" ? this._dropShadow = this._createProxy({ ...Na.defaultDropShadow,
            ...e
        }) : this._dropShadow = e ? this._createProxy({ ...Na.defaultDropShadow
        }) : null, this.update()
    }
    get fontFamily() {
        return this._fontFamily
    }
    set fontFamily(e) {
        this._fontFamily = e, this.update()
    }
    get fontSize() {
        return this._fontSize
    }
    set fontSize(e) {
        typeof e == "string" ? this._fontSize = parseInt(e, 10) : this._fontSize = e, this.update()
    }
    get fontStyle() {
        return this._fontStyle
    }
    set fontStyle(e) {
        this._fontStyle = e.toLowerCase(), this.update()
    }
    get fontVariant() {
        return this._fontVariant
    }
    set fontVariant(e) {
        this._fontVariant = e, this.update()
    }
    get fontWeight() {
        return this._fontWeight
    }
    set fontWeight(e) {
        this._fontWeight = e, this.update()
    }
    get leading() {
        return this._leading
    }
    set leading(e) {
        this._leading = e, this.update()
    }
    get letterSpacing() {
        return this._letterSpacing
    }
    set letterSpacing(e) {
        this._letterSpacing = e, this.update()
    }
    get lineHeight() {
        return this._lineHeight
    }
    set lineHeight(e) {
        this._lineHeight = e, this.update()
    }
    get padding() {
        return this._padding
    }
    set padding(e) {
        this._padding = e, this.update()
    }
    get trim() {
        return this._trim
    }
    set trim(e) {
        this._trim = e, this.update()
    }
    get textBaseline() {
        return this._textBaseline
    }
    set textBaseline(e) {
        this._textBaseline = e, this.update()
    }
    get whiteSpace() {
        return this._whiteSpace
    }
    set whiteSpace(e) {
        this._whiteSpace = e, this.update()
    }
    get wordWrap() {
        return this._wordWrap
    }
    set wordWrap(e) {
        this._wordWrap = e, this.update()
    }
    get wordWrapWidth() {
        return this._wordWrapWidth
    }
    set wordWrapWidth(e) {
        this._wordWrapWidth = e, this.update()
    }
    get fill() {
        return this._originalFill
    }
    set fill(e) {
        e !== this._originalFill && (this._originalFill = e, this._isFillStyle(e) && (this._originalFill = this._createProxy({ ...dr.defaultFillStyle,
            ...e
        }, () => {
            this._fill = Po({ ...this._originalFill
            }, dr.defaultFillStyle)
        })), this._fill = Po(e === 0 ? "black" : e, dr.defaultFillStyle), this.update())
    }
    get stroke() {
        return this._originalStroke
    }
    set stroke(e) {
        e !== this._originalStroke && (this._originalStroke = e, this._isFillStyle(e) && (this._originalStroke = this._createProxy({ ...dr.defaultStrokeStyle,
            ...e
        }, () => {
            this._stroke = Mh({ ...this._originalStroke
            }, dr.defaultStrokeStyle)
        })), this._stroke = Mh(e, dr.defaultStrokeStyle), this.update())
    }
    _generateKey() {
        return this._styleKey = d$(this), this._styleKey
    }
    update() {
        this._styleKey = null, this.emit("update", this)
    }
    reset() {
        const e = Na.defaultTextStyle;
        for (const n in e) this[n] = e[n]
    }
    get styleKey() {
        return this._styleKey || this._generateKey()
    }
    clone() {
        return new Na({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this._dropShadow ? { ...this._dropShadow
            } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            leading: this.leading,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            textBaseline: this.textBaseline,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth
        })
    }
    destroy(e = !1) {
        var r, i, s, o;
        if (this.removeAllListeners(), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
            const a = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
            (r = this._fill) != null && r.texture && this._fill.texture.destroy(a), (i = this._originalFill) != null && i.texture && this._originalFill.texture.destroy(a), (s = this._stroke) != null && s.texture && this._stroke.texture.destroy(a), (o = this._originalStroke) != null && o.texture && this._originalStroke.texture.destroy(a)
        }
        this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null
    }
    _createProxy(e, n) {
        return new Proxy(e, {
            set: (r, i, s) => (r[i] = s, n == null || n(i, s), this.update(), !0)
        })
    }
    _isFillStyle(e) {
        return (e ? ? null) !== null && !(rt.isColorLike(e) || e instanceof Hs || e instanceof tm)
    }
};
tw.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5
};
tw.defaultTextStyle = {
    align: "left",
    breakWords: !1,
    dropShadow: null,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: null,
    textBaseline: "alphabetic",
    trim: !1,
    whiteSpace: "pre",
    wordWrap: !1,
    wordWrapWidth: 100
};
let Wi = tw;

function Eme(t) {
    const e = t;
    if (typeof e.dropShadow == "boolean" && e.dropShadow) {
        const n = Wi.defaultDropShadow;
        t.dropShadow = {
            alpha: e.dropShadowAlpha ? ? n.alpha,
            angle: e.dropShadowAngle ? ? n.angle,
            blur: e.dropShadowBlur ? ? n.blur,
            color: e.dropShadowColor ? ? n.color,
            distance: e.dropShadowDistance ? ? n.distance
        }
    }
    if (e.strokeThickness !== void 0) {
        $e(Ye, "strokeThickness is now a part of stroke");
        const n = e.stroke;
        let r = {};
        if (rt.isColorLike(n)) r.color = n;
        else if (n instanceof Hs || n instanceof tm) r.fill = n;
        else if (Object.hasOwnProperty.call(n, "color") || Object.hasOwnProperty.call(n, "fill")) r = n;
        else throw new Error("Invalid stroke value.");
        t.stroke = { ...r,
            width: e.strokeThickness
        }
    }
    if (Array.isArray(e.fillGradientStops)) {
        $e(Ye, "gradient fill is now a fill pattern: `new FillGradient(...)`");
        let n;
        t.fontSize == null ? t.fontSize = Wi.defaultTextStyle.fontSize : typeof t.fontSize == "string" ? n = parseInt(t.fontSize, 10) : n = t.fontSize;
        const r = new Hs({
                start: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: (n || 0) * 1.7
                }
            }),
            i = e.fillGradientStops.map(s => rt.shared.setValue(s).toNumber());
        i.forEach((s, o) => {
            const a = o / (i.length - 1);
            r.addColorStop(a, s)
        }), t.fill = {
            fill: r
        }
    }
}
class Sme {
    constructor(e) {
        this._canvasPool = Object.create(null), this.canvasOptions = e || {}, this.enableFullScreen = !1
    }
    _createCanvasAndContext(e, n) {
        const r = He.get().createCanvas();
        r.width = e, r.height = n;
        const i = r.getContext("2d");
        return {
            canvas: r,
            context: i
        }
    }
    getOptimalCanvasAndContext(e, n, r = 1) {
        e = Math.ceil(e * r - 1e-6), n = Math.ceil(n * r - 1e-6), e = Tl(e), n = Tl(n);
        const i = (e << 17) + (n << 1);
        this._canvasPool[i] || (this._canvasPool[i] = []);
        let s = this._canvasPool[i].pop();
        return s || (s = this._createCanvasAndContext(e, n)), s
    }
    returnCanvasAndContext(e) {
        const n = e.canvas,
            {
                width: r,
                height: i
            } = n,
            s = (r << 17) + (i << 1);
        e.context.clearRect(0, 0, r, i), this._canvasPool[s].push(e)
    }
    clear() {
        this._canvasPool = {}
    }
}
const Li = new Sme,
    Tme = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];

function kh(t) {
    const e = typeof t.fontSize == "number" ? `${t.fontSize}px` : t.fontSize;
    let n = t.fontFamily;
    Array.isArray(t.fontFamily) || (n = t.fontFamily.split(","));
    for (let r = n.length - 1; r >= 0; r--) {
        let i = n[r].trim();
        !/([\"\'])[^\'\"]+\1/.test(i) && !Tme.includes(i) && (i = `"${i}"`), n[r] = i
    }
    return `${t.fontStyle} ${t.fontVariant} ${t.fontWeight} ${e} ${n.join(",")}`
}
const mv = {
        willReadFrequently: !0
    },
    Fr = class Te {
        static get experimentalLetterSpacingSupported() {
            let e = Te._experimentalLetterSpacingSupported;
            if (e !== void 0) {
                const n = He.get().getCanvasRenderingContext2D().prototype;
                e = Te._experimentalLetterSpacingSupported = "letterSpacing" in n || "textLetterSpacing" in n
            }
            return e
        }
        constructor(e, n, r, i, s, o, a, l, c) {
            this.text = e, this.style = n, this.width = r, this.height = i, this.lines = s, this.lineWidths = o, this.lineHeight = a, this.maxLineWidth = l, this.fontProperties = c
        }
        static measureText(e = " ", n, r = Te._canvas, i = n.wordWrap) {
            var g;
            const s = `${e}:${n.styleKey}`;
            if (Te._measurementCache[s]) return Te._measurementCache[s];
            const o = kh(n),
                a = Te.measureFont(o);
            a.fontSize === 0 && (a.fontSize = n.fontSize, a.ascent = n.fontSize);
            const l = Te.__context;
            l.font = o;
            const u = (i ? Te._wordWrap(e, n, r) : e).split(/(?:\r\n|\r|\n)/),
                d = new Array(u.length);
            let f = 0;
            for (let v = 0; v < u.length; v++) {
                const _ = Te._measureText(u[v], n.letterSpacing, l);
                d[v] = _, f = Math.max(f, _)
            }
            const h = ((g = n._stroke) == null ? void 0 : g.width) || 0;
            let p = f + h;
            n.dropShadow && (p += n.dropShadow.distance);
            const b = n.lineHeight || a.fontSize;
            let y = Math.max(b, a.fontSize + h) + (u.length - 1) * (b + n.leading);
            return n.dropShadow && (y += n.dropShadow.distance), new Te(e, n, p, y, u, d, b + n.leading, f, a)
        }
        static _measureText(e, n, r) {
            let i = !1;
            Te.experimentalLetterSpacingSupported && (Te.experimentalLetterSpacing ? (r.letterSpacing = `${n}px`, r.textLetterSpacing = `${n}px`, i = !0) : (r.letterSpacing = "0px", r.textLetterSpacing = "0px"));
            const s = r.measureText(e);
            let o = s.width;
            const a = -s.actualBoundingBoxLeft;
            let c = s.actualBoundingBoxRight - a;
            if (o > 0)
                if (i) o -= n, c -= n;
                else {
                    const u = (Te.graphemeSegmenter(e).length - 1) * n;
                    o += u, c += u
                }
            return Math.max(o, c)
        }
        static _wordWrap(e, n, r = Te._canvas) {
            const i = r.getContext("2d", mv);
            let s = 0,
                o = "",
                a = "";
            const l = Object.create(null),
                {
                    letterSpacing: c,
                    whiteSpace: u
                } = n,
                d = Te._collapseSpaces(u),
                f = Te._collapseNewlines(u);
            let h = !d;
            const p = n.wordWrapWidth + c,
                b = Te._tokenize(e);
            for (let y = 0; y < b.length; y++) {
                let m = b[y];
                if (Te._isNewline(m)) {
                    if (!f) {
                        a += Te._addLine(o), h = !d, o = "", s = 0;
                        continue
                    }
                    m = " "
                }
                if (d) {
                    const v = Te.isBreakingSpace(m),
                        _ = Te.isBreakingSpace(o[o.length - 1]);
                    if (v && _) continue
                }
                const g = Te._getFromCache(m, c, l, i);
                if (g > p)
                    if (o !== "" && (a += Te._addLine(o), o = "", s = 0), Te.canBreakWords(m, n.breakWords)) {
                        const v = Te.wordWrapSplit(m);
                        for (let _ = 0; _ < v.length; _++) {
                            let x = v[_],
                                w = x,
                                S = 1;
                            for (; v[_ + S];) {
                                const A = v[_ + S];
                                if (!Te.canBreakChars(w, A, m, _, n.breakWords)) x += A;
                                else break;
                                w = A, S++
                            }
                            _ += S - 1;
                            const C = Te._getFromCache(x, c, l, i);
                            C + s > p && (a += Te._addLine(o), h = !1, o = "", s = 0), o += x, s += C
                        }
                    } else {
                        o.length > 0 && (a += Te._addLine(o), o = "", s = 0);
                        const v = y === b.length - 1;
                        a += Te._addLine(m, !v), h = !1, o = "", s = 0
                    }
                else g + s > p && (h = !1, a += Te._addLine(o), o = "", s = 0), (o.length > 0 || !Te.isBreakingSpace(m) || h) && (o += m, s += g)
            }
            return a += Te._addLine(o, !1), a
        }
        static _addLine(e, n = !0) {
            return e = Te._trimRight(e), e = n ? `${e}
` : e, e
        }
        static _getFromCache(e, n, r, i) {
            let s = r[e];
            return typeof s != "number" && (s = Te._measureText(e, n, i) + n, r[e] = s), s
        }
        static _collapseSpaces(e) {
            return e === "normal" || e === "pre-line"
        }
        static _collapseNewlines(e) {
            return e === "normal"
        }
        static _trimRight(e) {
            if (typeof e != "string") return "";
            for (let n = e.length - 1; n >= 0; n--) {
                const r = e[n];
                if (!Te.isBreakingSpace(r)) break;
                e = e.slice(0, -1)
            }
            return e
        }
        static _isNewline(e) {
            return typeof e != "string" ? !1 : Te._newlines.includes(e.charCodeAt(0))
        }
        static isBreakingSpace(e, n) {
            return typeof e != "string" ? !1 : Te._breakingSpaces.includes(e.charCodeAt(0))
        }
        static _tokenize(e) {
            const n = [];
            let r = "";
            if (typeof e != "string") return n;
            for (let i = 0; i < e.length; i++) {
                const s = e[i],
                    o = e[i + 1];
                if (Te.isBreakingSpace(s, o) || Te._isNewline(s)) {
                    r !== "" && (n.push(r), r = ""), n.push(s);
                    continue
                }
                r += s
            }
            return r !== "" && n.push(r), n
        }
        static canBreakWords(e, n) {
            return n
        }
        static canBreakChars(e, n, r, i, s) {
            return !0
        }
        static wordWrapSplit(e) {
            return Te.graphemeSegmenter(e)
        }
        static measureFont(e) {
            if (Te._fonts[e]) return Te._fonts[e];
            const n = Te._context;
            n.font = e;
            const r = n.measureText(Te.METRICS_STRING + Te.BASELINE_SYMBOL),
                i = {
                    ascent: r.actualBoundingBoxAscent,
                    descent: r.actualBoundingBoxDescent,
                    fontSize: r.actualBoundingBoxAscent + r.actualBoundingBoxDescent
                };
            return Te._fonts[e] = i, i
        }
        static clearMetrics(e = "") {
            e ? delete Te._fonts[e] : Te._fonts = {}
        }
        static get _canvas() {
            if (!Te.__canvas) {
                let e;
                try {
                    const n = new OffscreenCanvas(0, 0),
                        r = n.getContext("2d", mv);
                    if (r != null && r.measureText) return Te.__canvas = n, n;
                    e = He.get().createCanvas()
                } catch {
                    e = He.get().createCanvas()
                }
                e.width = e.height = 10, Te.__canvas = e
            }
            return Te.__canvas
        }
        static get _context() {
            return Te.__context || (Te.__context = Te._canvas.getContext("2d", mv)), Te.__context
        }
    };
Fr.METRICS_STRING = "|ÉqÅ";
Fr.BASELINE_SYMBOL = "M";
Fr.BASELINE_MULTIPLIER = 1.4;
Fr.HEIGHT_MULTIPLIER = 2;
Fr.graphemeSegmenter = (() => {
    if (typeof(Intl == null ? void 0 : Intl.Segmenter) == "function") {
        const t = new Intl.Segmenter;
        return e => [...t.segment(e)].map(n => n.segment)
    }
    return t => [...t]
})();
Fr.experimentalLetterSpacing = !1;
Fr._fonts = {};
Fr._newlines = [10, 13];
Fr._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
Fr._measurementCache = {};
let Ci = Fr;
const nP = 1e5;

function Bh(t, e, n, r = 0) {
    if (t.texture === we.WHITE && !t.fill) return rt.shared.setValue(t.color).setAlpha(t.alpha ? ? 1).toHexa();
    if (t.fill) {
        if (t.fill instanceof tm) {
            const i = t.fill,
                s = e.createPattern(i.texture.source.resource, "repeat"),
                o = i.transform.copyTo(Ce.shared);
            return o.scale(i.texture.frame.width, i.texture.frame.height), s.setTransform(o), s
        } else if (t.fill instanceof Hs) {
            const i = t.fill,
                s = i.type === "linear",
                o = i.textureSpace === "local";
            let a = 1,
                l = 1;
            o && n && (a = n.width + r, l = n.height + r);
            let c, u = !1;
            if (s) {
                const {
                    start: d,
                    end: f
                } = i;
                c = e.createLinearGradient(d.x * a, d.y * l, f.x * a, f.y * l), u = Math.abs(f.x - d.x) < Math.abs((f.y - d.y) * .1)
            } else {
                const {
                    center: d,
                    innerRadius: f,
                    outerCenter: h,
                    outerRadius: p
                } = i;
                c = e.createRadialGradient(d.x * a, d.y * l, f * a, h.x * a, h.y * l, p * a)
            }
            if (u && o && n) {
                const d = n.lineHeight / l;
                for (let f = 0; f < n.lines.length; f++) {
                    const h = (f * n.lineHeight + r / 2) / l;
                    i.colorStops.forEach(p => {
                        const b = h + p.offset * d;
                        c.addColorStop(Math.floor(b * nP) / nP, rt.shared.setValue(p.color).toHex())
                    })
                }
            } else i.colorStops.forEach(d => {
                c.addColorStop(d.offset, rt.shared.setValue(d.color).toHex())
            });
            return c
        }
    } else {
        const i = e.createPattern(t.texture.source.resource, "repeat"),
            s = t.matrix.copyTo(Ce.shared);
        return s.scale(t.texture.frame.width, t.texture.frame.height), i.setTransform(s), i
    }
    return Me("FillStyle not recognised", t), "red"
}

function h$(t) {
    if (t === "") return [];
    typeof t == "string" && (t = [t]);
    const e = [];
    for (let n = 0, r = t.length; n < r; n++) {
        const i = t[n];
        if (Array.isArray(i)) {
            if (i.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${i.length}.`);
            if (i[0].length === 0 || i[1].length === 0) throw new Error("[BitmapFont]: Invalid character delimiter.");
            const s = i[0].charCodeAt(0),
                o = i[1].charCodeAt(0);
            if (o < s) throw new Error("[BitmapFont]: Invalid character range.");
            for (let a = s, l = o; a <= l; a++) e.push(String.fromCharCode(a))
        } else e.push(...Array.from(i))
    }
    if (e.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return e
}
const p$ = class m$ extends KD {
    constructor(e) {
        super(), this.resolution = 1, this.pages = [], this._padding = 0, this._measureCache = Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentPageIndex = -1, this._skipKerning = !1;
        const n = { ...m$.defaultOptions,
            ...e
        };
        this._textureSize = n.textureSize, this._mipmap = n.mipmap;
        const r = n.style.clone();
        n.overrideFill && (r._fill.color = 16777215, r._fill.alpha = 1, r._fill.texture = we.WHITE, r._fill.fill = null), this.applyFillAsTint = n.overrideFill;
        const i = r.fontSize;
        r.fontSize = this.baseMeasurementFontSize;
        const s = kh(r);
        n.overrideSize ? r._stroke && (r._stroke.width *= this.baseRenderedFontSize / i) : r.fontSize = this.baseRenderedFontSize = i, this._style = r, this._skipKerning = n.skipKerning ? ? !1, this.resolution = n.resolution ? ? 1, this._padding = n.padding ? ? 4, this.fontMetrics = Ci.measureFont(s), this.lineHeight = r.lineHeight || this.fontMetrics.fontSize || r.fontSize
    }
    ensureCharacters(e) {
        var y, m;
        const n = h$(e).filter(g => !this._currentChars.includes(g)).filter((g, v, _) => _.indexOf(g) === v);
        if (!n.length) return;
        this._currentChars = [...this._currentChars, ...n];
        let r;
        this._currentPageIndex === -1 ? r = this._nextPage() : r = this.pages[this._currentPageIndex];
        let {
            canvas: i,
            context: s
        } = r.canvasAndContext, o = r.texture.source;
        const a = this._style;
        let l = this._currentX,
            c = this._currentY;
        const u = this.baseRenderedFontSize / this.baseMeasurementFontSize,
            d = this._padding * u;
        let f = 0,
            h = !1;
        const p = i.width / this.resolution,
            b = i.height / this.resolution;
        for (let g = 0; g < n.length; g++) {
            const v = n[g],
                _ = Ci.measureText(v, a, i, !1);
            _.lineHeight = _.height;
            const x = _.width * u,
                w = Math.ceil((a.fontStyle === "italic" ? 2 : 1) * x),
                S = _.height * u,
                C = w + d * 2,
                A = S + d * 2;
            if (h = !1, v !== `
` && v !== "\r" && v !== "	" && v !== " " && (h = !0, f = Math.ceil(Math.max(A, f))), l + C > p && (c += f, f = A, l = 0, c + f > b)) {
                o.update();
                const E = this._nextPage();
                i = E.canvasAndContext.canvas, s = E.canvasAndContext.context, o = E.texture.source, c = 0
            }
            const T = x / u - (((y = a.dropShadow) == null ? void 0 : y.distance) ? ? 0) - (((m = a._stroke) == null ? void 0 : m.width) ? ? 0);
            if (this.chars[v] = {
                    id: v.codePointAt(0),
                    xOffset: -this._padding,
                    yOffset: -this._padding,
                    xAdvance: T,
                    kerning: {}
                }, h) {
                this._drawGlyph(s, _, l + d, c + d, u, a);
                const E = o.width * u,
                    P = o.height * u,
                    B = new at(l / E * o.width, c / P * o.height, C / E * o.width, A / P * o.height);
                this.chars[v].texture = new we({
                    source: o,
                    frame: B
                }), l += Math.ceil(C)
            }
        }
        o.update(), this._currentX = l, this._currentY = c, this._skipKerning && this._applyKerning(n, s)
    }
    get pageTextures() {
        return $e(Ye, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages
    }
    _applyKerning(e, n) {
        const r = this._measureCache;
        for (let i = 0; i < e.length; i++) {
            const s = e[i];
            for (let o = 0; o < this._currentChars.length; o++) {
                const a = this._currentChars[o];
                let l = r[s];
                l || (l = r[s] = n.measureText(s).width);
                let c = r[a];
                c || (c = r[a] = n.measureText(a).width);
                let u = n.measureText(s + a).width,
                    d = u - (l + c);
                d && (this.chars[s].kerning[a] = d), u = n.measureText(s + a).width, d = u - (l + c), d && (this.chars[a].kerning[s] = d)
            }
        }
    }
    _nextPage() {
        this._currentPageIndex++;
        const e = this.resolution,
            n = Li.getOptimalCanvasAndContext(this._textureSize, this._textureSize, e);
        this._setupContext(n.context, this._style, e);
        const r = e * (this.baseRenderedFontSize / this.baseMeasurementFontSize),
            i = new we({
                source: new na({
                    resource: n.canvas,
                    resolution: r,
                    alphaMode: "premultiply-alpha-on-upload",
                    autoGenerateMipmaps: this._mipmap
                })
            }),
            s = {
                canvasAndContext: n,
                texture: i
            };
        return this.pages[this._currentPageIndex] = s, s
    }
    _setupContext(e, n, r) {
        n.fontSize = this.baseRenderedFontSize, e.scale(r, r), e.font = kh(n), n.fontSize = this.baseMeasurementFontSize, e.textBaseline = n.textBaseline;
        const i = n._stroke,
            s = (i == null ? void 0 : i.width) ? ? 0;
        if (i && (e.lineWidth = s, e.lineJoin = i.join, e.miterLimit = i.miterLimit, e.strokeStyle = Bh(i, e)), n._fill && (e.fillStyle = Bh(n._fill, e)), n.dropShadow) {
            const o = n.dropShadow,
                a = rt.shared.setValue(o.color).toArray(),
                l = o.blur * r,
                c = o.distance * r;
            e.shadowColor = `rgba(${a[0]*255},${a[1]*255},${a[2]*255},${o.alpha})`, e.shadowBlur = l, e.shadowOffsetX = Math.cos(o.angle) * c, e.shadowOffsetY = Math.sin(o.angle) * c
        } else e.shadowColor = "black", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0
    }
    _drawGlyph(e, n, r, i, s, o) {
        const a = n.text,
            l = n.fontProperties,
            c = o._stroke,
            u = ((c == null ? void 0 : c.width) ? ? 0) * s,
            d = r + u / 2,
            f = i - u / 2,
            h = l.descent * s,
            p = n.lineHeight * s;
        o.stroke && u && e.strokeText(a, d, f + p - h), o._fill && e.fillText(a, d, f + p - h)
    }
    destroy() {
        super.destroy();
        for (let e = 0; e < this.pages.length; e++) {
            const {
                canvasAndContext: n,
                texture: r
            } = this.pages[e];
            Li.returnCanvasAndContext(n), r.destroy(!0)
        }
        this.pages = null
    }
};
p$.defaultOptions = {
    textureSize: 512,
    style: new Wi,
    mipmap: !0
};
let rP = p$;

function g$(t, e, n, r) {
    const i = {
        width: 0,
        height: 0,
        offsetY: 0,
        scale: e.fontSize / n.baseMeasurementFontSize,
        lines: [{
            width: 0,
            charPositions: [],
            spaceWidth: 0,
            spacesIndex: [],
            chars: []
        }]
    };
    i.offsetY = n.baseLineOffset;
    let s = i.lines[0],
        o = null,
        a = !0;
    const l = {
            spaceWord: !1,
            width: 0,
            start: 0,
            index: 0,
            positions: [],
            chars: []
        },
        c = p => {
            const b = s.width;
            for (let y = 0; y < l.index; y++) {
                const m = p.positions[y];
                s.chars.push(p.chars[y]), s.charPositions.push(m + b)
            }
            s.width += p.width, a = !1, l.width = 0, l.index = 0, l.chars.length = 0
        },
        u = () => {
            let p = s.chars.length - 1;
            if (r) {
                let b = s.chars[p];
                for (; b === " ";) s.width -= n.chars[b].xAdvance, b = s.chars[--p]
            }
            i.width = Math.max(i.width, s.width), s = {
                width: 0,
                charPositions: [],
                chars: [],
                spaceWidth: 0,
                spacesIndex: []
            }, a = !0, i.lines.push(s), i.height += n.lineHeight
        },
        d = n.baseMeasurementFontSize / e.fontSize,
        f = e.letterSpacing * d,
        h = e.wordWrapWidth * d;
    for (let p = 0; p < t.length + 1; p++) {
        let b;
        const y = p === t.length;
        y || (b = t[p]);
        const m = n.chars[b] || n.chars[" "];
        if (/(?:\s)/.test(b) || b === "\r" || b === `
` || y) {
            if (!a && e.wordWrap && s.width + l.width - f > h ? (u(), c(l), y || s.charPositions.push(0)) : (l.start = s.width, c(l), y || s.charPositions.push(0)), b === "\r" || b === `
`) s.width !== 0 && u();
            else if (!y) {
                const x = m.xAdvance + (m.kerning[o] || 0) + f;
                s.width += x, s.spaceWidth = x, s.spacesIndex.push(s.charPositions.length), s.chars.push(b)
            }
        } else {
            const _ = m.kerning[o] || 0,
                x = m.xAdvance + _ + f;
            l.positions[l.index++] = l.width + _, l.chars.push(b), l.width += x
        }
        o = b
    }
    return u(), e.align === "center" ? Cme(i) : e.align === "right" ? Pme(i) : e.align === "justify" && Ame(i), i
}

function Cme(t) {
    for (let e = 0; e < t.lines.length; e++) {
        const n = t.lines[e],
            r = t.width / 2 - n.width / 2;
        for (let i = 0; i < n.charPositions.length; i++) n.charPositions[i] += r
    }
}

function Pme(t) {
    for (let e = 0; e < t.lines.length; e++) {
        const n = t.lines[e],
            r = t.width - n.width;
        for (let i = 0; i < n.charPositions.length; i++) n.charPositions[i] += r
    }
}

function Ame(t) {
    const e = t.width;
    for (let n = 0; n < t.lines.length; n++) {
        const r = t.lines[n];
        let i = 0,
            s = r.spacesIndex[i++],
            o = 0;
        const a = r.spacesIndex.length,
            c = (e - r.width) / a;
        for (let u = 0; u < r.charPositions.length; u++) u === s && (s = r.spacesIndex[i++], o += c), r.charPositions[u] += o
    }
}
let hf = 0;
class Ome {
    constructor() {
        this.ALPHA = [
            ["a", "z"],
            ["A", "Z"], " "
        ], this.NUMERIC = [
            ["0", "9"]
        ], this.ALPHANUMERIC = [
            ["a", "z"],
            ["A", "Z"],
            ["0", "9"], " "
        ], this.ASCII = [
            [" ", "~"]
        ], this.defaultOptions = {
            chars: this.ALPHANUMERIC,
            resolution: 1,
            padding: 4,
            skipKerning: !1
        }
    }
    getFont(e, n) {
        var o;
        let r = `${n.fontFamily}-bitmap`,
            i = !0;
        if (n._fill.fill && !n._stroke) r += n._fill.fill.styleKey, i = !1;
        else if (n._stroke || n.dropShadow) {
            let a = n.styleKey;
            a = a.substring(0, a.lastIndexOf("-")), r = `${a}-bitmap`, i = !1
        }
        if (!ft.has(r)) {
            const a = new rP({
                style: n,
                overrideFill: i,
                overrideSize: !0,
                ...this.defaultOptions
            });
            hf++, hf > 50 && Me("BitmapText", `You have dynamically created ${hf} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), a.once("destroy", () => {
                hf--, ft.remove(r)
            }), ft.set(r, a)
        }
        const s = ft.get(r);
        return (o = s.ensureCharacters) == null || o.call(s, e), s
    }
    getLayout(e, n, r = !0) {
        const i = this.getFont(e, n);
        return g$([...e], n, i, r)
    }
    measureText(e, n, r = !0) {
        return this.getLayout(e, n, r)
    }
    install(...e) {
        var c, u, d, f;
        let n = e[0];
        typeof n == "string" && (n = {
            name: n,
            style: e[1],
            chars: (c = e[2]) == null ? void 0 : c.chars,
            resolution: (u = e[2]) == null ? void 0 : u.resolution,
            padding: (d = e[2]) == null ? void 0 : d.padding,
            skipKerning: (f = e[2]) == null ? void 0 : f.skipKerning
        }, $e(Ye, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));
        const r = n == null ? void 0 : n.name;
        if (!r) throw new Error("[BitmapFontManager] Property `name` is required.");
        n = { ...this.defaultOptions,
            ...n
        };
        const i = n.style,
            s = i instanceof Wi ? i : new Wi(i),
            o = s._fill.fill !== null && s._fill.fill !== void 0,
            a = new rP({
                style: s,
                overrideFill: o,
                skipKerning: n.skipKerning,
                padding: n.padding,
                resolution: n.resolution,
                overrideSize: !1
            }),
            l = h$(n.chars);
        return a.ensureCharacters(l.join("")), ft.set(`${r}-bitmap`, a), a.once("destroy", () => ft.remove(`${r}-bitmap`)), a
    }
    uninstall(e) {
        const n = `${e}-bitmap`,
            r = ft.get(n);
        r && r.destroy()
    }
}
const L0 = new Ome;
class v$ extends KD {
    constructor(e, n) {
        super();
        const {
            textures: r,
            data: i
        } = e;
        Object.keys(i.pages).forEach(s => {
            const o = i.pages[parseInt(s, 10)],
                a = r[o.id];
            this.pages.push({
                texture: a
            })
        }), Object.keys(i.chars).forEach(s => {
            const o = i.chars[s],
                {
                    frame: a,
                    source: l
                } = r[o.page],
                c = new at(o.x + a.x, o.y + a.y, o.width, o.height),
                u = new we({
                    source: l,
                    frame: c
                });
            this.chars[s] = {
                id: s.codePointAt(0),
                xOffset: o.xOffset,
                yOffset: o.yOffset,
                xAdvance: o.xAdvance,
                kerning: o.kerning ? ? {},
                texture: u
            }
        }), this.baseRenderedFontSize = i.fontSize, this.baseMeasurementFontSize = i.fontSize, this.fontMetrics = {
            ascent: 0,
            descent: 0,
            fontSize: i.fontSize
        }, this.baseLineOffset = i.baseLineOffset, this.lineHeight = i.lineHeight, this.fontFamily = i.fontFamily, this.distanceField = i.distanceField ? ? {
            type: "none",
            range: 0
        }, this.url = n
    }
    destroy() {
        super.destroy();
        for (let e = 0; e < this.pages.length; e++) {
            const {
                texture: n
            } = this.pages[e];
            n.destroy(!0)
        }
        this.pages = null
    }
    static install(e) {
        L0.install(e)
    }
    static uninstall(e) {
        L0.uninstall(e)
    }
}
const gv = {
        test(t) {
            return typeof t == "string" && t.startsWith("info face=")
        },
        parse(t) {
            const e = t.match(/^[a-z]+\s+.+$/gm),
                n = {
                    info: [],
                    common: [],
                    page: [],
                    char: [],
                    chars: [],
                    kerning: [],
                    kernings: [],
                    distanceField: []
                };
            for (const d in e) {
                const f = e[d].match(/^[a-z]+/gm)[0],
                    h = e[d].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
                    p = {};
                for (const b in h) {
                    const y = h[b].split("="),
                        m = y[0],
                        g = y[1].replace(/"/gm, ""),
                        v = parseFloat(g),
                        _ = isNaN(v) ? g : v;
                    p[m] = _
                }
                n[f].push(p)
            }
            const r = {
                    chars: {},
                    pages: [],
                    lineHeight: 0,
                    fontSize: 0,
                    fontFamily: "",
                    distanceField: null,
                    baseLineOffset: 0
                },
                [i] = n.info,
                [s] = n.common,
                [o] = n.distanceField ? ? [];
            o && (r.distanceField = {
                range: parseInt(o.distanceRange, 10),
                type: o.fieldType
            }), r.fontSize = parseInt(i.size, 10), r.fontFamily = i.face, r.lineHeight = parseInt(s.lineHeight, 10);
            const a = n.page;
            for (let d = 0; d < a.length; d++) r.pages.push({
                id: parseInt(a[d].id, 10) || 0,
                file: a[d].file
            });
            const l = {};
            r.baseLineOffset = r.lineHeight - parseInt(s.base, 10);
            const c = n.char;
            for (let d = 0; d < c.length; d++) {
                const f = c[d],
                    h = parseInt(f.id, 10);
                let p = f.letter ? ? f.char ? ? String.fromCharCode(h);
                p === "space" && (p = " "), l[h] = p, r.chars[p] = {
                    id: h,
                    page: parseInt(f.page, 10) || 0,
                    x: parseInt(f.x, 10),
                    y: parseInt(f.y, 10),
                    width: parseInt(f.width, 10),
                    height: parseInt(f.height, 10),
                    xOffset: parseInt(f.xoffset, 10),
                    yOffset: parseInt(f.yoffset, 10),
                    xAdvance: parseInt(f.xadvance, 10),
                    kerning: {}
                }
            }
            const u = n.kerning || [];
            for (let d = 0; d < u.length; d++) {
                const f = parseInt(u[d].first, 10),
                    h = parseInt(u[d].second, 10),
                    p = parseInt(u[d].amount, 10);
                r.chars[l[h]].kerning[l[f]] = p
            }
            return r
        }
    },
    iP = {
        test(t) {
            const e = t;
            return typeof e != "string" && "getElementsByTagName" in e && e.getElementsByTagName("page").length && e.getElementsByTagName("info")[0].getAttribute("face") !== null
        },
        parse(t) {
            const e = {
                    chars: {},
                    pages: [],
                    lineHeight: 0,
                    fontSize: 0,
                    fontFamily: "",
                    distanceField: null,
                    baseLineOffset: 0
                },
                n = t.getElementsByTagName("info")[0],
                r = t.getElementsByTagName("common")[0],
                i = t.getElementsByTagName("distanceField")[0];
            i && (e.distanceField = {
                type: i.getAttribute("fieldType"),
                range: parseInt(i.getAttribute("distanceRange"), 10)
            });
            const s = t.getElementsByTagName("page"),
                o = t.getElementsByTagName("char"),
                a = t.getElementsByTagName("kerning");
            e.fontSize = parseInt(n.getAttribute("size"), 10), e.fontFamily = n.getAttribute("face"), e.lineHeight = parseInt(r.getAttribute("lineHeight"), 10);
            for (let c = 0; c < s.length; c++) e.pages.push({
                id: parseInt(s[c].getAttribute("id"), 10) || 0,
                file: s[c].getAttribute("file")
            });
            const l = {};
            e.baseLineOffset = e.lineHeight - parseInt(r.getAttribute("base"), 10);
            for (let c = 0; c < o.length; c++) {
                const u = o[c],
                    d = parseInt(u.getAttribute("id"), 10);
                let f = u.getAttribute("letter") ? ? u.getAttribute("char") ? ? String.fromCharCode(d);
                f === "space" && (f = " "), l[d] = f, e.chars[f] = {
                    id: d,
                    page: parseInt(u.getAttribute("page"), 10) || 0,
                    x: parseInt(u.getAttribute("x"), 10),
                    y: parseInt(u.getAttribute("y"), 10),
                    width: parseInt(u.getAttribute("width"), 10),
                    height: parseInt(u.getAttribute("height"), 10),
                    xOffset: parseInt(u.getAttribute("xoffset"), 10),
                    yOffset: parseInt(u.getAttribute("yoffset"), 10),
                    xAdvance: parseInt(u.getAttribute("xadvance"), 10),
                    kerning: {}
                }
            }
            for (let c = 0; c < a.length; c++) {
                const u = parseInt(a[c].getAttribute("first"), 10),
                    d = parseInt(a[c].getAttribute("second"), 10),
                    f = parseInt(a[c].getAttribute("amount"), 10);
                e.chars[l[d]].kerning[l[u]] = f
            }
            return e
        }
    },
    sP = {
        test(t) {
            return typeof t == "string" && t.includes("<font>") ? iP.test(He.get().parseXML(t)) : !1
        },
        parse(t) {
            return iP.parse(He.get().parseXML(t))
        }
    },
    Ime = [".xml", ".fnt"],
    Rme = {
        extension: {
            type: G.CacheParser,
            name: "cacheBitmapFont"
        },
        test: t => t instanceof v$,
        getCacheableAssets(t, e) {
            const n = {};
            return t.forEach(r => {
                n[r] = e, n[`${r}-bitmap`] = e
            }), n[`${e.fontFamily}-bitmap`] = e, n
        }
    },
    Mme = {
        extension: {
            type: G.LoadParser,
            priority: Zs.Normal
        },
        name: "loadBitmapFont",
        test(t) {
            return Ime.includes(Dn.extname(t).toLowerCase())
        },
        async testParse(t) {
            return gv.test(t) || sP.test(t)
        },
        async parse(t, e, n) {
            const r = gv.test(t) ? gv.parse(t) : sP.parse(t),
                {
                    src: i
                } = e,
                {
                    pages: s
                } = r,
                o = [],
                a = r.distanceField ? {
                    scaleMode: "linear",
                    alphaMode: "premultiply-alpha-on-upload",
                    autoGenerateMipmaps: !1,
                    resolution: 1
                } : {};
            for (let d = 0; d < s.length; ++d) {
                const f = s[d].file;
                let h = Dn.join(Dn.dirname(i), f);
                h = E0(h, i), o.push({
                    src: h,
                    data: a
                })
            }
            const l = await n.load(o),
                c = o.map(d => l[d.src]);
            return new v$({
                data: r,
                textures: c
            }, i)
        },
        async load(t, e) {
            return await (await He.get().fetch(t)).text()
        },
        async unload(t, e, n) {
            await Promise.all(t.pages.map(r => n.unload(r.texture.source._sourceOrigin))), t.destroy()
        }
    };
class kme {
    constructor(e, n = !1) {
        this._loader = e, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = n
    }
    add(e) {
        e.forEach(n => {
            this._assetList.push(n)
        }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next()
    }
    async _next() {
        if (this._assetList.length && this._isActive) {
            this._isLoading = !0;
            const e = [],
                n = Math.min(this._assetList.length, this._maxConcurrent);
            for (let r = 0; r < n; r++) e.push(this._assetList.pop());
            await this._loader.load(e), this._isLoading = !1, this._next()
        }
    }
    get active() {
        return this._isActive
    }
    set active(e) {
        this._isActive !== e && (this._isActive = e, e && !this._isLoading && this._next())
    }
}
const Bme = {
    extension: {
        type: G.CacheParser,
        name: "cacheTextureArray"
    },
    test: t => Array.isArray(t) && t.every(e => e instanceof we),
    getCacheableAssets: (t, e) => {
        const n = {};
        return t.forEach(r => {
            e.forEach((i, s) => {
                n[r + (s === 0 ? "" : s + 1)] = i
            })
        }), n
    }
};
async function y$(t) {
    if ("Image" in globalThis) return new Promise(e => {
        const n = new Image;
        n.onload = () => {
            e(!0)
        }, n.onerror = () => {
            e(!1)
        }, n.src = t
    });
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
        try {
            const e = await (await fetch(t)).blob();
            await createImageBitmap(e)
        } catch {
            return !1
        }
        return !0
    }
    return !1
}
const Dme = {
        extension: {
            type: G.DetectionParser,
            priority: 1
        },
        test: async () => y$("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),
        add: async t => [...t, "avif"],
        remove: async t => t.filter(e => e !== "avif")
    },
    oP = ["png", "jpg", "jpeg"],
    $me = {
        extension: {
            type: G.DetectionParser,
            priority: -1
        },
        test: () => Promise.resolve(!0),
        add: async t => [...t, ...oP],
        remove: async t => t.filter(e => !oP.includes(e))
    },
    Fme = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;

function nw(t) {
    return Fme ? !1 : document.createElement("video").canPlayType(t) !== ""
}
const Lme = {
        extension: {
            type: G.DetectionParser,
            priority: 0
        },
        test: async () => nw("video/mp4"),
        add: async t => [...t, "mp4", "m4v"],
        remove: async t => t.filter(e => e !== "mp4" && e !== "m4v")
    },
    Nme = {
        extension: {
            type: G.DetectionParser,
            priority: 0
        },
        test: async () => nw("video/ogg"),
        add: async t => [...t, "ogv"],
        remove: async t => t.filter(e => e !== "ogv")
    },
    Ume = {
        extension: {
            type: G.DetectionParser,
            priority: 0
        },
        test: async () => nw("video/webm"),
        add: async t => [...t, "webm"],
        remove: async t => t.filter(e => e !== "webm")
    },
    Gme = {
        extension: {
            type: G.DetectionParser,
            priority: 0
        },
        test: async () => y$("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),
        add: async t => [...t, "webp"],
        remove: async t => t.filter(e => e !== "webp")
    };
class Hme {
    constructor() {
        this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, {
            set: (e, n, r) => (this._parsersValidated = !1, e[n] = r, !0)
        }), this.promiseCache = {}
    }
    reset() {
        this._parsersValidated = !1, this.promiseCache = {}
    }
    _getLoadPromiseAndParser(e, n) {
        const r = {
            promise: null,
            parser: null
        };
        return r.promise = (async () => {
            var o, a;
            let i = null,
                s = null;
            if (n.loadParser && (s = this._parserHash[n.loadParser], s || Me(`[Assets] specified load parser "${n.loadParser}" not found while loading ${e}`)), !s) {
                for (let l = 0; l < this.parsers.length; l++) {
                    const c = this.parsers[l];
                    if (c.load && ((o = c.test) != null && o.call(c, e, n, this))) {
                        s = c;
                        break
                    }
                }
                if (!s) return Me(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null
            }
            i = await s.load(e, n, this), r.parser = s;
            for (let l = 0; l < this.parsers.length; l++) {
                const c = this.parsers[l];
                c.parse && c.parse && await ((a = c.testParse) == null ? void 0 : a.call(c, i, n, this)) && (i = await c.parse(i, n, this) || i, r.parser = c)
            }
            return i
        })(), r
    }
    async load(e, n) {
        this._parsersValidated || this._validateParsers();
        let r = 0;
        const i = {},
            s = Ih(e),
            o = Er(e, c => ({
                alias: [c],
                src: c,
                data: {}
            })),
            a = o.length,
            l = o.map(async c => {
                const u = Dn.toAbsolute(c.src);
                if (!i[c.src]) try {
                    this.promiseCache[u] || (this.promiseCache[u] = this._getLoadPromiseAndParser(u, c)), i[c.src] = await this.promiseCache[u].promise, n && n(++r / a)
                } catch (d) {
                    throw delete this.promiseCache[u], delete i[c.src], new Error(`[Loader.load] Failed to load ${u}.
${d}`)
                }
            });
        return await Promise.all(l), s ? i[o[0].src] : i
    }
    async unload(e) {
        const r = Er(e, i => ({
            alias: [i],
            src: i
        })).map(async i => {
            var a, l;
            const s = Dn.toAbsolute(i.src),
                o = this.promiseCache[s];
            if (o) {
                const c = await o.promise;
                delete this.promiseCache[s], await ((l = (a = o.parser) == null ? void 0 : a.unload) == null ? void 0 : l.call(a, c, i, this))
            }
        });
        await Promise.all(r)
    }
    _validateParsers() {
        this._parsersValidated = !0, this._parserHash = this._parsers.filter(e => e.name).reduce((e, n) => (n.name ? e[n.name] && Me(`[Assets] loadParser name conflict "${n.name}"`) : Me("[Assets] loadParser should have a name"), { ...e,
            [n.name]: n
        }), {})
    }
}

function jl(t, e) {
    if (Array.isArray(e)) {
        for (const n of e)
            if (t.startsWith(`data:${n}`)) return !0;
        return !1
    }
    return t.startsWith(`data:${e}`)
}

function Vl(t, e) {
    const n = t.split("?")[0],
        r = Dn.extname(n).toLowerCase();
    return Array.isArray(e) ? e.includes(r) : r === e
}
const zme = ".json",
    jme = "application/json",
    Vme = {
        extension: {
            type: G.LoadParser,
            priority: Zs.Low
        },
        name: "loadJson",
        test(t) {
            return jl(t, jme) || Vl(t, zme)
        },
        async load(t) {
            return await (await He.get().fetch(t)).json()
        }
    },
    Wme = ".txt",
    Yme = "text/plain",
    Xme = {
        name: "loadTxt",
        extension: {
            type: G.LoadParser,
            priority: Zs.Low,
            name: "loadTxt"
        },
        test(t) {
            return jl(t, Yme) || Vl(t, Wme)
        },
        async load(t) {
            return await (await He.get().fetch(t)).text()
        }
    },
    Kme = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"],
    qme = [".ttf", ".otf", ".woff", ".woff2"],
    Jme = ["font/ttf", "font/otf", "font/woff", "font/woff2"],
    Zme = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;

function Qme(t) {
    const e = Dn.extname(t),
        i = Dn.basename(t, e).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(a => a.charAt(0).toUpperCase() + a.slice(1));
    let s = i.length > 0;
    for (const a of i)
        if (!a.match(Zme)) {
            s = !1;
            break
        }
    let o = i.join(" ");
    return s || (o = `"${o.replace(/[\\"]/g,"\\$&")}"`), o
}
const ege = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;

function tge(t) {
    return ege.test(t) ? t : encodeURI(t)
}
const nge = {
    extension: {
        type: G.LoadParser,
        priority: Zs.Low
    },
    name: "loadWebFont",
    test(t) {
        return jl(t, Jme) || Vl(t, qme)
    },
    async load(t, e) {
        var r, i, s;
        const n = He.get().getFontFaceSet();
        if (n) {
            const o = [],
                a = ((r = e.data) == null ? void 0 : r.family) ? ? Qme(t),
                l = ((s = (i = e.data) == null ? void 0 : i.weights) == null ? void 0 : s.filter(u => Kme.includes(u))) ? ? ["normal"],
                c = e.data ? ? {};
            for (let u = 0; u < l.length; u++) {
                const d = l[u],
                    f = new FontFace(a, `url(${tge(t)})`, { ...c,
                        weight: d
                    });
                await f.load(), n.add(f), o.push(f)
            }
            return ft.set(`${a}-and-url`, {
                url: t,
                fontFaces: o
            }), o.length === 1 ? o[0] : o
        }
        return Me("[loadWebFont] FontFace API is not supported. Skipping loading font"), null
    },
    unload(t) {
        (Array.isArray(t) ? t : [t]).forEach(e => {
            ft.remove(`${e.family}-and-url`), He.get().getFontFaceSet().delete(e)
        })
    }
};

function rw(t, e = 1) {
    var r;
    const n = (r = Hl.RETINA_PREFIX) == null ? void 0 : r.exec(t);
    return n ? parseFloat(n[1]) : e
}

function iw(t, e, n) {
    t.label = n, t._sourceOrigin = n;
    const r = new we({
            source: t,
            label: n
        }),
        i = () => {
            delete e.promiseCache[n], ft.has(n) && ft.remove(n)
        };
    return r.source.once("destroy", () => {
        e.promiseCache[n] && (Me("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."), i())
    }), r.once("destroy", () => {
        t.destroyed || (Me("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), i())
    }), r
}
const rge = ".svg",
    ige = "image/svg+xml",
    sge = {
        extension: {
            type: G.LoadParser,
            priority: Zs.Low,
            name: "loadSVG"
        },
        name: "loadSVG",
        config: {
            crossOrigin: "anonymous",
            parseAsGraphicsContext: !1
        },
        test(t) {
            return jl(t, ige) || Vl(t, rge)
        },
        async load(t, e, n) {
            var r;
            return ((r = e.data) == null ? void 0 : r.parseAsGraphicsContext) ? ? this.config.parseAsGraphicsContext ? age(t) : oge(t, e, n, this.config.crossOrigin)
        },
        unload(t) {
            t.destroy(!0)
        }
    };
async function oge(t, e, n, r) {
    var y, m, g;
    const s = await (await He.get().fetch(t)).blob(),
        o = URL.createObjectURL(s),
        a = new Image;
    a.src = o, a.crossOrigin = r, await a.decode(), URL.revokeObjectURL(o);
    const l = document.createElement("canvas"),
        c = l.getContext("2d"),
        u = ((y = e.data) == null ? void 0 : y.resolution) || rw(t),
        d = ((m = e.data) == null ? void 0 : m.width) ? ? a.width,
        f = ((g = e.data) == null ? void 0 : g.height) ? ? a.height;
    l.width = d * u, l.height = f * u, c.drawImage(a, 0, 0, d * u, f * u);
    const {
        parseAsGraphicsContext: h,
        ...p
    } = e.data ? ? {}, b = new na({
        resource: l,
        alphaMode: "premultiply-alpha-on-upload",
        resolution: u,
        ...p
    });
    return iw(b, n, t)
}
async function age(t) {
    const n = await (await He.get().fetch(t)).text(),
        r = new dr;
    return r.svg(n), r
}
const lge = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
let el = null,
    N0 = class {
        constructor() {
            el || (el = URL.createObjectURL(new Blob([lge], {
                type: "application/javascript"
            }))), this.worker = new Worker(el)
        }
    };
N0.revokeObjectURL = function() {
    el && (URL.revokeObjectURL(el), el = null)
};
const cge = `(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
let tl = null;
class _$ {
    constructor() {
        tl || (tl = URL.createObjectURL(new Blob([cge], {
            type: "application/javascript"
        }))), this.worker = new Worker(tl)
    }
}
_$.revokeObjectURL = function() {
    tl && (URL.revokeObjectURL(tl), tl = null)
};
let aP = 0,
    vv;
class uge {
    constructor() {
        this._initialized = !1, this._createdWorkers = 0, this._workerPool = [], this._queue = [], this._resolveHash = {}
    }
    isImageBitmapSupported() {
        return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(e => {
            const {
                worker: n
            } = new N0;
            n.addEventListener("message", r => {
                n.terminate(), N0.revokeObjectURL(), e(r.data)
            })
        }), this._isImageBitmapSupported)
    }
    loadImageBitmap(e, n) {
        var r;
        return this._run("loadImageBitmap", [e, (r = n == null ? void 0 : n.data) == null ? void 0 : r.alphaMode])
    }
    async _initWorkers() {
        this._initialized || (this._initialized = !0)
    }
    _getWorker() {
        vv === void 0 && (vv = navigator.hardwareConcurrency || 4);
        let e = this._workerPool.pop();
        return !e && this._createdWorkers < vv && (this._createdWorkers++, e = new _$().worker, e.addEventListener("message", n => {
            this._complete(n.data), this._returnWorker(n.target), this._next()
        })), e
    }
    _returnWorker(e) {
        this._workerPool.push(e)
    }
    _complete(e) {
        e.error !== void 0 ? this._resolveHash[e.uuid].reject(e.error) : this._resolveHash[e.uuid].resolve(e.data), this._resolveHash[e.uuid] = null
    }
    async _run(e, n) {
        await this._initWorkers();
        const r = new Promise((i, s) => {
            this._queue.push({
                id: e,
                arguments: n,
                resolve: i,
                reject: s
            })
        });
        return this._next(), r
    }
    _next() {
        if (!this._queue.length) return;
        const e = this._getWorker();
        if (!e) return;
        const n = this._queue.pop(),
            r = n.id;
        this._resolveHash[aP] = {
            resolve: n.resolve,
            reject: n.reject
        }, e.postMessage({
            data: n.arguments,
            uuid: aP++,
            id: r
        })
    }
}
const lP = new uge,
    dge = [".jpeg", ".jpg", ".png", ".webp", ".avif"],
    fge = ["image/jpeg", "image/png", "image/webp", "image/avif"];
async function hge(t, e) {
    var i;
    const n = await He.get().fetch(t);
    if (!n.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${t}: ${n.status} ${n.statusText}`);
    const r = await n.blob();
    return ((i = e == null ? void 0 : e.data) == null ? void 0 : i.alphaMode) === "premultiplied-alpha" ? createImageBitmap(r, {
        premultiplyAlpha: "none"
    }) : createImageBitmap(r)
}
const b$ = {
        name: "loadTextures",
        extension: {
            type: G.LoadParser,
            priority: Zs.High,
            name: "loadTextures"
        },
        config: {
            preferWorkers: !0,
            preferCreateImageBitmap: !0,
            crossOrigin: "anonymous"
        },
        test(t) {
            return jl(t, fge) || Vl(t, dge)
        },
        async load(t, e, n) {
            var s;
            let r = null;
            globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await lP.isImageBitmapSupported() ? r = await lP.loadImageBitmap(t, e) : r = await hge(t, e) : r = await new Promise((o, a) => {
                r = new Image, r.crossOrigin = this.config.crossOrigin, r.src = t, r.complete ? o(r) : (r.onload = () => {
                    o(r)
                }, r.onerror = a)
            });
            const i = new na({
                resource: r,
                alphaMode: "premultiply-alpha-on-upload",
                resolution: ((s = e.data) == null ? void 0 : s.resolution) || rw(t),
                ...e.data
            });
            return iw(i, n, t)
        },
        unload(t) {
            t.destroy(!0)
        }
    },
    x$ = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"],
    pge = x$.map(t => `video/${t.substring(1)}`);

function mge(t, e, n) {
    n === void 0 && !e.startsWith("data:") ? t.crossOrigin = vge(e) : n !== !1 && (t.crossOrigin = typeof n == "string" ? n : "anonymous")
}

function gge(t) {
    return new Promise((e, n) => {
        t.addEventListener("canplaythrough", r), t.addEventListener("error", i), t.load();

        function r() {
            s(), e()
        }

        function i(o) {
            s(), n(o)
        }

        function s() {
            t.removeEventListener("canplaythrough", r), t.removeEventListener("error", i)
        }
    })
}

function vge(t, e = globalThis.location) {
    if (t.startsWith("data:")) return "";
    e || (e = globalThis.location);
    const n = new URL(t, document.baseURI);
    return n.hostname !== e.hostname || n.port !== e.port || n.protocol !== e.protocol ? "anonymous" : ""
}
const yge = {
        name: "loadVideo",
        extension: {
            type: G.LoadParser,
            name: "loadVideo"
        },
        test(t) {
            const e = jl(t, pge),
                n = Vl(t, x$);
            return e || n
        },
        async load(t, e, n) {
            var l, c;
            const r = { ...Uf.defaultOptions,
                    resolution: ((l = e.data) == null ? void 0 : l.resolution) || rw(t),
                    alphaMode: ((c = e.data) == null ? void 0 : c.alphaMode) || await ED(),
                    ...e.data
                },
                i = document.createElement("video"),
                s = {
                    preload: r.autoLoad !== !1 ? "auto" : void 0,
                    "webkit-playsinline": r.playsinline !== !1 ? "" : void 0,
                    playsinline: r.playsinline !== !1 ? "" : void 0,
                    muted: r.muted === !0 ? "" : void 0,
                    loop: r.loop === !0 ? "" : void 0,
                    autoplay: r.autoPlay !== !1 ? "" : void 0
                };
            Object.keys(s).forEach(u => {
                const d = s[u];
                d !== void 0 && i.setAttribute(u, d)
            }), r.muted === !0 && (i.muted = !0), mge(i, t, r.crossorigin);
            const o = document.createElement("source");
            let a;
            if (t.startsWith("data:")) a = t.slice(5, t.indexOf(";"));
            else if (!t.startsWith("blob:")) {
                const u = t.split("?")[0].slice(t.lastIndexOf(".") + 1).toLowerCase();
                a = Uf.MIME_TYPES[u] || `video/${u}`
            }
            return o.src = t, a && (o.type = a), new Promise(u => {
                const d = async () => {
                    const f = new Uf({ ...r,
                        resource: i
                    });
                    i.removeEventListener("canplay", d), e.data.preload && await gge(i), u(iw(f, n, t))
                };
                i.addEventListener("canplay", d), i.appendChild(o)
            })
        },
        unload(t) {
            t.destroy(!0)
        }
    },
    w$ = {
        extension: {
            type: G.ResolveParser,
            name: "resolveTexture"
        },
        test: b$.test,
        parse: t => {
            var e;
            return {
                resolution: parseFloat(((e = Hl.RETINA_PREFIX.exec(t)) == null ? void 0 : e[1]) ? ? "1"),
                format: t.split(".").pop(),
                src: t
            }
        }
    },
    _ge = {
        extension: {
            type: G.ResolveParser,
            priority: -2,
            name: "resolveJson"
        },
        test: t => Hl.RETINA_PREFIX.test(t) && t.endsWith(".json"),
        parse: w$.parse
    };
class bge {
    constructor() {
        this._detections = [], this._initialized = !1, this.resolver = new Hl, this.loader = new Hme, this.cache = ft, this._backgroundLoader = new kme(this.loader), this._backgroundLoader.active = !0, this.reset()
    }
    async init(e = {}) {
        var s, o;
        if (this._initialized) {
            Me("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
            return
        }
        if (this._initialized = !0, e.defaultSearchParams && this.resolver.setDefaultSearchParams(e.defaultSearchParams), e.basePath && (this.resolver.basePath = e.basePath), e.bundleIdentifier && this.resolver.setBundleIdentifier(e.bundleIdentifier), e.manifest) {
            let a = e.manifest;
            typeof a == "string" && (a = await this.load(a)), this.resolver.addManifest(a)
        }
        const n = ((s = e.texturePreference) == null ? void 0 : s.resolution) ? ? 1,
            r = typeof n == "number" ? [n] : n,
            i = await this._detectFormats({
                preferredFormats: (o = e.texturePreference) == null ? void 0 : o.format,
                skipDetections: e.skipDetections,
                detections: this._detections
            });
        this.resolver.prefer({
            params: {
                format: i,
                resolution: r
            }
        }), e.preferences && this.setPreferences(e.preferences)
    }
    add(e) {
        this.resolver.add(e)
    }
    async load(e, n) {
        this._initialized || await this.init();
        const r = Ih(e),
            i = Er(e).map(a => {
                if (typeof a != "string") {
                    const l = this.resolver.getAlias(a);
                    return l.some(c => !this.resolver.hasKey(c)) && this.add(a), Array.isArray(l) ? l[0] : l
                }
                return this.resolver.hasKey(a) || this.add({
                    alias: a,
                    src: a
                }), a
            }),
            s = this.resolver.resolve(i),
            o = await this._mapLoadToResolve(s, n);
        return r ? o[i[0]] : o
    }
    addBundle(e, n) {
        this.resolver.addBundle(e, n)
    }
    async loadBundle(e, n) {
        this._initialized || await this.init();
        let r = !1;
        typeof e == "string" && (r = !0, e = [e]);
        const i = this.resolver.resolveBundle(e),
            s = {},
            o = Object.keys(i);
        let a = 0,
            l = 0;
        const c = () => {
                n == null || n(++a / l)
            },
            u = o.map(d => {
                const f = i[d];
                return l += Object.keys(f).length, this._mapLoadToResolve(f, c).then(h => {
                    s[d] = h
                })
            });
        return await Promise.all(u), r ? s[e[0]] : s
    }
    async backgroundLoad(e) {
        this._initialized || await this.init(), typeof e == "string" && (e = [e]);
        const n = this.resolver.resolve(e);
        this._backgroundLoader.add(Object.values(n))
    }
    async backgroundLoadBundle(e) {
        this._initialized || await this.init(), typeof e == "string" && (e = [e]);
        const n = this.resolver.resolveBundle(e);
        Object.values(n).forEach(r => {
            this._backgroundLoader.add(Object.values(r))
        })
    }
    reset() {
        this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1
    }
    get(e) {
        if (typeof e == "string") return ft.get(e);
        const n = {};
        for (let r = 0; r < e.length; r++) n[r] = ft.get(e[r]);
        return n
    }
    async _mapLoadToResolve(e, n) {
        const r = [...new Set(Object.values(e))];
        this._backgroundLoader.active = !1;
        const i = await this.loader.load(r, n);
        this._backgroundLoader.active = !0;
        const s = {};
        return r.forEach(o => {
            const a = i[o.src],
                l = [o.src];
            o.alias && l.push(...o.alias), l.forEach(c => {
                s[c] = a
            }), ft.set(l, a)
        }), s
    }
    async unload(e) {
        this._initialized || await this.init();
        const n = Er(e).map(i => typeof i != "string" ? i.src : i),
            r = this.resolver.resolve(n);
        await this._unloadFromResolved(r)
    }
    async unloadBundle(e) {
        this._initialized || await this.init(), e = Er(e);
        const n = this.resolver.resolveBundle(e),
            r = Object.keys(n).map(i => this._unloadFromResolved(n[i]));
        await Promise.all(r)
    }
    async _unloadFromResolved(e) {
        const n = Object.values(e);
        n.forEach(r => {
            ft.remove(r.src)
        }), await this.loader.unload(n)
    }
    async _detectFormats(e) {
        let n = [];
        e.preferredFormats && (n = Array.isArray(e.preferredFormats) ? e.preferredFormats : [e.preferredFormats]);
        for (const r of e.detections) e.skipDetections || await r.test() ? n = await r.add(n) : e.skipDetections || (n = await r.remove(n));
        return n = n.filter((r, i) => n.indexOf(r) === i), n
    }
    get detections() {
        return this._detections
    }
    setPreferences(e) {
        this.loader.parsers.forEach(n => {
            n.config && Object.keys(n.config).filter(r => r in e).forEach(r => {
                n.config[r] = e[r]
            })
        })
    }
}
const pf = new bge;
Ie.handleByList(G.LoadParser, pf.loader.parsers).handleByList(G.ResolveParser, pf.resolver.parsers).handleByList(G.CacheParser, pf.cache.parsers).handleByList(G.DetectionParser, pf.detections);
Ie.add(Bme, $me, Dme, Gme, Lme, Nme, Ume, Vme, Xme, nge, sge, b$, yge, Mme, Rme, w$, _ge);
const cP = {
    loader: G.LoadParser,
    resolver: G.ResolveParser,
    cache: G.CacheParser,
    detection: G.DetectionParser
};
Ie.handle(G.Asset, t => {
    const e = t.ref;
    Object.entries(cP).filter(([n]) => !!e[n]).forEach(([n, r]) => Ie.add(Object.assign(e[n], {
        extension: e[n].extension ? ? r
    })))
}, t => {
    const e = t.ref;
    Object.keys(cP).filter(n => !!e[n]).forEach(n => Ie.remove(e[n]))
});
class E$ {
    constructor(e) {
        this._destroyRenderableBound = this.destroyRenderable.bind(this), this._attachedDomElements = [], this._renderer = e, this._renderer.runners.postrender.add(this), this._domElement = document.createElement("div"), this._domElement.style.position = "absolute", this._domElement.style.top = "0", this._domElement.style.left = "0", this._domElement.style.pointerEvents = "none", this._domElement.style.zIndex = "1000"
    }
    addRenderable(e, n) {
        this._attachedDomElements.includes(e) || (this._attachedDomElements.push(e), e.on("destroyed", this._destroyRenderableBound))
    }
    updateRenderable(e) {}
    validateRenderable(e) {
        return !0
    }
    destroyRenderable(e) {
        const n = this._attachedDomElements.indexOf(e);
        n !== -1 && this._attachedDomElements.splice(n, 1), e.off("destroyed", this._destroyRenderableBound)
    }
    postrender() {
        var r;
        const e = this._attachedDomElements;
        if (e.length === 0) {
            this._domElement.remove();
            return
        }
        const n = this._renderer.view.canvas;
        this._domElement.parentNode !== n.parentNode && ((r = n.parentNode) == null || r.appendChild(this._domElement)), this._domElement.style.transform = `translate(${n.offsetLeft}px, ${n.offsetTop}px)`;
        for (let i = 0; i < e.length; i++) {
            const s = e[i],
                o = s.element;
            if (!s.parent || s.globalDisplayStatus < 7) o.remove(), e.splice(i, 1), i--;
            else {
                this._domElement.contains(o) || (o.style.position = "absolute", o.style.pointerEvents = "auto", this._domElement.appendChild(o));
                const a = s.worldTransform,
                    l = s._anchor,
                    c = s.width * l.x,
                    u = s.height * l.y;
                o.style.transformOrigin = `${c}px ${u}px`, o.style.transform = `matrix(${a.a}, ${a.b}, ${a.c}, ${a.d}, ${a.tx-c}, ${a.ty-u})`, o.style.opacity = s.groupAlpha.toString()
            }
        }
    }
    destroy() {
        this._renderer.runners.postrender.remove(this);
        for (let e = 0; e < this._attachedDomElements.length; e++) {
            const n = this._attachedDomElements[e];
            n.off("destroyed", this._destroyRenderableBound), n.element.remove()
        }
        this._attachedDomElements.length = 0, this._domElement.remove(), this._renderer = null
    }
}
E$.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "dom"
};
class xge {
    constructor() {
        this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this._tickerAdded = !1, this._pauseUpdate = !0
    }
    init(e) {
        this.removeTickerListener(), this.events = e, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this._tickerAdded = !1, this._pauseUpdate = !0
    }
    get pauseUpdate() {
        return this._pauseUpdate
    }
    set pauseUpdate(e) {
        this._pauseUpdate = e
    }
    addTickerListener() {
        this._tickerAdded || !this.domElement || (bn.system.add(this._tickerUpdate, this, Pl.INTERACTION), this._tickerAdded = !0)
    }
    removeTickerListener() {
        this._tickerAdded && (bn.system.remove(this._tickerUpdate, this), this._tickerAdded = !1)
    }
    pointerMoved() {
        this._didMove = !0
    }
    _update() {
        if (!this.domElement || this._pauseUpdate) return;
        if (this._didMove) {
            this._didMove = !1;
            return
        }
        const e = this.events._rootPointerEvent;
        this.events.supportsTouchEvents && e.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
            clientX: e.clientX,
            clientY: e.clientY,
            pointerType: e.pointerType,
            pointerId: e.pointerId
        }))
    }
    _tickerUpdate(e) {
        this._deltaTime += e.deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this._update())
    }
}
const hs = new xge;
class Dh extends cd {
    constructor() {
        super(...arguments), this.client = new ct, this.movement = new ct, this.offset = new ct, this.global = new ct, this.screen = new ct
    }
    get clientX() {
        return this.client.x
    }
    get clientY() {
        return this.client.y
    }
    get x() {
        return this.clientX
    }
    get y() {
        return this.clientY
    }
    get movementX() {
        return this.movement.x
    }
    get movementY() {
        return this.movement.y
    }
    get offsetX() {
        return this.offset.x
    }
    get offsetY() {
        return this.offset.y
    }
    get globalX() {
        return this.global.x
    }
    get globalY() {
        return this.global.y
    }
    get screenX() {
        return this.screen.x
    }
    get screenY() {
        return this.screen.y
    }
    getLocalPosition(e, n, r) {
        return e.worldTransform.applyInverse(r || this.global, n)
    }
    getModifierState(e) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(e)
    }
    initMouseEvent(e, n, r, i, s, o, a, l, c, u, d, f, h, p, b) {
        throw new Error("Method not implemented.")
    }
}
class yr extends Dh {
    constructor() {
        super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1
    }
    getCoalescedEvents() {
        return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : []
    }
    getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!")
    }
}
class Ol extends Dh {
    constructor() {
        super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2
    }
}
Ol.DOM_DELTA_PIXEL = 0;
Ol.DOM_DELTA_LINE = 1;
Ol.DOM_DELTA_PAGE = 2;
const wge = 2048,
    Ege = new ct,
    hc = new ct;
class Sge {
    constructor(e) {
        this.dispatch = new rr, this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = {
            trackingData: {}
        }, this.eventPool = new Map, this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = !1, this.rootTarget = e, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel)
    }
    addEventMapping(e, n) {
        this.mappingTable[e] || (this.mappingTable[e] = []), this.mappingTable[e].push({
            fn: n,
            priority: 0
        }), this.mappingTable[e].sort((r, i) => r.priority - i.priority)
    }
    dispatchEvent(e, n) {
        e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, n), this.dispatch.emit(n || e.type, e)
    }
    mapEvent(e) {
        if (!this.rootTarget) return;
        const n = this.mappingTable[e.type];
        if (n)
            for (let r = 0, i = n.length; r < i; r++) n[r].fn(e);
        else Me(`[EventBoundary]: Event mapping not defined for ${e.type}`)
    }
    hitTest(e, n) {
        hs.pauseUpdate = !0;
        const i = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive",
            s = this[i](this.rootTarget, this.rootTarget.eventMode, Ege.set(e, n), this.hitTestFn, this.hitPruneFn);
        return s && s[0]
    }
    propagate(e, n) {
        if (!e.target) return;
        const r = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for (let i = 0, s = r.length - 1; i < s; i++)
            if (e.currentTarget = r[i], this.notifyTarget(e, n), e.propagationStopped || e.propagationImmediatelyStopped) return;
        if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, n), !(e.propagationStopped || e.propagationImmediatelyStopped)) {
            e.eventPhase = e.BUBBLING_PHASE;
            for (let i = r.length - 2; i >= 0; i--)
                if (e.currentTarget = r[i], this.notifyTarget(e, n), e.propagationStopped || e.propagationImmediatelyStopped) return
        }
    }
    all(e, n, r = this._allInteractiveElements) {
        if (r.length === 0) return;
        e.eventPhase = e.BUBBLING_PHASE;
        const i = Array.isArray(n) ? n : [n];
        for (let s = r.length - 1; s >= 0; s--) i.forEach(o => {
            e.currentTarget = r[s], this.notifyTarget(e, o)
        })
    }
    propagationPath(e) {
        const n = [e];
        for (let r = 0; r < wge && e !== this.rootTarget && e.parent; r++) {
            if (!e.parent) throw new Error("Cannot find propagation path to disconnected target");
            n.push(e.parent), e = e.parent
        }
        return n.reverse(), n
    }
    hitTestMoveRecursive(e, n, r, i, s, o = !1) {
        let a = !1;
        if (this._interactivePrune(e)) return null;
        if ((e.eventMode === "dynamic" || n === "dynamic") && (hs.pauseUpdate = !1), e.interactiveChildren && e.children) {
            const u = e.children;
            for (let d = u.length - 1; d >= 0; d--) {
                const f = u[d],
                    h = this.hitTestMoveRecursive(f, this._isInteractive(n) ? n : f.eventMode, r, i, s, o || s(e, r));
                if (h) {
                    if (h.length > 0 && !h[h.length - 1].parent) continue;
                    const p = e.isInteractive();
                    (h.length > 0 || p) && (p && this._allInteractiveElements.push(e), h.push(e)), this._hitElements.length === 0 && (this._hitElements = h), a = !0
                }
            }
        }
        const l = this._isInteractive(n),
            c = e.isInteractive();
        return c && c && this._allInteractiveElements.push(e), o || this._hitElements.length > 0 ? null : a ? this._hitElements : l && !s(e, r) && i(e, r) ? c ? [e] : [] : null
    }
    hitTestRecursive(e, n, r, i, s) {
        if (this._interactivePrune(e) || s(e, r)) return null;
        if ((e.eventMode === "dynamic" || n === "dynamic") && (hs.pauseUpdate = !1), e.interactiveChildren && e.children) {
            const l = e.children,
                c = r;
            for (let u = l.length - 1; u >= 0; u--) {
                const d = l[u],
                    f = this.hitTestRecursive(d, this._isInteractive(n) ? n : d.eventMode, c, i, s);
                if (f) {
                    if (f.length > 0 && !f[f.length - 1].parent) continue;
                    const h = e.isInteractive();
                    return (f.length > 0 || h) && f.push(e), f
                }
            }
        }
        const o = this._isInteractive(n),
            a = e.isInteractive();
        return o && i(e, r) ? a ? [e] : [] : null
    }
    _isInteractive(e) {
        return e === "static" || e === "dynamic"
    }
    _interactivePrune(e) {
        return !e || !e.visible || !e.renderable || !e.measurable || e.eventMode === "none" || e.eventMode === "passive" && !e.interactiveChildren
    }
    hitPruneFn(e, n) {
        if (e.hitArea && (e.worldTransform.applyInverse(n, hc), !e.hitArea.contains(hc.x, hc.y))) return !0;
        if (e.effects && e.effects.length)
            for (let r = 0; r < e.effects.length; r++) {
                const i = e.effects[r];
                if (i.containsPoint && !i.containsPoint(n, this.hitTestFn)) return !0
            }
        return !1
    }
    hitTestFn(e, n) {
        return e.hitArea ? !0 : e != null && e.containsPoint ? (e.worldTransform.applyInverse(n, hc), e.containsPoint(hc)) : !1
    }
    notifyTarget(e, n) {
        var s, o;
        if (!e.currentTarget.isInteractive()) return;
        n ? ? (n = e.type);
        const r = `on${n}`;
        (o = (s = e.currentTarget)[r]) == null || o.call(s, e);
        const i = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${n}capture` : n;
        this._notifyListeners(e, i), e.eventPhase === e.AT_TARGET && this._notifyListeners(e, n)
    }
    mapPointerDown(e) {
        if (!(e instanceof yr)) {
            Me("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = this.createPointerEvent(e);
        if (this.dispatchEvent(n, "pointerdown"), n.pointerType === "touch") this.dispatchEvent(n, "touchstart");
        else if (n.pointerType === "mouse" || n.pointerType === "pen") {
            const i = n.button === 2;
            this.dispatchEvent(n, i ? "rightdown" : "mousedown")
        }
        const r = this.trackingData(e.pointerId);
        r.pressTargetsByButton[e.button] = n.composedPath(), this.freeEvent(n)
    }
    mapPointerMove(e) {
        var l, c;
        if (!(e instanceof yr)) {
            Me("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = !0;
        const n = this.createPointerEvent(e);
        this._isPointerMoveEvent = !1;
        const r = n.pointerType === "mouse" || n.pointerType === "pen",
            i = this.trackingData(e.pointerId),
            s = this.findMountedTarget(i.overTargets);
        if (((l = i.overTargets) == null ? void 0 : l.length) > 0 && s !== n.target) {
            const u = e.type === "mousemove" ? "mouseout" : "pointerout",
                d = this.createPointerEvent(e, u, s);
            if (this.dispatchEvent(d, "pointerout"), r && this.dispatchEvent(d, "mouseout"), !n.composedPath().includes(s)) {
                const f = this.createPointerEvent(e, "pointerleave", s);
                for (f.eventPhase = f.AT_TARGET; f.target && !n.composedPath().includes(f.target);) f.currentTarget = f.target, this.notifyTarget(f), r && this.notifyTarget(f, "mouseleave"), f.target = f.target.parent;
                this.freeEvent(f)
            }
            this.freeEvent(d)
        }
        if (s !== n.target) {
            const u = e.type === "mousemove" ? "mouseover" : "pointerover",
                d = this.clonePointerEvent(n, u);
            this.dispatchEvent(d, "pointerover"), r && this.dispatchEvent(d, "mouseover");
            let f = s == null ? void 0 : s.parent;
            for (; f && f !== this.rootTarget.parent && f !== n.target;) f = f.parent;
            if (!f || f === this.rootTarget.parent) {
                const p = this.clonePointerEvent(n, "pointerenter");
                for (p.eventPhase = p.AT_TARGET; p.target && p.target !== s && p.target !== this.rootTarget.parent;) p.currentTarget = p.target, this.notifyTarget(p), r && this.notifyTarget(p, "mouseenter"), p.target = p.target.parent;
                this.freeEvent(p)
            }
            this.freeEvent(d)
        }
        const o = [],
            a = this.enableGlobalMoveEvents ? ? !0;
        this.moveOnAll ? o.push("pointermove") : this.dispatchEvent(n, "pointermove"), a && o.push("globalpointermove"), n.pointerType === "touch" && (this.moveOnAll ? o.splice(1, 0, "touchmove") : this.dispatchEvent(n, "touchmove"), a && o.push("globaltouchmove")), r && (this.moveOnAll ? o.splice(1, 0, "mousemove") : this.dispatchEvent(n, "mousemove"), a && o.push("globalmousemove"), this.cursor = (c = n.target) == null ? void 0 : c.cursor), o.length > 0 && this.all(n, o), this._allInteractiveElements.length = 0, this._hitElements.length = 0, i.overTargets = n.composedPath(), this.freeEvent(n)
    }
    mapPointerOver(e) {
        var o;
        if (!(e instanceof yr)) {
            Me("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = this.trackingData(e.pointerId),
            r = this.createPointerEvent(e),
            i = r.pointerType === "mouse" || r.pointerType === "pen";
        this.dispatchEvent(r, "pointerover"), i && this.dispatchEvent(r, "mouseover"), r.pointerType === "mouse" && (this.cursor = (o = r.target) == null ? void 0 : o.cursor);
        const s = this.clonePointerEvent(r, "pointerenter");
        for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent;) s.currentTarget = s.target, this.notifyTarget(s), i && this.notifyTarget(s, "mouseenter"), s.target = s.target.parent;
        n.overTargets = r.composedPath(), this.freeEvent(r), this.freeEvent(s)
    }
    mapPointerOut(e) {
        if (!(e instanceof yr)) {
            Me("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = this.trackingData(e.pointerId);
        if (n.overTargets) {
            const r = e.pointerType === "mouse" || e.pointerType === "pen",
                i = this.findMountedTarget(n.overTargets),
                s = this.createPointerEvent(e, "pointerout", i);
            this.dispatchEvent(s), r && this.dispatchEvent(s, "mouseout");
            const o = this.createPointerEvent(e, "pointerleave", i);
            for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent;) o.currentTarget = o.target, this.notifyTarget(o), r && this.notifyTarget(o, "mouseleave"), o.target = o.target.parent;
            n.overTargets = null, this.freeEvent(s), this.freeEvent(o)
        }
        this.cursor = null
    }
    mapPointerUp(e) {
        if (!(e instanceof yr)) {
            Me("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = performance.now(),
            r = this.createPointerEvent(e);
        if (this.dispatchEvent(r, "pointerup"), r.pointerType === "touch") this.dispatchEvent(r, "touchend");
        else if (r.pointerType === "mouse" || r.pointerType === "pen") {
            const a = r.button === 2;
            this.dispatchEvent(r, a ? "rightup" : "mouseup")
        }
        const i = this.trackingData(e.pointerId),
            s = this.findMountedTarget(i.pressTargetsByButton[e.button]);
        let o = s;
        if (s && !r.composedPath().includes(s)) {
            let a = s;
            for (; a && !r.composedPath().includes(a);) {
                if (r.currentTarget = a, this.notifyTarget(r, "pointerupoutside"), r.pointerType === "touch") this.notifyTarget(r, "touchendoutside");
                else if (r.pointerType === "mouse" || r.pointerType === "pen") {
                    const l = r.button === 2;
                    this.notifyTarget(r, l ? "rightupoutside" : "mouseupoutside")
                }
                a = a.parent
            }
            delete i.pressTargetsByButton[e.button], o = a
        }
        if (o) {
            const a = this.clonePointerEvent(r, "click");
            a.target = o, a.path = null, i.clicksByButton[e.button] || (i.clicksByButton[e.button] = {
                clickCount: 0,
                target: a.target,
                timeStamp: n
            });
            const l = i.clicksByButton[e.button];
            if (l.target === a.target && n - l.timeStamp < 200 ? ++l.clickCount : l.clickCount = 1, l.target = a.target, l.timeStamp = n, a.detail = l.clickCount, a.pointerType === "mouse") {
                const c = a.button === 2;
                this.dispatchEvent(a, c ? "rightclick" : "click")
            } else a.pointerType === "touch" && this.dispatchEvent(a, "tap");
            this.dispatchEvent(a, "pointertap"), this.freeEvent(a)
        }
        this.freeEvent(r)
    }
    mapPointerUpOutside(e) {
        if (!(e instanceof yr)) {
            Me("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = this.trackingData(e.pointerId),
            r = this.findMountedTarget(n.pressTargetsByButton[e.button]),
            i = this.createPointerEvent(e);
        if (r) {
            let s = r;
            for (; s;) i.currentTarget = s, this.notifyTarget(i, "pointerupoutside"), i.pointerType === "touch" ? this.notifyTarget(i, "touchendoutside") : (i.pointerType === "mouse" || i.pointerType === "pen") && this.notifyTarget(i, i.button === 2 ? "rightupoutside" : "mouseupoutside"), s = s.parent;
            delete n.pressTargetsByButton[e.button]
        }
        this.freeEvent(i)
    }
    mapWheel(e) {
        if (!(e instanceof Ol)) {
            Me("EventBoundary cannot map a non-wheel event as a wheel event");
            return
        }
        const n = this.createWheelEvent(e);
        this.dispatchEvent(n), this.freeEvent(n)
    }
    findMountedTarget(e) {
        if (!e) return null;
        let n = e[0];
        for (let r = 1; r < e.length && e[r].parent === n; r++) n = e[r];
        return n
    }
    createPointerEvent(e, n, r) {
        const i = this.allocateEvent(yr);
        return this.copyPointerData(e, i), this.copyMouseData(e, i), this.copyData(e, i), i.nativeEvent = e.nativeEvent, i.originalEvent = e, i.target = r ? ? this.hitTest(i.global.x, i.global.y) ? ? this._hitElements[0], typeof n == "string" && (i.type = n), i
    }
    createWheelEvent(e) {
        const n = this.allocateEvent(Ol);
        return this.copyWheelData(e, n), this.copyMouseData(e, n), this.copyData(e, n), n.nativeEvent = e.nativeEvent, n.originalEvent = e, n.target = this.hitTest(n.global.x, n.global.y), n
    }
    clonePointerEvent(e, n) {
        const r = this.allocateEvent(yr);
        return r.nativeEvent = e.nativeEvent, r.originalEvent = e.originalEvent, this.copyPointerData(e, r), this.copyMouseData(e, r), this.copyData(e, r), r.target = e.target, r.path = e.composedPath().slice(), r.type = n ? ? r.type, r
    }
    copyWheelData(e, n) {
        n.deltaMode = e.deltaMode, n.deltaX = e.deltaX, n.deltaY = e.deltaY, n.deltaZ = e.deltaZ
    }
    copyPointerData(e, n) {
        e instanceof yr && n instanceof yr && (n.pointerId = e.pointerId, n.width = e.width, n.height = e.height, n.isPrimary = e.isPrimary, n.pointerType = e.pointerType, n.pressure = e.pressure, n.tangentialPressure = e.tangentialPressure, n.tiltX = e.tiltX, n.tiltY = e.tiltY, n.twist = e.twist)
    }
    copyMouseData(e, n) {
        e instanceof Dh && n instanceof Dh && (n.altKey = e.altKey, n.button = e.button, n.buttons = e.buttons, n.client.copyFrom(e.client), n.ctrlKey = e.ctrlKey, n.metaKey = e.metaKey, n.movement.copyFrom(e.movement), n.screen.copyFrom(e.screen), n.shiftKey = e.shiftKey, n.global.copyFrom(e.global))
    }
    copyData(e, n) {
        n.isTrusted = e.isTrusted, n.srcElement = e.srcElement, n.timeStamp = performance.now(), n.type = e.type, n.detail = e.detail, n.view = e.view, n.which = e.which, n.layer.copyFrom(e.layer), n.page.copyFrom(e.page)
    }
    trackingData(e) {
        return this.mappingState.trackingData[e] || (this.mappingState.trackingData[e] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
        }), this.mappingState.trackingData[e]
    }
    allocateEvent(e) {
        this.eventPool.has(e) || this.eventPool.set(e, []);
        const n = this.eventPool.get(e).pop() || new e(this);
        return n.eventPhase = n.NONE, n.currentTarget = null, n.defaultPrevented = !1, n.path = null, n.target = null, n
    }
    freeEvent(e) {
        if (e.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const n = e.constructor;
        this.eventPool.has(n) || this.eventPool.set(n, []), this.eventPool.get(n).push(e)
    }
    _notifyListeners(e, n) {
        const r = e.currentTarget._events[n];
        if (r)
            if ("fn" in r) r.once && e.currentTarget.removeListener(n, r.fn, void 0, !0), r.fn.call(r.context, e);
            else
                for (let i = 0, s = r.length; i < s && !e.propagationImmediatelyStopped; i++) r[i].once && e.currentTarget.removeListener(n, r[i].fn, void 0, !0), r[i].fn.call(r[i].context, e)
    }
}
const Tge = 1,
    Cge = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
    },
    sw = class U0 {
        constructor(e) {
            this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = e, this.rootBoundary = new Sge(null), hs.init(this), this.autoPreventDefault = !0, this._eventsAdded = !1, this._rootPointerEvent = new yr(null), this._rootWheelEvent = new Ol(null), this.cursorStyles = {
                default: "inherit",
                pointer: "pointer"
            }, this.features = new Proxy({ ...U0.defaultEventFeatures
            }, {
                set: (n, r, i) => (r === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = i), n[r] = i, !0)
            }), this._onPointerDown = this._onPointerDown.bind(this), this._onPointerMove = this._onPointerMove.bind(this), this._onPointerUp = this._onPointerUp.bind(this), this._onPointerOverOut = this._onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this)
        }
        static get defaultEventMode() {
            return this._defaultEventMode
        }
        init(e) {
            const {
                canvas: n,
                resolution: r
            } = this.renderer;
            this.setTargetElement(n), this.resolution = r, U0._defaultEventMode = e.eventMode ? ? "passive", Object.assign(this.features, e.eventFeatures ? ? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove
        }
        resolutionChange(e) {
            this.resolution = e
        }
        destroy() {
            this.setTargetElement(null), this.renderer = null, this._currentCursor = null
        }
        setCursor(e) {
            e || (e = "default");
            let n = !0;
            if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (n = !1), this._currentCursor === e) return;
            this._currentCursor = e;
            const r = this.cursorStyles[e];
            if (r) switch (typeof r) {
                case "string":
                    n && (this.domElement.style.cursor = r);
                    break;
                case "function":
                    r(e);
                    break;
                case "object":
                    n && Object.assign(this.domElement.style, r);
                    break
            } else n && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.domElement.style.cursor = e)
        }
        get pointer() {
            return this._rootPointerEvent
        }
        _onPointerDown(e) {
            if (!this.features.click) return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            const n = this._normalizeToPointerData(e);
            this.autoPreventDefault && n[0].isNormalized && (e.cancelable || !("cancelable" in e)) && e.preventDefault();
            for (let r = 0, i = n.length; r < i; r++) {
                const s = n[r],
                    o = this._bootstrapEvent(this._rootPointerEvent, s);
                this.rootBoundary.mapEvent(o)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        _onPointerMove(e) {
            if (!this.features.move) return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, hs.pointerMoved();
            const n = this._normalizeToPointerData(e);
            for (let r = 0, i = n.length; r < i; r++) {
                const s = this._bootstrapEvent(this._rootPointerEvent, n[r]);
                this.rootBoundary.mapEvent(s)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        _onPointerUp(e) {
            if (!this.features.click) return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            let n = e.target;
            e.composedPath && e.composedPath().length > 0 && (n = e.composedPath()[0]);
            const r = n !== this.domElement ? "outside" : "",
                i = this._normalizeToPointerData(e);
            for (let s = 0, o = i.length; s < o; s++) {
                const a = this._bootstrapEvent(this._rootPointerEvent, i[s]);
                a.type += r, this.rootBoundary.mapEvent(a)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        _onPointerOverOut(e) {
            if (!this.features.click) return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            const n = this._normalizeToPointerData(e);
            for (let r = 0, i = n.length; r < i; r++) {
                const s = this._bootstrapEvent(this._rootPointerEvent, n[r]);
                this.rootBoundary.mapEvent(s)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onWheel(e) {
            if (!this.features.wheel) return;
            const n = this.normalizeWheelEvent(e);
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(n)
        }
        setTargetElement(e) {
            this._removeEvents(), this.domElement = e, hs.domElement = e, this._addEvents()
        }
        _addEvents() {
            if (this._eventsAdded || !this.domElement) return;
            hs.addTickerListener();
            const e = this.domElement.style;
            e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none", e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this._onPointerMove, !0), this.domElement.addEventListener("pointerdown", this._onPointerDown, !0), this.domElement.addEventListener("pointerleave", this._onPointerOverOut, !0), this.domElement.addEventListener("pointerover", this._onPointerOverOut, !0), globalThis.addEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this._onPointerMove, !0), this.domElement.addEventListener("mousedown", this._onPointerDown, !0), this.domElement.addEventListener("mouseout", this._onPointerOverOut, !0), this.domElement.addEventListener("mouseover", this._onPointerOverOut, !0), globalThis.addEventListener("mouseup", this._onPointerUp, !0), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this._onPointerDown, !0), this.domElement.addEventListener("touchend", this._onPointerUp, !0), this.domElement.addEventListener("touchmove", this._onPointerMove, !0))), this.domElement.addEventListener("wheel", this.onWheel, {
                passive: !0,
                capture: !0
            }), this._eventsAdded = !0
        }
        _removeEvents() {
            if (!this._eventsAdded || !this.domElement) return;
            hs.removeTickerListener();
            const e = this.domElement.style;
            e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "", e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = "")), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this._onPointerMove, !0), this.domElement.removeEventListener("pointerdown", this._onPointerDown, !0), this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, !0), this.domElement.removeEventListener("pointerover", this._onPointerOverOut, !0), globalThis.removeEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this._onPointerMove, !0), this.domElement.removeEventListener("mousedown", this._onPointerDown, !0), this.domElement.removeEventListener("mouseout", this._onPointerOverOut, !0), this.domElement.removeEventListener("mouseover", this._onPointerOverOut, !0), globalThis.removeEventListener("mouseup", this._onPointerUp, !0), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this._onPointerDown, !0), this.domElement.removeEventListener("touchend", this._onPointerUp, !0), this.domElement.removeEventListener("touchmove", this._onPointerMove, !0))), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this._eventsAdded = !1
        }
        mapPositionToPoint(e, n, r) {
            const i = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
                    x: 0,
                    y: 0,
                    width: this.domElement.width,
                    height: this.domElement.height,
                    left: 0,
                    top: 0
                },
                s = 1 / this.resolution;
            e.x = (n - i.left) * (this.domElement.width / i.width) * s, e.y = (r - i.top) * (this.domElement.height / i.height) * s
        }
        _normalizeToPointerData(e) {
            const n = [];
            if (this.supportsTouchEvents && e instanceof TouchEvent)
                for (let r = 0, i = e.changedTouches.length; r < i; r++) {
                    const s = e.changedTouches[r];
                    typeof s.button > "u" && (s.button = 0), typeof s.buttons > "u" && (s.buttons = 1), typeof s.isPrimary > "u" && (s.isPrimary = e.touches.length === 1 && e.type === "touchstart"), typeof s.width > "u" && (s.width = s.radiusX || 1), typeof s.height > "u" && (s.height = s.radiusY || 1), typeof s.tiltX > "u" && (s.tiltX = 0), typeof s.tiltY > "u" && (s.tiltY = 0), typeof s.pointerType > "u" && (s.pointerType = "touch"), typeof s.pointerId > "u" && (s.pointerId = s.identifier || 0), typeof s.pressure > "u" && (s.pressure = s.force || .5), typeof s.twist > "u" && (s.twist = 0), typeof s.tangentialPressure > "u" && (s.tangentialPressure = 0), typeof s.layerX > "u" && (s.layerX = s.offsetX = s.clientX), typeof s.layerY > "u" && (s.layerY = s.offsetY = s.clientY), s.isNormalized = !0, s.type = e.type, n.push(s)
                } else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
                    const r = e;
                    typeof r.isPrimary > "u" && (r.isPrimary = !0), typeof r.width > "u" && (r.width = 1), typeof r.height > "u" && (r.height = 1), typeof r.tiltX > "u" && (r.tiltX = 0), typeof r.tiltY > "u" && (r.tiltY = 0), typeof r.pointerType > "u" && (r.pointerType = "mouse"), typeof r.pointerId > "u" && (r.pointerId = Tge), typeof r.pressure > "u" && (r.pressure = .5), typeof r.twist > "u" && (r.twist = 0), typeof r.tangentialPressure > "u" && (r.tangentialPressure = 0), r.isNormalized = !0, n.push(r)
                } else n.push(e);
            return n
        }
        normalizeWheelEvent(e) {
            const n = this._rootWheelEvent;
            return this._transferMouseData(n, e), n.deltaX = e.deltaX, n.deltaY = e.deltaY, n.deltaZ = e.deltaZ, n.deltaMode = e.deltaMode, this.mapPositionToPoint(n.screen, e.clientX, e.clientY), n.global.copyFrom(n.screen), n.offset.copyFrom(n.screen), n.nativeEvent = e, n.type = e.type, n
        }
        _bootstrapEvent(e, n) {
            return e.originalEvent = null, e.nativeEvent = n, e.pointerId = n.pointerId, e.width = n.width, e.height = n.height, e.isPrimary = n.isPrimary, e.pointerType = n.pointerType, e.pressure = n.pressure, e.tangentialPressure = n.tangentialPressure, e.tiltX = n.tiltX, e.tiltY = n.tiltY, e.twist = n.twist, this._transferMouseData(e, n), this.mapPositionToPoint(e.screen, n.clientX, n.clientY), e.global.copyFrom(e.screen), e.offset.copyFrom(e.screen), e.isTrusted = n.isTrusted, e.type === "pointerleave" && (e.type = "pointerout"), e.type.startsWith("mouse") && (e.type = e.type.replace("mouse", "pointer")), e.type.startsWith("touch") && (e.type = Cge[e.type] || e.type), e
        }
        _transferMouseData(e, n) {
            e.isTrusted = n.isTrusted, e.srcElement = n.srcElement, e.timeStamp = performance.now(), e.type = n.type, e.altKey = n.altKey, e.button = n.button, e.buttons = n.buttons, e.client.x = n.clientX, e.client.y = n.clientY, e.ctrlKey = n.ctrlKey, e.metaKey = n.metaKey, e.movement.x = n.movementX, e.movement.y = n.movementY, e.page.x = n.pageX, e.page.y = n.pageY, e.relatedTarget = null, e.shiftKey = n.shiftKey
        }
    };
sw.extension = {
    name: "events",
    type: [G.WebGLSystem, G.CanvasSystem, G.WebGPUSystem],
    priority: -1
};
sw.defaultEventFeatures = {
    move: !0,
    globalMove: !0,
    click: !0,
    wheel: !0
};
let S$ = sw;
const Pge = {
        onclick: null,
        onmousedown: null,
        onmouseenter: null,
        onmouseleave: null,
        onmousemove: null,
        onglobalmousemove: null,
        onmouseout: null,
        onmouseover: null,
        onmouseup: null,
        onmouseupoutside: null,
        onpointercancel: null,
        onpointerdown: null,
        onpointerenter: null,
        onpointerleave: null,
        onpointermove: null,
        onglobalpointermove: null,
        onpointerout: null,
        onpointerover: null,
        onpointertap: null,
        onpointerup: null,
        onpointerupoutside: null,
        onrightclick: null,
        onrightdown: null,
        onrightup: null,
        onrightupoutside: null,
        ontap: null,
        ontouchcancel: null,
        ontouchend: null,
        ontouchendoutside: null,
        ontouchmove: null,
        onglobaltouchmove: null,
        ontouchstart: null,
        onwheel: null,
        get interactive() {
            return this.eventMode === "dynamic" || this.eventMode === "static"
        },
        set interactive(t) {
            this.eventMode = t ? "static" : "passive"
        },
        _internalEventMode: void 0,
        get eventMode() {
            return this._internalEventMode ? ? S$.defaultEventMode
        },
        set eventMode(t) {
            this._internalEventMode = t
        },
        isInteractive() {
            return this.eventMode === "static" || this.eventMode === "dynamic"
        },
        interactiveChildren: !0,
        hitArea: null,
        addEventListener(t, e, n) {
            const r = typeof n == "boolean" && n || typeof n == "object" && n.capture,
                i = typeof n == "object" ? n.signal : void 0,
                s = typeof n == "object" ? n.once === !0 : !1,
                o = typeof e == "function" ? void 0 : e;
            t = r ? `${t}capture` : t;
            const a = typeof e == "function" ? e : e.handleEvent,
                l = this;
            i && i.addEventListener("abort", () => {
                l.off(t, a, o)
            }), s ? l.once(t, a, o) : l.on(t, a, o)
        },
        removeEventListener(t, e, n) {
            const r = typeof n == "boolean" && n || typeof n == "object" && n.capture,
                i = typeof e == "function" ? void 0 : e;
            t = r ? `${t}capture` : t, e = typeof e == "function" ? e : e.handleEvent, this.off(t, e, i)
        },
        dispatchEvent(t) {
            if (!(t instanceof cd)) throw new Error("Container cannot propagate events outside of the Federated Events API");
            return t.defaultPrevented = !1, t.path = null, t.target = this, t.manager.dispatchEvent(t), !t.defaultPrevented
        }
    },
    T$ = {
        5: [.153388, .221461, .250301],
        7: [.071303, .131514, .189879, .214607],
        9: [.028532, .067234, .124009, .179044, .20236],
        11: [.0093, .028002, .065984, .121703, .175713, .198596],
        13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
        15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
    },
    Age = ["in vec2 vBlurTexCoords[%size%];", "uniform sampler2D uTexture;", "out vec4 finalColor;", "void main(void)", "{", "    finalColor = vec4(0.0);", "    %blur%", "}"].join(`
`);

function Oge(t) {
    const e = T$[t],
        n = e.length;
    let r = Age,
        i = "";
    const s = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
    let o;
    for (let a = 0; a < t; a++) {
        let l = s.replace("%index%", a.toString());
        o = a, a >= n && (o = t - a - 1), l = l.replace("%value%", e[o].toString()), i += l, i += `
`
    }
    return r = r.replace("%blur%", i), r = r.replace("%size%", t.toString()), r
}
const Ige = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;

function Rge(t, e) {
    const n = Math.ceil(t / 2);
    let r = Ige,
        i = "",
        s;
    e ? s = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);" : s = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
    for (let o = 0; o < t; o++) {
        let a = s.replace("%index%", o.toString());
        a = a.replace("%sampleIndex%", `${o-(n-1)}.0`), i += a, i += `
`
    }
    return r = r.replace("%blur%", i), r = r.replace("%size%", t.toString()), r = r.replace("%dimension%", e ? "z" : "w"), r
}

function Mge(t, e) {
    const n = Rge(e, t),
        r = Oge(e);
    return ga.from({
        vertex: n,
        fragment: r,
        name: `blur-${t?"horizontal":"vertical"}-pass-filter`
    })
}
var kge = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlurUniforms {
  uStrength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   finalColor = vec4(0.0);

    %blur-sampling%

    return finalColor;
}`;

function Bge(t, e) {
    const n = T$[e],
        r = n.length,
        i = [],
        s = [],
        o = [];
    for (let d = 0; d < e; d++) {
        i[d] = `@location(${d}) offset${d}: vec2<f32>,`, t ? s[d] = `filteredCord + vec2(${d-r+1} * pixelStrength, 0.0),` : s[d] = `filteredCord + vec2(0.0, ${d-r+1} * pixelStrength),`;
        const f = d < r ? d : e - d - 1,
            h = n[f].toString();
        o[d] = `finalColor += textureSample(uTexture, uSampler, offset${d}) * ${h};`
    }
    const a = i.join(`
`),
        l = s.join(`
`),
        c = o.join(`
`),
        u = kge.replace("%blur-struct%", a).replace("%blur-vertex-out%", l).replace("%blur-fragment-in%", a).replace("%blur-sampling%", c).replace("%dimension%", t ? "z" : "w");
    return Qs.from({
        vertex: {
            source: u,
            entryPoint: "mainVertex"
        },
        fragment: {
            source: u,
            entryPoint: "mainFragment"
        }
    })
}
const C$ = class P$ extends Lx {
    constructor(e) {
        e = { ...P$.defaultOptions,
            ...e
        };
        const n = Mge(e.horizontal, e.kernelSize),
            r = Bge(e.horizontal, e.kernelSize);
        super({
            glProgram: n,
            gpuProgram: r,
            resources: {
                blurUniforms: {
                    uStrength: {
                        value: 0,
                        type: "f32"
                    }
                }
            },
            ...e
        }), this.horizontal = e.horizontal, this._quality = 0, this.quality = e.quality, this.blur = e.strength, this._uniforms = this.resources.blurUniforms.uniforms
    }
    apply(e, n, r, i) {
        if (this._uniforms.uStrength = this.strength / this.passes, this.passes === 1) e.applyFilter(this, n, r, i);
        else {
            const s = Ft.getSameSizeTexture(n);
            let o = n,
                a = s;
            this._state.blend = !1;
            const l = e.renderer.type === Qn.WEBGPU;
            for (let c = 0; c < this.passes - 1; c++) {
                e.applyFilter(this, o, a, c === 0 ? !0 : l);
                const u = a;
                a = o, o = u
            }
            this._state.blend = !0, e.applyFilter(this, o, r, i), Ft.returnTexture(s)
        }
    }
    get blur() {
        return this.strength
    }
    set blur(e) {
        this.padding = 1 + Math.abs(e) * 2, this.strength = e
    }
    get quality() {
        return this._quality
    }
    set quality(e) {
        this._quality = e, this.passes = e
    }
};
C$.defaultOptions = {
    strength: 8,
    quality: 4,
    kernelSize: 5
};
let yv = C$;
class Dge extends Lx {
    constructor(...e) {
        let n = e[0] ? ? {};
        typeof n == "number" && ($e(Ye, "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"), n = {
            strength: n
        }, e[1] !== void 0 && (n.quality = e[1]), e[2] !== void 0 && (n.resolution = e[2] || "inherit"), e[3] !== void 0 && (n.kernelSize = e[3])), n = { ...yv.defaultOptions,
            ...n
        };
        const {
            strength: r,
            strengthX: i,
            strengthY: s,
            quality: o,
            ...a
        } = n;
        super({ ...a,
            compatibleRenderers: Qn.BOTH,
            resources: {}
        }), this._repeatEdgePixels = !1, this.blurXFilter = new yv({
            horizontal: !0,
            ...n
        }), this.blurYFilter = new yv({
            horizontal: !1,
            ...n
        }), this.quality = o, this.strengthX = i ? ? r, this.strengthY = s ? ? r, this.repeatEdgePixels = !1
    }
    apply(e, n, r, i) {
        const s = Math.abs(this.blurXFilter.strength),
            o = Math.abs(this.blurYFilter.strength);
        if (s && o) {
            const a = Ft.getSameSizeTexture(n);
            this.blurXFilter.blendMode = "normal", this.blurXFilter.apply(e, n, a, !0), this.blurYFilter.blendMode = this.blendMode, this.blurYFilter.apply(e, a, r, i), Ft.returnTexture(a)
        } else o ? (this.blurYFilter.blendMode = this.blendMode, this.blurYFilter.apply(e, n, r, i)) : (this.blurXFilter.blendMode = this.blendMode, this.blurXFilter.apply(e, n, r, i))
    }
    updatePadding() {
        this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2
    }
    get strength() {
        if (this.strengthX !== this.strengthY) throw new Error("BlurFilter's strengthX and strengthY are different");
        return this.strengthX
    }
    set strength(e) {
        this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding()
    }
    get quality() {
        return this.blurXFilter.quality
    }
    set quality(e) {
        this.blurXFilter.quality = this.blurYFilter.quality = e
    }
    get strengthX() {
        return this.blurXFilter.blur
    }
    set strengthX(e) {
        this.blurXFilter.blur = e, this.updatePadding()
    }
    get strengthY() {
        return this.blurYFilter.blur
    }
    set strengthY(e) {
        this.blurYFilter.blur = e, this.updatePadding()
    }
    get blur() {
        return $e("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead."), this.strength
    }
    set blur(e) {
        $e("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead."), this.strength = e
    }
    get blurX() {
        return $e("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead."), this.strengthX
    }
    set blurX(e) {
        $e("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead."), this.strengthX = e
    }
    get blurY() {
        return $e("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead."), this.strengthY
    }
    set blurY(e) {
        $e("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead."), this.strengthY = e
    }
    get repeatEdgePixels() {
        return this._repeatEdgePixels
    }
    set repeatEdgePixels(e) {
        this._repeatEdgePixels = e, this.updatePadding()
    }
}
Dge.defaultOptions = {
    strength: 8,
    quality: 4,
    kernelSize: 5
};
class A$ {
    constructor(e) {
        this._renderer = e
    }
    push(e, n, r) {
        this._renderer.renderPipes.batch.break(r), r.add({
            renderPipeId: "filter",
            canBundle: !1,
            action: "pushFilter",
            container: n,
            filterEffect: e
        })
    }
    pop(e, n, r) {
        this._renderer.renderPipes.batch.break(r), r.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: !1
        })
    }
    execute(e) {
        e.action === "pushFilter" ? this._renderer.filter.push(e) : e.action === "popFilter" && this._renderer.filter.pop()
    }
    destroy() {
        this._renderer = null
    }
}
A$.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "filter"
};

function $ge(t, e) {
    e.clear();
    const n = e.matrix;
    for (let r = 0; r < t.length; r++) {
        const i = t[r];
        i.globalDisplayStatus < 7 || (e.matrix = i.worldTransform, e.addBounds(i.bounds))
    }
    return e.matrix = n, e
}
const Fge = new ud({
    attributes: {
        aPosition: {
            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
        }
    },
    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
});
class O$ {
    constructor(e) {
        this._filterStackIndex = 0, this._filterStack = [], this._filterGlobalUniforms = new Cn({
            uInputSize: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uInputPixel: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uInputClamp: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uOutputFrame: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uGlobalFrame: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uOutputTexture: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            }
        }), this._globalFilterBindGroup = new Fi({}), this.renderer = e
    }
    get activeBackTexture() {
        var e;
        return (e = this._activeFilterData) == null ? void 0 : e.backTexture
    }
    push(e) {
        var h;
        const n = this.renderer,
            r = e.filterEffect.filters;
        this._filterStack[this._filterStackIndex] || (this._filterStack[this._filterStackIndex] = this._getFilterData());
        const i = this._filterStack[this._filterStackIndex];
        if (this._filterStackIndex++, r.length === 0) {
            i.skip = !0;
            return
        }
        const s = i.bounds;
        if (e.renderables ? $ge(e.renderables, s) : e.filterEffect.filterArea ? (s.clear(), s.addRect(e.filterEffect.filterArea), s.applyMatrix(e.container.worldTransform)) : e.container.getFastGlobalBounds(!0, s), e.container) {
            const b = (e.container.renderGroup || e.container.parentRenderGroup).cacheToLocalTransform;
            b && s.applyMatrix(b)
        }
        const o = n.renderTarget.renderTarget.colorTexture.source;
        let a = 1 / 0,
            l = 0,
            c = !0,
            u = !1,
            d = !1,
            f = !0;
        for (let p = 0; p < r.length; p++) {
            const b = r[p];
            if (a = Math.min(a, b.resolution === "inherit" ? o._resolution : b.resolution), l += b.padding, b.antialias === "off" ? c = !1 : b.antialias === "inherit" && c && (c = o.antialias), b.clipToViewport || (f = !1), !!!(b.compatibleRenderers & n.type)) {
                d = !1;
                break
            }
            if (b.blendRequired && !(((h = n.backBuffer) == null ? void 0 : h.useBackBuffer) ? ? !0)) {
                Me("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."), d = !1;
                break
            }
            d = b.enabled || d, u || (u = b.blendRequired)
        }
        if (!d) {
            i.skip = !0;
            return
        }
        if (f) {
            const p = n.renderTarget.rootViewPort,
                b = n.renderTarget.renderTarget.resolution;
            s.fitBounds(0, p.width / b, 0, p.height / b)
        }
        if (s.scale(a).ceil().scale(1 / a).pad(l | 0), !s.isPositive) {
            i.skip = !0;
            return
        }
        i.skip = !1, i.bounds = s, i.blendRequired = u, i.container = e.container, i.filterEffect = e.filterEffect, i.previousRenderSurface = n.renderTarget.renderSurface, i.inputTexture = Ft.getOptimalTexture(s.width, s.height, a, c), n.renderTarget.bind(i.inputTexture, !0), n.globalUniforms.push({
            offset: s
        })
    }
    pop() {
        const e = this.renderer;
        this._filterStackIndex--;
        const n = this._filterStack[this._filterStackIndex];
        if (n.skip) return;
        this._activeFilterData = n;
        const r = n.inputTexture,
            i = n.bounds;
        let s = we.EMPTY;
        if (e.renderTarget.finishRenderPass(), n.blendRequired) {
            const a = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null,
                l = e.renderTarget.getRenderTarget(n.previousRenderSurface);
            s = this.getBackTexture(l, i, a)
        }
        n.backTexture = s;
        const o = n.filterEffect.filters;
        if (this._globalFilterBindGroup.setResource(r.source.style, 2), this._globalFilterBindGroup.setResource(s.source, 3), e.globalUniforms.pop(), o.length === 1) o[0].apply(this, r, n.previousRenderSurface, !1), Ft.returnTexture(r);
        else {
            let a = n.inputTexture,
                l = Ft.getOptimalTexture(i.width, i.height, a.source._resolution, !1),
                c = 0;
            for (c = 0; c < o.length - 1; ++c) {
                o[c].apply(this, a, l, !0);
                const d = a;
                a = l, l = d
            }
            o[c].apply(this, a, n.previousRenderSurface, !1), Ft.returnTexture(a), Ft.returnTexture(l)
        }
        n.blendRequired && Ft.returnTexture(s)
    }
    getBackTexture(e, n, r) {
        const i = e.colorTexture.source._resolution,
            s = Ft.getOptimalTexture(n.width, n.height, i, !1);
        let o = n.minX,
            a = n.minY;
        r && (o -= r.minX, a -= r.minY), o = Math.floor(o * i), a = Math.floor(a * i);
        const l = Math.ceil(n.width * i),
            c = Math.ceil(n.height * i);
        return this.renderer.renderTarget.copyToTexture(e, s, {
            x: o,
            y: a
        }, {
            width: l,
            height: c
        }, {
            x: 0,
            y: 0
        }), s
    }
    applyFilter(e, n, r, i) {
        const s = this.renderer,
            o = this._filterStack[this._filterStackIndex],
            a = o.bounds,
            l = ct.shared,
            u = o.previousRenderSurface === r;
        let d = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,
            f = this._filterStackIndex - 1;
        for (; f > 0 && this._filterStack[f].skip;) --f;
        f > 0 && (d = this._filterStack[f].inputTexture.source._resolution);
        const h = this._filterGlobalUniforms,
            p = h.uniforms,
            b = p.uOutputFrame,
            y = p.uInputSize,
            m = p.uInputPixel,
            g = p.uInputClamp,
            v = p.uGlobalFrame,
            _ = p.uOutputTexture;
        if (u) {
            let S = this._filterStackIndex;
            for (; S > 0;) {
                S--;
                const C = this._filterStack[this._filterStackIndex - 1];
                if (!C.skip) {
                    l.x = C.bounds.minX, l.y = C.bounds.minY;
                    break
                }
            }
            b[0] = a.minX - l.x, b[1] = a.minY - l.y
        } else b[0] = 0, b[1] = 0;
        b[2] = n.frame.width, b[3] = n.frame.height, y[0] = n.source.width, y[1] = n.source.height, y[2] = 1 / y[0], y[3] = 1 / y[1], m[0] = n.source.pixelWidth, m[1] = n.source.pixelHeight, m[2] = 1 / m[0], m[3] = 1 / m[1], g[0] = .5 * m[2], g[1] = .5 * m[3], g[2] = n.frame.width * y[2] - .5 * m[2], g[3] = n.frame.height * y[3] - .5 * m[3];
        const x = this.renderer.renderTarget.rootRenderTarget.colorTexture;
        v[0] = l.x * d, v[1] = l.y * d, v[2] = x.source.width * d, v[3] = x.source.height * d;
        const w = this.renderer.renderTarget.getRenderTarget(r);
        if (s.renderTarget.bind(r, !!i), r instanceof we ? (_[0] = r.frame.width, _[1] = r.frame.height) : (_[0] = w.width, _[1] = w.height), _[2] = w.isRoot ? -1 : 1, h.update(), s.renderPipes.uniformBatch) {
            const S = s.renderPipes.uniformBatch.getUboResource(h);
            this._globalFilterBindGroup.setResource(S, 0)
        } else this._globalFilterBindGroup.setResource(h, 0);
        this._globalFilterBindGroup.setResource(n.source, 1), this._globalFilterBindGroup.setResource(n.source.style, 2), e.groups[0] = this._globalFilterBindGroup, s.encoder.draw({
            geometry: Fge,
            shader: e,
            state: e._state,
            topology: "triangle-list"
        }), s.type === Qn.WEBGL && s.renderTarget.finishRenderPass()
    }
    _getFilterData() {
        return {
            skip: !1,
            inputTexture: null,
            bounds: new rn,
            container: null,
            filterEffect: null,
            blendRequired: !1,
            previousRenderSurface: null
        }
    }
    calculateSpriteMatrix(e, n) {
        const r = this._activeFilterData,
            i = e.set(r.inputTexture._source.width, 0, 0, r.inputTexture._source.height, r.bounds.minX, r.bounds.minY),
            s = n.worldTransform.copyTo(Ce.shared),
            o = n.renderGroup || n.parentRenderGroup;
        return o && o.cacheToLocalTransform && s.prepend(o.cacheToLocalTransform), s.invert(), i.prepend(s), i.scale(1 / n.texture.frame.width, 1 / n.texture.frame.height), i.translate(n.anchor.x, n.anchor.y), i
    }
}
O$.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "filter"
};
var Lge = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`,
    Nge = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`,
    uP = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;
class Uge extends Lx {
    constructor(e) {
        const {
            sprite: n,
            ...r
        } = e, i = new sD(n.texture), s = new Cn({
            uFilterMatrix: {
                value: new Ce,
                type: "mat3x3<f32>"
            },
            uMaskClamp: {
                value: i.uClampFrame,
                type: "vec4<f32>"
            },
            uAlpha: {
                value: 1,
                type: "f32"
            },
            uInverse: {
                value: e.inverse ? 1 : 0,
                type: "f32"
            }
        }), o = Qs.from({
            vertex: {
                source: uP,
                entryPoint: "mainVertex"
            },
            fragment: {
                source: uP,
                entryPoint: "mainFragment"
            }
        }), a = ga.from({
            vertex: Nge,
            fragment: Lge,
            name: "mask-filter"
        });
        super({ ...r,
            gpuProgram: o,
            glProgram: a,
            resources: {
                filterUniforms: s,
                uMaskTexture: n.texture.source
            }
        }), this.sprite = n, this._textureMatrix = i
    }
    set inverse(e) {
        this.resources.filterUniforms.uniforms.uInverse = e ? 1 : 0
    }
    get inverse() {
        return this.resources.filterUniforms.uniforms.uInverse === 1
    }
    apply(e, n, r, i) {
        this._textureMatrix.texture = this.sprite.texture, e.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, e.applyFilter(this, n, r, i)
    }
}
class $h extends ld {
    constructor(e) {
        e instanceof dr && (e = {
            context: e
        });
        const {
            context: n,
            roundPixels: r,
            ...i
        } = e || {};
        super({
            label: "Graphics",
            ...i
        }), this.renderPipeId = "graphics", n ? this._context = n : this._context = this._ownedContext = new dr, this._context.on("update", this.onViewUpdate, this), this.allowChildren = !1, this.roundPixels = r ? ? !1
    }
    set context(e) {
        e !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = e, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate())
    }
    get context() {
        return this._context
    }
    get bounds() {
        return this._context.bounds
    }
    updateBounds() {}
    containsPoint(e) {
        return this._context.containsPoint(e)
    }
    destroy(e) {
        this._ownedContext && !e ? this._ownedContext.destroy(e) : (e === !0 || (e == null ? void 0 : e.context) === !0) && this._context.destroy(e), this._ownedContext = null, this._context = null, super.destroy(e)
    }
    _callContextMethod(e, n) {
        return this.context[e](...n), this
    }
    setFillStyle(...e) {
        return this._callContextMethod("setFillStyle", e)
    }
    setStrokeStyle(...e) {
        return this._callContextMethod("setStrokeStyle", e)
    }
    fill(...e) {
        return this._callContextMethod("fill", e)
    }
    stroke(...e) {
        return this._callContextMethod("stroke", e)
    }
    texture(...e) {
        return this._callContextMethod("texture", e)
    }
    beginPath() {
        return this._callContextMethod("beginPath", [])
    }
    cut() {
        return this._callContextMethod("cut", [])
    }
    arc(...e) {
        return this._callContextMethod("arc", e)
    }
    arcTo(...e) {
        return this._callContextMethod("arcTo", e)
    }
    arcToSvg(...e) {
        return this._callContextMethod("arcToSvg", e)
    }
    bezierCurveTo(...e) {
        return this._callContextMethod("bezierCurveTo", e)
    }
    closePath() {
        return this._callContextMethod("closePath", [])
    }
    ellipse(...e) {
        return this._callContextMethod("ellipse", e)
    }
    circle(...e) {
        return this._callContextMethod("circle", e)
    }
    path(...e) {
        return this._callContextMethod("path", e)
    }
    lineTo(...e) {
        return this._callContextMethod("lineTo", e)
    }
    moveTo(...e) {
        return this._callContextMethod("moveTo", e)
    }
    quadraticCurveTo(...e) {
        return this._callContextMethod("quadraticCurveTo", e)
    }
    rect(...e) {
        return this._callContextMethod("rect", e)
    }
    roundRect(...e) {
        return this._callContextMethod("roundRect", e)
    }
    poly(...e) {
        return this._callContextMethod("poly", e)
    }
    regularPoly(...e) {
        return this._callContextMethod("regularPoly", e)
    }
    roundPoly(...e) {
        return this._callContextMethod("roundPoly", e)
    }
    roundShape(...e) {
        return this._callContextMethod("roundShape", e)
    }
    filletRect(...e) {
        return this._callContextMethod("filletRect", e)
    }
    chamferRect(...e) {
        return this._callContextMethod("chamferRect", e)
    }
    star(...e) {
        return this._callContextMethod("star", e)
    }
    svg(...e) {
        return this._callContextMethod("svg", e)
    }
    restore(...e) {
        return this._callContextMethod("restore", e)
    }
    save() {
        return this._callContextMethod("save", [])
    }
    getTransform() {
        return this.context.getTransform()
    }
    resetTransform() {
        return this._callContextMethod("resetTransform", [])
    }
    rotateTransform(...e) {
        return this._callContextMethod("rotate", e)
    }
    scaleTransform(...e) {
        return this._callContextMethod("scale", e)
    }
    setTransform(...e) {
        return this._callContextMethod("setTransform", e)
    }
    transform(...e) {
        return this._callContextMethod("transform", e)
    }
    translateTransform(...e) {
        return this._callContextMethod("translate", e)
    }
    clear() {
        return this._callContextMethod("clear", [])
    }
    get fillStyle() {
        return this._context.fillStyle
    }
    set fillStyle(e) {
        this._context.fillStyle = e
    }
    get strokeStyle() {
        return this._context.strokeStyle
    }
    set strokeStyle(e) {
        this._context.strokeStyle = e
    }
    clone(e = !1) {
        return e ? new $h(this._context.clone()) : (this._ownedContext = null, new $h(this._context))
    }
    lineStyle(e, n, r) {
        $e(Ye, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
        const i = {};
        return e && (i.width = e), n && (i.color = n), r && (i.alpha = r), this.context.strokeStyle = i, this
    }
    beginFill(e, n) {
        $e(Ye, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
        const r = {};
        return e !== void 0 && (r.color = e), n !== void 0 && (r.alpha = n), this.context.fillStyle = r, this
    }
    endFill() {
        $e(Ye, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
        const e = this.context.strokeStyle;
        return (e.width !== dr.defaultStrokeStyle.width || e.color !== dr.defaultStrokeStyle.color || e.alpha !== dr.defaultStrokeStyle.alpha) && this.context.stroke(), this
    }
    drawCircle(...e) {
        return $e(Ye, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", e)
    }
    drawEllipse(...e) {
        return $e(Ye, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", e)
    }
    drawPolygon(...e) {
        return $e(Ye, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", e)
    }
    drawRect(...e) {
        return $e(Ye, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", e)
    }
    drawRoundedRect(...e) {
        return $e(Ye, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", e)
    }
    drawStar(...e) {
        return $e(Ye, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", e)
    }
}
const I$ = class R$ extends ud {
    constructor(...e) {
        let n = e[0] ? ? {};
        n instanceof Float32Array && ($e(Ye, "use new MeshGeometry({ positions, uvs, indices }) instead"), n = {
            positions: n,
            uvs: e[1],
            indices: e[2]
        }), n = { ...R$.defaultOptions,
            ...n
        };
        const r = n.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        let i = n.uvs;
        i || (n.positions ? i = new Float32Array(r.length) : i = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]));
        const s = n.indices || new Uint32Array([0, 1, 2, 0, 2, 3]),
            o = n.shrinkBuffersToFit,
            a = new qn({
                data: r,
                label: "attribute-mesh-positions",
                shrinkToFit: o,
                usage: Xe.VERTEX | Xe.COPY_DST
            }),
            l = new qn({
                data: i,
                label: "attribute-mesh-uvs",
                shrinkToFit: o,
                usage: Xe.VERTEX | Xe.COPY_DST
            }),
            c = new qn({
                data: s,
                label: "index-mesh-buffer",
                shrinkToFit: o,
                usage: Xe.INDEX | Xe.COPY_DST
            });
        super({
            attributes: {
                aPosition: {
                    buffer: a,
                    format: "float32x2",
                    stride: 2 * 4,
                    offset: 0
                },
                aUV: {
                    buffer: l,
                    format: "float32x2",
                    stride: 2 * 4,
                    offset: 0
                }
            },
            indexBuffer: c,
            topology: n.topology
        }), this.batchMode = "auto"
    }
    get positions() {
        return this.attributes.aPosition.buffer.data
    }
    set positions(e) {
        this.attributes.aPosition.buffer.data = e
    }
    get uvs() {
        return this.attributes.aUV.buffer.data
    }
    set uvs(e) {
        this.attributes.aUV.buffer.data = e
    }
    get indices() {
        return this.indexBuffer.data
    }
    set indices(e) {
        this.indexBuffer.data = e
    }
};
I$.defaultOptions = {
    topology: "triangle-list",
    shrinkBuffersToFit: !1
};
let ow = I$;
class Gge {
    constructor({
        matrix: e,
        observer: n
    } = {}) {
        this.dirty = !0, this._matrix = e ? ? new Ce, this.observer = n, this.position = new jt(this, 0, 0), this.scale = new jt(this, 1, 1), this.pivot = new jt(this, 0, 0), this.skew = new jt(this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1
    }
    get matrix() {
        const e = this._matrix;
        return this.dirty && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this.dirty = !1), e
    }
    _onUpdate(e) {
        var n;
        this.dirty = !0, e === this.skew && this.updateSkew(), (n = this.observer) == null || n._onUpdate(this)
    }
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this.dirty = !0
    }
    toString() {
        return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
    }
    setFromMatrix(e) {
        e.decompose(this), this.dirty = !0
    }
    get rotation() {
        return this._rotation
    }
    set rotation(e) {
        this._rotation !== e && (this._rotation = e, this._onUpdate(this.skew))
    }
}
const M$ = class Hf extends ld {
    constructor(...e) {
        let n = e[0] || {};
        n instanceof we && (n = {
            texture: n
        }), e.length > 1 && ($e(Ye, "use new TilingSprite({ texture, width:100, height:100 }) instead"), n.width = e[1], n.height = e[2]), n = { ...Hf.defaultOptions,
            ...n
        };
        const {
            texture: r,
            anchor: i,
            tilePosition: s,
            tileScale: o,
            tileRotation: a,
            width: l,
            height: c,
            applyAnchorToTexture: u,
            roundPixels: d,
            ...f
        } = n ? ? {};
        super({
            label: "TilingSprite",
            ...f
        }), this.renderPipeId = "tilingSprite", this.batched = !0, this.allowChildren = !1, this._anchor = new jt({
            _onUpdate: () => {
                this.onViewUpdate()
            }
        }), this.applyAnchorToTexture = u, this.texture = r, this._width = l ? ? r.width, this._height = c ? ? r.height, this._tileTransform = new Gge({
            observer: {
                _onUpdate: () => this.onViewUpdate()
            }
        }), i && (this.anchor = i), this.tilePosition = s, this.tileScale = o, this.tileRotation = a, this.roundPixels = d ? ? !1
    }
    static from(e, n = {}) {
        return typeof e == "string" ? new Hf({
            texture: ft.get(e),
            ...n
        }) : new Hf({
            texture: e,
            ...n
        })
    }
    get uvRespectAnchor() {
        return Me("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"), this.applyAnchorToTexture
    }
    set uvRespectAnchor(e) {
        Me("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"), this.applyAnchorToTexture = e
    }
    get clampMargin() {
        return this._texture.textureMatrix.clampMargin
    }
    set clampMargin(e) {
        this._texture.textureMatrix.clampMargin = e
    }
    get anchor() {
        return this._anchor
    }
    set anchor(e) {
        typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
    }
    get tilePosition() {
        return this._tileTransform.position
    }
    set tilePosition(e) {
        this._tileTransform.position.copyFrom(e)
    }
    get tileScale() {
        return this._tileTransform.scale
    }
    set tileScale(e) {
        typeof e == "number" ? this._tileTransform.scale.set(e) : this._tileTransform.scale.copyFrom(e)
    }
    set tileRotation(e) {
        this._tileTransform.rotation = e
    }
    get tileRotation() {
        return this._tileTransform.rotation
    }
    get tileTransform() {
        return this._tileTransform
    }
    set texture(e) {
        e || (e = we.EMPTY);
        const n = this._texture;
        n !== e && (n && n.dynamic && n.off("update", this.onViewUpdate, this), e.dynamic && e.on("update", this.onViewUpdate, this), this._texture = e, this.onViewUpdate())
    }
    get texture() {
        return this._texture
    }
    set width(e) {
        this._width = e, this.onViewUpdate()
    }
    get width() {
        return this._width
    }
    set height(e) {
        this._height = e, this.onViewUpdate()
    }
    get height() {
        return this._height
    }
    setSize(e, n) {
        typeof e == "object" && (n = e.height ? ? e.width, e = e.width), this._width = e, this._height = n ? ? e, this.onViewUpdate()
    }
    getSize(e) {
        return e || (e = {}), e.width = this._width, e.height = this._height, e
    }
    updateBounds() {
        const e = this._bounds,
            n = this._anchor,
            r = this._width,
            i = this._height;
        e.minX = -n._x * r, e.maxX = e.minX + r, e.minY = -n._y * i, e.maxY = e.minY + i
    }
    containsPoint(e) {
        const n = this._width,
            r = this._height,
            i = -n * this._anchor._x;
        let s = 0;
        return e.x >= i && e.x <= i + n && (s = -r * this._anchor._y, e.y >= s && e.y <= s + r)
    }
    destroy(e = !1) {
        if (super.destroy(e), this._anchor = null, this._tileTransform = null, this._bounds = null, typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
            const r = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
            this._texture.destroy(r)
        }
        this._texture = null
    }
};
M$.defaultOptions = {
    texture: we.EMPTY,
    anchor: {
        x: 0,
        y: 0
    },
    tilePosition: {
        x: 0,
        y: 0
    },
    tileScale: {
        x: 1,
        y: 1
    },
    tileRotation: 0,
    applyAnchorToTexture: !1
};
let Tbe = M$;
class Hge extends ld {
    constructor(e, n) {
        const {
            text: r,
            resolution: i,
            style: s,
            anchor: o,
            width: a,
            height: l,
            roundPixels: c,
            ...u
        } = e;
        super({ ...u
        }), this.batched = !0, this._resolution = null, this._autoResolution = !0, this._didTextUpdate = !0, this._styleClass = n, this.text = r ? ? "", this.style = s, this.resolution = i ? ? null, this.allowChildren = !1, this._anchor = new jt({
            _onUpdate: () => {
                this.onViewUpdate()
            }
        }), o && (this.anchor = o), this.roundPixels = c ? ? !1, a !== void 0 && (this.width = a), l !== void 0 && (this.height = l)
    }
    get anchor() {
        return this._anchor
    }
    set anchor(e) {
        typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
    }
    set text(e) {
        e = e.toString(), this._text !== e && (this._text = e, this.onViewUpdate())
    }
    get text() {
        return this._text
    }
    set resolution(e) {
        this._autoResolution = e === null, this._resolution = e, this.onViewUpdate()
    }
    get resolution() {
        return this._resolution
    }
    get style() {
        return this._style
    }
    set style(e) {
        var n;
        e || (e = {}), (n = this._style) == null || n.off("update", this.onViewUpdate, this), e instanceof this._styleClass ? this._style = e : this._style = new this._styleClass(e), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate()
    }
    get width() {
        return Math.abs(this.scale.x) * this.bounds.width
    }
    set width(e) {
        this._setWidth(e, this.bounds.width)
    }
    get height() {
        return Math.abs(this.scale.y) * this.bounds.height
    }
    set height(e) {
        this._setHeight(e, this.bounds.height)
    }
    getSize(e) {
        return e || (e = {}), e.width = Math.abs(this.scale.x) * this.bounds.width, e.height = Math.abs(this.scale.y) * this.bounds.height, e
    }
    setSize(e, n) {
        typeof e == "object" ? (n = e.height ? ? e.width, e = e.width) : n ? ? (n = e), e !== void 0 && this._setWidth(e, this.bounds.width), n !== void 0 && this._setHeight(n, this.bounds.height)
    }
    containsPoint(e) {
        const n = this.bounds.width,
            r = this.bounds.height,
            i = -n * this.anchor.x;
        let s = 0;
        return e.x >= i && e.x <= i + n && (s = -r * this.anchor.y, e.y >= s && e.y <= s + r)
    }
    onViewUpdate() {
        this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate()
    }
    _getKey() {
        return `${this.text}:${this._style.styleKey}:${this._resolution}`
    }
    destroy(e = !1) {
        super.destroy(e), this.owner = null, this._bounds = null, this._anchor = null, (typeof e == "boolean" ? e : e != null && e.style) && this._style.destroy(e), this._style = null, this._text = null
    }
}

function zge(t, e) {
    let n = t[0] ? ? {};
    return (typeof n == "string" || t[1]) && ($e(Ye, `use new ${e}({ text: "hi!", style }) instead`), n = {
        text: n,
        style: t[1]
    }), n
}
class Cbe extends Hge {
    constructor(...e) {
        const n = zge(e, "Text");
        super(n, Wi), this.renderPipeId = "text"
    }
    updateBounds() {
        const e = this._bounds,
            n = this._anchor,
            r = Ci.measureText(this._text, this._style),
            {
                width: i,
                height: s
            } = r;
        e.minX = -n._x * i, e.maxX = e.minX + i, e.minY = -n._y * s, e.maxY = e.minY + s
    }
}

function jge(t) {
    const e = t._stroke,
        n = t._fill,
        i = [`div { ${[`color: ${rt.shared.setValue(n.color).toHex()}`,`font-size: ${t.fontSize}px`,`font-family: ${t.fontFamily}`,`font-weight: ${t.fontWeight}`,`font-style: ${t.fontStyle}`,`font-variant: ${t.fontVariant}`,`letter-spacing: ${t.letterSpacing}px`,`text-align: ${t.align}`,`padding: ${t.padding}px`,`white-space: ${t.whiteSpace==="pre"&&t.wordWrap?"pre-wrap":t.whiteSpace}`,...t.lineHeight?[`line-height: ${t.lineHeight}px`]:[],...t.wordWrap?[`word-wrap: ${t.breakWords?"break-all":"break-word"}`,`max-width: ${t.wordWrapWidth}px`]:[],...e?[B$(e)]:[],...t.dropShadow?[k$(t.dropShadow)]:[],...t.cssOverrides].join(";")} }`];
    return Vge(t.tagStyles, i), i.join(" ")
}

function k$(t) {
    const e = rt.shared.setValue(t.color).setAlpha(t.alpha).toHexa(),
        n = Math.round(Math.cos(t.angle) * t.distance),
        r = Math.round(Math.sin(t.angle) * t.distance),
        i = `${n}px ${r}px`;
    return t.blur > 0 ? `text-shadow: ${i} ${t.blur}px ${e}` : `text-shadow: ${i} ${e}`
}

function B$(t) {
    return [`-webkit-text-stroke-width: ${t.width}px`, `-webkit-text-stroke-color: ${rt.shared.setValue(t.color).toHex()}`, `text-stroke-width: ${t.width}px`, `text-stroke-color: ${rt.shared.setValue(t.color).toHex()}`, "paint-order: stroke"].join(";")
}
const dP = {
        fontSize: "font-size: {{VALUE}}px",
        fontFamily: "font-family: {{VALUE}}",
        fontWeight: "font-weight: {{VALUE}}",
        fontStyle: "font-style: {{VALUE}}",
        fontVariant: "font-variant: {{VALUE}}",
        letterSpacing: "letter-spacing: {{VALUE}}px",
        align: "text-align: {{VALUE}}",
        padding: "padding: {{VALUE}}px",
        whiteSpace: "white-space: {{VALUE}}",
        lineHeight: "line-height: {{VALUE}}px",
        wordWrapWidth: "max-width: {{VALUE}}px"
    },
    fP = {
        fill: t => `color: ${rt.shared.setValue(t).toHex()}`,
        breakWords: t => `word-wrap: ${t?"break-all":"break-word"}`,
        stroke: B$,
        dropShadow: k$
    };

function Vge(t, e) {
    for (const n in t) {
        const r = t[n],
            i = [];
        for (const s in r) fP[s] ? i.push(fP[s](r[s])) : dP[s] && i.push(dP[s].replace("{{VALUE}}", r[s]));
        e.push(`${n} { ${i.join(";")} }`)
    }
}
class aw extends Wi {
    constructor(e = {}) {
        super(e), this._cssOverrides = [], this.cssOverrides ? ? (this.cssOverrides = e.cssOverrides), this.tagStyles = e.tagStyles ? ? {}
    }
    set cssOverrides(e) {
        this._cssOverrides = e instanceof Array ? e : [e], this.update()
    }
    get cssOverrides() {
        return this._cssOverrides
    }
    _generateKey() {
        return this._styleKey = d$(this) + this._cssOverrides.join("-"), this._styleKey
    }
    update() {
        this._cssStyle = null, super.update()
    }
    clone() {
        return new aw({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this.dropShadow ? { ...this.dropShadow
            } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            cssOverrides: this.cssOverrides
        })
    }
    get cssStyle() {
        return this._cssStyle || (this._cssStyle = jge(this)), this._cssStyle
    }
    addOverride(...e) {
        const n = e.filter(r => !this.cssOverrides.includes(r));
        n.length > 0 && (this.cssOverrides.push(...n), this.update())
    }
    removeOverride(...e) {
        const n = e.filter(r => this.cssOverrides.includes(r));
        n.length > 0 && (this.cssOverrides = this.cssOverrides.filter(r => !n.includes(r)), this.update())
    }
    set fill(e) {
        typeof e != "string" && typeof e != "number" && Me("[HTMLTextStyle] only color fill is not supported by HTMLText"), super.fill = e
    }
    set stroke(e) {
        e && typeof e != "string" && typeof e != "number" && Me("[HTMLTextStyle] only color stroke is not supported by HTMLText"), super.stroke = e
    }
}
const hP = "http://www.w3.org/2000/svg",
    pP = "http://www.w3.org/1999/xhtml";
class D$ {
    constructor() {
        this.svgRoot = document.createElementNS(hP, "svg"), this.foreignObject = document.createElementNS(hP, "foreignObject"), this.domElement = document.createElementNS(pP, "div"), this.styleElement = document.createElementNS(pP, "style"), this.image = new Image;
        const {
            foreignObject: e,
            svgRoot: n,
            styleElement: r,
            domElement: i
        } = this;
        e.setAttribute("width", "10000"), e.setAttribute("height", "10000"), e.style.overflow = "hidden", n.appendChild(e), e.appendChild(r), e.appendChild(i)
    }
}
let mP;

function Wge(t, e, n, r) {
    r || (r = mP || (mP = new D$));
    const {
        domElement: i,
        styleElement: s,
        svgRoot: o
    } = r;
    i.innerHTML = `<style>${e.cssStyle};</style><div style='padding:0'>${t}</div>`, i.setAttribute("style", "transform-origin: top left; display: inline-block"), n && (s.textContent = n), document.body.appendChild(o);
    const a = i.getBoundingClientRect();
    o.remove();
    const l = e.padding * 2;
    return {
        width: a.width - l,
        height: a.height - l
    }
}
class $$ {
    constructor() {
        this._tempState = kr.for2d(), this._didUploadHash = {}
    }
    init(e) {
        e.renderer.runners.contextChange.add(this)
    }
    contextChange() {
        this._didUploadHash = {}
    }
    start(e, n, r) {
        const i = e.renderer,
            s = this._didUploadHash[r.uid];
        i.shader.bind(r, s), s || (this._didUploadHash[r.uid] = !0), i.shader.updateUniformGroup(i.globalUniforms.uniformGroup), i.geometry.bind(n, r.glProgram)
    }
    execute(e, n) {
        const r = e.renderer;
        this._tempState.blendMode = n.blendMode, r.state.set(this._tempState);
        const i = n.textures.textures;
        for (let s = 0; s < n.textures.count; s++) r.texture.bind(i[s], s);
        r.geometry.draw(n.topology, n.size, n.start)
    }
}
$$.extension = {
    type: [G.WebGLPipesAdaptor],
    name: "batch"
};
const mf = kr.for2d();
class F$ {
    start(e, n, r) {
        const i = e.renderer,
            s = i.encoder,
            o = r.gpuProgram;
        this._shader = r, this._geometry = n, s.setGeometry(n, o), mf.blendMode = "normal", i.pipeline.getPipeline(n, o, mf);
        const a = i.globalUniforms.bindGroup;
        s.resetBindGroup(1), s.setBindGroup(0, a, o)
    }
    execute(e, n) {
        const r = this._shader.gpuProgram,
            i = e.renderer,
            s = i.encoder;
        if (!n.bindGroup) {
            const l = n.textures;
            n.bindGroup = jx(l.textures, l.count)
        }
        mf.blendMode = n.blendMode;
        const o = i.bindGroup.getBindGroup(n.bindGroup, r, 1),
            a = i.pipeline.getPipeline(this._geometry, r, mf, n.topology);
        n.bindGroup._touch(i.textureGC.count), s.setPipeline(a), s.renderPassEncoder.setBindGroup(1, o), s.renderPassEncoder.drawIndexed(n.size, 1, n.start)
    }
}
F$.extension = {
    type: [G.WebGPUPipesAdaptor],
    name: "batch"
};
const lw = class L$ {
    constructor(e, n) {
        var r, i;
        this.state = kr.for2d(), this._batchersByInstructionSet = Object.create(null), this._activeBatches = Object.create(null), this.renderer = e, this._adaptor = n, (i = (r = this._adaptor).init) == null || i.call(r, this)
    }
    static getBatcher(e) {
        return new this._availableBatchers[e]
    }
    buildStart(e) {
        let n = this._batchersByInstructionSet[e.uid];
        n || (n = this._batchersByInstructionSet[e.uid] = Object.create(null), n.default || (n.default = new qx)), this._activeBatches = n, this._activeBatch = this._activeBatches.default;
        for (const r in this._activeBatches) this._activeBatches[r].begin()
    }
    addToBatch(e, n) {
        if (this._activeBatch.name !== e.batcherName) {
            this._activeBatch.break(n);
            let r = this._activeBatches[e.batcherName];
            r || (r = this._activeBatches[e.batcherName] = L$.getBatcher(e.batcherName), r.begin()), this._activeBatch = r
        }
        this._activeBatch.add(e)
    }
    break (e) {
        this._activeBatch.break(e)
    }
    buildEnd(e) {
        this._activeBatch.break(e);
        const n = this._activeBatches;
        for (const r in n) {
            const i = n[r],
                s = i.geometry;
            s.indexBuffer.setDataWithSize(i.indexBuffer, i.indexSize, !0), s.buffers[0].setDataWithSize(i.attributeBuffer.float32View, i.attributeSize, !1)
        }
    }
    upload(e) {
        const n = this._batchersByInstructionSet[e.uid];
        for (const r in n) {
            const i = n[r],
                s = i.geometry;
            i.dirty && (i.dirty = !1, s.buffers[0].update(i.attributeSize * 4))
        }
    }
    execute(e) {
        if (e.action === "startBatch") {
            const n = e.batcher,
                r = n.geometry,
                i = n.shader;
            this._adaptor.start(this, r, i)
        }
        this._adaptor.execute(this, e)
    }
    destroy() {
        this.state = null, this.renderer = null, this._adaptor = null;
        for (const e in this._activeBatches) this._activeBatches[e].destroy();
        this._activeBatches = null
    }
};
lw.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "batch"
};
lw._availableBatchers = Object.create(null);
let N$ = lw;
Ie.handleByMap(G.Batcher, N$._availableBatchers);
Ie.add(qx);
const Yc = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
            main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
            end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        }
    },
    Yge = { ...Yc,
        vertex: { ...Yc.vertex,
            header: Yc.vertex.header.replace("group(1)", "group(2)")
        }
    },
    cw = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        }
    },
    Xge = {
        name: "texture-bit",
        vertex: {
            header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
            main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
            header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `,
            main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
        }
    },
    Kge = {
        name: "texture-bit",
        vertex: {
            header: `
            uniform mat3 uTextureMatrix;
        `,
            main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
            header: `
        uniform sampler2D uTexture;

         
        `,
            main: `
            outColor = texture(uTexture, vUV);
        `
        }
    },
    qge = new rn;
class Jge extends Ph {
    constructor() {
        super(), this.filters = [new Uge({
            sprite: new ta(we.EMPTY),
            inverse: !1,
            resolution: "inherit",
            antialias: "inherit"
        })]
    }
    get sprite() {
        return this.filters[0].sprite
    }
    set sprite(e) {
        this.filters[0].sprite = e
    }
    get inverse() {
        return this.filters[0].inverse
    }
    set inverse(e) {
        this.filters[0].inverse = e
    }
}
class U$ {
    constructor(e) {
        this._activeMaskStage = [], this._renderer = e
    }
    push(e, n, r) {
        const i = this._renderer;
        if (i.renderPipes.batch.break(r), r.add({
                renderPipeId: "alphaMask",
                action: "pushMaskBegin",
                mask: e,
                inverse: n._maskOptions.inverse,
                canBundle: !1,
                maskedContainer: n
            }), e.inverse = n._maskOptions.inverse, e.renderMaskToTexture) {
            const s = e.mask;
            s.includeInBuild = !0, s.collectRenderables(r, i, null), s.includeInBuild = !1
        }
        i.renderPipes.batch.break(r), r.add({
            renderPipeId: "alphaMask",
            action: "pushMaskEnd",
            mask: e,
            maskedContainer: n,
            inverse: n._maskOptions.inverse,
            canBundle: !1
        })
    }
    pop(e, n, r) {
        this._renderer.renderPipes.batch.break(r), r.add({
            renderPipeId: "alphaMask",
            action: "popMaskEnd",
            mask: e,
            inverse: n._maskOptions.inverse,
            canBundle: !1
        })
    }
    execute(e) {
        const n = this._renderer,
            r = e.mask.renderMaskToTexture;
        if (e.action === "pushMaskBegin") {
            const i = We.get(Jge);
            if (i.inverse = e.inverse, r) {
                e.mask.mask.measurable = !0;
                const s = kx(e.mask.mask, !0, qge);
                e.mask.mask.measurable = !1, s.ceil();
                const o = n.renderTarget.renderTarget.colorTexture.source,
                    a = Ft.getOptimalTexture(s.width, s.height, o._resolution, o.antialias);
                n.renderTarget.push(a, !0), n.globalUniforms.push({
                    offset: s,
                    worldColor: 4294967295
                });
                const l = i.sprite;
                l.texture = a, l.worldTransform.tx = s.minX, l.worldTransform.ty = s.minY, this._activeMaskStage.push({
                    filterEffect: i,
                    maskedContainer: e.maskedContainer,
                    filterTexture: a
                })
            } else i.sprite = e.mask.mask, this._activeMaskStage.push({
                filterEffect: i,
                maskedContainer: e.maskedContainer
            })
        } else if (e.action === "pushMaskEnd") {
            const i = this._activeMaskStage[this._activeMaskStage.length - 1];
            r && (n.type === Qn.WEBGL && n.renderTarget.finishRenderPass(), n.renderTarget.pop(), n.globalUniforms.pop()), n.filter.push({
                renderPipeId: "filter",
                action: "pushFilter",
                container: i.maskedContainer,
                filterEffect: i.filterEffect,
                canBundle: !1
            })
        } else if (e.action === "popMaskEnd") {
            n.filter.pop();
            const i = this._activeMaskStage.pop();
            r && Ft.returnTexture(i.filterTexture), We.return(i.filterEffect)
        }
    }
    destroy() {
        this._renderer = null, this._activeMaskStage = null
    }
}
U$.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "alphaMask"
};
class G$ {
    constructor(e) {
        this._colorStack = [], this._colorStackIndex = 0, this._currentColor = 0, this._renderer = e
    }
    buildStart() {
        this._colorStack[0] = 15, this._colorStackIndex = 1, this._currentColor = 15
    }
    push(e, n, r) {
        this._renderer.renderPipes.batch.break(r);
        const s = this._colorStack;
        s[this._colorStackIndex] = s[this._colorStackIndex - 1] & e.mask;
        const o = this._colorStack[this._colorStackIndex];
        o !== this._currentColor && (this._currentColor = o, r.add({
            renderPipeId: "colorMask",
            colorMask: o,
            canBundle: !1
        })), this._colorStackIndex++
    }
    pop(e, n, r) {
        this._renderer.renderPipes.batch.break(r);
        const s = this._colorStack;
        this._colorStackIndex--;
        const o = s[this._colorStackIndex - 1];
        o !== this._currentColor && (this._currentColor = o, r.add({
            renderPipeId: "colorMask",
            colorMask: o,
            canBundle: !1
        }))
    }
    execute(e) {
        this._renderer.colorMask.setMask(e.colorMask)
    }
    destroy() {
        this._colorStack = null
    }
}
G$.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "colorMask"
};
class H$ {
    constructor(e) {
        this._maskStackHash = {}, this._maskHash = new WeakMap, this._renderer = e
    }
    push(e, n, r) {
        var i;
        const s = e,
            o = this._renderer;
        o.renderPipes.batch.break(r), o.renderPipes.blendMode.setBlendMode(s.mask, "none", r), r.add({
            renderPipeId: "stencilMask",
            action: "pushMaskBegin",
            mask: e,
            inverse: n._maskOptions.inverse,
            canBundle: !1
        });
        const a = s.mask;
        a.includeInBuild = !0, this._maskHash.has(s) || this._maskHash.set(s, {
            instructionsStart: 0,
            instructionsLength: 0
        });
        const l = this._maskHash.get(s);
        l.instructionsStart = r.instructionSize, a.collectRenderables(r, o, null), a.includeInBuild = !1, o.renderPipes.batch.break(r), r.add({
            renderPipeId: "stencilMask",
            action: "pushMaskEnd",
            mask: e,
            inverse: n._maskOptions.inverse,
            canBundle: !1
        });
        const c = r.instructionSize - l.instructionsStart - 1;
        l.instructionsLength = c;
        const u = o.renderTarget.renderTarget.uid;
        (i = this._maskStackHash)[u] ? ? (i[u] = 0)
    }
    pop(e, n, r) {
        const i = e,
            s = this._renderer;
        s.renderPipes.batch.break(r), s.renderPipes.blendMode.setBlendMode(i.mask, "none", r), r.add({
            renderPipeId: "stencilMask",
            action: "popMaskBegin",
            inverse: n._maskOptions.inverse,
            canBundle: !1
        });
        const o = this._maskHash.get(e);
        for (let a = 0; a < o.instructionsLength; a++) r.instructions[r.instructionSize++] = r.instructions[o.instructionsStart++];
        r.add({
            renderPipeId: "stencilMask",
            action: "popMaskEnd",
            canBundle: !1
        })
    }
    execute(e) {
        var n;
        const r = this._renderer,
            i = r.renderTarget.renderTarget.uid;
        let s = (n = this._maskStackHash)[i] ? ? (n[i] = 0);
        e.action === "pushMaskBegin" ? (r.renderTarget.ensureDepthStencil(), r.stencil.setStencilMode(Mt.RENDERING_MASK_ADD, s), s++, r.colorMask.setMask(0)) : e.action === "pushMaskEnd" ? (e.inverse ? r.stencil.setStencilMode(Mt.INVERSE_MASK_ACTIVE, s) : r.stencil.setStencilMode(Mt.MASK_ACTIVE, s), r.colorMask.setMask(15)) : e.action === "popMaskBegin" ? (r.colorMask.setMask(0), s !== 0 ? r.stencil.setStencilMode(Mt.RENDERING_MASK_REMOVE, s) : (r.renderTarget.clear(null, jn.STENCIL), r.stencil.setStencilMode(Mt.DISABLED, s)), s--) : e.action === "popMaskEnd" && (e.inverse ? r.stencil.setStencilMode(Mt.INVERSE_MASK_ACTIVE, s) : r.stencil.setStencilMode(Mt.MASK_ACTIVE, s), r.colorMask.setMask(15)), this._maskStackHash[i] = s
    }
    destroy() {
        this._renderer = null, this._maskStackHash = null, this._maskHash = null
    }
}
H$.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "stencilMask"
};
var zf = (t => (t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", t))(zf || {});
class Zge {
    constructor(e, n) {
        this._lastBindBaseLocation = -1, this._lastBindCallId = -1, this.buffer = e || null, this.updateID = -1, this.byteLength = -1, this.type = n
    }
}
class z$ {
    constructor(e) {
        this._gpuBuffers = Object.create(null), this._boundBufferBases = Object.create(null), this._minBaseLocation = 0, this._nextBindBaseIndex = this._minBaseLocation, this._bindCallId = 0, this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers")
    }
    destroy() {
        this._renderer = null, this._gl = null, this._gpuBuffers = null, this._boundBufferBases = null
    }
    contextChange() {
        const e = this._gl = this._renderer.gl;
        this._gpuBuffers = Object.create(null), this._maxBindings = e.MAX_UNIFORM_BUFFER_BINDINGS ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0
    }
    getGlBuffer(e) {
        return this._gpuBuffers[e.uid] || this.createGLBuffer(e)
    }
    bind(e) {
        const {
            _gl: n
        } = this, r = this.getGlBuffer(e);
        n.bindBuffer(r.type, r.buffer)
    }
    bindBufferBase(e, n) {
        const {
            _gl: r
        } = this;
        this._boundBufferBases[n] !== e && (this._boundBufferBases[n] = e, e._lastBindBaseLocation = n, r.bindBufferBase(r.UNIFORM_BUFFER, n, e.buffer))
    }
    nextBindBase(e) {
        this._bindCallId++, this._minBaseLocation = 0, e && (this._boundBufferBases[0] = null, this._minBaseLocation = 1, this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1))
    }
    freeLocationForBufferBase(e) {
        let n = this.getLastBindBaseLocation(e);
        if (n >= this._minBaseLocation) return e._lastBindCallId = this._bindCallId, n;
        let r = 0,
            i = this._nextBindBaseIndex;
        for (; r < 2;) {
            i >= this._maxBindings && (i = this._minBaseLocation, r++);
            const s = this._boundBufferBases[i];
            if (s && s._lastBindCallId === this._bindCallId) {
                i++;
                continue
            }
            break
        }
        return n = i, this._nextBindBaseIndex = i + 1, r >= 2 ? -1 : (e._lastBindCallId = this._bindCallId, this._boundBufferBases[n] = null, n)
    }
    getLastBindBaseLocation(e) {
        const n = e._lastBindBaseLocation;
        return this._boundBufferBases[n] === e ? n : -1
    }
    bindBufferRange(e, n, r, i) {
        const {
            _gl: s
        } = this;
        r || (r = 0), n || (n = 0), this._boundBufferBases[n] = null, s.bindBufferRange(s.UNIFORM_BUFFER, n || 0, e.buffer, r * 256, i || 256)
    }
    updateBuffer(e) {
        const {
            _gl: n
        } = this, r = this.getGlBuffer(e);
        if (e._updateID === r.updateID) return r;
        r.updateID = e._updateID, n.bindBuffer(r.type, r.buffer);
        const i = e.data,
            s = e.descriptor.usage & Xe.STATIC ? n.STATIC_DRAW : n.DYNAMIC_DRAW;
        return i ? r.byteLength >= i.byteLength ? n.bufferSubData(r.type, 0, i, 0, e._updateSize / i.BYTES_PER_ELEMENT) : (r.byteLength = i.byteLength, n.bufferData(r.type, i, s)) : (r.byteLength = e.descriptor.size, n.bufferData(r.type, r.byteLength, s)), r
    }
    destroyAll() {
        const e = this._gl;
        for (const n in this._gpuBuffers) e.deleteBuffer(this._gpuBuffers[n].buffer);
        this._gpuBuffers = Object.create(null)
    }
    onBufferDestroy(e, n) {
        const r = this._gpuBuffers[e.uid],
            i = this._gl;
        n || i.deleteBuffer(r.buffer), this._gpuBuffers[e.uid] = null
    }
    createGLBuffer(e) {
        const {
            _gl: n
        } = this;
        let r = zf.ARRAY_BUFFER;
        e.descriptor.usage & Xe.INDEX ? r = zf.ELEMENT_ARRAY_BUFFER : e.descriptor.usage & Xe.UNIFORM && (r = zf.UNIFORM_BUFFER);
        const i = new Zge(n.createBuffer(), r);
        return this._gpuBuffers[e.uid] = i, e.on("destroy", this.onBufferDestroy, this), i
    }
    resetState() {
        this._boundBufferBases = Object.create(null)
    }
}
z$.extension = {
    type: [G.WebGLSystem],
    name: "buffer"
};
const uw = class j$ {
    constructor(e) {
        this.supports = {
            uint32Indices: !0,
            uniformBufferObject: !0,
            vertexArrayObject: !0,
            srgbTextures: !0,
            nonPowOf2wrapping: !0,
            msaa: !0,
            nonPowOf2mipmaps: !0
        }, this._renderer = e, this.extensions = Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this)
    }
    get isLost() {
        return !this.gl || this.gl.isContextLost()
    }
    contextChange(e) {
        this.gl = e, this._renderer.gl = e
    }
    init(e) {
        e = { ...j$.defaultOptions,
            ...e
        };
        let n = this.multiView = e.multiView;
        if (e.context && n && (Me("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."), n = !1), n ? this.canvas = He.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height) : this.canvas = this._renderer.view.canvas, e.context) this.initFromContext(e.context);
        else {
            const r = this._renderer.background.alpha < 1,
                i = e.premultipliedAlpha ? ? !0,
                s = e.antialias && !this._renderer.backBuffer.useBackBuffer;
            this.createContext(e.preferWebGLVersion, {
                alpha: r,
                premultipliedAlpha: i,
                antialias: s,
                stencil: !0,
                preserveDrawingBuffer: e.preserveDrawingBuffer,
                powerPreference: e.powerPreference ? ? "default"
            })
        }
    }
    ensureCanvasSize(e) {
        if (!this.multiView) {
            e !== this.canvas && Me("multiView is disabled, but targetCanvas is not the main canvas");
            return
        }
        const {
            canvas: n
        } = this;
        (n.width < e.width || n.height < e.height) && (n.width = Math.max(e.width, e.width), n.height = Math.max(e.height, e.height))
    }
    initFromContext(e) {
        this.gl = e, this.webGLVersion = e instanceof He.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(e), this._renderer.runners.contextChange.emit(e);
        const n = this._renderer.view.canvas;
        n.addEventListener("webglcontextlost", this.handleContextLost, !1), n.addEventListener("webglcontextrestored", this.handleContextRestored, !1)
    }
    createContext(e, n) {
        let r;
        const i = this.canvas;
        if (e === 2 && (r = i.getContext("webgl2", n)), !r && (r = i.getContext("webgl", n), !r)) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        this.gl = r, this.initFromContext(this.gl)
    }
    getExtensions() {
        const {
            gl: e
        } = this, n = {
            anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: e.getExtension("OES_texture_float_linear"),
            s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: e.getExtension("WEBGL_compressed_texture_etc"),
            etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: e.getExtension("WEBGL_compressed_texture_atc"),
            astc: e.getExtension("WEBGL_compressed_texture_astc"),
            bptc: e.getExtension("EXT_texture_compression_bptc"),
            rgtc: e.getExtension("EXT_texture_compression_rgtc"),
            loseContext: e.getExtension("WEBGL_lose_context")
        };
        if (this.webGLVersion === 1) this.extensions = { ...n,
            drawBuffers: e.getExtension("WEBGL_draw_buffers"),
            depthTexture: e.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: e.getExtension("OES_vertex_array_object") || e.getExtension("MOZ_OES_vertex_array_object") || e.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: e.getExtension("OES_element_index_uint"),
            floatTexture: e.getExtension("OES_texture_float"),
            floatTextureLinear: e.getExtension("OES_texture_float_linear"),
            textureHalfFloat: e.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear"),
            vertexAttribDivisorANGLE: e.getExtension("ANGLE_instanced_arrays"),
            srgb: e.getExtension("EXT_sRGB")
        };
        else {
            this.extensions = { ...n,
                colorBufferFloat: e.getExtension("EXT_color_buffer_float")
            };
            const r = e.getExtension("WEBGL_provoking_vertex");
            r && r.provokingVertexWEBGL(r.FIRST_VERTEX_CONVENTION_WEBGL)
        }
    }
    handleContextLost(e) {
        e.preventDefault(), this._contextLossForced && (this._contextLossForced = !1, setTimeout(() => {
            var n;
            this.gl.isContextLost() && ((n = this.extensions.loseContext) == null || n.restoreContext())
        }, 0))
    }
    handleContextRestored() {
        this.getExtensions(), this._renderer.runners.contextChange.emit(this.gl)
    }
    destroy() {
        var n;
        const e = this._renderer.view.canvas;
        this._renderer = null, e.removeEventListener("webglcontextlost", this.handleContextLost), e.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), (n = this.extensions.loseContext) == null || n.loseContext()
    }
    forceContextLoss() {
        var e;
        (e = this.extensions.loseContext) == null || e.loseContext(), this._contextLossForced = !0
    }
    validateContext(e) {
        const n = e.getContextAttributes();
        n && !n.stencil && Me("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        const r = this.supports,
            i = this.webGLVersion === 2,
            s = this.extensions;
        r.uint32Indices = i || !!s.uint32ElementIndex, r.uniformBufferObject = i, r.vertexArrayObject = i || !!s.vertexArrayObject, r.srgbTextures = i || !!s.srgb, r.nonPowOf2wrapping = i, r.nonPowOf2mipmaps = i, r.msaa = i, r.uint32Indices || Me("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly")
    }
};
uw.extension = {
    type: [G.WebGLSystem],
    name: "context"
};
uw.defaultOptions = {
    context: null,
    premultipliedAlpha: !0,
    preserveDrawingBuffer: !1,
    powerPreference: void 0,
    preferWebGLVersion: 2,
    multiView: !1
};
let Qge = uw;

function V$(t, e) {
    for (const n in t.attributes) {
        const r = t.attributes[n],
            i = e[n];
        i ? (r.format ? ? (r.format = i.format), r.offset ? ? (r.offset = i.offset), r.instance ? ? (r.instance = i.instance)) : Me(`Attribute ${n} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)
    }
    eve(t)
}

function eve(t) {
    const {
        buffers: e,
        attributes: n
    } = t, r = {}, i = {};
    for (const s in e) {
        const o = e[s];
        r[o.uid] = 0, i[o.uid] = 0
    }
    for (const s in n) {
        const o = n[s];
        r[o.buffer.uid] += Gs(o.format).stride
    }
    for (const s in n) {
        const o = n[s];
        o.stride ? ? (o.stride = r[o.buffer.uid]), o.start ? ? (o.start = i[o.buffer.uid]), i[o.buffer.uid] += Gs(o.format).stride
    }
}
var G0 = (t => (t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.RG = 33319] = "RG", t[t.RED = 6403] = "RED", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", t))(G0 || {}),
    W$ = (t => (t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", t))(W$ || {}),
    Qe = (t => (t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.BYTE = 5120] = "BYTE", t[t.SHORT = 5122] = "SHORT", t[t.INT = 5124] = "INT", t[t.FLOAT = 5126] = "FLOAT", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT", t))(Qe || {});
const gP = {
    uint8x2: Qe.UNSIGNED_BYTE,
    uint8x4: Qe.UNSIGNED_BYTE,
    sint8x2: Qe.BYTE,
    sint8x4: Qe.BYTE,
    unorm8x2: Qe.UNSIGNED_BYTE,
    unorm8x4: Qe.UNSIGNED_BYTE,
    snorm8x2: Qe.BYTE,
    snorm8x4: Qe.BYTE,
    uint16x2: Qe.UNSIGNED_SHORT,
    uint16x4: Qe.UNSIGNED_SHORT,
    sint16x2: Qe.SHORT,
    sint16x4: Qe.SHORT,
    unorm16x2: Qe.UNSIGNED_SHORT,
    unorm16x4: Qe.UNSIGNED_SHORT,
    snorm16x2: Qe.SHORT,
    snorm16x4: Qe.SHORT,
    float16x2: Qe.HALF_FLOAT,
    float16x4: Qe.HALF_FLOAT,
    float32: Qe.FLOAT,
    float32x2: Qe.FLOAT,
    float32x3: Qe.FLOAT,
    float32x4: Qe.FLOAT,
    uint32: Qe.UNSIGNED_INT,
    uint32x2: Qe.UNSIGNED_INT,
    uint32x3: Qe.UNSIGNED_INT,
    uint32x4: Qe.UNSIGNED_INT,
    sint32: Qe.INT,
    sint32x2: Qe.INT,
    sint32x3: Qe.INT,
    sint32x4: Qe.INT
};

function tve(t) {
    return gP[t] ? ? gP.float32
}
const nve = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 3,
    "triangle-list": 4,
    "triangle-strip": 5
};
class Y$ {
    constructor(e) {
        this._geometryVaoHash = Object.create(null), this._renderer = e, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash")
    }
    contextChange() {
        const e = this.gl = this._renderer.gl;
        if (!this._renderer.context.supports.vertexArrayObject) throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
        const n = this._renderer.context.extensions.vertexArrayObject;
        n && (e.createVertexArray = () => n.createVertexArrayOES(), e.bindVertexArray = i => n.bindVertexArrayOES(i), e.deleteVertexArray = i => n.deleteVertexArrayOES(i));
        const r = this._renderer.context.extensions.vertexAttribDivisorANGLE;
        r && (e.drawArraysInstanced = (i, s, o, a) => {
            r.drawArraysInstancedANGLE(i, s, o, a)
        }, e.drawElementsInstanced = (i, s, o, a, l) => {
            r.drawElementsInstancedANGLE(i, s, o, a, l)
        }, e.vertexAttribDivisor = (i, s) => r.vertexAttribDivisorANGLE(i, s)), this._activeGeometry = null, this._activeVao = null, this._geometryVaoHash = Object.create(null)
    }
    bind(e, n) {
        const r = this.gl;
        this._activeGeometry = e;
        const i = this.getVao(e, n);
        this._activeVao !== i && (this._activeVao = i, r.bindVertexArray(i)), this.updateBuffers()
    }
    resetState() {
        this.unbind()
    }
    updateBuffers() {
        const e = this._activeGeometry,
            n = this._renderer.buffer;
        for (let r = 0; r < e.buffers.length; r++) {
            const i = e.buffers[r];
            n.updateBuffer(i)
        }
    }
    checkCompatibility(e, n) {
        const r = e.attributes,
            i = n._attributeData;
        for (const s in i)
            if (!r[s]) throw new Error(`shader and geometry incompatible, geometry missing the "${s}" attribute`)
    }
    getSignature(e, n) {
        const r = e.attributes,
            i = n._attributeData,
            s = ["g", e.uid];
        for (const o in r) i[o] && s.push(o, i[o].location);
        return s.join("-")
    }
    getVao(e, n) {
        var r;
        return ((r = this._geometryVaoHash[e.uid]) == null ? void 0 : r[n._key]) || this.initGeometryVao(e, n)
    }
    initGeometryVao(e, n, r = !0) {
        const i = this._renderer.gl,
            s = this._renderer.buffer;
        this._renderer.shader._getProgramData(n), this.checkCompatibility(e, n);
        const o = this.getSignature(e, n);
        this._geometryVaoHash[e.uid] || (this._geometryVaoHash[e.uid] = Object.create(null), e.on("destroy", this.onGeometryDestroy, this));
        const a = this._geometryVaoHash[e.uid];
        let l = a[o];
        if (l) return a[n._key] = l, l;
        V$(e, n._attributeData);
        const c = e.buffers;
        l = i.createVertexArray(), i.bindVertexArray(l);
        for (let u = 0; u < c.length; u++) {
            const d = c[u];
            s.bind(d)
        }
        return this.activateVao(e, n), a[n._key] = l, a[o] = l, i.bindVertexArray(null), l
    }
    onGeometryDestroy(e, n) {
        const r = this._geometryVaoHash[e.uid],
            i = this.gl;
        if (r) {
            if (n)
                for (const s in r) this._activeVao !== r[s] && this.unbind(), i.deleteVertexArray(r[s]);
            this._geometryVaoHash[e.uid] = null
        }
    }
    destroyAll(e = !1) {
        const n = this.gl;
        for (const r in this._geometryVaoHash) {
            if (e)
                for (const i in this._geometryVaoHash[r]) {
                    const s = this._geometryVaoHash[r];
                    this._activeVao !== s && this.unbind(), n.deleteVertexArray(s[i])
                }
            this._geometryVaoHash[r] = null
        }
    }
    activateVao(e, n) {
        var a;
        const r = this._renderer.gl,
            i = this._renderer.buffer,
            s = e.attributes;
        e.indexBuffer && i.bind(e.indexBuffer);
        let o = null;
        for (const l in s) {
            const c = s[l],
                u = c.buffer,
                d = i.getGlBuffer(u),
                f = n._attributeData[l];
            if (f) {
                o !== d && (i.bind(u), o = d);
                const h = f.location;
                r.enableVertexAttribArray(h);
                const p = Gs(c.format),
                    b = tve(c.format);
                if (((a = f.format) == null ? void 0 : a.substring(1, 4)) === "int" ? r.vertexAttribIPointer(h, p.size, b, c.stride, c.offset) : r.vertexAttribPointer(h, p.size, b, p.normalised, c.stride, c.offset), c.instance)
                    if (this.hasInstance) {
                        const y = c.divisor ? ? 1;
                        r.vertexAttribDivisor(h, y)
                    } else throw new Error("geometry error, GPU Instancing is not supported on this device")
            }
        }
    }
    draw(e, n, r, i) {
        const {
            gl: s
        } = this._renderer, o = this._activeGeometry, a = nve[e || o.topology];
        if (i ? ? (i = o.instanceCount), o.indexBuffer) {
            const l = o.indexBuffer.data.BYTES_PER_ELEMENT,
                c = l === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
            i > 1 ? s.drawElementsInstanced(a, n || o.indexBuffer.data.length, c, (r || 0) * l, i) : s.drawElements(a, n || o.indexBuffer.data.length, c, (r || 0) * l)
        } else i > 1 ? s.drawArraysInstanced(a, r || 0, n || o.getSize(), i) : s.drawArrays(a, r || 0, n || o.getSize());
        return this
    }
    unbind() {
        this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
    }
    destroy() {
        this._renderer = null, this.gl = null, this._activeVao = null, this._activeGeometry = null
    }
}
Y$.extension = {
    type: [G.WebGLSystem],
    name: "geometry"
};
const rve = new ud({
        attributes: {
            aPosition: [-1, -1, 3, -1, -1, 3]
        }
    }),
    dw = class X$ {
        constructor(e) {
            this.useBackBuffer = !1, this._useBackBufferThisRender = !1, this._renderer = e
        }
        init(e = {}) {
            const {
                useBackBuffer: n,
                antialias: r
            } = { ...X$.defaultOptions,
                ...e
            };
            this.useBackBuffer = n, this._antialias = r, this._renderer.context.supports.msaa || (Me("antialiasing, is not supported on when using the back buffer"), this._antialias = !1), this._state = kr.for2d();
            const i = new ga({
                vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
                fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
                name: "big-triangle"
            });
            this._bigTriangleShader = new pr({
                glProgram: i,
                resources: {
                    uTexture: we.WHITE.source
                }
            })
        }
        renderStart(e) {
            const n = this._renderer.renderTarget.getRenderTarget(e.target);
            if (this._useBackBufferThisRender = this.useBackBuffer && !!n.isRoot, this._useBackBufferThisRender) {
                const r = this._renderer.renderTarget.getRenderTarget(e.target);
                this._targetTexture = r.colorTexture, e.target = this._getBackBufferTexture(r.colorTexture)
            }
        }
        renderEnd() {
            this._presentBackBuffer()
        }
        _presentBackBuffer() {
            const e = this._renderer;
            e.renderTarget.finishRenderPass(), this._useBackBufferThisRender && (e.renderTarget.bind(this._targetTexture, !1), this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source, e.encoder.draw({
                geometry: rve,
                shader: this._bigTriangleShader,
                state: this._state
            }))
        }
        _getBackBufferTexture(e) {
            return this._backBufferTexture = this._backBufferTexture || new we({
                source: new Qt({
                    width: e.width,
                    height: e.height,
                    resolution: e._resolution,
                    antialias: this._antialias
                })
            }), this._backBufferTexture.source.resize(e.width, e.height, e._resolution), this._backBufferTexture
        }
        destroy() {
            this._backBufferTexture && (this._backBufferTexture.destroy(), this._backBufferTexture = null)
        }
    };
dw.extension = {
    type: [G.WebGLSystem],
    name: "backBuffer",
    priority: 1
};
dw.defaultOptions = {
    useBackBuffer: !1
};
let ive = dw;
class K$ {
    constructor(e) {
        this._colorMaskCache = 15, this._renderer = e
    }
    setMask(e) {
        this._colorMaskCache !== e && (this._colorMaskCache = e, this._renderer.gl.colorMask(!!(e & 8), !!(e & 4), !!(e & 2), !!(e & 1)))
    }
}
K$.extension = {
    type: [G.WebGLSystem],
    name: "colorMask"
};
class q$ {
    constructor(e) {
        this.commandFinished = Promise.resolve(), this._renderer = e
    }
    setGeometry(e, n) {
        this._renderer.geometry.bind(e, n.glProgram)
    }
    finishRenderPass() {}
    draw(e) {
        const n = this._renderer,
            {
                geometry: r,
                shader: i,
                state: s,
                skipSync: o,
                topology: a,
                size: l,
                start: c,
                instanceCount: u
            } = e;
        n.shader.bind(i, o), n.geometry.bind(r, n.shader._activeProgram), s && n.state.set(s), n.geometry.draw(a, l, c, u ? ? r.instanceCount)
    }
    destroy() {
        this._renderer = null
    }
}
q$.extension = {
    type: [G.WebGLSystem],
    name: "encoder"
};
class sve {
    constructor() {
        this.width = -1, this.height = -1, this.msaa = !1, this.msaaRenderBuffer = []
    }
}
const eo = [];
eo[Mt.NONE] = void 0;
eo[Mt.DISABLED] = {
    stencilWriteMask: 0,
    stencilReadMask: 0
};
eo[Mt.RENDERING_MASK_ADD] = {
    stencilFront: {
        compare: "equal",
        passOp: "increment-clamp"
    },
    stencilBack: {
        compare: "equal",
        passOp: "increment-clamp"
    }
};
eo[Mt.RENDERING_MASK_REMOVE] = {
    stencilFront: {
        compare: "equal",
        passOp: "decrement-clamp"
    },
    stencilBack: {
        compare: "equal",
        passOp: "decrement-clamp"
    }
};
eo[Mt.MASK_ACTIVE] = {
    stencilWriteMask: 0,
    stencilFront: {
        compare: "equal",
        passOp: "keep"
    },
    stencilBack: {
        compare: "equal",
        passOp: "keep"
    }
};
eo[Mt.INVERSE_MASK_ACTIVE] = {
    stencilWriteMask: 0,
    stencilFront: {
        compare: "not-equal",
        passOp: "replace"
    },
    stencilBack: {
        compare: "not-equal",
        passOp: "replace"
    }
};
class J$ {
    constructor(e) {
        this._stencilCache = {
            enabled: !1,
            stencilReference: 0,
            stencilMode: Mt.NONE
        }, this._renderTargetStencilState = Object.create(null), e.renderTarget.onRenderTargetChange.add(this)
    }
    contextChange(e) {
        this._gl = e, this._comparisonFuncMapping = {
            always: e.ALWAYS,
            never: e.NEVER,
            equal: e.EQUAL,
            "not-equal": e.NOTEQUAL,
            less: e.LESS,
            "less-equal": e.LEQUAL,
            greater: e.GREATER,
            "greater-equal": e.GEQUAL
        }, this._stencilOpsMapping = {
            keep: e.KEEP,
            zero: e.ZERO,
            replace: e.REPLACE,
            invert: e.INVERT,
            "increment-clamp": e.INCR,
            "decrement-clamp": e.DECR,
            "increment-wrap": e.INCR_WRAP,
            "decrement-wrap": e.DECR_WRAP
        }, this.resetState()
    }
    onRenderTargetChange(e) {
        if (this._activeRenderTarget === e) return;
        this._activeRenderTarget = e;
        let n = this._renderTargetStencilState[e.uid];
        n || (n = this._renderTargetStencilState[e.uid] = {
            stencilMode: Mt.DISABLED,
            stencilReference: 0
        }), this.setStencilMode(n.stencilMode, n.stencilReference)
    }
    resetState() {
        this._stencilCache.enabled = !1, this._stencilCache.stencilMode = Mt.NONE, this._stencilCache.stencilReference = 0
    }
    setStencilMode(e, n) {
        const r = this._renderTargetStencilState[this._activeRenderTarget.uid],
            i = this._gl,
            s = eo[e],
            o = this._stencilCache;
        if (r.stencilMode = e, r.stencilReference = n, e === Mt.DISABLED) {
            this._stencilCache.enabled && (this._stencilCache.enabled = !1, i.disable(i.STENCIL_TEST));
            return
        }
        this._stencilCache.enabled || (this._stencilCache.enabled = !0, i.enable(i.STENCIL_TEST)), (e !== o.stencilMode || o.stencilReference !== n) && (o.stencilMode = e, o.stencilReference = n, i.stencilFunc(this._comparisonFuncMapping[s.stencilBack.compare], n, 255), i.stencilOp(i.KEEP, i.KEEP, this._stencilOpsMapping[s.stencilBack.passOp]))
    }
}
J$.extension = {
    type: [G.WebGLSystem],
    name: "stencil"
};
class Z$ {
    constructor(e) {
        this._syncFunctionHash = Object.create(null), this._adaptor = e, this._systemCheck()
    }
    _systemCheck() {
        if (!FD()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")
    }
    ensureUniformGroup(e) {
        const n = this.getUniformGroupData(e);
        e.buffer || (e.buffer = new qn({
            data: new Float32Array(n.layout.size / 4),
            usage: Xe.UNIFORM | Xe.COPY_DST
        }))
    }
    getUniformGroupData(e) {
        return this._syncFunctionHash[e._signature] || this._initUniformGroup(e)
    }
    _initUniformGroup(e) {
        const n = e._signature;
        let r = this._syncFunctionHash[n];
        if (!r) {
            const i = Object.keys(e.uniformStructures).map(a => e.uniformStructures[a]),
                s = this._adaptor.createUboElements(i),
                o = this._generateUboSync(s.uboElements);
            r = this._syncFunctionHash[n] = {
                layout: s,
                syncFunction: o
            }
        }
        return this._syncFunctionHash[n]
    }
    _generateUboSync(e) {
        return this._adaptor.generateUboSync(e)
    }
    syncUniformGroup(e, n, r) {
        const i = this.getUniformGroupData(e);
        e.buffer || (e.buffer = new qn({
            data: new Float32Array(i.layout.size / 4),
            usage: Xe.UNIFORM | Xe.COPY_DST
        }));
        let s = null;
        return n || (n = e.buffer.data, s = e.buffer.dataInt32), r || (r = 0), i.syncFunction(e.uniforms, n, s, r), !0
    }
    updateUniformGroup(e) {
        if (e.isStatic && !e._dirtyId) return !1;
        e._dirtyId = 0;
        const n = this.syncUniformGroup(e);
        return e.buffer.update(), n
    }
    destroy() {
        this._syncFunctionHash = null
    }
}
const Q$ = {
    f32: 4,
    i32: 4,
    "vec2<f32>": 8,
    "vec3<f32>": 12,
    "vec4<f32>": 16,
    "vec2<i32>": 8,
    "vec3<i32>": 12,
    "vec4<i32>": 16,
    "mat2x2<f32>": 16 * 2,
    "mat3x3<f32>": 16 * 3,
    "mat4x4<f32>": 16 * 4
};

function ove(t) {
    const e = t.map(s => ({
            data: s,
            offset: 0,
            size: 0
        })),
        n = 16;
    let r = 0,
        i = 0;
    for (let s = 0; s < e.length; s++) {
        const o = e[s];
        if (r = Q$[o.data.type], !r) throw new Error(`Unknown type ${o.data.type}`);
        o.data.size > 1 && (r = Math.max(r, n) * o.data.size);
        const a = r === 12 ? 16 : r;
        o.size = r;
        const l = i % n;
        l > 0 && n - l < a ? i += (n - l) % 16 : i += (r - l % r) % r, o.offset = i, i += r
    }
    return i = Math.ceil(i / 16) * 16, {
        uboElements: e,
        size: i
    }
}
const Ao = [{
    type: "mat3x3<f32>",
    test: t => t.value.a !== void 0,
    ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
    uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
}, {
    type: "vec4<f32>",
    test: t => t.type === "vec4<f32>" && t.size === 1 && t.value.width !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
}, {
    type: "vec2<f32>",
    test: t => t.type === "vec2<f32>" && t.size === 1 && t.value.x !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
}, {
    type: "vec4<f32>",
    test: t => t.type === "vec4<f32>" && t.size === 1 && t.value.red !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
}, {
    type: "vec3<f32>",
    test: t => t.type === "vec3<f32>" && t.size === 1 && t.value.red !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
}];

function e3(t, e, n, r) {
    const i = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
    let s = 0;
    for (let a = 0; a < t.length; a++) {
        const l = t[a],
            c = l.data.name;
        let u = !1,
            d = 0;
        for (let f = 0; f < Ao.length; f++)
            if (Ao[f].test(l.data)) {
                d = l.offset / 4, i.push(`name = "${c}";`, `offset += ${d-s};`, Ao[f][e] || Ao[f].ubo), u = !0;
                break
            }
        if (!u)
            if (l.data.size > 1) d = l.offset / 4, i.push(n(l, d - s));
            else {
                const f = r[l.data.type];
                d = l.offset / 4, i.push(`
                    v = uv.${c};
                    offset += ${d-s};
                    ${f};
                `)
            }
        s = d
    }
    const o = i.join(`
`);
    return new Function("uv", "data", "dataInt32", "offset", o)
}

function Da(t, e) {
    return `
        for (let i = 0; i < ${t*e}; i++) {
            data[offset + (((i / ${t})|0) * 4) + (i % ${t})] = v[i];
        }
    `
}
const t3 = {
        f32: `
        data[offset] = v;`,
        i32: `
        dataInt32[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
        "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
        "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": Da(3, 2),
        "mat4x2<f32>": Da(4, 2),
        "mat2x3<f32>": Da(2, 3),
        "mat4x3<f32>": Da(4, 3),
        "mat2x4<f32>": Da(2, 4),
        "mat3x4<f32>": Da(3, 4)
    },
    ave = { ...t3,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
    };

function lve(t, e) {
    const n = Math.max(Q$[t.data.type] / 16, 1),
        r = t.data.value.length / t.data.size,
        i = (4 - r % 4) % 4,
        s = t.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
    return `
        v = uv.${t.data.name};
        offset += ${e};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${t.data.size*n}; i++)
        {
            for(var j = 0; j < ${r}; j++)
            {
                ${s}[arrayOffset++] = v[t++];
            }
            ${i!==0?`arrayOffset += ${i};`:""}
        }
    `
}

function cve(t) {
    return e3(t, "uboStd40", lve, t3)
}
class n3 extends Z$ {
    constructor() {
        super({
            createUboElements: ove,
            generateUboSync: cve
        })
    }
}
n3.extension = {
    type: [G.WebGLSystem],
    name: "ubo"
};
class uve {
    constructor() {
        this._clearColorCache = [0, 0, 0, 0], this._viewPortCache = new at
    }
    init(e, n) {
        this._renderer = e, this._renderTargetSystem = n, e.runners.contextChange.add(this)
    }
    contextChange() {
        this._clearColorCache = [0, 0, 0, 0], this._viewPortCache = new at
    }
    copyToTexture(e, n, r, i, s) {
        const o = this._renderTargetSystem,
            a = this._renderer,
            l = o.getGpuRenderTarget(e),
            c = a.gl;
        return this.finishRenderPass(e), c.bindFramebuffer(c.FRAMEBUFFER, l.resolveTargetFramebuffer), a.texture.bind(n, 0), c.copyTexSubImage2D(c.TEXTURE_2D, 0, s.x, s.y, r.x, r.y, i.width, i.height), n
    }
    startRenderPass(e, n = !0, r, i) {
        const s = this._renderTargetSystem,
            o = e.colorTexture,
            a = s.getGpuRenderTarget(e);
        let l = i.y;
        e.isRoot && (l = o.pixelHeight - i.height), e.colorTextures.forEach(d => {
            this._renderer.texture.unbind(d)
        });
        const c = this._renderer.gl;
        c.bindFramebuffer(c.FRAMEBUFFER, a.framebuffer);
        const u = this._viewPortCache;
        (u.x !== i.x || u.y !== l || u.width !== i.width || u.height !== i.height) && (u.x = i.x, u.y = l, u.width = i.width, u.height = i.height, c.viewport(i.x, l, i.width, i.height)), !a.depthStencilRenderBuffer && (e.stencil || e.depth) && this._initStencil(a), this.clear(e, n, r)
    }
    finishRenderPass(e) {
        const r = this._renderTargetSystem.getGpuRenderTarget(e);
        if (!r.msaa) return;
        const i = this._renderer.gl;
        i.bindFramebuffer(i.FRAMEBUFFER, r.resolveTargetFramebuffer), i.bindFramebuffer(i.READ_FRAMEBUFFER, r.framebuffer), i.blitFramebuffer(0, 0, r.width, r.height, 0, 0, r.width, r.height, i.COLOR_BUFFER_BIT, i.NEAREST), i.bindFramebuffer(i.FRAMEBUFFER, r.framebuffer)
    }
    initGpuRenderTarget(e) {
        const r = this._renderer.gl,
            i = new sve,
            s = e.colorTexture;
        return ni.test(s.resource) ? (this._renderer.context.ensureCanvasSize(e.colorTexture.resource), i.framebuffer = null, i) : (this._initColor(e, i), r.bindFramebuffer(r.FRAMEBUFFER, null), i)
    }
    destroyGpuRenderTarget(e) {
        const n = this._renderer.gl;
        e.framebuffer && (n.deleteFramebuffer(e.framebuffer), e.framebuffer = null), e.resolveTargetFramebuffer && (n.deleteFramebuffer(e.resolveTargetFramebuffer), e.resolveTargetFramebuffer = null), e.depthStencilRenderBuffer && (n.deleteRenderbuffer(e.depthStencilRenderBuffer), e.depthStencilRenderBuffer = null), e.msaaRenderBuffer.forEach(r => {
            n.deleteRenderbuffer(r)
        }), e.msaaRenderBuffer = null
    }
    clear(e, n, r) {
        if (!n) return;
        const i = this._renderTargetSystem;
        typeof n == "boolean" && (n = n ? jn.ALL : jn.NONE);
        const s = this._renderer.gl;
        if (n & jn.COLOR) {
            r ? ? (r = i.defaultClearColor);
            const o = this._clearColorCache,
                a = r;
            (o[0] !== a[0] || o[1] !== a[1] || o[2] !== a[2] || o[3] !== a[3]) && (o[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[3], s.clearColor(a[0], a[1], a[2], a[3]))
        }
        s.clear(n)
    }
    resizeGpuRenderTarget(e) {
        if (e.isRoot) return;
        const r = this._renderTargetSystem.getGpuRenderTarget(e);
        this._resizeColor(e, r), (e.stencil || e.depth) && this._resizeStencil(r)
    }
    _initColor(e, n) {
        const r = this._renderer,
            i = r.gl,
            s = i.createFramebuffer();
        if (n.resolveTargetFramebuffer = s, i.bindFramebuffer(i.FRAMEBUFFER, s), n.width = e.colorTexture.source.pixelWidth, n.height = e.colorTexture.source.pixelHeight, e.colorTextures.forEach((o, a) => {
                const l = o.source;
                l.antialias && (r.context.supports.msaa ? n.msaa = !0 : Me("[RenderTexture] Antialiasing on textures is not supported in WebGL1")), r.texture.bindSource(l, 0);
                const u = r.texture.getGlSource(l).texture;
                i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + a, 3553, u, 0)
            }), n.msaa) {
            const o = i.createFramebuffer();
            n.framebuffer = o, i.bindFramebuffer(i.FRAMEBUFFER, o), e.colorTextures.forEach((a, l) => {
                const c = i.createRenderbuffer();
                n.msaaRenderBuffer[l] = c
            })
        } else n.framebuffer = s;
        this._resizeColor(e, n)
    }
    _resizeColor(e, n) {
        const r = e.colorTexture.source;
        if (n.width = r.pixelWidth, n.height = r.pixelHeight, e.colorTextures.forEach((i, s) => {
                s !== 0 && i.source.resize(r.width, r.height, r._resolution)
            }), n.msaa) {
            const i = this._renderer,
                s = i.gl,
                o = n.framebuffer;
            s.bindFramebuffer(s.FRAMEBUFFER, o), e.colorTextures.forEach((a, l) => {
                const c = a.source;
                i.texture.bindSource(c, 0);
                const d = i.texture.getGlSource(c).internalFormat,
                    f = n.msaaRenderBuffer[l];
                s.bindRenderbuffer(s.RENDERBUFFER, f), s.renderbufferStorageMultisample(s.RENDERBUFFER, 4, d, c.pixelWidth, c.pixelHeight), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + l, s.RENDERBUFFER, f)
            })
        }
    }
    _initStencil(e) {
        if (e.framebuffer === null) return;
        const n = this._renderer.gl,
            r = n.createRenderbuffer();
        e.depthStencilRenderBuffer = r, n.bindRenderbuffer(n.RENDERBUFFER, r), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, r), this._resizeStencil(e)
    }
    _resizeStencil(e) {
        const n = this._renderer.gl;
        n.bindRenderbuffer(n.RENDERBUFFER, e.depthStencilRenderBuffer), e.msaa ? n.renderbufferStorageMultisample(n.RENDERBUFFER, 4, n.DEPTH24_STENCIL8, e.width, e.height) : n.renderbufferStorage(n.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? n.DEPTH24_STENCIL8 : n.DEPTH_STENCIL, e.width, e.height)
    }
    prerender(e) {
        const n = e.colorTexture.resource;
        this._renderer.context.multiView && ni.test(n) && this._renderer.context.ensureCanvasSize(n)
    }
    postrender(e) {
        if (this._renderer.context.multiView && ni.test(e.colorTexture.resource)) {
            const n = this._renderer.context.canvas,
                r = e.colorTexture;
            r.context2D.drawImage(n, 0, r.pixelHeight - n.height)
        }
    }
}

function dve(t, e, n, r, i, s) {
    const o = s ? 1 : -1;
    return t.identity(), t.a = 1 / r * 2, t.d = o * (1 / i * 2), t.tx = -1 - e * t.a, t.ty = -o - n * t.d, t
}
const pc = new Map;

function r3(t, e) {
    if (!pc.has(t)) {
        const n = new we({
                source: new ni({
                    resource: t,
                    ...e
                })
            }),
            r = () => {
                pc.get(t) === n && pc.delete(t)
            };
        n.once("destroy", r), n.source.once("destroy", r), pc.set(t, n)
    }
    return pc.get(t)
}

function fve(t) {
    const e = t.colorTexture.source.resource;
    return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement && document.body.contains(e)
}
const i3 = class s3 {
    constructor(e = {}) {
        if (this.uid = yt("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = !1, this._size = new Float32Array(2), this._managedColorTextures = !1, e = { ...s3.defaultOptions,
                ...e
            }, this.stencil = e.stencil, this.depth = e.depth, this.isRoot = e.isRoot, typeof e.colorTextures == "number") {
            this._managedColorTextures = !0;
            for (let n = 0; n < e.colorTextures; n++) this.colorTextures.push(new Qt({
                width: e.width,
                height: e.height,
                resolution: e.resolution,
                antialias: e.antialias
            }))
        } else {
            this.colorTextures = [...e.colorTextures.map(r => r.source)];
            const n = this.colorTexture.source;
            this.resize(n.width, n.height, n._resolution)
        }
        this.colorTexture.source.on("resize", this.onSourceResize, this), (e.depthStencilTexture || this.stencil) && (e.depthStencilTexture instanceof we || e.depthStencilTexture instanceof Qt ? this.depthStencilTexture = e.depthStencilTexture.source : this.ensureDepthStencilTexture())
    }
    get size() {
        const e = this._size;
        return e[0] = this.pixelWidth, e[1] = this.pixelHeight, e
    }
    get width() {
        return this.colorTexture.source.width
    }
    get height() {
        return this.colorTexture.source.height
    }
    get pixelWidth() {
        return this.colorTexture.source.pixelWidth
    }
    get pixelHeight() {
        return this.colorTexture.source.pixelHeight
    }
    get resolution() {
        return this.colorTexture.source._resolution
    }
    get colorTexture() {
        return this.colorTextures[0]
    }
    onSourceResize(e) {
        this.resize(e.width, e.height, e._resolution, !0)
    }
    ensureDepthStencilTexture() {
        this.depthStencilTexture || (this.depthStencilTexture = new Qt({
            width: this.width,
            height: this.height,
            resolution: this.resolution,
            format: "depth24plus-stencil8",
            autoGenerateMipmaps: !1,
            antialias: !1,
            mipLevelCount: 1
        }))
    }
    resize(e, n, r = this.resolution, i = !1) {
        this.dirtyId++, this.colorTextures.forEach((s, o) => {
            i && o === 0 || s.source.resize(e, n, r)
        }), this.depthStencilTexture && this.depthStencilTexture.source.resize(e, n, r)
    }
    destroy() {
        this.colorTexture.source.off("resize", this.onSourceResize, this), this._managedColorTextures && this.colorTextures.forEach(e => {
            e.destroy()
        }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture)
    }
};
i3.defaultOptions = {
    width: 0,
    height: 0,
    resolution: 1,
    colorTextures: 1,
    stencil: !1,
    depth: !1,
    antialias: !1,
    isRoot: !1
};
let H0 = i3;
class o3 {
    constructor(e) {
        this.rootViewPort = new at, this.viewport = new at, this.onRenderTargetChange = new GD("onRenderTargetChange"), this.projectionMatrix = new Ce, this.defaultClearColor = [0, 0, 0, 0], this._renderSurfaceToRenderTargetHash = new Map, this._gpuRenderTargetHash = Object.create(null), this._renderTargetStack = [], this._renderer = e, e.renderableGC.addManagedHash(this, "_gpuRenderTargetHash")
    }
    finishRenderPass() {
        this.adaptor.finishRenderPass(this.renderTarget)
    }
    renderStart({
        target: e,
        clear: n,
        clearColor: r,
        frame: i
    }) {
        var s, o;
        this._renderTargetStack.length = 0, this.push(e, n, r, i), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = fve(this.rootRenderTarget), (o = (s = this.adaptor).prerender) == null || o.call(s, this.rootRenderTarget)
    }
    postrender() {
        var e, n;
        (n = (e = this.adaptor).postrender) == null || n.call(e, this.rootRenderTarget)
    }
    bind(e, n = !0, r, i) {
        const s = this.getRenderTarget(e),
            o = this.renderTarget !== s;
        this.renderTarget = s, this.renderSurface = e;
        const a = this.getGpuRenderTarget(s);
        (s.pixelWidth !== a.width || s.pixelHeight !== a.height) && (this.adaptor.resizeGpuRenderTarget(s), a.width = s.pixelWidth, a.height = s.pixelHeight);
        const l = s.colorTexture,
            c = this.viewport,
            u = l.pixelWidth,
            d = l.pixelHeight;
        if (!i && e instanceof we && (i = e.frame), i) {
            const f = l._resolution;
            c.x = i.x * f + .5 | 0, c.y = i.y * f + .5 | 0, c.width = i.width * f + .5 | 0, c.height = i.height * f + .5 | 0
        } else c.x = 0, c.y = 0, c.width = u, c.height = d;
        return dve(this.projectionMatrix, 0, 0, c.width / l.resolution, c.height / l.resolution, !s.isRoot), this.adaptor.startRenderPass(s, n, r, c), o && this.onRenderTargetChange.emit(s), s
    }
    clear(e, n = jn.ALL, r) {
        n && (e && (e = this.getRenderTarget(e)), this.adaptor.clear(e || this.renderTarget, n, r, this.viewport))
    }
    contextChange() {
        this._gpuRenderTargetHash = Object.create(null)
    }
    push(e, n = jn.ALL, r, i) {
        const s = this.bind(e, n, r, i);
        return this._renderTargetStack.push({
            renderTarget: s,
            frame: i
        }), s
    }
    pop() {
        this._renderTargetStack.pop();
        const e = this._renderTargetStack[this._renderTargetStack.length - 1];
        this.bind(e.renderTarget, !1, null, e.frame)
    }
    getRenderTarget(e) {
        return e.isTexture && (e = e.source), this._renderSurfaceToRenderTargetHash.get(e) ? ? this._initRenderTarget(e)
    }
    copyToTexture(e, n, r, i, s) {
        r.x < 0 && (i.width += r.x, s.x -= r.x, r.x = 0), r.y < 0 && (i.height += r.y, s.y -= r.y, r.y = 0);
        const {
            pixelWidth: o,
            pixelHeight: a
        } = e;
        return i.width = Math.min(i.width, o - r.x), i.height = Math.min(i.height, a - r.y), this.adaptor.copyToTexture(e, n, r, i, s)
    }
    ensureDepthStencil() {
        this.renderTarget.stencil || (this.renderTarget.stencil = !0, this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport))
    }
    destroy() {
        this._renderer = null, this._renderSurfaceToRenderTargetHash.forEach((e, n) => {
            e !== n && e.destroy()
        }), this._renderSurfaceToRenderTargetHash.clear(), this._gpuRenderTargetHash = Object.create(null)
    }
    _initRenderTarget(e) {
        let n = null;
        return ni.test(e) && (e = r3(e).source), e instanceof H0 ? n = e : e instanceof Qt && (n = new H0({
            colorTextures: [e]
        }), ni.test(e.source.resource) && (n.isRoot = !0), e.once("destroy", () => {
            n.destroy(), this._renderSurfaceToRenderTargetHash.delete(e);
            const r = this._gpuRenderTargetHash[n.uid];
            r && (this._gpuRenderTargetHash[n.uid] = null, this.adaptor.destroyGpuRenderTarget(r))
        })), this._renderSurfaceToRenderTargetHash.set(e, n), n
    }
    getGpuRenderTarget(e) {
        return this._gpuRenderTargetHash[e.uid] || (this._gpuRenderTargetHash[e.uid] = this.adaptor.initGpuRenderTarget(e))
    }
    resetState() {
        this.renderTarget = null, this.renderSurface = null
    }
}
class a3 extends o3 {
    constructor(e) {
        super(e), this.adaptor = new uve, this.adaptor.init(e, this)
    }
}
a3.extension = {
    type: [G.WebGLSystem],
    name: "renderTarget"
};
class fw extends rr {
    constructor({
        buffer: e,
        offset: n,
        size: r
    }) {
        super(), this.uid = yt("buffer"), this._resourceType = "bufferResource", this._touched = 0, this._resourceId = yt("resource"), this._bufferResource = !0, this.destroyed = !1, this.buffer = e, this.offset = n | 0, this.size = r, this.buffer.on("change", this.onBufferChange, this)
    }
    onBufferChange() {
        this._resourceId = yt("resource"), this.emit("change", this)
    }
    destroy(e = !1) {
        this.destroyed = !0, e && this.buffer.destroy(), this.emit("change", this), this.buffer = null
    }
}

function hve(t, e) {
    const n = [],
        r = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
    let i = !1,
        s = 0;
    const o = e._getProgramData(t.glProgram);
    for (const l in t.groups) {
        const c = t.groups[l];
        n.push(`
            resources = g[${l}].resources;
        `);
        for (const u in c.resources) {
            const d = c.resources[u];
            if (d instanceof Cn)
                if (d.ubo) {
                    const f = t._uniformBindMap[l][Number(u)];
                    n.push(`
                        sS.bindUniformBlock(
                            resources[${u}],
                            '${f}',
                            ${t.glProgram._uniformBlockData[f].index}
                        );
                    `)
                } else n.push(`
                        ugS.updateUniformGroup(resources[${u}], p, sD);
                    `);
            else if (d instanceof fw) {
                const f = t._uniformBindMap[l][Number(u)];
                n.push(`
                    sS.bindUniformBlock(
                        resources[${u}],
                        '${f}',
                        ${t.glProgram._uniformBlockData[f].index}
                    );
                `)
            } else if (d instanceof Qt) {
                const f = t._uniformBindMap[l][u],
                    h = o.uniformData[f];
                h && (i || (i = !0, r.push(`
                        var tS = r.texture;
                        `)), e._gl.uniform1i(h.location, s), n.push(`
                        tS.bind(resources[${u}], ${s});
                    `), s++)
            }
        }
    }
    const a = [...r, ...n].join(`
`);
    return new Function("r", "s", "sD", a)
}
class pve {
    constructor(e, n) {
        this.program = e, this.uniformData = n, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {}
    }
    destroy() {
        this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null
    }
}

function vP(t, e, n) {
    const r = t.createShader(e);
    return t.shaderSource(r, n), t.compileShader(r), r
}

function _v(t) {
    const e = new Array(t);
    for (let n = 0; n < e.length; n++) e[n] = !1;
    return e
}

function l3(t, e) {
    switch (t) {
        case "float":
            return 0;
        case "vec2":
            return new Float32Array(2 * e);
        case "vec3":
            return new Float32Array(3 * e);
        case "vec4":
            return new Float32Array(4 * e);
        case "int":
        case "uint":
        case "sampler2D":
        case "sampler2DArray":
            return 0;
        case "ivec2":
            return new Int32Array(2 * e);
        case "ivec3":
            return new Int32Array(3 * e);
        case "ivec4":
            return new Int32Array(4 * e);
        case "uvec2":
            return new Uint32Array(2 * e);
        case "uvec3":
            return new Uint32Array(3 * e);
        case "uvec4":
            return new Uint32Array(4 * e);
        case "bool":
            return !1;
        case "bvec2":
            return _v(2 * e);
        case "bvec3":
            return _v(3 * e);
        case "bvec4":
            return _v(4 * e);
        case "mat2":
            return new Float32Array([1, 0, 0, 1]);
        case "mat3":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
}
let gf = null;
const yP = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    },
    mve = {
        float: "float32",
        vec2: "float32x2",
        vec3: "float32x3",
        vec4: "float32x4",
        int: "sint32",
        ivec2: "sint32x2",
        ivec3: "sint32x3",
        ivec4: "sint32x4",
        uint: "uint32",
        uvec2: "uint32x2",
        uvec3: "uint32x3",
        uvec4: "uint32x4",
        bool: "uint32",
        bvec2: "uint32x2",
        bvec3: "uint32x3",
        bvec4: "uint32x4"
    };

function c3(t, e) {
    if (!gf) {
        const n = Object.keys(yP);
        gf = {};
        for (let r = 0; r < n.length; ++r) {
            const i = n[r];
            gf[t[i]] = yP[i]
        }
    }
    return gf[e]
}

function gve(t, e) {
    const n = c3(t, e);
    return mve[n] || "float32"
}

function vve(t, e, n = !1) {
    const r = {},
        i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
    for (let o = 0; o < i; o++) {
        const a = e.getActiveAttrib(t, o);
        if (a.name.startsWith("gl_")) continue;
        const l = gve(e, a.type);
        r[a.name] = {
            location: 0,
            format: l,
            stride: Gs(l).stride,
            offset: 0,
            instance: !1,
            start: 0
        }
    }
    const s = Object.keys(r);
    if (n) {
        s.sort((o, a) => o > a ? 1 : -1);
        for (let o = 0; o < s.length; o++) r[s[o]].location = o, e.bindAttribLocation(t, o, s[o]);
        e.linkProgram(t)
    } else
        for (let o = 0; o < s.length; o++) r[s[o]].location = e.getAttribLocation(t, s[o]);
    return r
}

function yve(t, e) {
    if (!e.ACTIVE_UNIFORM_BLOCKS) return {};
    const n = {},
        r = e.getProgramParameter(t, e.ACTIVE_UNIFORM_BLOCKS);
    for (let i = 0; i < r; i++) {
        const s = e.getActiveUniformBlockName(t, i),
            o = e.getUniformBlockIndex(t, s),
            a = e.getActiveUniformBlockParameter(t, i, e.UNIFORM_BLOCK_DATA_SIZE);
        n[s] = {
            name: s,
            index: o,
            size: a
        }
    }
    return n
}

function _ve(t, e) {
    const n = {},
        r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; i++) {
        const s = e.getActiveUniform(t, i),
            o = s.name.replace(/\[.*?\]$/, ""),
            a = !!s.name.match(/\[.*?\]$/),
            l = c3(e, s.type);
        n[o] = {
            name: o,
            index: i,
            type: l,
            size: s.size,
            isArray: a,
            value: l3(l, s.size)
        }
    }
    return n
}

function _P(t, e) {
    const n = t.getShaderSource(e).split(`
`).map((c, u) => `${u}: ${c}`),
        r = t.getShaderInfoLog(e),
        i = r.split(`
`),
        s = {},
        o = i.map(c => parseFloat(c.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(c => c && !s[c] ? (s[c] = !0, !0) : !1),
        a = [""];
    o.forEach(c => {
        n[c - 1] = `%c${n[c-1]}%c`, a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
    });
    const l = n.join(`
`);
    a[0] = l, console.error(r), console.groupCollapsed("click to view full shader code"), console.warn(...a), console.groupEnd()
}

function bve(t, e, n, r) {
    t.getProgramParameter(e, t.LINK_STATUS) || (t.getShaderParameter(n, t.COMPILE_STATUS) || _P(t, n), t.getShaderParameter(r, t.COMPILE_STATUS) || _P(t, r), console.error("PixiJS Error: Could not initialize shader."), t.getProgramInfoLog(e) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(e)))
}

function xve(t, e) {
    const n = vP(t, t.VERTEX_SHADER, e.vertex),
        r = vP(t, t.FRAGMENT_SHADER, e.fragment),
        i = t.createProgram();
    t.attachShader(i, n), t.attachShader(i, r);
    const s = e.transformFeedbackVaryings;
    s && (typeof t.transformFeedbackVaryings != "function" ? Me("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : t.transformFeedbackVaryings(i, s.names, s.bufferMode === "separate" ? t.SEPARATE_ATTRIBS : t.INTERLEAVED_ATTRIBS)), t.linkProgram(i), t.getProgramParameter(i, t.LINK_STATUS) || bve(t, i, n, r), e._attributeData = vve(i, t, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertex)), e._uniformData = _ve(i, t), e._uniformBlockData = yve(i, t), t.deleteShader(n), t.deleteShader(r);
    const o = {};
    for (const l in e._uniformData) {
        const c = e._uniformData[l];
        o[l] = {
            location: t.getUniformLocation(i, l),
            value: l3(c.type, c.size)
        }
    }
    return new pve(i, o)
}
const vf = {
    textureCount: 0,
    blockIndex: 0
};
class u3 {
    constructor(e) {
        this._activeProgram = null, this._programDataHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_programDataHash")
    }
    contextChange(e) {
        this._gl = e, this._programDataHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._activeProgram = null, this.maxTextures = zl()
    }
    bind(e, n) {
        if (this._setProgram(e.glProgram), n) return;
        vf.textureCount = 0, vf.blockIndex = 0;
        let r = this._shaderSyncFunctions[e.glProgram._key];
        r || (r = this._shaderSyncFunctions[e.glProgram._key] = this._generateShaderSync(e, this)), this._renderer.buffer.nextBindBase(!!e.glProgram.transformFeedbackVaryings), r(this._renderer, e, vf)
    }
    updateUniformGroup(e) {
        this._renderer.uniformGroup.updateUniformGroup(e, this._activeProgram, vf)
    }
    bindUniformBlock(e, n, r = 0) {
        const i = this._renderer.buffer,
            s = this._getProgramData(this._activeProgram),
            o = e._bufferResource;
        o || this._renderer.ubo.updateUniformGroup(e);
        const a = e.buffer,
            l = i.updateBuffer(a),
            c = i.freeLocationForBufferBase(l);
        if (o) {
            const {
                offset: d,
                size: f
            } = e;
            d === 0 && f === a.data.byteLength ? i.bindBufferBase(l, c) : i.bindBufferRange(l, c, d)
        } else i.getLastBindBaseLocation(l) !== c && i.bindBufferBase(l, c);
        const u = this._activeProgram._uniformBlockData[n].index;
        s.uniformBlockBindings[r] !== c && (s.uniformBlockBindings[r] = c, this._renderer.gl.uniformBlockBinding(s.program, u, c))
    }
    _setProgram(e) {
        if (this._activeProgram === e) return;
        this._activeProgram = e;
        const n = this._getProgramData(e);
        this._gl.useProgram(n.program)
    }
    _getProgramData(e) {
        return this._programDataHash[e._key] || this._createProgramData(e)
    }
    _createProgramData(e) {
        const n = e._key;
        return this._programDataHash[n] = xve(this._gl, e), this._programDataHash[n]
    }
    destroy() {
        for (const e of Object.keys(this._programDataHash)) this._programDataHash[e].destroy(), this._programDataHash[e] = null;
        this._programDataHash = null
    }
    _generateShaderSync(e, n) {
        return hve(e, n)
    }
    resetState() {
        this._activeProgram = null
    }
}
u3.extension = {
    type: [G.WebGLSystem],
    name: "shader"
};
const wve = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);"
    },
    Eve = {
        f32: "gl.uniform1fv(location, v);",
        "vec2<f32>": "gl.uniform2fv(location, v);",
        "vec3<f32>": "gl.uniform3fv(location, v);",
        "vec4<f32>": "gl.uniform4fv(location, v);",
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
        i32: "gl.uniform1iv(location, v);",
        "vec2<i32>": "gl.uniform2iv(location, v);",
        "vec3<i32>": "gl.uniform3iv(location, v);",
        "vec4<i32>": "gl.uniform4iv(location, v);",
        u32: "gl.uniform1iv(location, v);",
        "vec2<u32>": "gl.uniform2iv(location, v);",
        "vec3<u32>": "gl.uniform3iv(location, v);",
        "vec4<u32>": "gl.uniform4iv(location, v);",
        bool: "gl.uniform1iv(location, v);",
        "vec2<bool>": "gl.uniform2iv(location, v);",
        "vec3<bool>": "gl.uniform3iv(location, v);",
        "vec4<bool>": "gl.uniform4iv(location, v);"
    };

function Sve(t, e) {
    const n = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
    for (const r in t.uniforms) {
        if (!e[r]) {
            t.uniforms[r] instanceof Cn ? t.uniforms[r].ubo ? n.push(`
                        renderer.shader.bindUniformBlock(uv.${r}, "${r}");
                    `) : n.push(`
                        renderer.shader.updateUniformGroup(uv.${r});
                    `) : t.uniforms[r] instanceof fw && n.push(`
                        renderer.shader.bindBufferResource(uv.${r}, "${r}");
                    `);
            continue
        }
        const i = t.uniformStructures[r];
        let s = !1;
        for (let o = 0; o < Ao.length; o++) {
            const a = Ao[o];
            if (i.type === a.type && a.test(i)) {
                n.push(`name = "${r}";`, Ao[o].uniform), s = !0;
                break
            }
        }
        if (!s) {
            const a = (i.size === 1 ? wve : Eve)[i.type].replace("location", `ud["${r}"].location`);
            n.push(`
            cu = ud["${r}"];
            cv = cu.value;
            v = uv["${r}"];
            ${a};`)
        }
    }
    return new Function("ud", "uv", "renderer", "syncData", n.join(`
`))
}
class d3 {
    constructor(e) {
        this._cache = {}, this._uniformGroupSyncHash = {}, this._renderer = e, this.gl = null, this._cache = {}
    }
    contextChange(e) {
        this.gl = e
    }
    updateUniformGroup(e, n, r) {
        const i = this._renderer.shader._getProgramData(n);
        (!e.isStatic || e._dirtyId !== i.uniformDirtyGroups[e.uid]) && (i.uniformDirtyGroups[e.uid] = e._dirtyId, this._getUniformSyncFunction(e, n)(i.uniformData, e.uniforms, this._renderer, r))
    }
    _getUniformSyncFunction(e, n) {
        var r;
        return ((r = this._uniformGroupSyncHash[e._signature]) == null ? void 0 : r[n._key]) || this._createUniformSyncFunction(e, n)
    }
    _createUniformSyncFunction(e, n) {
        const r = this._uniformGroupSyncHash[e._signature] || (this._uniformGroupSyncHash[e._signature] = {}),
            i = this._getSignature(e, n._uniformData, "u");
        return this._cache[i] || (this._cache[i] = this._generateUniformsSync(e, n._uniformData)), r[n._key] = this._cache[i], r[n._key]
    }
    _generateUniformsSync(e, n) {
        return Sve(e, n)
    }
    _getSignature(e, n, r) {
        const i = e.uniforms,
            s = [`${r}-`];
        for (const o in i) s.push(o), n[o] && s.push(n[o].type);
        return s.join("-")
    }
    destroy() {
        this._renderer = null, this._cache = null
    }
}
d3.extension = {
    type: [G.WebGLSystem],
    name: "uniformGroup"
};

function Tve(t) {
    const e = {};
    if (e.normal = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e.add = [t.ONE, t.ONE], e.multiply = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e.screen = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e.none = [0, 0], e["normal-npm"] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e["add-npm"] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE], e["screen-npm"] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e.erase = [t.ZERO, t.ONE_MINUS_SRC_ALPHA], !(t instanceof He.get().getWebGLRenderingContext())) e.min = [t.ONE, t.ONE, t.ONE, t.ONE, t.MIN, t.MIN], e.max = [t.ONE, t.ONE, t.ONE, t.ONE, t.MAX, t.MAX];
    else {
        const r = t.getExtension("EXT_blend_minmax");
        r && (e.min = [t.ONE, t.ONE, t.ONE, t.ONE, r.MIN_EXT, r.MIN_EXT], e.max = [t.ONE, t.ONE, t.ONE, t.ONE, r.MAX_EXT, r.MAX_EXT])
    }
    return e
}
const Cve = 0,
    Pve = 1,
    Ave = 2,
    Ove = 3,
    Ive = 4,
    Rve = 5,
    f3 = class z0 {
        constructor(e) {
            this._invertFrontFace = !1, this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this._blendEq = !1, this.map = [], this.map[Cve] = this.setBlend, this.map[Pve] = this.setOffset, this.map[Ave] = this.setCullFace, this.map[Ove] = this.setDepthTest, this.map[Ive] = this.setFrontFace, this.map[Rve] = this.setDepthMask, this.checks = [], this.defaultState = kr.for2d(), e.renderTarget.onRenderTargetChange.add(this)
        }
        onRenderTargetChange(e) {
            this._invertFrontFace = !e.isRoot, this._cullFace ? this.setFrontFace(this._frontFace) : this._frontFaceDirty = !0
        }
        contextChange(e) {
            this.gl = e, this.blendModesMap = Tve(e), this.resetState()
        }
        set(e) {
            if (e || (e = this.defaultState), this.stateId !== e.data) {
                let n = this.stateId ^ e.data,
                    r = 0;
                for (; n;) n & 1 && this.map[r].call(this, !!(e.data & 1 << r)), n >>= 1, r++;
                this.stateId = e.data
            }
            for (let n = 0; n < this.checks.length; n++) this.checks[n](this, e)
        }
        forceState(e) {
            e || (e = this.defaultState);
            for (let n = 0; n < this.map.length; n++) this.map[n].call(this, !!(e.data & 1 << n));
            for (let n = 0; n < this.checks.length; n++) this.checks[n](this, e);
            this.stateId = e.data
        }
        setBlend(e) {
            this._updateCheck(z0._checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND)
        }
        setOffset(e) {
            this._updateCheck(z0._checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
        }
        setDepthTest(e) {
            this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST)
        }
        setDepthMask(e) {
            this.gl.depthMask(e)
        }
        setCullFace(e) {
            this._cullFace = e, this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE), this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace)
        }
        setFrontFace(e) {
            this._frontFace = e, this._frontFaceDirty = !1;
            const n = this._invertFrontFace ? !e : e;
            this._glFrontFace !== n && (this._glFrontFace = n, this.gl.frontFace(this.gl[n ? "CW" : "CCW"]))
        }
        setBlendMode(e) {
            if (this.blendModesMap[e] || (e = "normal"), e === this.blendMode) return;
            this.blendMode = e;
            const n = this.blendModesMap[e],
                r = this.gl;
            n.length === 2 ? r.blendFunc(n[0], n[1]) : r.blendFuncSeparate(n[0], n[1], n[2], n[3]), n.length === 6 ? (this._blendEq = !0, r.blendEquationSeparate(n[4], n[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD))
        }
        setPolygonOffset(e, n) {
            this.gl.polygonOffset(e, n)
        }
        resetState() {
            this._glFrontFace = !1, this._frontFace = !1, this._cullFace = !1, this._frontFaceDirty = !1, this._invertFrontFace = !1, this.gl.frontFace(this.gl.CCW), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = "", this.setBlendMode("normal")
        }
        _updateCheck(e, n) {
            const r = this.checks.indexOf(e);
            n && r === -1 ? this.checks.push(e) : !n && r !== -1 && this.checks.splice(r, 1)
        }
        static _checkBlendMode(e, n) {
            e.setBlendMode(n.blendMode)
        }
        static _checkPolygonOffset(e, n) {
            e.setPolygonOffset(1, n.polygonOffset)
        }
        destroy() {
            this.gl = null, this.checks.length = 0
        }
    };
f3.extension = {
    type: [G.WebGLSystem],
    name: "state"
};
let Mve = f3;
class kve {
    constructor(e) {
        this.target = W$.TEXTURE_2D, this.texture = e, this.width = -1, this.height = -1, this.type = Qe.UNSIGNED_BYTE, this.internalFormat = G0.RGBA, this.format = G0.RGBA, this.samplerType = 0
    }
}
const Bve = {
        id: "buffer",
        upload(t, e, n) {
            e.width === t.width || e.height === t.height ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, t.width, t.height, e.format, e.type, t.resource) : n.texImage2D(e.target, 0, e.internalFormat, t.width, t.height, 0, e.format, e.type, t.resource), e.width = t.width, e.height = t.height
        }
    },
    Dve = {
        "bc1-rgba-unorm": !0,
        "bc1-rgba-unorm-srgb": !0,
        "bc2-rgba-unorm": !0,
        "bc2-rgba-unorm-srgb": !0,
        "bc3-rgba-unorm": !0,
        "bc3-rgba-unorm-srgb": !0,
        "bc4-r-unorm": !0,
        "bc4-r-snorm": !0,
        "bc5-rg-unorm": !0,
        "bc5-rg-snorm": !0,
        "bc6h-rgb-ufloat": !0,
        "bc6h-rgb-float": !0,
        "bc7-rgba-unorm": !0,
        "bc7-rgba-unorm-srgb": !0,
        "etc2-rgb8unorm": !0,
        "etc2-rgb8unorm-srgb": !0,
        "etc2-rgb8a1unorm": !0,
        "etc2-rgb8a1unorm-srgb": !0,
        "etc2-rgba8unorm": !0,
        "etc2-rgba8unorm-srgb": !0,
        "eac-r11unorm": !0,
        "eac-r11snorm": !0,
        "eac-rg11unorm": !0,
        "eac-rg11snorm": !0,
        "astc-4x4-unorm": !0,
        "astc-4x4-unorm-srgb": !0,
        "astc-5x4-unorm": !0,
        "astc-5x4-unorm-srgb": !0,
        "astc-5x5-unorm": !0,
        "astc-5x5-unorm-srgb": !0,
        "astc-6x5-unorm": !0,
        "astc-6x5-unorm-srgb": !0,
        "astc-6x6-unorm": !0,
        "astc-6x6-unorm-srgb": !0,
        "astc-8x5-unorm": !0,
        "astc-8x5-unorm-srgb": !0,
        "astc-8x6-unorm": !0,
        "astc-8x6-unorm-srgb": !0,
        "astc-8x8-unorm": !0,
        "astc-8x8-unorm-srgb": !0,
        "astc-10x5-unorm": !0,
        "astc-10x5-unorm-srgb": !0,
        "astc-10x6-unorm": !0,
        "astc-10x6-unorm-srgb": !0,
        "astc-10x8-unorm": !0,
        "astc-10x8-unorm-srgb": !0,
        "astc-10x10-unorm": !0,
        "astc-10x10-unorm-srgb": !0,
        "astc-12x10-unorm": !0,
        "astc-12x10-unorm-srgb": !0,
        "astc-12x12-unorm": !0,
        "astc-12x12-unorm-srgb": !0
    },
    $ve = {
        id: "compressed",
        upload(t, e, n) {
            n.pixelStorei(n.UNPACK_ALIGNMENT, 4);
            let r = t.pixelWidth,
                i = t.pixelHeight;
            const s = !!Dve[t.format];
            for (let o = 0; o < t.resource.length; o++) {
                const a = t.resource[o];
                s ? n.compressedTexImage2D(n.TEXTURE_2D, o, e.internalFormat, r, i, 0, a) : n.texImage2D(n.TEXTURE_2D, o, e.internalFormat, r, i, 0, e.format, e.type, a), r = Math.max(r >> 1, 1), i = Math.max(i >> 1, 1)
            }
        }
    },
    h3 = {
        id: "image",
        upload(t, e, n, r) {
            const i = e.width,
                s = e.height,
                o = t.pixelWidth,
                a = t.pixelHeight,
                l = t.resourceWidth,
                c = t.resourceHeight;
            l < o || c < a ? ((i !== o || s !== a) && n.texImage2D(e.target, 0, e.internalFormat, o, a, 0, e.format, e.type, null), r === 2 ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, l, c, e.format, e.type, t.resource) : n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e.format, e.type, t.resource)) : i === o && s === a ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e.format, e.type, t.resource) : r === 2 ? n.texImage2D(e.target, 0, e.internalFormat, o, a, 0, e.format, e.type, t.resource) : n.texImage2D(e.target, 0, e.internalFormat, e.format, e.type, t.resource), e.width = o, e.height = a
        }
    },
    Fve = {
        id: "video",
        upload(t, e, n, r) {
            if (!t.isValid) {
                n.texImage2D(e.target, 0, e.internalFormat, 1, 1, 0, e.format, e.type, null);
                return
            }
            h3.upload(t, e, n, r)
        }
    },
    bP = {
        linear: 9729,
        nearest: 9728
    },
    Lve = {
        linear: {
            linear: 9987,
            nearest: 9985
        },
        nearest: {
            linear: 9986,
            nearest: 9984
        }
    },
    bv = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
    },
    Nve = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
    };

function xP(t, e, n, r, i, s, o, a) {
    const l = s;
    if (!a || t.addressModeU !== "repeat" || t.addressModeV !== "repeat" || t.addressModeW !== "repeat") {
        const c = bv[o ? "clamp-to-edge" : t.addressModeU],
            u = bv[o ? "clamp-to-edge" : t.addressModeV],
            d = bv[o ? "clamp-to-edge" : t.addressModeW];
        e[i](l, e.TEXTURE_WRAP_S, c), e[i](l, e.TEXTURE_WRAP_T, u), e.TEXTURE_WRAP_R && e[i](l, e.TEXTURE_WRAP_R, d)
    }
    if ((!a || t.magFilter !== "linear") && e[i](l, e.TEXTURE_MAG_FILTER, bP[t.magFilter]), n) {
        if (!a || t.mipmapFilter !== "linear") {
            const c = Lve[t.minFilter][t.mipmapFilter];
            e[i](l, e.TEXTURE_MIN_FILTER, c)
        }
    } else e[i](l, e.TEXTURE_MIN_FILTER, bP[t.minFilter]);
    if (r && t.maxAnisotropy > 1) {
        const c = Math.min(t.maxAnisotropy, e.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        e[i](l, r.TEXTURE_MAX_ANISOTROPY_EXT, c)
    }
    t.compare && e[i](l, e.TEXTURE_COMPARE_FUNC, Nve[t.compare])
}

function Uve(t) {
    return {
        r8unorm: t.RED,
        r8snorm: t.RED,
        r8uint: t.RED,
        r8sint: t.RED,
        r16uint: t.RED,
        r16sint: t.RED,
        r16float: t.RED,
        rg8unorm: t.RG,
        rg8snorm: t.RG,
        rg8uint: t.RG,
        rg8sint: t.RG,
        r32uint: t.RED,
        r32sint: t.RED,
        r32float: t.RED,
        rg16uint: t.RG,
        rg16sint: t.RG,
        rg16float: t.RG,
        rgba8unorm: t.RGBA,
        "rgba8unorm-srgb": t.RGBA,
        rgba8snorm: t.RGBA,
        rgba8uint: t.RGBA,
        rgba8sint: t.RGBA,
        bgra8unorm: t.RGBA,
        "bgra8unorm-srgb": t.RGBA,
        rgb9e5ufloat: t.RGB,
        rgb10a2unorm: t.RGBA,
        rg11b10ufloat: t.RGB,
        rg32uint: t.RG,
        rg32sint: t.RG,
        rg32float: t.RG,
        rgba16uint: t.RGBA,
        rgba16sint: t.RGBA,
        rgba16float: t.RGBA,
        rgba32uint: t.RGBA,
        rgba32sint: t.RGBA,
        rgba32float: t.RGBA,
        stencil8: t.STENCIL_INDEX8,
        depth16unorm: t.DEPTH_COMPONENT,
        depth24plus: t.DEPTH_COMPONENT,
        "depth24plus-stencil8": t.DEPTH_STENCIL,
        depth32float: t.DEPTH_COMPONENT,
        "depth32float-stencil8": t.DEPTH_STENCIL
    }
}

function Gve(t, e) {
    let n = {},
        r = t.RGBA;
    return t instanceof He.get().getWebGLRenderingContext() ? e.srgb && (n = {
        "rgba8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT,
        "bgra8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT
    }) : (n = {
        "rgba8unorm-srgb": t.SRGB8_ALPHA8,
        "bgra8unorm-srgb": t.SRGB8_ALPHA8
    }, r = t.RGBA8), {
        r8unorm: t.R8,
        r8snorm: t.R8_SNORM,
        r8uint: t.R8UI,
        r8sint: t.R8I,
        r16uint: t.R16UI,
        r16sint: t.R16I,
        r16float: t.R16F,
        rg8unorm: t.RG8,
        rg8snorm: t.RG8_SNORM,
        rg8uint: t.RG8UI,
        rg8sint: t.RG8I,
        r32uint: t.R32UI,
        r32sint: t.R32I,
        r32float: t.R32F,
        rg16uint: t.RG16UI,
        rg16sint: t.RG16I,
        rg16float: t.RG16F,
        rgba8unorm: t.RGBA,
        ...n,
        rgba8snorm: t.RGBA8_SNORM,
        rgba8uint: t.RGBA8UI,
        rgba8sint: t.RGBA8I,
        bgra8unorm: r,
        rgb9e5ufloat: t.RGB9_E5,
        rgb10a2unorm: t.RGB10_A2,
        rg11b10ufloat: t.R11F_G11F_B10F,
        rg32uint: t.RG32UI,
        rg32sint: t.RG32I,
        rg32float: t.RG32F,
        rgba16uint: t.RGBA16UI,
        rgba16sint: t.RGBA16I,
        rgba16float: t.RGBA16F,
        rgba32uint: t.RGBA32UI,
        rgba32sint: t.RGBA32I,
        rgba32float: t.RGBA32F,
        stencil8: t.STENCIL_INDEX8,
        depth16unorm: t.DEPTH_COMPONENT16,
        depth24plus: t.DEPTH_COMPONENT24,
        "depth24plus-stencil8": t.DEPTH24_STENCIL8,
        depth32float: t.DEPTH_COMPONENT32F,
        "depth32float-stencil8": t.DEPTH32F_STENCIL8,
        ...e.s3tc ? {
            "bc1-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
            "bc2-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
            "bc3-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
        } : {},
        ...e.s3tc_sRGB ? {
            "bc1-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
            "bc2-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
            "bc3-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        } : {},
        ...e.rgtc ? {
            "bc4-r-unorm": e.rgtc.COMPRESSED_RED_RGTC1_EXT,
            "bc4-r-snorm": e.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
            "bc5-rg-unorm": e.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
            "bc5-rg-snorm": e.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
        } : {},
        ...e.bptc ? {
            "bc6h-rgb-float": e.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
            "bc6h-rgb-ufloat": e.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
            "bc7-rgba-unorm": e.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
            "bc7-rgba-unorm-srgb": e.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
        } : {},
        ...e.etc ? {
            "etc2-rgb8unorm": e.etc.COMPRESSED_RGB8_ETC2,
            "etc2-rgb8unorm-srgb": e.etc.COMPRESSED_SRGB8_ETC2,
            "etc2-rgb8a1unorm": e.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            "etc2-rgb8a1unorm-srgb": e.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            "etc2-rgba8unorm": e.etc.COMPRESSED_RGBA8_ETC2_EAC,
            "etc2-rgba8unorm-srgb": e.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
            "eac-r11unorm": e.etc.COMPRESSED_R11_EAC,
            "eac-rg11unorm": e.etc.COMPRESSED_SIGNED_RG11_EAC
        } : {},
        ...e.astc ? {
            "astc-4x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
            "astc-4x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
            "astc-5x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
            "astc-5x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
            "astc-5x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
            "astc-5x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
            "astc-6x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
            "astc-6x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
            "astc-6x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
            "astc-6x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
            "astc-8x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
            "astc-8x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
            "astc-8x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
            "astc-8x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
            "astc-8x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
            "astc-8x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
            "astc-10x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
            "astc-10x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
            "astc-10x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
            "astc-10x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
            "astc-10x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
            "astc-10x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
            "astc-10x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
            "astc-10x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
            "astc-12x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
            "astc-12x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
            "astc-12x12-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
            "astc-12x12-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
        } : {}
    }
}

function Hve(t) {
    return {
        r8unorm: t.UNSIGNED_BYTE,
        r8snorm: t.BYTE,
        r8uint: t.UNSIGNED_BYTE,
        r8sint: t.BYTE,
        r16uint: t.UNSIGNED_SHORT,
        r16sint: t.SHORT,
        r16float: t.HALF_FLOAT,
        rg8unorm: t.UNSIGNED_BYTE,
        rg8snorm: t.BYTE,
        rg8uint: t.UNSIGNED_BYTE,
        rg8sint: t.BYTE,
        r32uint: t.UNSIGNED_INT,
        r32sint: t.INT,
        r32float: t.FLOAT,
        rg16uint: t.UNSIGNED_SHORT,
        rg16sint: t.SHORT,
        rg16float: t.HALF_FLOAT,
        rgba8unorm: t.UNSIGNED_BYTE,
        "rgba8unorm-srgb": t.UNSIGNED_BYTE,
        rgba8snorm: t.BYTE,
        rgba8uint: t.UNSIGNED_BYTE,
        rgba8sint: t.BYTE,
        bgra8unorm: t.UNSIGNED_BYTE,
        "bgra8unorm-srgb": t.UNSIGNED_BYTE,
        rgb9e5ufloat: t.UNSIGNED_INT_5_9_9_9_REV,
        rgb10a2unorm: t.UNSIGNED_INT_2_10_10_10_REV,
        rg11b10ufloat: t.UNSIGNED_INT_10F_11F_11F_REV,
        rg32uint: t.UNSIGNED_INT,
        rg32sint: t.INT,
        rg32float: t.FLOAT,
        rgba16uint: t.UNSIGNED_SHORT,
        rgba16sint: t.SHORT,
        rgba16float: t.HALF_FLOAT,
        rgba32uint: t.UNSIGNED_INT,
        rgba32sint: t.INT,
        rgba32float: t.FLOAT,
        stencil8: t.UNSIGNED_BYTE,
        depth16unorm: t.UNSIGNED_SHORT,
        depth24plus: t.UNSIGNED_INT,
        "depth24plus-stencil8": t.UNSIGNED_INT_24_8,
        depth32float: t.FLOAT,
        "depth32float-stencil8": t.FLOAT_32_UNSIGNED_INT_24_8_REV
    }
}
const zve = 4;
class p3 {
    constructor(e) {
        this.managedTextures = [], this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundTextures = [], this._activeTextureLocation = -1, this._boundSamplers = Object.create(null), this._uploads = {
            image: h3,
            buffer: Bve,
            video: Fve,
            compressed: $ve
        }, this._premultiplyAlpha = !1, this._useSeparateSamplers = !1, this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_glTextures"), this._renderer.renderableGC.addManagedHash(this, "_glSamplers")
    }
    contextChange(e) {
        this._gl = e, this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = Gve(e, this._renderer.context.extensions), this._mapFormatToType = Hve(e), this._mapFormatToFormat = Uve(e)), this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundSamplers = Object.create(null), this._premultiplyAlpha = !1;
        for (let n = 0; n < 16; n++) this.bind(we.EMPTY, n)
    }
    initSource(e) {
        this.bind(e)
    }
    bind(e, n = 0) {
        const r = e.source;
        e ? (this.bindSource(r, n), this._useSeparateSamplers && this._bindSampler(r.style, n)) : (this.bindSource(null, n), this._useSeparateSamplers && this._bindSampler(null, n))
    }
    bindSource(e, n = 0) {
        const r = this._gl;
        if (e._touched = this._renderer.textureGC.count, this._boundTextures[n] !== e) {
            this._boundTextures[n] = e, this._activateLocation(n), e || (e = we.EMPTY.source);
            const i = this.getGlSource(e);
            r.bindTexture(i.target, i.texture)
        }
    }
    _bindSampler(e, n = 0) {
        const r = this._gl;
        if (!e) {
            this._boundSamplers[n] = null, r.bindSampler(n, null);
            return
        }
        const i = this._getGlSampler(e);
        this._boundSamplers[n] !== i && (this._boundSamplers[n] = i, r.bindSampler(n, i))
    }
    unbind(e) {
        const n = e.source,
            r = this._boundTextures,
            i = this._gl;
        for (let s = 0; s < r.length; s++)
            if (r[s] === n) {
                this._activateLocation(s);
                const o = this.getGlSource(n);
                i.bindTexture(o.target, null), r[s] = null
            }
    }
    _activateLocation(e) {
        this._activeTextureLocation !== e && (this._activeTextureLocation = e, this._gl.activeTexture(this._gl.TEXTURE0 + e))
    }
    _initSource(e) {
        const n = this._gl,
            r = new kve(n.createTexture());
        if (r.type = this._mapFormatToType[e.format], r.internalFormat = this._mapFormatToInternalFormat[e.format], r.format = this._mapFormatToFormat[e.format], e.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || e.isPowerOfTwo)) {
            const i = Math.max(e.width, e.height);
            e.mipLevelCount = Math.floor(Math.log2(i)) + 1
        }
        return this._glTextures[e.uid] = r, this.managedTextures.includes(e) || (e.on("update", this.onSourceUpdate, this), e.on("resize", this.onSourceUpdate, this), e.on("styleChange", this.onStyleChange, this), e.on("destroy", this.onSourceDestroy, this), e.on("unload", this.onSourceUnload, this), e.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(e)), this.onSourceUpdate(e), this.updateStyle(e, !1), r
    }
    onStyleChange(e) {
        this.updateStyle(e, !1)
    }
    updateStyle(e, n) {
        const r = this._gl,
            i = this.getGlSource(e);
        r.bindTexture(r.TEXTURE_2D, i.texture), this._boundTextures[this._activeTextureLocation] = e, xP(e.style, r, e.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", r.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !e.isPowerOfTwo, n)
    }
    onSourceUnload(e) {
        const n = this._glTextures[e.uid];
        n && (this.unbind(e), this._glTextures[e.uid] = null, this._gl.deleteTexture(n.texture))
    }
    onSourceUpdate(e) {
        const n = this._gl,
            r = this.getGlSource(e);
        n.bindTexture(n.TEXTURE_2D, r.texture), this._boundTextures[this._activeTextureLocation] = e;
        const i = e.alphaMode === "premultiply-alpha-on-upload";
        this._premultiplyAlpha !== i && (this._premultiplyAlpha = i, n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i)), this._uploads[e.uploadMethodId] ? this._uploads[e.uploadMethodId].upload(e, r, n, this._renderer.context.webGLVersion) : n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, e.pixelWidth, e.pixelHeight, 0, n.RGBA, n.UNSIGNED_BYTE, null), e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e, !1)
    }
    onUpdateMipmaps(e, n = !0) {
        n && this.bindSource(e, 0);
        const r = this.getGlSource(e);
        this._gl.generateMipmap(r.target)
    }
    onSourceDestroy(e) {
        e.off("destroy", this.onSourceDestroy, this), e.off("update", this.onSourceUpdate, this), e.off("resize", this.onSourceUpdate, this), e.off("unload", this.onSourceUnload, this), e.off("styleChange", this.onStyleChange, this), e.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(e), 1), this.onSourceUnload(e)
    }
    _initSampler(e) {
        const n = this._gl,
            r = this._gl.createSampler();
        return this._glSamplers[e._resourceId] = r, xP(e, n, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", r, !1, !0), this._glSamplers[e._resourceId]
    }
    _getGlSampler(e) {
        return this._glSamplers[e._resourceId] || this._initSampler(e)
    }
    getGlSource(e) {
        return this._glTextures[e.uid] || this._initSource(e)
    }
    generateCanvas(e) {
        const {
            pixels: n,
            width: r,
            height: i
        } = this.getPixels(e), s = He.get().createCanvas();
        s.width = r, s.height = i;
        const o = s.getContext("2d");
        if (o) {
            const a = o.createImageData(r, i);
            a.data.set(n), o.putImageData(a, 0, 0)
        }
        return s
    }
    getPixels(e) {
        const n = e.source.resolution,
            r = e.frame,
            i = Math.max(Math.round(r.width * n), 1),
            s = Math.max(Math.round(r.height * n), 1),
            o = new Uint8Array(zve * i * s),
            a = this._renderer,
            l = a.renderTarget.getRenderTarget(e),
            c = a.renderTarget.getGpuRenderTarget(l),
            u = a.gl;
        return u.bindFramebuffer(u.FRAMEBUFFER, c.resolveTargetFramebuffer), u.readPixels(Math.round(r.x * n), Math.round(r.y * n), i, s, u.RGBA, u.UNSIGNED_BYTE, o), {
            pixels: new Uint8ClampedArray(o.buffer),
            width: i,
            height: s
        }
    }
    destroy() {
        this.managedTextures.slice().forEach(e => this.onSourceDestroy(e)), this.managedTextures = null, this._renderer = null
    }
    resetState() {
        this._activeTextureLocation = -1, this._boundTextures.fill(we.EMPTY.source), this._boundSamplers = Object.create(null);
        const e = this._gl;
        this._premultiplyAlpha = !1, e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha)
    }
}
p3.extension = {
    type: [G.WebGLSystem],
    name: "texture"
};
class m3 {
    init() {
        const e = new Cn({
                uColor: {
                    value: new Float32Array([1, 1, 1, 1]),
                    type: "vec4<f32>"
                },
                uTransformMatrix: {
                    value: new Ce,
                    type: "mat3x3<f32>"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            }),
            n = zl(),
            r = fd({
                name: "graphics",
                bits: [Wx, Xx(n), cw, pd]
            });
        this.shader = new pr({
            glProgram: r,
            resources: {
                localUniforms: e,
                batchSamplers: Kx(n)
            }
        })
    }
    execute(e, n) {
        const r = n.context,
            i = r.customShader || this.shader,
            s = e.renderer,
            o = s.graphicsContext,
            {
                batcher: a,
                instructions: l
            } = o.getContextRenderData(r);
        i.groups[0] = s.globalUniforms.bindGroup, s.state.set(e.state), s.shader.bind(i), s.geometry.bind(a.geometry, i.glProgram);
        const c = l.instructions;
        for (let u = 0; u < l.instructionSize; u++) {
            const d = c[u];
            if (d.size) {
                for (let f = 0; f < d.textures.count; f++) s.texture.bind(d.textures.textures[f], f);
                s.geometry.draw(d.topology, d.size, d.start)
            }
        }
    }
    destroy() {
        this.shader.destroy(!0), this.shader = null
    }
}
m3.extension = {
    type: [G.WebGLPipesAdaptor],
    name: "graphics"
};
class g3 {
    init() {
        const e = fd({
            name: "mesh",
            bits: [cw, Kge, pd]
        });
        this._shader = new pr({
            glProgram: e,
            resources: {
                uTexture: we.EMPTY.source,
                textureUniforms: {
                    uTextureMatrix: {
                        type: "mat3x3<f32>",
                        value: new Ce
                    }
                }
            }
        })
    }
    execute(e, n) {
        const r = e.renderer;
        let i = n._shader;
        if (i) {
            if (!i.glProgram) {
                Me("Mesh shader has no glProgram", n.shader);
                return
            }
        } else {
            i = this._shader;
            const s = n.texture,
                o = s.source;
            i.resources.uTexture = o, i.resources.uSampler = o.style, i.resources.textureUniforms.uniforms.uTextureMatrix = s.textureMatrix.mapCoord
        }
        i.groups[100] = r.globalUniforms.bindGroup, i.groups[101] = e.localUniformsBindGroup, r.encoder.draw({
            geometry: n._geometry,
            shader: i,
            state: n.state
        })
    }
    destroy() {
        this._shader.destroy(!0), this._shader = null
    }
}
g3.extension = {
    type: [G.WebGLPipesAdaptor],
    name: "mesh"
};
class v3 {
    constructor(e) {
        this._renderer = e
    }
    updateRenderable() {}
    destroyRenderable() {}
    validateRenderable() {
        return !1
    }
    addRenderable(e, n) {
        this._renderer.renderPipes.batch.break(n), n.add(e)
    }
    execute(e) {
        e.isRenderable && e.render(this._renderer)
    }
    destroy() {
        this._renderer = null
    }
}
v3.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "customRender"
};
class rm {
    constructor() {
        this.batcherName = "default", this.topology = "triangle-list", this.attributeSize = 4, this.indexSize = 6, this.packAsQuad = !0, this.roundPixels = 0, this._attributeStart = 0, this._batcher = null, this._batch = null
    }
    get blendMode() {
        return this.renderable.groupBlendMode
    }
    get color() {
        return this.renderable.groupColorAlpha
    }
    reset() {
        this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.bounds = null
    }
}

function j0(t, e) {
    const n = t.instructionSet,
        r = n.instructions;
    for (let i = 0; i < n.instructionSize; i++) {
        const s = r[i];
        e[s.renderPipeId].execute(s)
    }
}
const jve = new Ce;
class y3 {
    constructor(e) {
        this._renderer = e
    }
    addRenderGroup(e, n) {
        e.isCachedAsTexture ? this._addRenderableCacheAsTexture(e, n) : this._addRenderableDirect(e, n)
    }
    execute(e) {
        e.isRenderable && (e.isCachedAsTexture ? this._executeCacheAsTexture(e) : this._executeDirect(e))
    }
    destroy() {
        this._renderer = null
    }
    _addRenderableDirect(e, n) {
        this._renderer.renderPipes.batch.break(n), e._batchableRenderGroup && (We.return(e._batchableRenderGroup), e._batchableRenderGroup = null), n.add(e)
    }
    _addRenderableCacheAsTexture(e, n) {
        const r = e._batchableRenderGroup ? ? (e._batchableRenderGroup = We.get(rm));
        r.renderable = e.root, r.transform = e.root.relativeGroupTransform, r.texture = e.texture, r.bounds = e._textureBounds, n.add(e), this._renderer.renderPipes.batch.addToBatch(r, n)
    }
    _executeCacheAsTexture(e) {
        if (e.textureNeedsUpdate) {
            e.textureNeedsUpdate = !1;
            const n = jve.identity().translate(-e._textureBounds.x, -e._textureBounds.y);
            this._renderer.renderTarget.push(e.texture, !0, null, e.texture.frame), this._renderer.globalUniforms.push({
                worldTransformMatrix: n,
                worldColor: 4294967295
            }), j0(e, this._renderer.renderPipes), this._renderer.renderTarget.finishRenderPass(), this._renderer.renderTarget.pop(), this._renderer.globalUniforms.pop()
        }
        e._batchableRenderGroup._batcher.updateElement(e._batchableRenderGroup), e._batchableRenderGroup._batcher.geometry.buffers[0].update()
    }
    _executeDirect(e) {
        this._renderer.globalUniforms.push({
            worldTransformMatrix: e.inverseParentTextureTransform,
            worldColor: e.worldColorAlpha
        }), j0(e, this._renderer.renderPipes), this._renderer.globalUniforms.pop()
    }
}
y3.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "renderGroup"
};

function V0(t, e) {
    e || (e = 0);
    for (let n = e; n < t.length && t[n]; n++) t[n] = null
}
const Vve = new Zn,
    wP = jc | Oh | $x;

function _3(t, e = !1) {
    Wve(t);
    const n = t.childrenToUpdate,
        r = t.updateTick++;
    for (const i in n) {
        const s = Number(i),
            o = n[i],
            a = o.list,
            l = o.index;
        for (let c = 0; c < l; c++) {
            const u = a[c];
            u.parentRenderGroup === t && u.relativeRenderGroupDepth === s && b3(u, r, 0)
        }
        V0(a, l), o.index = 0
    }
    if (e)
        for (let i = 0; i < t.renderGroupChildren.length; i++) _3(t.renderGroupChildren[i], e)
}

function Wve(t) {
    const e = t.root;
    let n;
    if (t.renderGroupParent) {
        const r = t.renderGroupParent;
        t.worldTransform.appendFrom(e.relativeGroupTransform, r.worldTransform), t.worldColor = Ah(e.groupColor, r.worldColor), n = e.groupAlpha * r.worldAlpha
    } else t.worldTransform.copyFrom(e.localTransform), t.worldColor = e.localColor, n = e.localAlpha;
    n = n < 0 ? 0 : n > 1 ? 1 : n, t.worldAlpha = n, t.worldColorAlpha = t.worldColor + ((n * 255 | 0) << 24)
}

function b3(t, e, n) {
    if (e === t.updateTick) return;
    t.updateTick = e, t.didChange = !1;
    const r = t.localTransform;
    t.updateLocalTransform();
    const i = t.parent;
    if (i && !i.renderGroup ? (n |= t._updateFlags, t.relativeGroupTransform.appendFrom(r, i.relativeGroupTransform), n & wP && EP(t, i, n)) : (n = t._updateFlags, t.relativeGroupTransform.copyFrom(r), n & wP && EP(t, Vve, n)), !t.renderGroup) {
        const s = t.children,
            o = s.length;
        for (let c = 0; c < o; c++) b3(s[c], e, n);
        const a = t.parentRenderGroup,
            l = t;
        l.renderPipeId && !a.structureDidChange && a.updateRenderable(l)
    }
}

function EP(t, e, n) {
    if (n & Oh) {
        t.groupColor = Ah(t.localColor, e.groupColor);
        let r = t.localAlpha * e.groupAlpha;
        r = r < 0 ? 0 : r > 1 ? 1 : r, t.groupAlpha = r, t.groupColorAlpha = t.groupColor + ((r * 255 | 0) << 24)
    }
    n & $x && (t.groupBlendMode = t.localBlendMode === "inherit" ? e.groupBlendMode : t.localBlendMode), n & jc && (t.globalDisplayStatus = t.localDisplayStatus & e.globalDisplayStatus), t._updateFlags = 0
}

function Yve(t, e) {
    const {
        list: n,
        index: r
    } = t.childrenRenderablesToUpdate;
    let i = !1;
    for (let s = 0; s < r; s++) {
        const o = n[s];
        if (i = e[o.renderPipeId].validateRenderable(o), i) break
    }
    return t.structureDidChange = i, i
}
const Xve = new Ce;
class x3 {
    constructor(e) {
        this._renderer = e
    }
    render({
        container: e,
        transform: n
    }) {
        const r = e.parent,
            i = e.renderGroup.renderGroupParent;
        e.parent = null, e.renderGroup.renderGroupParent = null;
        const s = this._renderer;
        let o = Xve;
        n && (o = o.copyFrom(e.renderGroup.localTransform), e.renderGroup.localTransform.copyFrom(n));
        const a = s.renderPipes;
        this._updateCachedRenderGroups(e.renderGroup, null), this._updateRenderGroups(e.renderGroup), s.globalUniforms.start({
            worldTransformMatrix: n ? e.renderGroup.localTransform : e.renderGroup.worldTransform,
            worldColor: e.renderGroup.worldColorAlpha
        }), j0(e.renderGroup, a), a.uniformBatch && a.uniformBatch.renderEnd(), n && e.renderGroup.localTransform.copyFrom(o), e.parent = r, e.renderGroup.renderGroupParent = i
    }
    destroy() {
        this._renderer = null
    }
    _updateCachedRenderGroups(e, n) {
        if (e.isCachedAsTexture) {
            if (!e.updateCacheTexture) return;
            n = e
        }
        e._parentCacheAsTextureRenderGroup = n;
        for (let r = e.renderGroupChildren.length - 1; r >= 0; r--) this._updateCachedRenderGroups(e.renderGroupChildren[r], n);
        if (e.invalidateMatrices(), e.isCachedAsTexture) {
            if (e.textureNeedsUpdate) {
                const r = e.root.getLocalBounds();
                r.ceil();
                const i = e.texture;
                e.texture && Ft.returnTexture(e.texture);
                const s = this._renderer,
                    o = e.textureOptions.resolution || s.view.resolution,
                    a = e.textureOptions.antialias ? ? s.view.antialias;
                e.texture = Ft.getOptimalTexture(r.width, r.height, o, a), e._textureBounds || (e._textureBounds = new rn), e._textureBounds.copyFrom(r), i !== e.texture && e.renderGroupParent && (e.renderGroupParent.structureDidChange = !0)
            }
        } else e.texture && (Ft.returnTexture(e.texture), e.texture = null)
    }
    _updateRenderGroups(e) {
        const n = this._renderer,
            r = n.renderPipes;
        if (e.runOnRender(n), e.instructionSet.renderPipes = r, e.structureDidChange ? V0(e.childrenRenderablesToUpdate.list, 0) : Yve(e, r), _3(e), e.structureDidChange ? (e.structureDidChange = !1, this._buildInstructions(e, n)) : this._updateRenderables(e), e.childrenRenderablesToUpdate.index = 0, n.renderPipes.batch.upload(e.instructionSet), !(e.isCachedAsTexture && !e.textureNeedsUpdate))
            for (let i = 0; i < e.renderGroupChildren.length; i++) this._updateRenderGroups(e.renderGroupChildren[i])
    }
    _updateRenderables(e) {
        const {
            list: n,
            index: r
        } = e.childrenRenderablesToUpdate;
        for (let i = 0; i < r; i++) {
            const s = n[i];
            s.didViewUpdate && e.updateRenderable(s)
        }
        V0(n, r)
    }
    _buildInstructions(e, n) {
        const r = e.root,
            i = e.instructionSet;
        i.reset();
        const s = n.renderPipes ? n : n.batch.renderer,
            o = s.renderPipes;
        o.batch.buildStart(i), o.blendMode.buildStart(), o.colorMask.buildStart(), r.sortableChildren && r.sortChildren(), r.collectRenderablesWithEffects(i, s, null), o.batch.buildEnd(i), o.blendMode.buildEnd(i)
    }
}
x3.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "renderGroup"
};
class w3 {
    constructor(e) {
        this._gpuSpriteHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash")
    }
    addRenderable(e, n) {
        const r = this._getGpuSprite(e);
        e.didViewUpdate && this._updateBatchableSprite(e, r), this._renderer.renderPipes.batch.addToBatch(r, n)
    }
    updateRenderable(e) {
        const n = this._gpuSpriteHash[e.uid];
        e.didViewUpdate && this._updateBatchableSprite(e, n), n._batcher.updateElement(n)
    }
    validateRenderable(e) {
        const n = this._getGpuSprite(e);
        return !n._batcher.checkAndUpdateTexture(n, e._texture)
    }
    destroyRenderable(e) {
        const n = this._gpuSpriteHash[e.uid];
        We.return(n), this._gpuSpriteHash[e.uid] = null, e.off("destroyed", this._destroyRenderableBound)
    }
    _updateBatchableSprite(e, n) {
        n.bounds = e.visualBounds, n.texture = e._texture
    }
    _getGpuSprite(e) {
        return this._gpuSpriteHash[e.uid] || this._initGPUSprite(e)
    }
    _initGPUSprite(e) {
        const n = We.get(rm);
        return n.renderable = e, n.transform = e.groupTransform, n.texture = e._texture, n.bounds = e.visualBounds, n.roundPixels = this._renderer._roundPixels | e._roundPixels, this._gpuSpriteHash[e.uid] = n, e.on("destroyed", this._destroyRenderableBound), n
    }
    destroy() {
        for (const e in this._gpuSpriteHash) We.return(this._gpuSpriteHash[e]);
        this._gpuSpriteHash = null, this._renderer = null
    }
}
w3.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "sprite"
};
const hw = class E3 {
    constructor() {
        this.clearBeforeRender = !0, this._backgroundColor = new rt(0), this.color = this._backgroundColor, this.alpha = 1
    }
    init(e) {
        e = { ...E3.defaultOptions,
            ...e
        }, this.clearBeforeRender = e.clearBeforeRender, this.color = e.background || e.backgroundColor || this._backgroundColor, this.alpha = e.backgroundAlpha, this._backgroundColor.setAlpha(e.backgroundAlpha)
    }
    get color() {
        return this._backgroundColor
    }
    set color(e) {
        this._backgroundColor.setValue(e)
    }
    get alpha() {
        return this._backgroundColor.alpha
    }
    set alpha(e) {
        this._backgroundColor.setAlpha(e)
    }
    get colorRgba() {
        return this._backgroundColor.toArray()
    }
    destroy() {}
};
hw.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "background",
    priority: 0
};
hw.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: !0
};
let Kve = hw;
const Xc = {};
Ie.handle(G.BlendMode, t => {
    if (!t.name) throw new Error("BlendMode extension must have a name property");
    Xc[t.name] = t.ref
}, t => {
    delete Xc[t.name]
});
class S3 {
    constructor(e) {
        this._isAdvanced = !1, this._filterHash = Object.create(null), this._renderer = e, this._renderer.runners.prerender.add(this)
    }
    prerender() {
        this._activeBlendMode = "normal", this._isAdvanced = !1
    }
    setBlendMode(e, n, r) {
        if (this._activeBlendMode === n) {
            this._isAdvanced && this._renderableList.push(e);
            return
        }
        this._activeBlendMode = n, this._isAdvanced && this._endAdvancedBlendMode(r), this._isAdvanced = !!Xc[n], this._isAdvanced && (this._beginAdvancedBlendMode(r), this._renderableList.push(e))
    }
    _beginAdvancedBlendMode(e) {
        this._renderer.renderPipes.batch.break(e);
        const n = this._activeBlendMode;
        if (!Xc[n]) {
            Me(`Unable to assign BlendMode: '${n}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
            return
        }
        let r = this._filterHash[n];
        r || (r = this._filterHash[n] = new Ph, r.filters = [new Xc[n]]);
        const i = {
            renderPipeId: "filter",
            action: "pushFilter",
            renderables: [],
            filterEffect: r,
            canBundle: !1
        };
        this._renderableList = i.renderables, e.add(i)
    }
    _endAdvancedBlendMode(e) {
        this._renderableList = null, this._renderer.renderPipes.batch.break(e), e.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: !1
        })
    }
    buildStart() {
        this._isAdvanced = !1
    }
    buildEnd(e) {
        this._isAdvanced && this._endAdvancedBlendMode(e)
    }
    destroy() {
        this._renderer = null, this._renderableList = null;
        for (const e in this._filterHash) this._filterHash[e].destroy();
        this._filterHash = null
    }
}
S3.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "blendMode"
};
const xv = {
        png: "image/png",
        jpg: "image/jpeg",
        webp: "image/webp"
    },
    pw = class T3 {
        constructor(e) {
            this._renderer = e
        }
        _normalizeOptions(e, n = {}) {
            return e instanceof Zn || e instanceof we ? {
                target: e,
                ...n
            } : { ...n,
                ...e
            }
        }
        async image(e) {
            const n = new Image;
            return n.src = await this.base64(e), n
        }
        async base64(e) {
            e = this._normalizeOptions(e, T3.defaultImageOptions);
            const {
                format: n,
                quality: r
            } = e, i = this.canvas(e);
            if (i.toBlob !== void 0) return new Promise((s, o) => {
                i.toBlob(a => {
                    if (!a) {
                        o(new Error("ICanvas.toBlob failed!"));
                        return
                    }
                    const l = new FileReader;
                    l.onload = () => s(l.result), l.onerror = o, l.readAsDataURL(a)
                }, xv[n], r)
            });
            if (i.toDataURL !== void 0) return i.toDataURL(xv[n], r);
            if (i.convertToBlob !== void 0) {
                const s = await i.convertToBlob({
                    type: xv[n],
                    quality: r
                });
                return new Promise((o, a) => {
                    const l = new FileReader;
                    l.onload = () => o(l.result), l.onerror = a, l.readAsDataURL(s)
                })
            }
            throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")
        }
        canvas(e) {
            e = this._normalizeOptions(e);
            const n = e.target,
                r = this._renderer;
            if (n instanceof we) return r.texture.generateCanvas(n);
            const i = r.textureGenerator.generateTexture(e),
                s = r.texture.generateCanvas(i);
            return i.destroy(!0), s
        }
        pixels(e) {
            e = this._normalizeOptions(e);
            const n = e.target,
                r = this._renderer,
                i = n instanceof we ? n : r.textureGenerator.generateTexture(e),
                s = r.texture.getPixels(i);
            return n instanceof Zn && i.destroy(!0), s
        }
        texture(e) {
            return e = this._normalizeOptions(e), e.target instanceof we ? e.target : this._renderer.textureGenerator.generateTexture(e)
        }
        download(e) {
            e = this._normalizeOptions(e);
            const n = this.canvas(e),
                r = document.createElement("a");
            r.download = e.filename ? ? "image.png", r.href = n.toDataURL("image/png"), document.body.appendChild(r), r.click(), document.body.removeChild(r)
        }
        log(e) {
            const n = e.width ? ? 200;
            e = this._normalizeOptions(e);
            const r = this.canvas(e),
                i = r.toDataURL();
            console.log(`[Pixi Texture] ${r.width}px ${r.height}px`);
            const s = ["font-size: 1px;", `padding: ${n}px 300px;`, `background: url(${i}) no-repeat;`, "background-size: contain;"].join(" ");
            console.log("%c ", s)
        }
        destroy() {
            this._renderer = null
        }
    };
pw.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "extract"
};
pw.defaultImageOptions = {
    format: "png",
    quality: 1
};
let qve = pw;
class mw extends we {
    static create(e) {
        return new mw({
            source: new Qt(e)
        })
    }
    resize(e, n, r) {
        return this.source.resize(e, n, r), this
    }
}
const Jve = new at,
    Zve = new rn,
    Qve = [0, 0, 0, 0];
class C3 {
    constructor(e) {
        this._renderer = e
    }
    generateTexture(e) {
        var c;
        e instanceof Zn && (e = {
            target: e,
            frame: void 0,
            textureSourceOptions: {},
            resolution: void 0
        });
        const n = e.resolution || this._renderer.resolution,
            r = e.antialias || this._renderer.view.antialias,
            i = e.target;
        let s = e.clearColor;
        s ? s = Array.isArray(s) && s.length === 4 ? s : rt.shared.setValue(s).toArray() : s = Qve;
        const o = ((c = e.frame) == null ? void 0 : c.copyTo(Jve)) || Dx(i, Zve).rectangle;
        o.width = Math.max(o.width, 1 / n) | 0, o.height = Math.max(o.height, 1 / n) | 0;
        const a = mw.create({ ...e.textureSourceOptions,
                width: o.width,
                height: o.height,
                resolution: n,
                antialias: r
            }),
            l = Ce.shared.translate(-o.x, -o.y);
        return this._renderer.render({
            container: i,
            transform: l,
            target: a,
            clearColor: s
        }), a.source.updateMipmaps(), a
    }
    destroy() {
        this._renderer = null
    }
}
C3.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "textureGenerator"
};

function md(t, e, n) {
    const r = (t >> 24 & 255) / 255;
    e[n++] = (t & 255) / 255 * r, e[n++] = (t >> 8 & 255) / 255 * r, e[n++] = (t >> 16 & 255) / 255 * r, e[n++] = r
}
class P3 {
    constructor(e) {
        this._stackIndex = 0, this._globalUniformDataStack = [], this._uniformsPool = [], this._activeUniforms = [], this._bindGroupPool = [], this._activeBindGroups = [], this._renderer = e
    }
    reset() {
        this._stackIndex = 0;
        for (let e = 0; e < this._activeUniforms.length; e++) this._uniformsPool.push(this._activeUniforms[e]);
        for (let e = 0; e < this._activeBindGroups.length; e++) this._bindGroupPool.push(this._activeBindGroups[e]);
        this._activeUniforms.length = 0, this._activeBindGroups.length = 0
    }
    start(e) {
        this.reset(), this.push(e)
    }
    bind({
        size: e,
        projectionMatrix: n,
        worldTransformMatrix: r,
        worldColor: i,
        offset: s
    }) {
        const o = this._renderer.renderTarget.renderTarget,
            a = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
                projectionData: o,
                worldTransformMatrix: new Ce,
                worldColor: 4294967295,
                offset: new ct
            },
            l = {
                projectionMatrix: n || this._renderer.renderTarget.projectionMatrix,
                resolution: e || o.size,
                worldTransformMatrix: r || a.worldTransformMatrix,
                worldColor: i || a.worldColor,
                offset: s || a.offset,
                bindGroup: null
            },
            c = this._uniformsPool.pop() || this._createUniforms();
        this._activeUniforms.push(c);
        const u = c.uniforms;
        u.uProjectionMatrix = l.projectionMatrix, u.uResolution = l.resolution, u.uWorldTransformMatrix.copyFrom(l.worldTransformMatrix), u.uWorldTransformMatrix.tx -= l.offset.x, u.uWorldTransformMatrix.ty -= l.offset.y, md(l.worldColor, u.uWorldColorAlpha, 0), c.update();
        let d;
        this._renderer.renderPipes.uniformBatch ? d = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(c, !1) : (d = this._bindGroupPool.pop() || new Fi, this._activeBindGroups.push(d), d.setResource(c, 0)), l.bindGroup = d, this._currentGlobalUniformData = l
    }
    push(e) {
        this.bind(e), this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData
    }
    pop() {
        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1], this._renderer.type === Qn.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update()
    }
    get bindGroup() {
        return this._currentGlobalUniformData.bindGroup
    }
    get globalUniformData() {
        return this._currentGlobalUniformData
    }
    get uniformGroup() {
        return this._currentGlobalUniformData.bindGroup.resources[0]
    }
    _createUniforms() {
        return new Cn({
            uProjectionMatrix: {
                value: new Ce,
                type: "mat3x3<f32>"
            },
            uWorldTransformMatrix: {
                value: new Ce,
                type: "mat3x3<f32>"
            },
            uWorldColorAlpha: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uResolution: {
                value: [0, 0],
                type: "vec2<f32>"
            }
        }, {
            isStatic: !0
        })
    }
    destroy() {
        this._renderer = null
    }
}
P3.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "globalUniforms"
};
let eye = 1;
class A3 {
    constructor() {
        this._tasks = [], this._offset = 0
    }
    init() {
        bn.system.add(this._update, this)
    }
    repeat(e, n, r = !0) {
        const i = eye++;
        let s = 0;
        return r && (this._offset += 1e3, s = this._offset), this._tasks.push({
            func: e,
            duration: n,
            start: performance.now(),
            offset: s,
            last: performance.now(),
            repeat: !0,
            id: i
        }), i
    }
    cancel(e) {
        for (let n = 0; n < this._tasks.length; n++)
            if (this._tasks[n].id === e) {
                this._tasks.splice(n, 1);
                return
            }
    }
    _update() {
        const e = performance.now();
        for (let n = 0; n < this._tasks.length; n++) {
            const r = this._tasks[n];
            if (e - r.offset - r.last >= r.duration) {
                const i = e - r.start;
                r.func(i), r.last = e
            }
        }
    }
    destroy() {
        bn.system.remove(this._update, this), this._tasks.length = 0
    }
}
A3.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "scheduler",
    priority: 0
};
let SP = !1;

function tye(t) {
    if (!SP) {
        if (He.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
            const e = [`%c  %c  %c  %c  %c PixiJS %c v${Rh} (${t}) http://www.pixijs.com/

`, "background: #E72264; padding:5px 0;", "background: #6CA2EA; padding:5px 0;", "background: #B5D33D; padding:5px 0;", "background: #FED23F; padding:5px 0;", "color: #FFFFFF; background: #E72264; padding:5px 0;", "color: #E72264; background: #FFFFFF; padding:5px 0;"];
            globalThis.console.log(...e)
        } else globalThis.console && globalThis.console.log(`PixiJS ${Rh} - ${t} - http://www.pixijs.com/`);
        SP = !0
    }
}
class gw {
    constructor(e) {
        this._renderer = e
    }
    init(e) {
        if (e.hello) {
            let n = this._renderer.name;
            this._renderer.type === Qn.WEBGL && (n += ` ${this._renderer.context.webGLVersion}`), tye(n)
        }
    }
}
gw.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "hello",
    priority: -2
};
gw.defaultOptions = {
    hello: !1
};

function nye(t) {
    let e = !1;
    for (const r in t)
        if (t[r] == null) {
            e = !0;
            break
        }
    if (!e) return t;
    const n = Object.create(null);
    for (const r in t) {
        const i = t[r];
        i && (n[r] = i)
    }
    return n
}

function rye(t) {
    let e = 0;
    for (let n = 0; n < t.length; n++) t[n] == null ? e++ : t[n - e] = t[n];
    return t.length -= e, t
}
let iye = 0;
const vw = class O3 {
    constructor(e) {
        this._managedRenderables = [], this._managedHashes = [], this._managedArrays = [], this._renderer = e
    }
    init(e) {
        e = { ...O3.defaultOptions,
            ...e
        }, this.maxUnusedTime = e.renderableGCMaxUnusedTime, this._frequency = e.renderableGCFrequency, this.enabled = e.renderableGCActive
    }
    get enabled() {
        return !!this._handler
    }
    set enabled(e) {
        this.enabled !== e && (e ? (this._handler = this._renderer.scheduler.repeat(() => this.run(), this._frequency, !1), this._hashHandler = this._renderer.scheduler.repeat(() => {
            for (const n of this._managedHashes) n.context[n.hash] = nye(n.context[n.hash])
        }, this._frequency), this._arrayHandler = this._renderer.scheduler.repeat(() => {
            for (const n of this._managedArrays) rye(n.context[n.hash])
        }, this._frequency)) : (this._renderer.scheduler.cancel(this._handler), this._renderer.scheduler.cancel(this._hashHandler), this._renderer.scheduler.cancel(this._arrayHandler)))
    }
    addManagedHash(e, n) {
        this._managedHashes.push({
            context: e,
            hash: n
        })
    }
    addManagedArray(e, n) {
        this._managedArrays.push({
            context: e,
            hash: n
        })
    }
    prerender({
        container: e
    }) {
        this._now = performance.now(), e.renderGroup.gcTick = iye++, this._updateInstructionGCTick(e.renderGroup, e.renderGroup.gcTick)
    }
    addRenderable(e) {
        this.enabled && (e._lastUsed === -1 && (this._managedRenderables.push(e), e.once("destroyed", this._removeRenderable, this)), e._lastUsed = this._now)
    }
    run() {
        var s;
        const e = this._now,
            n = this._managedRenderables,
            r = this._renderer.renderPipes;
        let i = 0;
        for (let o = 0; o < n.length; o++) {
            const a = n[o];
            if (a === null) {
                i++;
                continue
            }
            const l = a.renderGroup ? ? a.parentRenderGroup,
                c = ((s = l == null ? void 0 : l.instructionSet) == null ? void 0 : s.gcTick) ? ? -1;
            if (((l == null ? void 0 : l.gcTick) ? ? 0) === c && (a._lastUsed = e), e - a._lastUsed > this.maxUnusedTime) {
                if (!a.destroyed) {
                    const u = r;
                    l && (l.structureDidChange = !0), u[a.renderPipeId].destroyRenderable(a)
                }
                a._lastUsed = -1, i++, a.off("destroyed", this._removeRenderable, this)
            } else n[o - i] = a
        }
        n.length -= i
    }
    destroy() {
        this.enabled = !1, this._renderer = null, this._managedRenderables.length = 0, this._managedHashes.length = 0, this._managedArrays.length = 0
    }
    _removeRenderable(e) {
        const n = this._managedRenderables.indexOf(e);
        n >= 0 && (e.off("destroyed", this._removeRenderable, this), this._managedRenderables[n] = null)
    }
    _updateInstructionGCTick(e, n) {
        e.instructionSet.gcTick = n;
        for (const r of e.renderGroupChildren) this._updateInstructionGCTick(r, n)
    }
};
vw.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "renderableGC",
    priority: 0
};
vw.defaultOptions = {
    renderableGCActive: !0,
    renderableGCMaxUnusedTime: 6e4,
    renderableGCFrequency: 3e4
};
let sye = vw;
const yw = class I3 {
    constructor(e) {
        this._renderer = e, this.count = 0, this.checkCount = 0
    }
    init(e) {
        e = { ...I3.defaultOptions,
            ...e
        }, this.checkCountMax = e.textureGCCheckCountMax, this.maxIdle = e.textureGCAMaxIdle ? ? e.textureGCMaxIdle, this.active = e.textureGCActive
    }
    postrender() {
        this._renderer.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
    }
    run() {
        const e = this._renderer.texture.managedTextures;
        for (let n = 0; n < e.length; n++) {
            const r = e[n];
            r.autoGarbageCollect && r.resource && r._touched > -1 && this.count - r._touched > this.maxIdle && (r._touched = -1, r.unload())
        }
    }
    destroy() {
        this._renderer = null
    }
};
yw.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "textureGC"
};
yw.defaultOptions = {
    textureGCActive: !0,
    textureGCAMaxIdle: null,
    textureGCMaxIdle: 60 * 60,
    textureGCCheckCountMax: 600
};
let oye = yw;
const _w = class R3 {
    get autoDensity() {
        return this.texture.source.autoDensity
    }
    set autoDensity(e) {
        this.texture.source.autoDensity = e
    }
    get resolution() {
        return this.texture.source._resolution
    }
    set resolution(e) {
        this.texture.source.resize(this.texture.source.width, this.texture.source.height, e)
    }
    init(e) {
        e = { ...R3.defaultOptions,
            ...e
        }, e.view && ($e(Ye, "ViewSystem.view has been renamed to ViewSystem.canvas"), e.canvas = e.view), this.screen = new at(0, 0, e.width, e.height), this.canvas = e.canvas || He.get().createCanvas(), this.antialias = !!e.antialias, this.texture = r3(this.canvas, e), this.renderTarget = new H0({
            colorTextures: [this.texture],
            depth: !!e.depth,
            isRoot: !0
        }), this.texture.source.transparent = e.backgroundAlpha < 1, this.resolution = e.resolution
    }
    resize(e, n, r) {
        this.texture.source.resize(e, n, r), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height
    }
    destroy(e = !1) {
        (typeof e == "boolean" ? e : !!(e != null && e.removeView)) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)
    }
};
_w.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "view",
    priority: 0
};
_w.defaultOptions = {
    width: 800,
    height: 600,
    autoDensity: !1,
    antialias: !1
};
let aye = _w;
const M3 = [Kve, P3, gw, aye, x3, oye, C3, qve, VD, sye, A3],
    k3 = [S3, N$, w3, y3, U$, H$, G$, v3],
    lye = [...M3, n3, ive, Qge, z$, p3, a3, Y$, d3, u3, q$, Mve, J$, K$],
    cye = [...k3],
    uye = [$$, g3, m3],
    B3 = [],
    D3 = [],
    $3 = [];
Ie.handleByNamedList(G.WebGLSystem, B3);
Ie.handleByNamedList(G.WebGLPipes, D3);
Ie.handleByNamedList(G.WebGLPipesAdaptor, $3);
Ie.add(...lye, ...cye, ...uye);
class dye extends em {
    constructor() {
        const e = {
            name: "webgl",
            type: Qn.WEBGL,
            systems: B3,
            renderPipes: D3,
            renderPipeAdaptors: $3
        };
        super(e)
    }
}
const fye = Object.freeze(Object.defineProperty({
    __proto__: null,
    WebGLRenderer: dye
}, Symbol.toStringTag, {
    value: "Module"
}));
class F3 {
    constructor(e) {
        this._hash = Object.create(null), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_hash")
    }
    contextChange(e) {
        this._gpu = e
    }
    getBindGroup(e, n, r) {
        return e._updateKey(), this._hash[e._key] || this._createBindGroup(e, n, r)
    }
    _createBindGroup(e, n, r) {
        const i = this._gpu.device,
            s = n.layout[r],
            o = [],
            a = this._renderer;
        for (const u in s) {
            const d = e.resources[u] ? ? e.resources[s[u]];
            let f;
            if (d._resourceType === "uniformGroup") {
                const h = d;
                a.ubo.updateUniformGroup(h);
                const p = h.buffer;
                f = {
                    buffer: a.buffer.getGPUBuffer(p),
                    offset: 0,
                    size: p.descriptor.size
                }
            } else if (d._resourceType === "buffer") {
                const h = d;
                f = {
                    buffer: a.buffer.getGPUBuffer(h),
                    offset: 0,
                    size: h.descriptor.size
                }
            } else if (d._resourceType === "bufferResource") {
                const h = d;
                f = {
                    buffer: a.buffer.getGPUBuffer(h.buffer),
                    offset: h.offset,
                    size: h.size
                }
            } else if (d._resourceType === "textureSampler") {
                const h = d;
                f = a.texture.getGpuSampler(h)
            } else if (d._resourceType === "textureSource") {
                const h = d;
                f = a.texture.getGpuSource(h).createView({})
            }
            o.push({
                binding: s[u],
                resource: f
            })
        }
        const l = a.shader.getProgramData(n).bindGroups[r],
            c = i.createBindGroup({
                layout: l,
                entries: o
            });
        return this._hash[e._key] = c, c
    }
    destroy() {
        for (const e of Object.keys(this._hash)) this._hash[e] = null;
        this._hash = null, this._renderer = null
    }
}
F3.extension = {
    type: [G.WebGPUSystem],
    name: "bindGroup"
};
class L3 {
    constructor(e) {
        this._gpuBuffers = Object.create(null), this._managedBuffers = [], e.renderableGC.addManagedHash(this, "_gpuBuffers")
    }
    contextChange(e) {
        this._gpu = e
    }
    getGPUBuffer(e) {
        return this._gpuBuffers[e.uid] || this.createGPUBuffer(e)
    }
    updateBuffer(e) {
        const n = this._gpuBuffers[e.uid] || this.createGPUBuffer(e),
            r = e.data;
        return e._updateID && r && (e._updateID = 0, this._gpu.device.queue.writeBuffer(n, 0, r.buffer, 0, (e._updateSize || r.byteLength) + 3 & -4)), n
    }
    destroyAll() {
        for (const e in this._gpuBuffers) this._gpuBuffers[e].destroy();
        this._gpuBuffers = {}
    }
    createGPUBuffer(e) {
        this._gpuBuffers[e.uid] || (e.on("update", this.updateBuffer, this), e.on("change", this.onBufferChange, this), e.on("destroy", this.onBufferDestroy, this), this._managedBuffers.push(e));
        const n = this._gpu.device.createBuffer(e.descriptor);
        return e._updateID = 0, e.data && (k0(e.data.buffer, n.getMappedRange()), n.unmap()), this._gpuBuffers[e.uid] = n, n
    }
    onBufferChange(e) {
        this._gpuBuffers[e.uid].destroy(), e._updateID = 0, this._gpuBuffers[e.uid] = this.createGPUBuffer(e)
    }
    onBufferDestroy(e) {
        this._managedBuffers.splice(this._managedBuffers.indexOf(e), 1), this._destroyBuffer(e)
    }
    destroy() {
        this._managedBuffers.forEach(e => this._destroyBuffer(e)), this._managedBuffers = null, this._gpuBuffers = null
    }
    _destroyBuffer(e) {
        this._gpuBuffers[e.uid].destroy(), e.off("update", this.updateBuffer, this), e.off("change", this.onBufferChange, this), e.off("destroy", this.onBufferDestroy, this), this._gpuBuffers[e.uid] = null
    }
}
L3.extension = {
    type: [G.WebGPUSystem],
    name: "buffer"
};
class hye {
    constructor({
        minUniformOffsetAlignment: e
    }) {
        this._minUniformOffsetAlignment = 256, this.byteIndex = 0, this._minUniformOffsetAlignment = e, this.data = new Float32Array(65535)
    }
    clear() {
        this.byteIndex = 0
    }
    addEmptyGroup(e) {
        if (e > this._minUniformOffsetAlignment / 4) throw new Error(`UniformBufferBatch: array is too large: ${e*4}`);
        const n = this.byteIndex;
        let r = n + e * 4;
        if (r = Math.ceil(r / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment, r > this.data.length * 4) throw new Error("UniformBufferBatch: ubo batch got too big");
        return this.byteIndex = r, n
    }
    addGroup(e) {
        const n = this.addEmptyGroup(e.length);
        for (let r = 0; r < e.length; r++) this.data[n / 4 + r] = e[r];
        return n
    }
    destroy() {
        this.data = null
    }
}
class N3 {
    constructor(e) {
        this._colorMaskCache = 15, this._renderer = e
    }
    setMask(e) {
        this._colorMaskCache !== e && (this._colorMaskCache = e, this._renderer.pipeline.setColorMask(e))
    }
    destroy() {
        this._renderer = null, this._colorMaskCache = null
    }
}
N3.extension = {
    type: [G.WebGPUSystem],
    name: "colorMask"
};
class bw {
    constructor(e) {
        this._renderer = e
    }
    async init(e) {
        return this._initPromise ? this._initPromise : (this._initPromise = this._createDeviceAndAdaptor(e).then(n => {
            this.gpu = n, this._renderer.runners.contextChange.emit(this.gpu)
        }), this._initPromise)
    }
    contextChange(e) {
        this._renderer.gpu = e
    }
    async _createDeviceAndAdaptor(e) {
        const n = await He.get().getNavigator().gpu.requestAdapter({
                powerPreference: e.powerPreference,
                forceFallbackAdapter: e.forceFallbackAdapter
            }),
            r = ["texture-compression-bc", "texture-compression-astc", "texture-compression-etc2"].filter(s => n.features.has(s)),
            i = await n.requestDevice({
                requiredFeatures: r
            });
        return {
            adapter: n,
            device: i
        }
    }
    destroy() {
        this.gpu = null, this._renderer = null
    }
}
bw.extension = {
    type: [G.WebGPUSystem],
    name: "device"
};
bw.defaultOptions = {
    powerPreference: void 0,
    forceFallbackAdapter: !1
};
class U3 {
    constructor(e) {
        this._boundBindGroup = Object.create(null), this._boundVertexBuffer = Object.create(null), this._renderer = e
    }
    renderStart() {
        this.commandFinished = new Promise(e => {
            this._resolveCommandFinished = e
        }), this.commandEncoder = this._renderer.gpu.device.createCommandEncoder()
    }
    beginRenderPass(e) {
        this.endRenderPass(), this._clearCache(), this.renderPassEncoder = this.commandEncoder.beginRenderPass(e.descriptor)
    }
    endRenderPass() {
        this.renderPassEncoder && this.renderPassEncoder.end(), this.renderPassEncoder = null
    }
    setViewport(e) {
        this.renderPassEncoder.setViewport(e.x, e.y, e.width, e.height, 0, 1)
    }
    setPipelineFromGeometryProgramAndState(e, n, r, i) {
        const s = this._renderer.pipeline.getPipeline(e, n, r, i);
        this.setPipeline(s)
    }
    setPipeline(e) {
        this._boundPipeline !== e && (this._boundPipeline = e, this.renderPassEncoder.setPipeline(e))
    }
    _setVertexBuffer(e, n) {
        this._boundVertexBuffer[e] !== n && (this._boundVertexBuffer[e] = n, this.renderPassEncoder.setVertexBuffer(e, this._renderer.buffer.updateBuffer(n)))
    }
    _setIndexBuffer(e) {
        if (this._boundIndexBuffer === e) return;
        this._boundIndexBuffer = e;
        const n = e.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e), n)
    }
    resetBindGroup(e) {
        this._boundBindGroup[e] = null
    }
    setBindGroup(e, n, r) {
        if (this._boundBindGroup[e] === n) return;
        this._boundBindGroup[e] = n, n._touch(this._renderer.textureGC.count);
        const i = this._renderer.bindGroup.getBindGroup(n, r, e);
        this.renderPassEncoder.setBindGroup(e, i)
    }
    setGeometry(e, n) {
        const r = this._renderer.pipeline.getBufferNamesToBind(e, n);
        for (const i in r) this._setVertexBuffer(i, e.attributes[r[i]].buffer);
        e.indexBuffer && this._setIndexBuffer(e.indexBuffer)
    }
    _setShaderBindGroups(e, n) {
        for (const r in e.groups) {
            const i = e.groups[r];
            n || this._syncBindGroup(i), this.setBindGroup(r, i, e.gpuProgram)
        }
    }
    _syncBindGroup(e) {
        for (const n in e.resources) {
            const r = e.resources[n];
            r.isUniformGroup && this._renderer.ubo.updateUniformGroup(r)
        }
    }
    draw(e) {
        const {
            geometry: n,
            shader: r,
            state: i,
            topology: s,
            size: o,
            start: a,
            instanceCount: l,
            skipSync: c
        } = e;
        this.setPipelineFromGeometryProgramAndState(n, r.gpuProgram, i, s), this.setGeometry(n, r.gpuProgram), this._setShaderBindGroups(r, c), n.indexBuffer ? this.renderPassEncoder.drawIndexed(o || n.indexBuffer.data.length, l ? ? n.instanceCount, a || 0) : this.renderPassEncoder.draw(o || n.getSize(), l ? ? n.instanceCount, a || 0)
    }
    finishRenderPass() {
        this.renderPassEncoder && (this.renderPassEncoder.end(), this.renderPassEncoder = null)
    }
    postrender() {
        this.finishRenderPass(), this._gpu.device.queue.submit([this.commandEncoder.finish()]), this._resolveCommandFinished(), this.commandEncoder = null
    }
    restoreRenderPass() {
        const e = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, !1, [0, 0, 0, 1]);
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(e);
        const n = this._boundPipeline,
            r = { ...this._boundVertexBuffer
            },
            i = this._boundIndexBuffer,
            s = { ...this._boundBindGroup
            };
        this._clearCache();
        const o = this._renderer.renderTarget.viewport;
        this.renderPassEncoder.setViewport(o.x, o.y, o.width, o.height, 0, 1), this.setPipeline(n);
        for (const a in r) this._setVertexBuffer(a, r[a]);
        for (const a in s) this.setBindGroup(a, s[a], null);
        this._setIndexBuffer(i)
    }
    _clearCache() {
        for (let e = 0; e < 16; e++) this._boundBindGroup[e] = null, this._boundVertexBuffer[e] = null;
        this._boundIndexBuffer = null, this._boundPipeline = null
    }
    destroy() {
        this._renderer = null, this._gpu = null, this._boundBindGroup = null, this._boundVertexBuffer = null, this._boundIndexBuffer = null, this._boundPipeline = null
    }
    contextChange(e) {
        this._gpu = e
    }
}
U3.extension = {
    type: [G.WebGPUSystem],
    name: "encoder",
    priority: 1
};
class G3 {
    constructor(e) {
        this._renderTargetStencilState = Object.create(null), this._renderer = e, e.renderTarget.onRenderTargetChange.add(this)
    }
    onRenderTargetChange(e) {
        let n = this._renderTargetStencilState[e.uid];
        n || (n = this._renderTargetStencilState[e.uid] = {
            stencilMode: Mt.DISABLED,
            stencilReference: 0
        }), this._activeRenderTarget = e, this.setStencilMode(n.stencilMode, n.stencilReference)
    }
    setStencilMode(e, n) {
        const r = this._renderTargetStencilState[this._activeRenderTarget.uid];
        r.stencilMode = e, r.stencilReference = n;
        const i = this._renderer;
        i.pipeline.setStencilMode(e), i.encoder.renderPassEncoder.setStencilReference(n)
    }
    destroy() {
        this._renderer.renderTarget.onRenderTargetChange.remove(this), this._renderer = null, this._activeRenderTarget = null, this._renderTargetStencilState = null
    }
}
G3.extension = {
    type: [G.WebGPUSystem],
    name: "stencil"
};
const jf = {
    i32: {
        align: 4,
        size: 4
    },
    u32: {
        align: 4,
        size: 4
    },
    f32: {
        align: 4,
        size: 4
    },
    f16: {
        align: 2,
        size: 2
    },
    "vec2<i32>": {
        align: 8,
        size: 8
    },
    "vec2<u32>": {
        align: 8,
        size: 8
    },
    "vec2<f32>": {
        align: 8,
        size: 8
    },
    "vec2<f16>": {
        align: 4,
        size: 4
    },
    "vec3<i32>": {
        align: 16,
        size: 12
    },
    "vec3<u32>": {
        align: 16,
        size: 12
    },
    "vec3<f32>": {
        align: 16,
        size: 12
    },
    "vec3<f16>": {
        align: 8,
        size: 6
    },
    "vec4<i32>": {
        align: 16,
        size: 16
    },
    "vec4<u32>": {
        align: 16,
        size: 16
    },
    "vec4<f32>": {
        align: 16,
        size: 16
    },
    "vec4<f16>": {
        align: 8,
        size: 8
    },
    "mat2x2<f32>": {
        align: 8,
        size: 16
    },
    "mat2x2<f16>": {
        align: 4,
        size: 8
    },
    "mat3x2<f32>": {
        align: 8,
        size: 24
    },
    "mat3x2<f16>": {
        align: 4,
        size: 12
    },
    "mat4x2<f32>": {
        align: 8,
        size: 32
    },
    "mat4x2<f16>": {
        align: 4,
        size: 16
    },
    "mat2x3<f32>": {
        align: 16,
        size: 32
    },
    "mat2x3<f16>": {
        align: 8,
        size: 16
    },
    "mat3x3<f32>": {
        align: 16,
        size: 48
    },
    "mat3x3<f16>": {
        align: 8,
        size: 24
    },
    "mat4x3<f32>": {
        align: 16,
        size: 64
    },
    "mat4x3<f16>": {
        align: 8,
        size: 32
    },
    "mat2x4<f32>": {
        align: 16,
        size: 32
    },
    "mat2x4<f16>": {
        align: 8,
        size: 16
    },
    "mat3x4<f32>": {
        align: 16,
        size: 48
    },
    "mat3x4<f16>": {
        align: 8,
        size: 24
    },
    "mat4x4<f32>": {
        align: 16,
        size: 64
    },
    "mat4x4<f16>": {
        align: 8,
        size: 32
    }
};

function pye(t) {
    const e = t.map(r => ({
        data: r,
        offset: 0,
        size: 0
    }));
    let n = 0;
    for (let r = 0; r < e.length; r++) {
        const i = e[r];
        let s = jf[i.data.type].size;
        const o = jf[i.data.type].align;
        if (!jf[i.data.type]) throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${i.data.type}`);
        i.data.size > 1 && (s = Math.max(s, o) * i.data.size), n = Math.ceil(n / o) * o, i.size = s, i.offset = n, n += s
    }
    return n = Math.ceil(n / 16) * 16, {
        uboElements: e,
        size: n
    }
}

function mye(t, e) {
    const {
        size: n,
        align: r
    } = jf[t.data.type], i = (r - n) / 4, s = t.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
    return `
         v = uv.${t.data.name};
         ${e!==0?`offset += ${e};`:""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${t.data.size*(n/4)}; i++)
         {
             for(var j = 0; j < ${n/4}; j++)
             {
                 ${s}[arrayOffset++] = v[t++];
             }
             ${i!==0?`arrayOffset += ${i};`:""}
         }
     `
}

function gye(t) {
    return e3(t, "uboWgsl", mye, ave)
}
class H3 extends Z$ {
    constructor() {
        super({
            createUboElements: pye,
            generateUboSync: gye
        })
    }
}
H3.extension = {
    type: [G.WebGPUSystem],
    name: "ubo"
};
const ss = 128;
class z3 {
    constructor(e) {
        this._bindGroupHash = Object.create(null), this._buffers = [], this._bindGroups = [], this._bufferResources = [], this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash"), this._batchBuffer = new hye({
            minUniformOffsetAlignment: ss
        });
        const n = 256 / ss;
        for (let r = 0; r < n; r++) {
            let i = Xe.UNIFORM | Xe.COPY_DST;
            r === 0 && (i |= Xe.COPY_SRC), this._buffers.push(new qn({
                data: this._batchBuffer.data,
                usage: i
            }))
        }
    }
    renderEnd() {
        this._uploadBindGroups(), this._resetBindGroups()
    }
    _resetBindGroups() {
        for (const e in this._bindGroupHash) this._bindGroupHash[e] = null;
        this._batchBuffer.clear()
    }
    getUniformBindGroup(e, n) {
        if (!n && this._bindGroupHash[e.uid]) return this._bindGroupHash[e.uid];
        this._renderer.ubo.ensureUniformGroup(e);
        const r = e.buffer.data,
            i = this._batchBuffer.addEmptyGroup(r.length);
        return this._renderer.ubo.syncUniformGroup(e, this._batchBuffer.data, i / 4), this._bindGroupHash[e.uid] = this._getBindGroup(i / ss), this._bindGroupHash[e.uid]
    }
    getUboResource(e) {
        this._renderer.ubo.updateUniformGroup(e);
        const n = e.buffer.data,
            r = this._batchBuffer.addGroup(n);
        return this._getBufferResource(r / ss)
    }
    getArrayBindGroup(e) {
        const n = this._batchBuffer.addGroup(e);
        return this._getBindGroup(n / ss)
    }
    getArrayBufferResource(e) {
        const r = this._batchBuffer.addGroup(e) / ss;
        return this._getBufferResource(r)
    }
    _getBufferResource(e) {
        if (!this._bufferResources[e]) {
            const n = this._buffers[e % 2];
            this._bufferResources[e] = new fw({
                buffer: n,
                offset: (e / 2 | 0) * 256,
                size: ss
            })
        }
        return this._bufferResources[e]
    }
    _getBindGroup(e) {
        if (!this._bindGroups[e]) {
            const n = new Fi({
                0: this._getBufferResource(e)
            });
            this._bindGroups[e] = n
        }
        return this._bindGroups[e]
    }
    _uploadBindGroups() {
        const e = this._renderer.buffer,
            n = this._buffers[0];
        n.update(this._batchBuffer.byteIndex), e.updateBuffer(n);
        const r = this._renderer.gpu.device.createCommandEncoder();
        for (let i = 1; i < this._buffers.length; i++) {
            const s = this._buffers[i];
            r.copyBufferToBuffer(e.getGPUBuffer(n), ss, e.getGPUBuffer(s), 0, this._batchBuffer.byteIndex)
        }
        this._renderer.gpu.device.queue.submit([r.finish()])
    }
    destroy() {
        for (let e = 0; e < this._bindGroups.length; e++) this._bindGroups[e].destroy();
        this._bindGroups = null, this._bindGroupHash = null;
        for (let e = 0; e < this._buffers.length; e++) this._buffers[e].destroy();
        this._buffers = null;
        for (let e = 0; e < this._bufferResources.length; e++) this._bufferResources[e].destroy();
        this._bufferResources = null, this._batchBuffer.destroy(), this._bindGroupHash = null, this._renderer = null
    }
}
z3.extension = {
    type: [G.WebGPUPipes],
    name: "uniformBatch"
};
const vye = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 2,
    "triangle-list": 3,
    "triangle-strip": 4
};

function yye(t, e, n, r, i) {
    return t << 24 | e << 16 | n << 10 | r << 5 | i
}

function _ye(t, e, n, r) {
    return n << 6 | t << 3 | r << 1 | e
}
class j3 {
    constructor(e) {
        this._moduleCache = Object.create(null), this._bufferLayoutsCache = Object.create(null), this._bindingNamesCache = Object.create(null), this._pipeCache = Object.create(null), this._pipeStateCaches = Object.create(null), this._colorMask = 15, this._multisampleCount = 1, this._renderer = e
    }
    contextChange(e) {
        this._gpu = e, this.setStencilMode(Mt.DISABLED), this._updatePipeHash()
    }
    setMultisampleCount(e) {
        this._multisampleCount !== e && (this._multisampleCount = e, this._updatePipeHash())
    }
    setRenderTarget(e) {
        this._multisampleCount = e.msaaSamples, this._depthStencilAttachment = e.descriptor.depthStencilAttachment ? 1 : 0, this._updatePipeHash()
    }
    setColorMask(e) {
        this._colorMask !== e && (this._colorMask = e, this._updatePipeHash())
    }
    setStencilMode(e) {
        this._stencilMode !== e && (this._stencilMode = e, this._stencilState = eo[e], this._updatePipeHash())
    }
    setPipeline(e, n, r, i) {
        const s = this.getPipeline(e, n, r);
        i.setPipeline(s)
    }
    getPipeline(e, n, r, i) {
        e._layoutKey || (V$(e, n.attributeData), this._generateBufferKey(e)), i || (i = e.topology);
        const s = yye(e._layoutKey, n._layoutKey, r.data, r._blendModeId, vye[i]);
        return this._pipeCache[s] ? this._pipeCache[s] : (this._pipeCache[s] = this._createPipeline(e, n, r, i), this._pipeCache[s])
    }
    _createPipeline(e, n, r, i) {
        const s = this._gpu.device,
            o = this._createVertexBufferLayouts(e, n),
            a = this._renderer.state.getColorTargets(r);
        a[0].writeMask = this._stencilMode === Mt.RENDERING_MASK_ADD ? 0 : this._colorMask;
        const l = this._renderer.shader.getProgramData(n).pipeline,
            c = {
                vertex: {
                    module: this._getModule(n.vertex.source),
                    entryPoint: n.vertex.entryPoint,
                    buffers: o
                },
                fragment: {
                    module: this._getModule(n.fragment.source),
                    entryPoint: n.fragment.entryPoint,
                    targets: a
                },
                primitive: {
                    topology: i,
                    cullMode: r.cullMode
                },
                layout: l,
                multisample: {
                    count: this._multisampleCount
                },
                label: "PIXI Pipeline"
            };
        return this._depthStencilAttachment && (c.depthStencil = { ...this._stencilState,
            format: "depth24plus-stencil8",
            depthWriteEnabled: r.depthTest,
            depthCompare: r.depthTest ? "less" : "always"
        }), s.createRenderPipeline(c)
    }
    _getModule(e) {
        return this._moduleCache[e] || this._createModule(e)
    }
    _createModule(e) {
        const n = this._gpu.device;
        return this._moduleCache[e] = n.createShaderModule({
            code: e
        }), this._moduleCache[e]
    }
    _generateBufferKey(e) {
        const n = [];
        let r = 0;
        const i = Object.keys(e.attributes).sort();
        for (let o = 0; o < i.length; o++) {
            const a = e.attributes[i[o]];
            n[r++] = a.offset, n[r++] = a.format, n[r++] = a.stride, n[r++] = a.instance
        }
        const s = n.join("|");
        return e._layoutKey = Cu(s, "geometry"), e._layoutKey
    }
    _generateAttributeLocationsKey(e) {
        const n = [];
        let r = 0;
        const i = Object.keys(e.attributeData).sort();
        for (let o = 0; o < i.length; o++) {
            const a = e.attributeData[i[o]];
            n[r++] = a.location
        }
        const s = n.join("|");
        return e._attributeLocationsKey = Cu(s, "programAttributes"), e._attributeLocationsKey
    }
    getBufferNamesToBind(e, n) {
        const r = e._layoutKey << 16 | n._attributeLocationsKey;
        if (this._bindingNamesCache[r]) return this._bindingNamesCache[r];
        const i = this._createVertexBufferLayouts(e, n),
            s = Object.create(null),
            o = n.attributeData;
        for (let a = 0; a < i.length; a++) {
            const c = Object.values(i[a].attributes)[0].shaderLocation;
            for (const u in o)
                if (o[u].location === c) {
                    s[a] = u;
                    break
                }
        }
        return this._bindingNamesCache[r] = s, s
    }
    _createVertexBufferLayouts(e, n) {
        n._attributeLocationsKey || this._generateAttributeLocationsKey(n);
        const r = e._layoutKey << 16 | n._attributeLocationsKey;
        if (this._bufferLayoutsCache[r]) return this._bufferLayoutsCache[r];
        const i = [];
        return e.buffers.forEach(s => {
            const o = {
                    arrayStride: 0,
                    stepMode: "vertex",
                    attributes: []
                },
                a = o.attributes;
            for (const l in n.attributeData) {
                const c = e.attributes[l];
                (c.divisor ? ? 1) !== 1 && Me(`Attribute ${l} has an invalid divisor value of '${c.divisor}'. WebGPU only supports a divisor value of 1`), c.buffer === s && (o.arrayStride = c.stride, o.stepMode = c.instance ? "instance" : "vertex", a.push({
                    shaderLocation: n.attributeData[l].location,
                    offset: c.offset,
                    format: c.format
                }))
            }
            a.length && i.push(o)
        }), this._bufferLayoutsCache[r] = i, i
    }
    _updatePipeHash() {
        const e = _ye(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);
        this._pipeStateCaches[e] || (this._pipeStateCaches[e] = Object.create(null)), this._pipeCache = this._pipeStateCaches[e]
    }
    destroy() {
        this._renderer = null, this._bufferLayoutsCache = null
    }
}
j3.extension = {
    type: [G.WebGPUSystem],
    name: "pipeline"
};
class bye {
    constructor() {
        this.contexts = [], this.msaaTextures = [], this.msaaSamples = 1
    }
}
class xye {
    init(e, n) {
        this._renderer = e, this._renderTargetSystem = n
    }
    copyToTexture(e, n, r, i, s) {
        const o = this._renderer,
            a = this._getGpuColorTexture(e),
            l = o.texture.getGpuSource(n.source);
        return o.encoder.commandEncoder.copyTextureToTexture({
            texture: a,
            origin: r
        }, {
            texture: l,
            origin: s
        }, i), n
    }
    startRenderPass(e, n = !0, r, i) {
        const o = this._renderTargetSystem.getGpuRenderTarget(e),
            a = this.getDescriptor(e, n, r);
        o.descriptor = a, this._renderer.pipeline.setRenderTarget(o), this._renderer.encoder.beginRenderPass(o), this._renderer.encoder.setViewport(i)
    }
    finishRenderPass() {
        this._renderer.encoder.endRenderPass()
    }
    _getGpuColorTexture(e) {
        const n = this._renderTargetSystem.getGpuRenderTarget(e);
        return n.contexts[0] ? n.contexts[0].getCurrentTexture() : this._renderer.texture.getGpuSource(e.colorTextures[0].source)
    }
    getDescriptor(e, n, r) {
        typeof n == "boolean" && (n = n ? jn.ALL : jn.NONE);
        const i = this._renderTargetSystem,
            s = i.getGpuRenderTarget(e),
            o = e.colorTextures.map((c, u) => {
                const d = s.contexts[u];
                let f, h;
                d ? f = d.getCurrentTexture().createView() : f = this._renderer.texture.getGpuSource(c).createView({
                    mipLevelCount: 1
                }), s.msaaTextures[u] && (h = f, f = this._renderer.texture.getTextureView(s.msaaTextures[u]));
                const p = n & jn.COLOR ? "clear" : "load";
                return r ? ? (r = i.defaultClearColor), {
                    view: f,
                    resolveTarget: h,
                    clearValue: r,
                    storeOp: "store",
                    loadOp: p
                }
            });
        let a;
        if ((e.stencil || e.depth) && !e.depthStencilTexture && (e.ensureDepthStencilTexture(), e.depthStencilTexture.source.sampleCount = s.msaa ? 4 : 1), e.depthStencilTexture) {
            const c = n & jn.STENCIL ? "clear" : "load",
                u = n & jn.DEPTH ? "clear" : "load";
            a = {
                view: this._renderer.texture.getGpuSource(e.depthStencilTexture.source).createView(),
                stencilStoreOp: "store",
                stencilLoadOp: c,
                depthClearValue: 1,
                depthLoadOp: u,
                depthStoreOp: "store"
            }
        }
        return {
            colorAttachments: o,
            depthStencilAttachment: a
        }
    }
    clear(e, n = !0, r, i) {
        if (!n) return;
        const {
            gpu: s,
            encoder: o
        } = this._renderer, a = s.device;
        if (o.commandEncoder === null) {
            const c = a.createCommandEncoder(),
                u = this.getDescriptor(e, n, r),
                d = c.beginRenderPass(u);
            d.setViewport(i.x, i.y, i.width, i.height, 0, 1), d.end();
            const f = c.finish();
            a.queue.submit([f])
        } else this.startRenderPass(e, n, r, i)
    }
    initGpuRenderTarget(e) {
        e.isRoot = !0;
        const n = new bye;
        return e.colorTextures.forEach((r, i) => {
            if (ni.test(r.resource)) {
                const s = r.resource.getContext("webgpu"),
                    o = r.transparent ? "premultiplied" : "opaque";
                try {
                    s.configure({
                        device: this._renderer.gpu.device,
                        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                        format: "bgra8unorm",
                        alphaMode: o
                    })
                } catch (a) {
                    console.error(a)
                }
                n.contexts[i] = s
            }
            if (n.msaa = r.source.antialias, r.source.antialias) {
                const s = new Qt({
                    width: 0,
                    height: 0,
                    sampleCount: 4
                });
                n.msaaTextures[i] = s
            }
        }), n.msaa && (n.msaaSamples = 4, e.depthStencilTexture && (e.depthStencilTexture.source.sampleCount = 4)), n
    }
    destroyGpuRenderTarget(e) {
        e.contexts.forEach(n => {
            n.unconfigure()
        }), e.msaaTextures.forEach(n => {
            n.destroy()
        }), e.msaaTextures.length = 0, e.contexts.length = 0
    }
    ensureDepthStencilTexture(e) {
        const n = this._renderTargetSystem.getGpuRenderTarget(e);
        e.depthStencilTexture && n.msaa && (e.depthStencilTexture.source.sampleCount = 4)
    }
    resizeGpuRenderTarget(e) {
        const n = this._renderTargetSystem.getGpuRenderTarget(e);
        n.width = e.width, n.height = e.height, n.msaa && e.colorTextures.forEach((r, i) => {
            const s = n.msaaTextures[i];
            s == null || s.resize(r.source.width, r.source.height, r.source._resolution)
        })
    }
}
class V3 extends o3 {
    constructor(e) {
        super(e), this.adaptor = new xye, this.adaptor.init(e, this)
    }
}
V3.extension = {
    type: [G.WebGPUSystem],
    name: "renderTarget"
};
class W3 {
    constructor() {
        this._gpuProgramData = Object.create(null)
    }
    contextChange(e) {
        this._gpu = e, this.maxTextures = e.device.limits.maxSampledTexturesPerShaderStage
    }
    getProgramData(e) {
        return this._gpuProgramData[e._layoutKey] || this._createGPUProgramData(e)
    }
    _createGPUProgramData(e) {
        const n = this._gpu.device,
            r = e.gpuLayout.map(s => n.createBindGroupLayout({
                entries: s
            })),
            i = {
                bindGroupLayouts: r
            };
        return this._gpuProgramData[e._layoutKey] = {
            bindGroups: r,
            pipeline: n.createPipelineLayout(i)
        }, this._gpuProgramData[e._layoutKey]
    }
    destroy() {
        this._gpu = null, this._gpuProgramData = null
    }
}
W3.extension = {
    type: [G.WebGPUSystem],
    name: "shader"
};
const Ln = {};
Ln.normal = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    }
};
Ln.add = {
    alpha: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
    }
};
Ln.multiply = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "dst",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    }
};
Ln.screen = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
    }
};
Ln.overlay = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
    }
};
Ln.none = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "zero",
        dstFactor: "zero",
        operation: "add"
    }
};
Ln["normal-npm"] = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    }
};
Ln["add-npm"] = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
    },
    color: {
        srcFactor: "src-alpha",
        dstFactor: "one",
        operation: "add"
    }
};
Ln["screen-npm"] = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src",
        operation: "add"
    }
};
Ln.erase = {
    alpha: {
        srcFactor: "zero",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "zero",
        dstFactor: "one-minus-src",
        operation: "add"
    }
};
Ln.min = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "min"
    },
    color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "min"
    }
};
Ln.max = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "max"
    },
    color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "max"
    }
};
class Y3 {
    constructor() {
        this.defaultState = new kr, this.defaultState.blend = !0
    }
    contextChange(e) {
        this.gpu = e
    }
    getColorTargets(e) {
        return [{
            format: "bgra8unorm",
            writeMask: 0,
            blend: Ln[e.blendMode] || Ln.normal
        }]
    }
    destroy() {
        this.gpu = null
    }
}
Y3.extension = {
    type: [G.WebGPUSystem],
    name: "state"
};
const wye = {
        type: "image",
        upload(t, e, n) {
            const r = t.resource,
                i = (t.pixelWidth | 0) * (t.pixelHeight | 0),
                s = r.byteLength / i;
            n.device.queue.writeTexture({
                texture: e
            }, r, {
                offset: 0,
                rowsPerImage: t.pixelHeight,
                bytesPerRow: t.pixelHeight * s
            }, {
                width: t.pixelWidth,
                height: t.pixelHeight,
                depthOrArrayLayers: 1
            })
        }
    },
    X3 = {
        "bc1-rgba-unorm": {
            blockBytes: 8,
            blockWidth: 4,
            blockHeight: 4
        },
        "bc2-rgba-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "bc3-rgba-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "bc7-rgba-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "etc1-rgb-unorm": {
            blockBytes: 8,
            blockWidth: 4,
            blockHeight: 4
        },
        "etc2-rgba8unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "astc-4x4-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        }
    },
    Eye = {
        blockBytes: 4,
        blockWidth: 1,
        blockHeight: 1
    },
    Sye = {
        type: "compressed",
        upload(t, e, n) {
            let r = t.pixelWidth,
                i = t.pixelHeight;
            const s = X3[t.format] || Eye;
            for (let o = 0; o < t.resource.length; o++) {
                const a = t.resource[o],
                    l = Math.ceil(r / s.blockWidth) * s.blockBytes;
                n.device.queue.writeTexture({
                    texture: e,
                    mipLevel: o
                }, a, {
                    offset: 0,
                    bytesPerRow: l
                }, {
                    width: Math.ceil(r / s.blockWidth) * s.blockWidth,
                    height: Math.ceil(i / s.blockHeight) * s.blockHeight,
                    depthOrArrayLayers: 1
                }), r = Math.max(r >> 1, 1), i = Math.max(i >> 1, 1)
            }
        }
    },
    K3 = {
        type: "image",
        upload(t, e, n) {
            const r = t.resource;
            if (!r) return;
            const i = Math.min(e.width, t.resourceWidth || t.pixelWidth),
                s = Math.min(e.height, t.resourceHeight || t.pixelHeight),
                o = t.alphaMode === "premultiply-alpha-on-upload";
            n.device.queue.copyExternalImageToTexture({
                source: r
            }, {
                texture: e,
                premultipliedAlpha: o
            }, {
                width: i,
                height: s
            })
        }
    },
    Tye = {
        type: "video",
        upload(t, e, n) {
            K3.upload(t, e, n)
        }
    };
class Cye {
    constructor(e) {
        this.device = e, this.sampler = e.createSampler({
            minFilter: "linear"
        }), this.pipelines = {}
    }
    _getMipmapPipeline(e) {
        let n = this.pipelines[e];
        return n || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({
            code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
        })), n = this.device.createRenderPipeline({
            layout: "auto",
            vertex: {
                module: this.mipmapShaderModule,
                entryPoint: "vertexMain"
            },
            fragment: {
                module: this.mipmapShaderModule,
                entryPoint: "fragmentMain",
                targets: [{
                    format: e
                }]
            }
        }), this.pipelines[e] = n), n
    }
    generateMipmap(e) {
        const n = this._getMipmapPipeline(e.format);
        if (e.dimension === "3d" || e.dimension === "1d") throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
        let r = e;
        const i = e.depthOrArrayLayers || 1,
            s = e.usage & GPUTextureUsage.RENDER_ATTACHMENT;
        if (!s) {
            const l = {
                size: {
                    width: Math.ceil(e.width / 2),
                    height: Math.ceil(e.height / 2),
                    depthOrArrayLayers: i
                },
                format: e.format,
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
                mipLevelCount: e.mipLevelCount - 1
            };
            r = this.device.createTexture(l)
        }
        const o = this.device.createCommandEncoder({}),
            a = n.getBindGroupLayout(0);
        for (let l = 0; l < i; ++l) {
            let c = e.createView({
                    baseMipLevel: 0,
                    mipLevelCount: 1,
                    dimension: "2d",
                    baseArrayLayer: l,
                    arrayLayerCount: 1
                }),
                u = s ? 1 : 0;
            for (let d = 1; d < e.mipLevelCount; ++d) {
                const f = r.createView({
                        baseMipLevel: u++,
                        mipLevelCount: 1,
                        dimension: "2d",
                        baseArrayLayer: l,
                        arrayLayerCount: 1
                    }),
                    h = o.beginRenderPass({
                        colorAttachments: [{
                            view: f,
                            storeOp: "store",
                            loadOp: "clear",
                            clearValue: {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0
                            }
                        }]
                    }),
                    p = this.device.createBindGroup({
                        layout: a,
                        entries: [{
                            binding: 0,
                            resource: this.sampler
                        }, {
                            binding: 1,
                            resource: c
                        }]
                    });
                h.setPipeline(n), h.setBindGroup(0, p), h.draw(3, 1, 0, 0), h.end(), c = f
            }
        }
        if (!s) {
            const l = {
                width: Math.ceil(e.width / 2),
                height: Math.ceil(e.height / 2),
                depthOrArrayLayers: i
            };
            for (let c = 1; c < e.mipLevelCount; ++c) o.copyTextureToTexture({
                texture: r,
                mipLevel: c - 1
            }, {
                texture: e,
                mipLevel: c
            }, l), l.width = Math.ceil(l.width / 2), l.height = Math.ceil(l.height / 2)
        }
        return this.device.queue.submit([o.finish()]), s || r.destroy(), e
    }
}
class q3 {
    constructor(e) {
        this.managedTextures = [], this._gpuSources = Object.create(null), this._gpuSamplers = Object.create(null), this._bindGroupHash = Object.create(null), this._textureViewHash = Object.create(null), this._uploads = {
            image: K3,
            buffer: wye,
            video: Tye,
            compressed: Sye
        }, this._renderer = e, e.renderableGC.addManagedHash(this, "_gpuSources"), e.renderableGC.addManagedHash(this, "_gpuSamplers"), e.renderableGC.addManagedHash(this, "_bindGroupHash"), e.renderableGC.addManagedHash(this, "_textureViewHash")
    }
    contextChange(e) {
        this._gpu = e
    }
    initSource(e) {
        if (e.autoGenerateMipmaps) {
            const l = Math.max(e.pixelWidth, e.pixelHeight);
            e.mipLevelCount = Math.floor(Math.log2(l)) + 1
        }
        let n = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
        e.uploadMethodId !== "compressed" && (n |= GPUTextureUsage.RENDER_ATTACHMENT, n |= GPUTextureUsage.COPY_SRC);
        const r = X3[e.format] || {
                blockBytes: 4,
                blockWidth: 1,
                blockHeight: 1
            },
            i = Math.ceil(e.pixelWidth / r.blockWidth) * r.blockWidth,
            s = Math.ceil(e.pixelHeight / r.blockHeight) * r.blockHeight,
            o = {
                label: e.label,
                size: {
                    width: i,
                    height: s
                },
                format: e.format,
                sampleCount: e.sampleCount,
                mipLevelCount: e.mipLevelCount,
                dimension: e.dimension,
                usage: n
            },
            a = this._gpu.device.createTexture(o);
        return this._gpuSources[e.uid] = a, this.managedTextures.includes(e) || (e.on("update", this.onSourceUpdate, this), e.on("resize", this.onSourceResize, this), e.on("destroy", this.onSourceDestroy, this), e.on("unload", this.onSourceUnload, this), e.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(e)), this.onSourceUpdate(e), a
    }
    onSourceUpdate(e) {
        const n = this.getGpuSource(e);
        n && (this._uploads[e.uploadMethodId] && this._uploads[e.uploadMethodId].upload(e, n, this._gpu), e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e))
    }
    onSourceUnload(e) {
        const n = this._gpuSources[e.uid];
        n && (this._gpuSources[e.uid] = null, n.destroy())
    }
    onUpdateMipmaps(e) {
        this._mipmapGenerator || (this._mipmapGenerator = new Cye(this._gpu.device));
        const n = this.getGpuSource(e);
        this._mipmapGenerator.generateMipmap(n)
    }
    onSourceDestroy(e) {
        e.off("update", this.onSourceUpdate, this), e.off("unload", this.onSourceUnload, this), e.off("destroy", this.onSourceDestroy, this), e.off("resize", this.onSourceResize, this), e.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(e), 1), this.onSourceUnload(e)
    }
    onSourceResize(e) {
        const n = this._gpuSources[e.uid];
        n ? (n.width !== e.pixelWidth || n.height !== e.pixelHeight) && (this._textureViewHash[e.uid] = null, this._bindGroupHash[e.uid] = null, this.onSourceUnload(e), this.initSource(e)) : this.initSource(e)
    }
    _initSampler(e) {
        return this._gpuSamplers[e._resourceId] = this._gpu.device.createSampler(e), this._gpuSamplers[e._resourceId]
    }
    getGpuSampler(e) {
        return this._gpuSamplers[e._resourceId] || this._initSampler(e)
    }
    getGpuSource(e) {
        return this._gpuSources[e.uid] || this.initSource(e)
    }
    getTextureBindGroup(e) {
        return this._bindGroupHash[e.uid] ? ? this._createTextureBindGroup(e)
    }
    _createTextureBindGroup(e) {
        const n = e.source;
        return this._bindGroupHash[e.uid] = new Fi({
            0: n,
            1: n.style,
            2: new Cn({
                uTextureMatrix: {
                    type: "mat3x3<f32>",
                    value: e.textureMatrix.mapCoord
                }
            })
        }), this._bindGroupHash[e.uid]
    }
    getTextureView(e) {
        const n = e.source;
        return this._textureViewHash[n.uid] ? ? this._createTextureView(n)
    }
    _createTextureView(e) {
        return this._textureViewHash[e.uid] = this.getGpuSource(e).createView(), this._textureViewHash[e.uid]
    }
    generateCanvas(e) {
        const n = this._renderer,
            r = n.gpu.device.createCommandEncoder(),
            i = He.get().createCanvas();
        i.width = e.source.pixelWidth, i.height = e.source.pixelHeight;
        const s = i.getContext("webgpu");
        return s.configure({
            device: n.gpu.device,
            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
            format: He.get().getNavigator().gpu.getPreferredCanvasFormat(),
            alphaMode: "premultiplied"
        }), r.copyTextureToTexture({
            texture: n.texture.getGpuSource(e.source),
            origin: {
                x: 0,
                y: 0
            }
        }, {
            texture: s.getCurrentTexture()
        }, {
            width: i.width,
            height: i.height
        }), n.gpu.device.queue.submit([r.finish()]), i
    }
    getPixels(e) {
        const n = this.generateCanvas(e),
            r = Li.getOptimalCanvasAndContext(n.width, n.height),
            i = r.context;
        i.drawImage(n, 0, 0);
        const {
            width: s,
            height: o
        } = n, a = i.getImageData(0, 0, s, o), l = new Uint8ClampedArray(a.data.buffer);
        return Li.returnCanvasAndContext(r), {
            pixels: l,
            width: s,
            height: o
        }
    }
    destroy() {
        this.managedTextures.slice().forEach(e => this.onSourceDestroy(e)), this.managedTextures = null;
        for (const e of Object.keys(this._bindGroupHash)) {
            const n = Number(e),
                r = this._bindGroupHash[n];
            r == null || r.destroy(), this._bindGroupHash[n] = null
        }
        this._gpu = null, this._mipmapGenerator = null, this._gpuSources = null, this._bindGroupHash = null, this._textureViewHash = null, this._gpuSamplers = null
    }
}
q3.extension = {
    type: [G.WebGPUSystem],
    name: "texture"
};
class J3 {
    init() {
        const e = new Cn({
                uTransformMatrix: {
                    value: new Ce,
                    type: "mat3x3<f32>"
                },
                uColor: {
                    value: new Float32Array([1, 1, 1, 1]),
                    type: "vec4<f32>"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            }),
            n = dd({
                name: "graphics",
                bits: [Vx, Yx(zl()), Yge, hd]
            });
        this.shader = new pr({
            gpuProgram: n,
            resources: {
                localUniforms: e
            }
        })
    }
    execute(e, n) {
        const r = n.context,
            i = r.customShader || this.shader,
            s = e.renderer,
            o = s.graphicsContext,
            {
                batcher: a,
                instructions: l
            } = o.getContextRenderData(r),
            c = s.encoder;
        c.setGeometry(a.geometry, i.gpuProgram);
        const u = s.globalUniforms.bindGroup;
        c.setBindGroup(0, u, i.gpuProgram);
        const d = s.renderPipes.uniformBatch.getUniformBindGroup(i.resources.localUniforms, !0);
        c.setBindGroup(2, d, i.gpuProgram);
        const f = l.instructions;
        let h = null;
        for (let p = 0; p < l.instructionSize; p++) {
            const b = f[p];
            if (b.topology !== h && (h = b.topology, c.setPipelineFromGeometryProgramAndState(a.geometry, i.gpuProgram, e.state, b.topology)), i.groups[1] = b.bindGroup, !b.gpuBindGroup) {
                const y = b.textures;
                b.bindGroup = jx(y.textures, y.count), b.gpuBindGroup = s.bindGroup.getBindGroup(b.bindGroup, i.gpuProgram, 1)
            }
            c.setBindGroup(1, b.bindGroup, i.gpuProgram), c.renderPassEncoder.drawIndexed(b.size, 1, b.start)
        }
    }
    destroy() {
        this.shader.destroy(!0), this.shader = null
    }
}
J3.extension = {
    type: [G.WebGPUPipesAdaptor],
    name: "graphics"
};
class Z3 {
    init() {
        const e = dd({
            name: "mesh",
            bits: [Yc, Xge, hd]
        });
        this._shader = new pr({
            gpuProgram: e,
            resources: {
                uTexture: we.EMPTY._source,
                uSampler: we.EMPTY._source.style,
                textureUniforms: {
                    uTextureMatrix: {
                        type: "mat3x3<f32>",
                        value: new Ce
                    }
                }
            }
        })
    }
    execute(e, n) {
        const r = e.renderer;
        let i = n._shader;
        if (!i) i = this._shader, i.groups[2] = r.texture.getTextureBindGroup(n.texture);
        else if (!i.gpuProgram) {
            Me("Mesh shader has no gpuProgram", n.shader);
            return
        }
        const s = i.gpuProgram;
        if (s.autoAssignGlobalUniforms && (i.groups[0] = r.globalUniforms.bindGroup), s.autoAssignLocalUniforms) {
            const o = e.localUniforms;
            i.groups[1] = r.renderPipes.uniformBatch.getUniformBindGroup(o, !0)
        }
        r.encoder.draw({
            geometry: n._geometry,
            shader: i,
            state: n.state
        })
    }
    destroy() {
        this._shader.destroy(!0), this._shader = null
    }
}
Z3.extension = {
    type: [G.WebGPUPipesAdaptor],
    name: "mesh"
};
const Pye = [...M3, H3, U3, bw, L3, q3, V3, W3, Y3, j3, N3, G3, F3],
    Aye = [...k3, z3],
    Oye = [F$, Z3, J3],
    Q3 = [],
    eF = [],
    tF = [];
Ie.handleByNamedList(G.WebGPUSystem, Q3);
Ie.handleByNamedList(G.WebGPUPipes, eF);
Ie.handleByNamedList(G.WebGPUPipesAdaptor, tF);
Ie.add(...Pye, ...Aye, ...Oye);
class Iye extends em {
    constructor() {
        const e = {
            name: "webgpu",
            type: Qn.WEBGPU,
            systems: Q3,
            renderPipes: eF,
            renderPipeAdaptors: tF
        };
        super(e)
    }
}
const Rye = Object.freeze(Object.defineProperty({
    __proto__: null,
    WebGPURenderer: Iye
}, Symbol.toStringTag, {
    value: "Module"
}));
class nF {
    constructor(e, n) {
        this.state = kr.for2d(), this._graphicsBatchesHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this.renderer = e, this._adaptor = n, this._adaptor.init(), this.renderer.renderableGC.addManagedHash(this, "_graphicsBatchesHash")
    }
    validateRenderable(e) {
        const n = e.context,
            r = !!this._graphicsBatchesHash[e.uid],
            i = this.renderer.graphicsContext.updateGpuContext(n);
        return !!(i.isBatchable || r !== i.isBatchable)
    }
    addRenderable(e, n) {
        const r = this.renderer.graphicsContext.updateGpuContext(e.context);
        e.didViewUpdate && this._rebuild(e), r.isBatchable ? this._addToBatcher(e, n) : (this.renderer.renderPipes.batch.break(n), n.add(e))
    }
    updateRenderable(e) {
        const n = this._graphicsBatchesHash[e.uid];
        if (n)
            for (let r = 0; r < n.length; r++) {
                const i = n[r];
                i._batcher.updateElement(i)
            }
    }
    destroyRenderable(e) {
        this._graphicsBatchesHash[e.uid] && this._removeBatchForRenderable(e.uid), e.off("destroyed", this._destroyRenderableBound)
    }
    execute(e) {
        if (!e.isRenderable) return;
        const n = this.renderer,
            r = e.context;
        if (!n.graphicsContext.getGpuContext(r).batches.length) return;
        const s = r.customShader || this._adaptor.shader;
        this.state.blendMode = e.groupBlendMode;
        const o = s.resources.localUniforms.uniforms;
        o.uTransformMatrix = e.groupTransform, o.uRound = n._roundPixels | e._roundPixels, md(e.groupColorAlpha, o.uColor, 0), this._adaptor.execute(this, e)
    }
    _rebuild(e) {
        const n = !!this._graphicsBatchesHash[e.uid],
            r = this.renderer.graphicsContext.updateGpuContext(e.context);
        n && this._removeBatchForRenderable(e.uid), r.isBatchable && this._initBatchesForRenderable(e), e.batched = r.isBatchable
    }
    _addToBatcher(e, n) {
        const r = this.renderer.renderPipes.batch,
            i = this._getBatchesForRenderable(e);
        for (let s = 0; s < i.length; s++) {
            const o = i[s];
            r.addToBatch(o, n)
        }
    }
    _getBatchesForRenderable(e) {
        return this._graphicsBatchesHash[e.uid] || this._initBatchesForRenderable(e)
    }
    _initBatchesForRenderable(e) {
        const n = e.context,
            r = this.renderer.graphicsContext.getGpuContext(n),
            i = this.renderer._roundPixels | e._roundPixels,
            s = r.batches.map(o => {
                const a = We.get(Jx);
                return o.copyTo(a), a.renderable = e, a.roundPixels = i, a
            });
        return this._graphicsBatchesHash[e.uid] === void 0 && e.on("destroyed", this._destroyRenderableBound), this._graphicsBatchesHash[e.uid] = s, s
    }
    _removeBatchForRenderable(e) {
        this._graphicsBatchesHash[e].forEach(n => {
            We.return(n)
        }), this._graphicsBatchesHash[e] = null
    }
    destroy() {
        this.renderer = null, this._adaptor.destroy(), this._adaptor = null, this.state = null;
        for (const e in this._graphicsBatchesHash) this._removeBatchForRenderable(e);
        this._graphicsBatchesHash = null
    }
}
nF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "graphics"
};
const rF = class iF extends ow {
    constructor(...e) {
        super({});
        let n = e[0] ? ? {};
        typeof n == "number" && ($e(Ye, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"), n = {
            width: n,
            height: e[1],
            verticesX: e[2],
            verticesY: e[3]
        }), this.build(n)
    }
    build(e) {
        e = { ...iF.defaultOptions,
            ...e
        }, this.verticesX = this.verticesX ? ? e.verticesX, this.verticesY = this.verticesY ? ? e.verticesY, this.width = this.width ? ? e.width, this.height = this.height ? ? e.height;
        const n = this.verticesX * this.verticesY,
            r = [],
            i = [],
            s = [],
            o = this.verticesX - 1,
            a = this.verticesY - 1,
            l = this.width / o,
            c = this.height / a;
        for (let d = 0; d < n; d++) {
            const f = d % this.verticesX,
                h = d / this.verticesX | 0;
            r.push(f * l, h * c), i.push(f / o, h / a)
        }
        const u = o * a;
        for (let d = 0; d < u; d++) {
            const f = d % o,
                h = d / o | 0,
                p = h * this.verticesX + f,
                b = h * this.verticesX + f + 1,
                y = (h + 1) * this.verticesX + f,
                m = (h + 1) * this.verticesX + f + 1;
            s.push(p, b, y, b, m, y)
        }
        this.buffers[0].data = new Float32Array(r), this.buffers[1].data = new Float32Array(i), this.indexBuffer.data = new Uint32Array(s), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update()
    }
};
rF.defaultOptions = {
    width: 100,
    height: 100,
    verticesX: 10,
    verticesY: 10
};
let Mye = rF;
class xw {
    constructor() {
        this.batcherName = "default", this.packAsQuad = !1, this.indexOffset = 0, this.attributeOffset = 0, this.roundPixels = 0, this._batcher = null, this._batch = null, this._textureMatrixUpdateId = -1, this._uvUpdateId = -1
    }
    get blendMode() {
        return this.renderable.groupBlendMode
    }
    get topology() {
        return this._topology || this.geometry.topology
    }
    set topology(e) {
        this._topology = e
    }
    reset() {
        this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.geometry = null, this._uvUpdateId = -1, this._textureMatrixUpdateId = -1
    }
    setTexture(e) {
        this.texture !== e && (this.texture = e, this._textureMatrixUpdateId = -1)
    }
    get uvs() {
        const n = this.geometry.getBuffer("aUV"),
            r = n.data;
        let i = r;
        const s = this.texture.textureMatrix;
        return s.isSimple || (i = this._transformedUvs, (this._textureMatrixUpdateId !== s._updateID || this._uvUpdateId !== n._updateID) && ((!i || i.length < r.length) && (i = this._transformedUvs = new Float32Array(r.length)), this._textureMatrixUpdateId = s._updateID, this._uvUpdateId = n._updateID, s.multiplyUvs(r, i))), i
    }
    get positions() {
        return this.geometry.positions
    }
    get indices() {
        return this.geometry.indices
    }
    get color() {
        return this.renderable.groupColorAlpha
    }
    get groupTransform() {
        return this.renderable.groupTransform
    }
    get attributeSize() {
        return this.geometry.positions.length / 2
    }
    get indexSize() {
        return this.geometry.indices.length
    }
}
class sF {
    constructor(e, n) {
        this.localUniforms = new Cn({
            uTransformMatrix: {
                value: new Ce,
                type: "mat3x3<f32>"
            },
            uColor: {
                value: new Float32Array([1, 1, 1, 1]),
                type: "vec4<f32>"
            },
            uRound: {
                value: 0,
                type: "f32"
            }
        }), this.localUniformsBindGroup = new Fi({
            0: this.localUniforms
        }), this._meshDataHash = Object.create(null), this._gpuBatchableMeshHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this.renderer = e, this._adaptor = n, this._adaptor.init(), e.renderableGC.addManagedHash(this, "_gpuBatchableMeshHash"), e.renderableGC.addManagedHash(this, "_meshDataHash")
    }
    validateRenderable(e) {
        const n = this._getMeshData(e),
            r = n.batched,
            i = e.batched;
        if (n.batched = i, r !== i) return !0;
        if (i) {
            const s = e._geometry;
            if (s.indices.length !== n.indexSize || s.positions.length !== n.vertexSize) return n.indexSize = s.indices.length, n.vertexSize = s.positions.length, !0;
            const o = this._getBatchableMesh(e);
            return o.texture.uid !== e._texture.uid && (o._textureMatrixUpdateId = -1), !o._batcher.checkAndUpdateTexture(o, e._texture)
        }
        return !1
    }
    addRenderable(e, n) {
        const r = this.renderer.renderPipes.batch,
            {
                batched: i
            } = this._getMeshData(e);
        if (i) {
            const s = this._getBatchableMesh(e);
            s.setTexture(e._texture), s.geometry = e._geometry, r.addToBatch(s, n)
        } else r.break(n), n.add(e)
    }
    updateRenderable(e) {
        if (e.batched) {
            const n = this._gpuBatchableMeshHash[e.uid];
            n.setTexture(e._texture), n.geometry = e._geometry, n._batcher.updateElement(n)
        }
    }
    destroyRenderable(e) {
        this._meshDataHash[e.uid] = null;
        const n = this._gpuBatchableMeshHash[e.uid];
        n && (We.return(n), this._gpuBatchableMeshHash[e.uid] = null), e.off("destroyed", this._destroyRenderableBound)
    }
    execute(e) {
        if (!e.isRenderable) return;
        e.state.blendMode = Iu(e.groupBlendMode, e.texture._source);
        const n = this.localUniforms;
        n.uniforms.uTransformMatrix = e.groupTransform, n.uniforms.uRound = this.renderer._roundPixels | e._roundPixels, n.update(), md(e.groupColorAlpha, n.uniforms.uColor, 0), this._adaptor.execute(this, e)
    }
    _getMeshData(e) {
        return this._meshDataHash[e.uid] || this._initMeshData(e)
    }
    _initMeshData(e) {
        var n, r;
        return this._meshDataHash[e.uid] = {
            batched: e.batched,
            indexSize: (n = e._geometry.indices) == null ? void 0 : n.length,
            vertexSize: (r = e._geometry.positions) == null ? void 0 : r.length
        }, e.on("destroyed", this._destroyRenderableBound), this._meshDataHash[e.uid]
    }
    _getBatchableMesh(e) {
        return this._gpuBatchableMeshHash[e.uid] || this._initBatchableMesh(e)
    }
    _initBatchableMesh(e) {
        const n = We.get(xw);
        return n.renderable = e, n.setTexture(e._texture), n.transform = e.groupTransform, n.roundPixels = this.renderer._roundPixels | e._roundPixels, this._gpuBatchableMeshHash[e.uid] = n, n
    }
    destroy() {
        for (const e in this._gpuBatchableMeshHash) this._gpuBatchableMeshHash[e] && We.return(this._gpuBatchableMeshHash[e]);
        this._gpuBatchableMeshHash = null, this._meshDataHash = null, this.localUniforms = null, this.localUniformsBindGroup = null, this._adaptor.destroy(), this._adaptor = null, this.renderer = null
    }
}
sF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "mesh"
};
class kye {
    execute(e, n) {
        const r = e.state,
            i = e.renderer,
            s = n.shader || e.defaultShader;
        s.resources.uTexture = n.texture._source, s.resources.uniforms = e.localUniforms;
        const o = i.gl,
            a = e.getBuffers(n);
        i.shader.bind(s), i.state.set(r), i.geometry.bind(a.geometry, s.glProgram);
        const c = a.geometry.indexBuffer.data.BYTES_PER_ELEMENT === 2 ? o.UNSIGNED_SHORT : o.UNSIGNED_INT;
        o.drawElements(o.TRIANGLES, n.particleChildren.length * 6, c, 0)
    }
}
class Bye {
    execute(e, n) {
        const r = e.renderer,
            i = n.shader || e.defaultShader;
        i.groups[0] = r.renderPipes.uniformBatch.getUniformBindGroup(e.localUniforms, !0), i.groups[1] = r.texture.getTextureBindGroup(n.texture);
        const s = e.state,
            o = e.getBuffers(n);
        r.encoder.draw({
            geometry: o.geometry,
            shader: n.shader || e.defaultShader,
            state: s,
            size: n.particleChildren.length * 6
        })
    }
}

function TP(t, e = null) {
    const n = t * 6;
    if (n > 65535 ? e || (e = new Uint32Array(n)) : e || (e = new Uint16Array(n)), e.length !== n) throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${n}`);
    for (let r = 0, i = 0; r < n; r += 6, i += 4) e[r + 0] = i + 0, e[r + 1] = i + 1, e[r + 2] = i + 2, e[r + 3] = i + 0, e[r + 4] = i + 2, e[r + 5] = i + 3;
    return e
}

function Dye(t) {
    return {
        dynamicUpdate: CP(t, !0),
        staticUpdate: CP(t, !1)
    }
}

function CP(t, e) {
    const n = [];
    n.push(`
      
        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
    let r = 0;
    for (const s in t) {
        const o = t[s];
        if (e !== o.dynamic) continue;
        n.push(`offset = index + ${r}`), n.push(o.code);
        const a = Gs(o.format);
        r += a.stride / 4
    }
    n.push(`
            index += stride * 4;
        }
    `), n.unshift(`
        var stride = ${r};
    `);
    const i = n.join(`
`);
    return new Function("ps", "f32v", "u32v", i)
}
class $ye {
    constructor(e) {
        this._size = 0, this._generateParticleUpdateCache = {};
        const n = this._size = e.size ? ? 1e3,
            r = e.properties;
        let i = 0,
            s = 0;
        for (const u in r) {
            const d = r[u],
                f = Gs(d.format);
            d.dynamic ? s += f.stride : i += f.stride
        }
        this._dynamicStride = s / 4, this._staticStride = i / 4, this.staticAttributeBuffer = new Va(n * 4 * i), this.dynamicAttributeBuffer = new Va(n * 4 * s), this.indexBuffer = TP(n);
        const o = new ud;
        let a = 0,
            l = 0;
        this._staticBuffer = new qn({
            data: new Float32Array(1),
            label: "static-particle-buffer",
            shrinkToFit: !1,
            usage: Xe.VERTEX | Xe.COPY_DST
        }), this._dynamicBuffer = new qn({
            data: new Float32Array(1),
            label: "dynamic-particle-buffer",
            shrinkToFit: !1,
            usage: Xe.VERTEX | Xe.COPY_DST
        });
        for (const u in r) {
            const d = r[u],
                f = Gs(d.format);
            d.dynamic ? (o.addAttribute(d.attributeName, {
                buffer: this._dynamicBuffer,
                stride: this._dynamicStride * 4,
                offset: a * 4,
                format: d.format
            }), a += f.size) : (o.addAttribute(d.attributeName, {
                buffer: this._staticBuffer,
                stride: this._staticStride * 4,
                offset: l * 4,
                format: d.format
            }), l += f.size)
        }
        o.addIndex(this.indexBuffer);
        const c = this.getParticleUpdate(r);
        this._dynamicUpload = c.dynamicUpdate, this._staticUpload = c.staticUpdate, this.geometry = o
    }
    getParticleUpdate(e) {
        const n = Fye(e);
        return this._generateParticleUpdateCache[n] ? this._generateParticleUpdateCache[n] : (this._generateParticleUpdateCache[n] = this.generateParticleUpdate(e), this._generateParticleUpdateCache[n])
    }
    generateParticleUpdate(e) {
        return Dye(e)
    }
    update(e, n) {
        e.length > this._size && (n = !0, this._size = Math.max(e.length, this._size * 1.5 | 0), this.staticAttributeBuffer = new Va(this._size * this._staticStride * 4 * 4), this.dynamicAttributeBuffer = new Va(this._size * this._dynamicStride * 4 * 4), this.indexBuffer = TP(this._size), this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, !0));
        const r = this.dynamicAttributeBuffer;
        if (this._dynamicUpload(e, r.float32View, r.uint32View), this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, e.length * this._dynamicStride * 4, !0), n) {
            const i = this.staticAttributeBuffer;
            this._staticUpload(e, i.float32View, i.uint32View), this._staticBuffer.setDataWithSize(i.float32View, e.length * this._staticStride * 4, !0)
        }
    }
    destroy() {
        this._staticBuffer.destroy(), this._dynamicBuffer.destroy(), this.geometry.destroy()
    }
}

function Fye(t) {
    const e = [];
    for (const n in t) {
        const r = t[n];
        e.push(n, r.code, r.dynamic ? "d" : "s")
    }
    return e.join("_")
}
var Lye = `varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`,
    Nye = `attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`,
    PP = `
struct ParticleUniforms {
  uProjectionMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uResolution:vec2<f32>,
  uRoundPixels:f32,
};

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`;
class Uye extends pr {
    constructor() {
        const e = ga.from({
                vertex: Nye,
                fragment: Lye
            }),
            n = Qs.from({
                fragment: {
                    source: PP,
                    entryPoint: "mainFragment"
                },
                vertex: {
                    source: PP,
                    entryPoint: "mainVertex"
                }
            });
        super({
            glProgram: e,
            gpuProgram: n,
            resources: {
                uTexture: we.WHITE.source,
                uSampler: new nD({}),
                uniforms: {
                    uTranslationMatrix: {
                        value: new Ce,
                        type: "mat3x3<f32>"
                    },
                    uColor: {
                        value: new rt(16777215),
                        type: "vec4<f32>"
                    },
                    uRound: {
                        value: 1,
                        type: "f32"
                    },
                    uResolution: {
                        value: [0, 0],
                        type: "vec2<f32>"
                    }
                }
            }
        })
    }
}
class oF {
    constructor(e, n) {
        this.state = kr.for2d(), this._gpuBufferHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this.localUniforms = new Cn({
            uTranslationMatrix: {
                value: new Ce,
                type: "mat3x3<f32>"
            },
            uColor: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uRound: {
                value: 1,
                type: "f32"
            },
            uResolution: {
                value: [0, 0],
                type: "vec2<f32>"
            }
        }), this.renderer = e, this.adaptor = n, this.defaultShader = new Uye, this.state = kr.for2d()
    }
    validateRenderable(e) {
        return !1
    }
    addRenderable(e, n) {
        this.renderer.renderPipes.batch.break(n), n.add(e)
    }
    getBuffers(e) {
        return this._gpuBufferHash[e.uid] || this._initBuffer(e)
    }
    _initBuffer(e) {
        return this._gpuBufferHash[e.uid] = new $ye({
            size: e.particleChildren.length,
            properties: e._properties
        }), e.on("destroyed", this._destroyRenderableBound), this._gpuBufferHash[e.uid]
    }
    updateRenderable(e) {}
    destroyRenderable(e) {
        this._gpuBufferHash[e.uid].destroy(), this._gpuBufferHash[e.uid] = null, e.off("destroyed", this._destroyRenderableBound)
    }
    execute(e) {
        const n = e.particleChildren;
        if (n.length === 0) return;
        const r = this.renderer,
            i = this.getBuffers(e);
        e.texture || (e.texture = n[0].texture);
        const s = this.state;
        i.update(n, e._childrenDirty), e._childrenDirty = !1, s.blendMode = Iu(e.blendMode, e.texture._source);
        const o = this.localUniforms.uniforms,
            a = o.uTranslationMatrix;
        e.worldTransform.copyTo(a), a.prepend(r.globalUniforms.globalUniformData.projectionMatrix), o.uResolution = r.globalUniforms.globalUniformData.resolution, o.uRound = r._roundPixels | e._roundPixels, md(e.groupColorAlpha, o.uColor, 0), this.adaptor.execute(this, e)
    }
    destroy() {
        this.defaultShader && (this.defaultShader.destroy(), this.defaultShader = null)
    }
}
class aF extends oF {
    constructor(e) {
        super(e, new kye)
    }
}
aF.extension = {
    type: [G.WebGLPipes],
    name: "particle"
};
class lF extends oF {
    constructor(e) {
        super(e, new Bye)
    }
}
lF.extension = {
    type: [G.WebGPUPipes],
    name: "particle"
};
const cF = class W0 {
    constructor(e) {
        if (e instanceof we) this.texture = e, x0(this, W0.defaultOptions, {});
        else {
            const n = { ...W0.defaultOptions,
                ...e
            };
            x0(this, n, {})
        }
    }
    get alpha() {
        return this._alpha
    }
    set alpha(e) {
        this._alpha = Math.min(Math.max(e, 0), 1), this._updateColor()
    }
    get tint() {
        return zc(this._tint)
    }
    set tint(e) {
        typeof e == "number" ? this._tint = e : this._tint = rt.shared.setValue(e ? ? 16777215).toBgrNumber(), this._updateColor()
    }
    _updateColor() {
        this.color = this._tint + ((this._alpha * 255 | 0) << 24)
    }
};
cF.defaultOptions = {
    anchorX: 0,
    anchorY: 0,
    x: 0,
    y: 0,
    scaleX: 1,
    scaleY: 1,
    rotation: 0,
    tint: 16777215,
    alpha: 1
};
let Pbe = cF;
const AP = {
        vertex: {
            attributeName: "aVertex",
            format: "float32x2",
            code: `
            const texture = p.texture;
            const sx = p.scaleX;
            const sy = p.scaleY;
            const ax = p.anchorX;
            const ay = p.anchorY;
            const trim = texture.trim;
            const orig = texture.orig;

            if (trim)
            {
                w1 = trim.x - (ax * orig.width);
                w0 = w1 + trim.width;

                h1 = trim.y - (ay * orig.height);
                h0 = h1 + trim.height;
            }
            else
            {
                w1 = -ax * (orig.width);
                w0 = w1 + orig.width;

                h1 = -ay * (orig.height);
                h0 = h1 + orig.height;
            }

            f32v[offset] = w1 * sx;
            f32v[offset + 1] = h1 * sy;

            f32v[offset + stride] = w0 * sx;
            f32v[offset + stride + 1] = h1 * sy;

            f32v[offset + (stride * 2)] = w0 * sx;
            f32v[offset + (stride * 2) + 1] = h0 * sy;

            f32v[offset + (stride * 3)] = w1 * sx;
            f32v[offset + (stride * 3) + 1] = h0 * sy;
        `,
            dynamic: !1
        },
        position: {
            attributeName: "aPosition",
            format: "float32x2",
            code: `
            var x = p.x;
            var y = p.y;

            f32v[offset] = x;
            f32v[offset + 1] = y;

            f32v[offset + stride] = x;
            f32v[offset + stride + 1] = y;

            f32v[offset + (stride * 2)] = x;
            f32v[offset + (stride * 2) + 1] = y;

            f32v[offset + (stride * 3)] = x;
            f32v[offset + (stride * 3) + 1] = y;
        `,
            dynamic: !0
        },
        rotation: {
            attributeName: "aRotation",
            format: "float32",
            code: `
            var rotation = p.rotation;

            f32v[offset] = rotation;
            f32v[offset + stride] = rotation;
            f32v[offset + (stride * 2)] = rotation;
            f32v[offset + (stride * 3)] = rotation;
        `,
            dynamic: !1
        },
        uvs: {
            attributeName: "aUV",
            format: "float32x2",
            code: `
            var uvs = p.texture.uvs;

            f32v[offset] = uvs.x0;
            f32v[offset + 1] = uvs.y0;

            f32v[offset + stride] = uvs.x1;
            f32v[offset + stride + 1] = uvs.y1;

            f32v[offset + (stride * 2)] = uvs.x2;
            f32v[offset + (stride * 2) + 1] = uvs.y2;

            f32v[offset + (stride * 3)] = uvs.x3;
            f32v[offset + (stride * 3) + 1] = uvs.y3;
        `,
            dynamic: !1
        },
        color: {
            attributeName: "aColor",
            format: "unorm8x4",
            code: `
            const c = p.color;

            u32v[offset] = c;
            u32v[offset + stride] = c;
            u32v[offset + (stride * 2)] = c;
            u32v[offset + (stride * 3)] = c;
        `,
            dynamic: !1
        }
    },
    Gye = new rn(0, 0, 0, 0),
    uF = class Y0 extends ld {
        constructor(e = {}) {
            e = { ...Y0.defaultOptions,
                ...e,
                dynamicProperties: { ...Y0.defaultOptions.dynamicProperties,
                    ...e == null ? void 0 : e.dynamicProperties
                }
            };
            const {
                dynamicProperties: n,
                shader: r,
                roundPixels: i,
                texture: s,
                particles: o,
                ...a
            } = e;
            super({
                label: "ParticleContainer",
                ...a
            }), this.renderPipeId = "particle", this.batched = !1, this._childrenDirty = !1, this.texture = s || null, this.shader = r, this._properties = {};
            for (const l in AP) {
                const c = AP[l],
                    u = n[l];
                this._properties[l] = { ...c,
                    dynamic: u
                }
            }
            this.allowChildren = !0, this.roundPixels = i ? ? !1, this.particleChildren = o ? ? []
        }
        addParticle(...e) {
            for (let n = 0; n < e.length; n++) this.particleChildren.push(e[n]);
            return this.onViewUpdate(), e[0]
        }
        removeParticle(...e) {
            let n = !1;
            for (let r = 0; r < e.length; r++) {
                const i = this.particleChildren.indexOf(e[r]);
                i > -1 && (this.particleChildren.splice(i, 1), n = !0)
            }
            return n && this.onViewUpdate(), e[0]
        }
        update() {
            this._childrenDirty = !0
        }
        onViewUpdate() {
            this._childrenDirty = !0, super.onViewUpdate()
        }
        get bounds() {
            return Gye
        }
        updateBounds() {}
        destroy(e = !1) {
            var r, i;
            if (super.destroy(e), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
                const s = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource,
                    o = this.texture ? ? ((r = this.particleChildren[0]) == null ? void 0 : r.texture);
                o && o.destroy(s)
            }
            this.texture = null, (i = this.shader) == null || i.destroy()
        }
        removeParticles(e, n) {
            const r = this.particleChildren.splice(e, n);
            return this.onViewUpdate(), r
        }
        removeParticleAt(e) {
            const n = this.particleChildren.splice(e, 1);
            return this.onViewUpdate(), n[0]
        }
        addParticleAt(e, n) {
            return this.particleChildren.splice(n, 0, e), this.onViewUpdate(), e
        }
        addChild(...e) {
            throw new Error("ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()")
        }
        removeChild(...e) {
            throw new Error("ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()")
        }
        removeChildren(e, n) {
            throw new Error("ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()")
        }
        removeChildAt(e) {
            throw new Error("ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()")
        }
        getChildAt(e) {
            throw new Error("ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()")
        }
        setChildIndex(e, n) {
            throw new Error("ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()")
        }
        getChildIndex(e) {
            throw new Error("ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()")
        }
        addChildAt(e, n) {
            throw new Error("ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()")
        }
        swapChildren(e, n) {
            throw new Error("ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()")
        }
        reparentChild(...e) {
            throw new Error("ParticleContainer.reparentChild() is not available with the particle container")
        }
        reparentChildAt(e, n) {
            throw new Error("ParticleContainer.reparentChildAt() is not available with the particle container")
        }
    };
uF.defaultOptions = {
    dynamicProperties: {
        vertex: !1,
        position: !0,
        rotation: !1,
        uvs: !1,
        color: !1
    },
    roundPixels: !1
};
let Abe = uF;
const dF = class fF extends Mye {
    constructor(e = {}) {
        e = { ...fF.defaultOptions,
            ...e
        }, super({
            width: e.width,
            height: e.height,
            verticesX: 4,
            verticesY: 4
        }), this.update(e)
    }
    update(e) {
        var n, r;
        this.width = e.width ? ? this.width, this.height = e.height ? ? this.height, this._originalWidth = e.originalWidth ? ? this._originalWidth, this._originalHeight = e.originalHeight ? ? this._originalHeight, this._leftWidth = e.leftWidth ? ? this._leftWidth, this._rightWidth = e.rightWidth ? ? this._rightWidth, this._topHeight = e.topHeight ? ? this._topHeight, this._bottomHeight = e.bottomHeight ? ? this._bottomHeight, this._anchorX = (n = e.anchor) == null ? void 0 : n.x, this._anchorY = (r = e.anchor) == null ? void 0 : r.y, this.updateUvs(), this.updatePositions()
    }
    updatePositions() {
        const e = this.positions,
            {
                width: n,
                height: r,
                _leftWidth: i,
                _rightWidth: s,
                _topHeight: o,
                _bottomHeight: a,
                _anchorX: l,
                _anchorY: c
            } = this,
            u = i + s,
            d = n > u ? 1 : n / u,
            f = o + a,
            h = r > f ? 1 : r / f,
            p = Math.min(d, h),
            b = l * n,
            y = c * r;
        e[0] = e[8] = e[16] = e[24] = -b, e[2] = e[10] = e[18] = e[26] = i * p - b, e[4] = e[12] = e[20] = e[28] = n - s * p - b, e[6] = e[14] = e[22] = e[30] = n - b, e[1] = e[3] = e[5] = e[7] = -y, e[9] = e[11] = e[13] = e[15] = o * p - y, e[17] = e[19] = e[21] = e[23] = r - a * p - y, e[25] = e[27] = e[29] = e[31] = r - y, this.getBuffer("aPosition").update()
    }
    updateUvs() {
        const e = this.uvs;
        e[0] = e[8] = e[16] = e[24] = 0, e[1] = e[3] = e[5] = e[7] = 0, e[6] = e[14] = e[22] = e[30] = 1, e[25] = e[27] = e[29] = e[31] = 1;
        const n = 1 / this._originalWidth,
            r = 1 / this._originalHeight;
        e[2] = e[10] = e[18] = e[26] = n * this._leftWidth, e[9] = e[11] = e[13] = e[15] = r * this._topHeight, e[4] = e[12] = e[20] = e[28] = 1 - n * this._rightWidth, e[17] = e[19] = e[21] = e[23] = 1 - r * this._bottomHeight, this.getBuffer("aUV").update()
    }
};
dF.defaultOptions = {
    width: 100,
    height: 100,
    leftWidth: 10,
    topHeight: 10,
    rightWidth: 10,
    bottomHeight: 10,
    originalWidth: 100,
    originalHeight: 100
};
let Hye = dF;
class hF {
    constructor(e) {
        this._gpuSpriteHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash")
    }
    addRenderable(e, n) {
        const r = this._getGpuSprite(e);
        e.didViewUpdate && this._updateBatchableSprite(e, r), this._renderer.renderPipes.batch.addToBatch(r, n)
    }
    updateRenderable(e) {
        const n = this._gpuSpriteHash[e.uid];
        e.didViewUpdate && this._updateBatchableSprite(e, n), n._batcher.updateElement(n)
    }
    validateRenderable(e) {
        const n = this._getGpuSprite(e);
        return !n._batcher.checkAndUpdateTexture(n, e._texture)
    }
    destroyRenderable(e) {
        const n = this._gpuSpriteHash[e.uid];
        We.return(n.geometry), We.return(n), this._gpuSpriteHash[e.uid] = null, e.off("destroyed", this._destroyRenderableBound)
    }
    _updateBatchableSprite(e, n) {
        n.geometry.update(e), n.setTexture(e._texture)
    }
    _getGpuSprite(e) {
        return this._gpuSpriteHash[e.uid] || this._initGPUSprite(e)
    }
    _initGPUSprite(e) {
        const n = We.get(xw);
        return n.geometry = We.get(Hye), n.renderable = e, n.transform = e.groupTransform, n.texture = e._texture, n.roundPixels = this._renderer._roundPixels | e._roundPixels, this._gpuSpriteHash[e.uid] = n, e.didViewUpdate || this._updateBatchableSprite(e, n), e.on("destroyed", this._destroyRenderableBound), n
    }
    destroy() {
        for (const e in this._gpuSpriteHash) this._gpuSpriteHash[e].geometry.destroy();
        this._gpuSpriteHash = null, this._renderer = null
    }
}
hF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "nineSliceSprite"
};
const zye = {
        name: "tiling-bit",
        vertex: {
            header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
            main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
        },
        fragment: {
            header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
            main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
        }
    },
    jye = {
        name: "tiling-bit",
        vertex: {
            header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,
            main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
        },
        fragment: {
            header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
            main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `
        }
    };
let wv, Ev;
class Vye extends pr {
    constructor() {
        wv ? ? (wv = dd({
            name: "tiling-sprite-shader",
            bits: [Yc, zye, hd]
        })), Ev ? ? (Ev = fd({
            name: "tiling-sprite-shader",
            bits: [cw, jye, pd]
        }));
        const e = new Cn({
            uMapCoord: {
                value: new Ce,
                type: "mat3x3<f32>"
            },
            uClampFrame: {
                value: new Float32Array([0, 0, 1, 1]),
                type: "vec4<f32>"
            },
            uClampOffset: {
                value: new Float32Array([0, 0]),
                type: "vec2<f32>"
            },
            uTextureTransform: {
                value: new Ce,
                type: "mat3x3<f32>"
            },
            uSizeAnchor: {
                value: new Float32Array([100, 100, .5, .5]),
                type: "vec4<f32>"
            }
        });
        super({
            glProgram: Ev,
            gpuProgram: wv,
            resources: {
                localUniforms: new Cn({
                    uTransformMatrix: {
                        value: new Ce,
                        type: "mat3x3<f32>"
                    },
                    uColor: {
                        value: new Float32Array([1, 1, 1, 1]),
                        type: "vec4<f32>"
                    },
                    uRound: {
                        value: 0,
                        type: "f32"
                    }
                }),
                tilingUniforms: e,
                uTexture: we.EMPTY.source,
                uSampler: we.EMPTY.source.style
            }
        })
    }
    updateUniforms(e, n, r, i, s, o) {
        const a = this.resources.tilingUniforms,
            l = o.width,
            c = o.height,
            u = o.textureMatrix,
            d = a.uniforms.uTextureTransform;
        d.set(r.a * l / e, r.b * l / n, r.c * c / e, r.d * c / n, r.tx / e, r.ty / n), d.invert(), a.uniforms.uMapCoord = u.mapCoord, a.uniforms.uClampFrame = u.uClampFrame, a.uniforms.uClampOffset = u.uClampOffset, a.uniforms.uTextureTransform = d, a.uniforms.uSizeAnchor[0] = e, a.uniforms.uSizeAnchor[1] = n, a.uniforms.uSizeAnchor[2] = i, a.uniforms.uSizeAnchor[3] = s, o && (this.resources.uTexture = o.source, this.resources.uSampler = o.source.style)
    }
}
class Wye extends ow {
    constructor() {
        super({
            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            indices: new Uint32Array([0, 1, 2, 0, 2, 3])
        })
    }
}

function Yye(t, e) {
    const n = t.anchor.x,
        r = t.anchor.y;
    e[0] = -n * t.width, e[1] = -r * t.height, e[2] = (1 - n) * t.width, e[3] = -r * t.height, e[4] = (1 - n) * t.width, e[5] = (1 - r) * t.height, e[6] = -n * t.width, e[7] = (1 - r) * t.height
}

function Xye(t, e, n, r) {
    let i = 0;
    const s = t.length / (e || 2),
        o = r.a,
        a = r.b,
        l = r.c,
        c = r.d,
        u = r.tx,
        d = r.ty;
    for (n *= e; i < s;) {
        const f = t[n],
            h = t[n + 1];
        t[n] = o * f + l * h + u, t[n + 1] = a * f + c * h + d, n += e, i++
    }
}

function Kye(t, e) {
    const n = t.texture,
        r = n.frame.width,
        i = n.frame.height;
    let s = 0,
        o = 0;
    t.applyAnchorToTexture && (s = t.anchor.x, o = t.anchor.y), e[0] = e[6] = -s, e[2] = e[4] = 1 - s, e[1] = e[3] = -o, e[5] = e[7] = 1 - o;
    const a = Ce.shared;
    a.copyFrom(t._tileTransform.matrix), a.tx /= t.width, a.ty /= t.height, a.invert(), a.scale(t.width / r, t.height / i), Xye(e, 2, 0, a)
}
const yf = new Wye;
class pF {
    constructor(e) {
        this._state = kr.default2d, this._tilingSpriteDataHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_tilingSpriteDataHash")
    }
    validateRenderable(e) {
        const n = this._getTilingSpriteData(e),
            r = n.canBatch;
        this._updateCanBatch(e);
        const i = n.canBatch;
        if (i && i === r) {
            const {
                batchableMesh: s
            } = n;
            return !s._batcher.checkAndUpdateTexture(s, e.texture)
        }
        return r !== i
    }
    addRenderable(e, n) {
        const r = this._renderer.renderPipes.batch;
        this._updateCanBatch(e);
        const i = this._getTilingSpriteData(e),
            {
                geometry: s,
                canBatch: o
            } = i;
        if (o) {
            i.batchableMesh || (i.batchableMesh = new xw);
            const a = i.batchableMesh;
            e.didViewUpdate && (this._updateBatchableMesh(e), a.geometry = s, a.renderable = e, a.transform = e.groupTransform, a.setTexture(e._texture)), a.roundPixels = this._renderer._roundPixels | e._roundPixels, r.addToBatch(a, n)
        } else r.break(n), i.shader || (i.shader = new Vye), this.updateRenderable(e), n.add(e)
    }
    execute(e) {
        const {
            shader: n
        } = this._tilingSpriteDataHash[e.uid];
        n.groups[0] = this._renderer.globalUniforms.bindGroup;
        const r = n.resources.localUniforms.uniforms;
        r.uTransformMatrix = e.groupTransform, r.uRound = this._renderer._roundPixels | e._roundPixels, md(e.groupColorAlpha, r.uColor, 0), this._state.blendMode = Iu(e.groupBlendMode, e.texture._source), this._renderer.encoder.draw({
            geometry: yf,
            shader: n,
            state: this._state
        })
    }
    updateRenderable(e) {
        const n = this._getTilingSpriteData(e),
            {
                canBatch: r
            } = n;
        if (r) {
            const {
                batchableMesh: i
            } = n;
            e.didViewUpdate && this._updateBatchableMesh(e), i._batcher.updateElement(i)
        } else if (e.didViewUpdate) {
            const {
                shader: i
            } = n;
            i.updateUniforms(e.width, e.height, e._tileTransform.matrix, e.anchor.x, e.anchor.y, e.texture)
        }
    }
    destroyRenderable(e) {
        var r;
        const n = this._getTilingSpriteData(e);
        n.batchableMesh = null, (r = n.shader) == null || r.destroy(), this._tilingSpriteDataHash[e.uid] = null, e.off("destroyed", this._destroyRenderableBound)
    }
    _getTilingSpriteData(e) {
        return this._tilingSpriteDataHash[e.uid] || this._initTilingSpriteData(e)
    }
    _initTilingSpriteData(e) {
        const n = new ow({
            indices: yf.indices,
            positions: yf.positions.slice(),
            uvs: yf.uvs.slice()
        });
        return this._tilingSpriteDataHash[e.uid] = {
            canBatch: !0,
            renderable: e,
            geometry: n
        }, e.on("destroyed", this._destroyRenderableBound), this._tilingSpriteDataHash[e.uid]
    }
    _updateBatchableMesh(e) {
        const n = this._getTilingSpriteData(e),
            {
                geometry: r
            } = n,
            i = e.texture.source.style;
        i.addressMode !== "repeat" && (i.addressMode = "repeat", i.update()), Kye(e, r.uvs), Yye(e, r.positions)
    }
    destroy() {
        for (const e in this._tilingSpriteDataHash) this.destroyRenderable(this._tilingSpriteDataHash[e].renderable);
        this._tilingSpriteDataHash = null, this._renderer = null
    }
    _updateCanBatch(e) {
        const n = this._getTilingSpriteData(e),
            r = e.texture;
        let i = !0;
        return this._renderer.type === Qn.WEBGL && (i = this._renderer.context.supports.nonPowOf2wrapping), n.canBatch = r.textureMatrix.isSimple && (i || r.source.isPowerOfTwo), n.canBatch
    }
}
pF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "tilingSprite"
};
const qye = {
        name: "local-uniform-msdf-bit",
        vertex: {
            header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
            main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
            end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        },
        fragment: {
            header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
            main: ` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
        }
    },
    Jye = {
        name: "local-uniform-msdf-bit",
        vertex: {
            header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        },
        fragment: {
            header: `
            uniform float uDistance;
         `,
            main: ` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
        }
    },
    Zye = {
        name: "msdf-bit",
        fragment: {
            header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `
        }
    },
    Qye = {
        name: "msdf-bit",
        fragment: {
            header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `
        }
    };
let Sv, Tv;
class e0e extends pr {
    constructor() {
        const e = new Cn({
                uColor: {
                    value: new Float32Array([1, 1, 1, 1]),
                    type: "vec4<f32>"
                },
                uTransformMatrix: {
                    value: new Ce,
                    type: "mat3x3<f32>"
                },
                uDistance: {
                    value: 4,
                    type: "f32"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            }),
            n = zl();
        Sv ? ? (Sv = dd({
            name: "sdf-shader",
            bits: [Vx, Yx(n), qye, Zye, hd]
        })), Tv ? ? (Tv = fd({
            name: "sdf-shader",
            bits: [Wx, Xx(n), Jye, Qye, pd]
        })), super({
            glProgram: Tv,
            gpuProgram: Sv,
            resources: {
                localUniforms: e,
                batchSamplers: Kx(n)
            }
        })
    }
}
class mF {
    constructor(e) {
        this._gpuBitmapText = {}, this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuBitmapText")
    }
    validateRenderable(e) {
        const n = this._getGpuBitmapText(e);
        return e._didTextUpdate && (e._didTextUpdate = !1, this._updateContext(e, n)), this._renderer.renderPipes.graphics.validateRenderable(n)
    }
    addRenderable(e, n) {
        const r = this._getGpuBitmapText(e);
        OP(e, r), e._didTextUpdate && (e._didTextUpdate = !1, this._updateContext(e, r)), this._renderer.renderPipes.graphics.addRenderable(r, n), r.context.customShader && this._updateDistanceField(e)
    }
    destroyRenderable(e) {
        e.off("destroyed", this._destroyRenderableBound), this._destroyRenderableByUid(e.uid)
    }
    _destroyRenderableByUid(e) {
        const n = this._gpuBitmapText[e].context;
        n.customShader && (We.return(n.customShader), n.customShader = null), We.return(this._gpuBitmapText[e]), this._gpuBitmapText[e] = null
    }
    updateRenderable(e) {
        const n = this._getGpuBitmapText(e);
        OP(e, n), this._renderer.renderPipes.graphics.updateRenderable(n), n.context.customShader && this._updateDistanceField(e)
    }
    _updateContext(e, n) {
        const {
            context: r
        } = n, i = L0.getFont(e.text, e._style);
        r.clear(), i.distanceField.type !== "none" && (r.customShader || (r.customShader = We.get(e0e)));
        const s = Array.from(e.text),
            o = e._style;
        let a = i.baseLineOffset;
        const l = g$(s, o, i, !0);
        let c = 0;
        const u = o.padding,
            d = l.scale;
        let f = l.width,
            h = l.height + l.offsetY;
        o._stroke && (f += o._stroke.width / d, h += o._stroke.width / d), r.translate(-e._anchor._x * f - u, -e._anchor._y * h - u).scale(d, d);
        const p = i.applyFillAsTint ? o._fill.color : 16777215;
        for (let b = 0; b < l.lines.length; b++) {
            const y = l.lines[b];
            for (let m = 0; m < y.charPositions.length; m++) {
                const g = s[c++],
                    v = i.chars[g];
                v != null && v.texture && r.texture(v.texture, p || "black", Math.round(y.charPositions[m] + v.xOffset), Math.round(a + v.yOffset))
            }
            a += i.lineHeight
        }
    }
    _getGpuBitmapText(e) {
        return this._gpuBitmapText[e.uid] || this.initGpuText(e)
    }
    initGpuText(e) {
        const n = We.get($h);
        return this._gpuBitmapText[e.uid] = n, this._updateContext(e, n), e.on("destroyed", this._destroyRenderableBound), this._gpuBitmapText[e.uid]
    }
    _updateDistanceField(e) {
        const n = this._getGpuBitmapText(e).context,
            r = e._style.fontFamily,
            i = ft.get(`${r}-bitmap`),
            {
                a: s,
                b: o,
                c: a,
                d: l
            } = e.groupTransform,
            c = Math.sqrt(s * s + o * o),
            u = Math.sqrt(a * a + l * l),
            d = (Math.abs(c) + Math.abs(u)) / 2,
            f = i.baseRenderedFontSize / e._style.fontSize,
            h = d * i.distanceField.range * (1 / f);
        n.customShader.resources.localUniforms.uniforms.uDistance = h
    }
    destroy() {
        for (const e in this._gpuBitmapText) this._destroyRenderableByUid(e);
        this._gpuBitmapText = null, this._renderer = null
    }
}
mF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "bitmapText"
};

function OP(t, e) {
    e.groupTransform = t.groupTransform, e.groupColorAlpha = t.groupColorAlpha, e.groupColor = t.groupColor, e.groupBlendMode = t.groupBlendMode, e.globalDisplayStatus = t.globalDisplayStatus, e.groupTransform = t.groupTransform, e.localDisplayStatus = t.localDisplayStatus, e.groupAlpha = t.groupAlpha, e._roundPixels = t._roundPixels
}

function X0(t, e) {
    const {
        texture: n,
        bounds: r
    } = t;
    oD(r, e._anchor, n);
    const i = e._style.padding;
    r.minX -= i, r.minY -= i, r.maxX -= i, r.maxY -= i
}
class gF {
    constructor(e) {
        this._gpuText = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.runners.resolutionChange.add(this), this._renderer.renderableGC.addManagedHash(this, "_gpuText")
    }
    resolutionChange() {
        for (const e in this._gpuText) {
            const n = this._gpuText[e];
            if (!n) continue;
            const r = n.batchableSprite.renderable;
            r._autoResolution && (r._resolution = this._renderer.resolution, r.onViewUpdate())
        }
    }
    validateRenderable(e) {
        const n = this._getGpuText(e),
            r = e._getKey();
        return n.textureNeedsUploading ? (n.textureNeedsUploading = !1, !0) : n.currentKey !== r
    }
    addRenderable(e, n) {
        const i = this._getGpuText(e).batchableSprite;
        e._didTextUpdate && this._updateText(e), this._renderer.renderPipes.batch.addToBatch(i, n)
    }
    updateRenderable(e) {
        const r = this._getGpuText(e).batchableSprite;
        e._didTextUpdate && this._updateText(e), r._batcher.updateElement(r)
    }
    destroyRenderable(e) {
        e.off("destroyed", this._destroyRenderableBound), this._destroyRenderableById(e.uid)
    }
    _destroyRenderableById(e) {
        const n = this._gpuText[e];
        this._renderer.htmlText.decreaseReferenceCount(n.currentKey), We.return(n.batchableSprite), this._gpuText[e] = null
    }
    _updateText(e) {
        const n = e._getKey(),
            r = this._getGpuText(e),
            i = r.batchableSprite;
        r.currentKey !== n && this._updateGpuText(e).catch(s => {
            console.error(s)
        }), e._didTextUpdate = !1, X0(i, e)
    }
    async _updateGpuText(e) {
        e._didTextUpdate = !1;
        const n = this._getGpuText(e);
        if (n.generatingTexture) return;
        const r = e._getKey();
        this._renderer.htmlText.decreaseReferenceCount(n.currentKey), n.generatingTexture = !0, n.currentKey = r;
        const i = e.resolution ? ? this._renderer.resolution,
            s = await this._renderer.htmlText.getManagedTexture(e.text, i, e._style, e._getKey()),
            o = n.batchableSprite;
        o.texture = n.texture = s, n.generatingTexture = !1, n.textureNeedsUploading = !0, e.onViewUpdate(), X0(o, e)
    }
    _getGpuText(e) {
        return this._gpuText[e.uid] || this.initGpuText(e)
    }
    initGpuText(e) {
        const n = {
                texture: we.EMPTY,
                currentKey: "--",
                batchableSprite: We.get(rm),
                textureNeedsUploading: !1,
                generatingTexture: !1
            },
            r = n.batchableSprite;
        return r.renderable = e, r.transform = e.groupTransform, r.texture = we.EMPTY, r.bounds = {
            minX: 0,
            maxX: 1,
            minY: 0,
            maxY: 0
        }, r.roundPixels = this._renderer._roundPixels | e._roundPixels, e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution, this._gpuText[e.uid] = n, e.on("destroyed", this._destroyRenderableBound), n
    }
    destroy() {
        for (const e in this._gpuText) this._destroyRenderableById(e);
        this._gpuText = null, this._renderer = null
    }
}
gF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "htmlText"
};

function t0e() {
    const {
        userAgent: t
    } = He.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(t)
}
const n0e = new rn;

function vF(t, e, n, r) {
    const i = n0e;
    i.minX = 0, i.minY = 0, i.maxX = t.width / r | 0, i.maxY = t.height / r | 0;
    const s = Ft.getOptimalTexture(i.width, i.height, r, !1);
    return s.source.uploadMethodId = "image", s.source.resource = t, s.source.alphaMode = "premultiply-alpha-on-upload", s.frame.width = e / r, s.frame.height = n / r, s.source.emit("update", s.source), s.updateUvs(), s
}

function r0e(t, e) {
    const n = e.fontFamily,
        r = [],
        i = {},
        s = /font-family:([^;"\s]+)/g,
        o = t.match(s);

    function a(l) {
        i[l] || (r.push(l), i[l] = !0)
    }
    if (Array.isArray(n))
        for (let l = 0; l < n.length; l++) a(n[l]);
    else a(n);
    o && o.forEach(l => {
        const c = l.split(":")[1].trim();
        a(c)
    });
    for (const l in e.tagStyles) {
        const c = e.tagStyles[l].fontFamily;
        a(c)
    }
    return r
}
async function i0e(t) {
    const n = await (await He.get().fetch(t)).blob(),
        r = new FileReader;
    return await new Promise((s, o) => {
        r.onloadend = () => s(r.result), r.onerror = o, r.readAsDataURL(n)
    })
}
async function IP(t, e) {
    const n = await i0e(e);
    return `@font-face {
        font-family: "${t.fontFamily}";
        src: url('${n}');
        font-weight: ${t.fontWeight};
        font-style: ${t.fontStyle};
    }`
}
const _f = new Map;
async function s0e(t, e, n) {
    const r = t.filter(i => ft.has(`${i}-and-url`)).map((i, s) => {
        if (!_f.has(i)) {
            const {
                url: o
            } = ft.get(`${i}-and-url`);
            s === 0 ? _f.set(i, IP({
                fontWeight: e.fontWeight,
                fontStyle: e.fontStyle,
                fontFamily: i
            }, o)) : _f.set(i, IP({
                fontWeight: n.fontWeight,
                fontStyle: n.fontStyle,
                fontFamily: i
            }, o))
        }
        return _f.get(i)
    });
    return (await Promise.all(r)).join(`
`)
}

function o0e(t, e, n, r, i) {
    const {
        domElement: s,
        styleElement: o,
        svgRoot: a
    } = i;
    s.innerHTML = `<style>${e.cssStyle}</style><div style='padding:0;'>${t}</div>`, s.setAttribute("style", `transform: scale(${n});transform-origin: top left; display: inline-block`), o.textContent = r;
    const {
        width: l,
        height: c
    } = i.image;
    return a.setAttribute("width", l.toString()), a.setAttribute("height", c.toString()), new XMLSerializer().serializeToString(a)
}

function a0e(t, e) {
    const n = Li.getOptimalCanvasAndContext(t.width, t.height, e),
        {
            context: r
        } = n;
    return r.clearRect(0, 0, t.width, t.height), r.drawImage(t, 0, 0), n
}

function l0e(t, e, n) {
    return new Promise(async r => {
        n && await new Promise(i => setTimeout(i, 100)), t.onload = () => {
            r()
        }, t.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(e)}`, t.crossOrigin = "anonymous"
    })
}
class ww {
    constructor(e) {
        this._activeTextures = {}, this._renderer = e, this._createCanvas = e.type === Qn.WEBGPU
    }
    getTexture(e) {
        return this._buildTexturePromise(e.text, e.resolution, e.style)
    }
    getManagedTexture(e, n, r, i) {
        if (this._activeTextures[i]) return this._increaseReferenceCount(i), this._activeTextures[i].promise;
        const s = this._buildTexturePromise(e, n, r).then(o => (this._activeTextures[i].texture = o, o));
        return this._activeTextures[i] = {
            texture: null,
            promise: s,
            usageCount: 1
        }, s
    }
    async _buildTexturePromise(e, n, r) {
        const i = We.get(D$),
            s = r0e(e, r),
            o = await s0e(s, r, aw.defaultTextStyle),
            a = Wge(e, r, o, i),
            l = Math.ceil(Math.ceil(Math.max(1, a.width) + r.padding * 2) * n),
            c = Math.ceil(Math.ceil(Math.max(1, a.height) + r.padding * 2) * n),
            u = i.image,
            d = 2;
        u.width = (l | 0) + d, u.height = (c | 0) + d;
        const f = o0e(e, r, n, o, i);
        await l0e(u, f, t0e() && s.length > 0);
        const h = u;
        let p;
        this._createCanvas && (p = a0e(u, n));
        const b = vF(p ? p.canvas : h, u.width - d, u.height - d, n);
        return this._createCanvas && (this._renderer.texture.initSource(b.source), Li.returnCanvasAndContext(p)), We.return(i), b
    }
    _increaseReferenceCount(e) {
        this._activeTextures[e].usageCount++
    }
    decreaseReferenceCount(e) {
        const n = this._activeTextures[e];
        n && (n.usageCount--, n.usageCount === 0 && (n.texture ? this._cleanUp(n) : n.promise.then(r => {
            n.texture = r, this._cleanUp(n)
        }).catch(() => {
            Me("HTMLTextSystem: Failed to clean texture")
        }), this._activeTextures[e] = null))
    }
    _cleanUp(e) {
        Ft.returnTexture(e.texture), e.texture.source.resource = null, e.texture.source.uploadMethodId = "unknown"
    }
    getReferenceCount(e) {
        return this._activeTextures[e].usageCount
    }
    destroy() {
        this._activeTextures = null
    }
}
ww.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "htmlText"
};
ww.defaultFontOptions = {
    fontFamily: "Arial",
    fontStyle: "normal",
    fontWeight: "normal"
};
class yF {
    constructor(e) {
        this._gpuText = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.runners.resolutionChange.add(this), this._renderer.renderableGC.addManagedHash(this, "_gpuText")
    }
    resolutionChange() {
        for (const e in this._gpuText) {
            const n = this._gpuText[e];
            if (!n) continue;
            const r = n.batchableSprite.renderable;
            r._autoResolution && (r._resolution = this._renderer.resolution, r.onViewUpdate())
        }
    }
    validateRenderable(e) {
        const n = this._getGpuText(e),
            r = e._getKey();
        return n.currentKey !== r
    }
    addRenderable(e, n) {
        const i = this._getGpuText(e).batchableSprite;
        e._didTextUpdate && this._updateText(e), this._renderer.renderPipes.batch.addToBatch(i, n)
    }
    updateRenderable(e) {
        const r = this._getGpuText(e).batchableSprite;
        e._didTextUpdate && this._updateText(e), r._batcher.updateElement(r)
    }
    destroyRenderable(e) {
        e.off("destroyed", this._destroyRenderableBound), this._destroyRenderableById(e.uid)
    }
    _destroyRenderableById(e) {
        const n = this._gpuText[e];
        this._renderer.canvasText.decreaseReferenceCount(n.currentKey), We.return(n.batchableSprite), this._gpuText[e] = null
    }
    _updateText(e) {
        const n = e._getKey(),
            r = this._getGpuText(e),
            i = r.batchableSprite;
        r.currentKey !== n && this._updateGpuText(e), e._didTextUpdate = !1, X0(i, e)
    }
    _updateGpuText(e) {
        const n = this._getGpuText(e),
            r = n.batchableSprite;
        n.texture && this._renderer.canvasText.decreaseReferenceCount(n.currentKey), n.texture = r.texture = this._renderer.canvasText.getManagedTexture(e), n.currentKey = e._getKey(), r.texture = n.texture
    }
    _getGpuText(e) {
        return this._gpuText[e.uid] || this.initGpuText(e)
    }
    initGpuText(e) {
        const n = {
            texture: null,
            currentKey: "--",
            batchableSprite: We.get(rm)
        };
        return n.batchableSprite.renderable = e, n.batchableSprite.transform = e.groupTransform, n.batchableSprite.bounds = {
            minX: 0,
            maxX: 1,
            minY: 0,
            maxY: 0
        }, n.batchableSprite.roundPixels = this._renderer._roundPixels | e._roundPixels, this._gpuText[e.uid] = n, e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution, this._updateText(e), e.on("destroyed", this._destroyRenderableBound), n
    }
    destroy() {
        for (const e in this._gpuText) this._destroyRenderableById(e);
        this._gpuText = null, this._renderer = null
    }
}
yF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "text"
};

function RP(t, e, n) {
    for (let r = 0, i = 4 * n * e; r < e; ++r, i += 4)
        if (t[i + 3] !== 0) return !1;
    return !0
}

function MP(t, e, n, r, i) {
    const s = 4 * e;
    for (let o = r, a = r * s + 4 * n; o <= i; ++o, a += s)
        if (t[a + 3] !== 0) return !1;
    return !0
}

function c0e(t, e = 1) {
    const {
        width: n,
        height: r
    } = t, i = t.getContext("2d", {
        willReadFrequently: !0
    });
    if (i === null) throw new TypeError("Failed to get canvas 2D context");
    const o = i.getImageData(0, 0, n, r).data;
    let a = 0,
        l = 0,
        c = n - 1,
        u = r - 1;
    for (; l < r && RP(o, n, l);) ++l;
    if (l === r) return at.EMPTY;
    for (; RP(o, n, u);) --u;
    for (; MP(o, n, a, l, u);) ++a;
    for (; MP(o, n, c, l, u);) --c;
    return ++c, ++u, new at(a / e, l / e, (c - a) / e, (u - l) / e)
}
class _F {
    constructor(e) {
        this._activeTextures = {}, this._renderer = e
    }
    getTextureSize(e, n, r) {
        const i = Ci.measureText(e || " ", r);
        let s = Math.ceil(Math.ceil(Math.max(1, i.width) + r.padding * 2) * n),
            o = Math.ceil(Math.ceil(Math.max(1, i.height) + r.padding * 2) * n);
        return s = Math.ceil(s - 1e-6), o = Math.ceil(o - 1e-6), s = Tl(s), o = Tl(o), {
            width: s,
            height: o
        }
    }
    getTexture(e, n, r, i) {
        typeof e == "string" && ($e("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"), e = {
            text: e,
            style: r,
            resolution: n
        }), e.style instanceof Wi || (e.style = new Wi(e.style));
        const {
            texture: s,
            canvasAndContext: o
        } = this.createTextureAndCanvas(e);
        return this._renderer.texture.initSource(s._source), Li.returnCanvasAndContext(o), s
    }
    createTextureAndCanvas(e) {
        const {
            text: n,
            style: r
        } = e, i = e.resolution ? ? this._renderer.resolution, s = Ci.measureText(n || " ", r), o = Math.ceil(Math.ceil(Math.max(1, s.width) + r.padding * 2) * i), a = Math.ceil(Math.ceil(Math.max(1, s.height) + r.padding * 2) * i), l = Li.getOptimalCanvasAndContext(o, a), {
            canvas: c
        } = l;
        this.renderTextToCanvas(n, r, i, l);
        const u = vF(c, o, a, i);
        if (r.trim) {
            const d = c0e(c, i);
            u.frame.copyFrom(d), u.updateUvs()
        }
        return {
            texture: u,
            canvasAndContext: l
        }
    }
    getManagedTexture(e) {
        e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution;
        const n = e._getKey();
        if (this._activeTextures[n]) return this._increaseReferenceCount(n), this._activeTextures[n].texture;
        const {
            texture: r,
            canvasAndContext: i
        } = this.createTextureAndCanvas(e);
        return this._activeTextures[n] = {
            canvasAndContext: i,
            texture: r,
            usageCount: 1
        }, r
    }
    _increaseReferenceCount(e) {
        this._activeTextures[e].usageCount++
    }
    returnTexture(e) {
        const n = e.source;
        n.resource = null, n.uploadMethodId = "unknown", n.alphaMode = "no-premultiply-alpha", Ft.returnTexture(e)
    }
    decreaseReferenceCount(e) {
        const n = this._activeTextures[e];
        n.usageCount--, n.usageCount === 0 && (Li.returnCanvasAndContext(n.canvasAndContext), this.returnTexture(n.texture), this._activeTextures[e] = null)
    }
    getReferenceCount(e) {
        return this._activeTextures[e].usageCount
    }
    renderTextToCanvas(e, n, r, i) {
        var g, v, _, x;
        const {
            canvas: s,
            context: o
        } = i, a = kh(n), l = Ci.measureText(e || " ", n), c = l.lines, u = l.lineHeight, d = l.lineWidths, f = l.maxLineWidth, h = l.fontProperties, p = s.height;
        if (o.resetTransform(), o.scale(r, r), o.textBaseline = n.textBaseline, (g = n._stroke) != null && g.width) {
            const w = n._stroke;
            o.lineWidth = w.width, o.miterLimit = w.miterLimit, o.lineJoin = w.join, o.lineCap = w.cap
        }
        o.font = a;
        let b, y;
        const m = n.dropShadow ? 2 : 1;
        for (let w = 0; w < m; ++w) {
            const S = n.dropShadow && w === 0,
                C = S ? Math.ceil(Math.max(1, p) + n.padding * 2) : 0,
                A = C * r;
            if (S) {
                o.fillStyle = "black", o.strokeStyle = "black";
                const P = n.dropShadow,
                    B = P.color,
                    F = P.alpha;
                o.shadowColor = rt.shared.setValue(B).setAlpha(F).toRgbaString();
                const H = P.blur * r,
                    k = P.distance * r;
                o.shadowBlur = H, o.shadowOffsetX = Math.cos(P.angle) * k, o.shadowOffsetY = Math.sin(P.angle) * k + A
            } else {
                if (o.fillStyle = n._fill ? Bh(n._fill, o, l) : null, (v = n._stroke) != null && v.width) {
                    const P = n._stroke.width * n._stroke.alignment;
                    o.strokeStyle = Bh(n._stroke, o, l, P)
                }
                o.shadowColor = "black"
            }
            let T = (u - h.fontSize) / 2;
            u - h.fontSize < 0 && (T = 0);
            const E = ((_ = n._stroke) == null ? void 0 : _.width) ? ? 0;
            for (let P = 0; P < c.length; P++) b = E / 2, y = E / 2 + P * u + h.ascent + T, n.align === "right" ? b += f - d[P] : n.align === "center" && (b += (f - d[P]) / 2), (x = n._stroke) != null && x.width && this._drawLetterSpacing(c[P], n, i, b + n.padding, y + n.padding - C, !0), n._fill !== void 0 && this._drawLetterSpacing(c[P], n, i, b + n.padding, y + n.padding - C)
        }
    }
    _drawLetterSpacing(e, n, r, i, s, o = !1) {
        const {
            context: a
        } = r, l = n.letterSpacing;
        let c = !1;
        if (Ci.experimentalLetterSpacingSupported && (Ci.experimentalLetterSpacing ? (a.letterSpacing = `${l}px`, a.textLetterSpacing = `${l}px`, c = !0) : (a.letterSpacing = "0px", a.textLetterSpacing = "0px")), l === 0 || c) {
            o ? a.strokeText(e, i, s) : a.fillText(e, i, s);
            return
        }
        let u = i;
        const d = Ci.graphemeSegmenter(e);
        let f = a.measureText(e).width,
            h = 0;
        for (let p = 0; p < d.length; ++p) {
            const b = d[p];
            o ? a.strokeText(b, u, s) : a.fillText(b, u, s);
            let y = "";
            for (let m = p + 1; m < d.length; ++m) y += d[m];
            h = a.measureText(y).width, u += f - h + l, f = h
        }
    }
    destroy() {
        this._activeTextures = null
    }
}
_F.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "canvasText"
};
Ie.add(Vde, Wde);
var Lo = {},
    bF = {},
    Ni = {};
Object.defineProperty(Ni, "__esModule", {
    value: !0
});
Ni.loop = Ni.conditional = Ni.parse = void 0;
var u0e = function t(e, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : r;
    if (Array.isArray(n)) n.forEach(function(o) {
        return t(e, o, r, i)
    });
    else if (typeof n == "function") n(e, r, i, t);
    else {
        var s = Object.keys(n)[0];
        Array.isArray(n[s]) ? (i[s] = {}, t(e, n[s], r, i[s])) : i[s] = n[s](e, r, i, t)
    }
    return r
};
Ni.parse = u0e;
var d0e = function(e, n) {
    return function(r, i, s, o) {
        n(r, i, s) && o(r, e, i, s)
    }
};
Ni.conditional = d0e;
var f0e = function(e, n) {
    return function(r, i, s, o) {
        for (var a = [], l = r.pos; n(r, i, s);) {
            var c = {};
            if (o(r, e, i, c), r.pos === l) break;
            l = r.pos, a.push(c)
        }
        return a
    }
};
Ni.loop = f0e;
var Rt = {};
Object.defineProperty(Rt, "__esModule", {
    value: !0
});
Rt.readBits = Rt.readArray = Rt.readUnsigned = Rt.readString = Rt.peekBytes = Rt.readBytes = Rt.peekByte = Rt.readByte = Rt.buildStream = void 0;
var h0e = function(e) {
    return {
        data: e,
        pos: 0
    }
};
Rt.buildStream = h0e;
var xF = function() {
    return function(e) {
        return e.data[e.pos++]
    }
};
Rt.readByte = xF;
var p0e = function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return function(n) {
        return n.data[n.pos + e]
    }
};
Rt.peekByte = p0e;
var im = function(e) {
    return function(n) {
        return n.data.subarray(n.pos, n.pos += e)
    }
};
Rt.readBytes = im;
var m0e = function(e) {
    return function(n) {
        return n.data.subarray(n.pos, n.pos + e)
    }
};
Rt.peekBytes = m0e;
var g0e = function(e) {
    return function(n) {
        return Array.from(im(e)(n)).map(function(r) {
            return String.fromCharCode(r)
        }).join("")
    }
};
Rt.readString = g0e;
var v0e = function(e) {
    return function(n) {
        var r = im(2)(n);
        return e ? (r[1] << 8) + r[0] : (r[0] << 8) + r[1]
    }
};
Rt.readUnsigned = v0e;
var y0e = function(e, n) {
    return function(r, i, s) {
        for (var o = typeof n == "function" ? n(r, i, s) : n, a = im(e), l = new Array(o), c = 0; c < o; c++) l[c] = a(r);
        return l
    }
};
Rt.readArray = y0e;
var _0e = function(e, n, r) {
        for (var i = 0, s = 0; s < r; s++) i += e[n + s] && Math.pow(2, r - s - 1);
        return i
    },
    b0e = function(e) {
        return function(n) {
            for (var r = xF()(n), i = new Array(8), s = 0; s < 8; s++) i[7 - s] = !!(r & 1 << s);
            return Object.keys(e).reduce(function(o, a) {
                var l = e[a];
                return l.length ? o[a] = _0e(i, l.index, l.length) : o[a] = i[l.index], o
            }, {})
        }
    };
Rt.readBits = b0e;
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.default = void 0;
    var e = Ni,
        n = Rt,
        r = {
            blocks: function(f) {
                for (var h = 0, p = [], b = f.data.length, y = 0, m = (0, n.readByte)()(f); m !== h && m; m = (0, n.readByte)()(f)) {
                    if (f.pos + m >= b) {
                        var g = b - f.pos;
                        p.push((0, n.readBytes)(g)(f)), y += g;
                        break
                    }
                    p.push((0, n.readBytes)(m)(f)), y += m
                }
                for (var v = new Uint8Array(y), _ = 0, x = 0; x < p.length; x++) v.set(p[x], _), _ += p[x].length;
                return v
            }
        },
        i = (0, e.conditional)({
            gce: [{
                codes: (0, n.readBytes)(2)
            }, {
                byteSize: (0, n.readByte)()
            }, {
                extras: (0, n.readBits)({
                    future: {
                        index: 0,
                        length: 3
                    },
                    disposal: {
                        index: 3,
                        length: 3
                    },
                    userInput: {
                        index: 6
                    },
                    transparentColorGiven: {
                        index: 7
                    }
                })
            }, {
                delay: (0, n.readUnsigned)(!0)
            }, {
                transparentColorIndex: (0, n.readByte)()
            }, {
                terminator: (0, n.readByte)()
            }]
        }, function(d) {
            var f = (0, n.peekBytes)(2)(d);
            return f[0] === 33 && f[1] === 249
        }),
        s = (0, e.conditional)({
            image: [{
                code: (0, n.readByte)()
            }, {
                descriptor: [{
                    left: (0, n.readUnsigned)(!0)
                }, {
                    top: (0, n.readUnsigned)(!0)
                }, {
                    width: (0, n.readUnsigned)(!0)
                }, {
                    height: (0, n.readUnsigned)(!0)
                }, {
                    lct: (0, n.readBits)({
                        exists: {
                            index: 0
                        },
                        interlaced: {
                            index: 1
                        },
                        sort: {
                            index: 2
                        },
                        future: {
                            index: 3,
                            length: 2
                        },
                        size: {
                            index: 5,
                            length: 3
                        }
                    })
                }]
            }, (0, e.conditional)({
                lct: (0, n.readArray)(3, function(d, f, h) {
                    return Math.pow(2, h.descriptor.lct.size + 1)
                })
            }, function(d, f, h) {
                return h.descriptor.lct.exists
            }), {
                data: [{
                    minCodeSize: (0, n.readByte)()
                }, r]
            }]
        }, function(d) {
            return (0, n.peekByte)()(d) === 44
        }),
        o = (0, e.conditional)({
            text: [{
                codes: (0, n.readBytes)(2)
            }, {
                blockSize: (0, n.readByte)()
            }, {
                preData: function(f, h, p) {
                    return (0, n.readBytes)(p.text.blockSize)(f)
                }
            }, r]
        }, function(d) {
            var f = (0, n.peekBytes)(2)(d);
            return f[0] === 33 && f[1] === 1
        }),
        a = (0, e.conditional)({
            application: [{
                codes: (0, n.readBytes)(2)
            }, {
                blockSize: (0, n.readByte)()
            }, {
                id: function(f, h, p) {
                    return (0, n.readString)(p.blockSize)(f)
                }
            }, r]
        }, function(d) {
            var f = (0, n.peekBytes)(2)(d);
            return f[0] === 33 && f[1] === 255
        }),
        l = (0, e.conditional)({
            comment: [{
                codes: (0, n.readBytes)(2)
            }, r]
        }, function(d) {
            var f = (0, n.peekBytes)(2)(d);
            return f[0] === 33 && f[1] === 254
        }),
        c = [{
            header: [{
                signature: (0, n.readString)(3)
            }, {
                version: (0, n.readString)(3)
            }]
        }, {
            lsd: [{
                width: (0, n.readUnsigned)(!0)
            }, {
                height: (0, n.readUnsigned)(!0)
            }, {
                gct: (0, n.readBits)({
                    exists: {
                        index: 0
                    },
                    resolution: {
                        index: 1,
                        length: 3
                    },
                    sort: {
                        index: 4
                    },
                    size: {
                        index: 5,
                        length: 3
                    }
                })
            }, {
                backgroundColorIndex: (0, n.readByte)()
            }, {
                pixelAspectRatio: (0, n.readByte)()
            }]
        }, (0, e.conditional)({
            gct: (0, n.readArray)(3, function(d, f) {
                return Math.pow(2, f.lsd.gct.size + 1)
            })
        }, function(d, f) {
            return f.lsd.gct.exists
        }), {
            frames: (0, e.loop)([i, a, l, s, o], function(d) {
                var f = (0, n.peekByte)()(d);
                return f === 33 || f === 44
            })
        }],
        u = c;
    t.default = u
})(bF);
var sm = {};
Object.defineProperty(sm, "__esModule", {
    value: !0
});
sm.deinterlace = void 0;
var x0e = function(e, n) {
    for (var r = new Array(e.length), i = e.length / n, s = function(f, h) {
            var p = e.slice(h * n, (h + 1) * n);
            r.splice.apply(r, [f * n, n].concat(p))
        }, o = [0, 4, 2, 1], a = [8, 8, 4, 2], l = 0, c = 0; c < 4; c++)
        for (var u = o[c]; u < i; u += a[c]) s(u, l), l++;
    return r
};
sm.deinterlace = x0e;
var om = {};
Object.defineProperty(om, "__esModule", {
    value: !0
});
om.lzw = void 0;
var w0e = function(e, n, r) {
    var i = 4096,
        s = -1,
        o = r,
        a, l, c, u, d, f, h, w, p, b, x, y, S, C, T, A, m = new Array(r),
        g = new Array(i),
        v = new Array(i),
        _ = new Array(i + 1);
    for (y = e, l = 1 << y, d = l + 1, a = l + 2, h = s, u = y + 1, c = (1 << u) - 1, p = 0; p < l; p++) g[p] = 0, v[p] = p;
    var x, w, S, C, A, T;
    for (x = w = S = C = A = T = 0, b = 0; b < o;) {
        if (C === 0) {
            if (w < u) {
                x += n[T] << w, w += 8, T++;
                continue
            }
            if (p = x & c, x >>= u, w -= u, p > a || p == d) break;
            if (p == l) {
                u = y + 1, c = (1 << u) - 1, a = l + 2, h = s;
                continue
            }
            if (h == s) {
                _[C++] = v[p], h = p, S = p;
                continue
            }
            for (f = p, p == a && (_[C++] = S, p = h); p > l;) _[C++] = v[p], p = g[p];
            S = v[p] & 255, _[C++] = S, a < i && (g[a] = h, v[a] = S, a++, !(a & c) && a < i && (u++, c += a)), h = f
        }
        C--, m[A++] = _[C], b++
    }
    for (b = A; b < o; b++) m[b] = 0;
    return m
};
om.lzw = w0e;
Object.defineProperty(Lo, "__esModule", {
    value: !0
});
var wF = Lo.decompressFrames = Lo.decompressFrame = EF = Lo.parseGIF = void 0,
    E0e = A0e(bF),
    S0e = Ni,
    T0e = Rt,
    C0e = sm,
    P0e = om;

function A0e(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
var O0e = function(e) {
        var n = new Uint8Array(e);
        return (0, S0e.parse)((0, T0e.buildStream)(n), E0e.default)
    },
    EF = Lo.parseGIF = O0e,
    I0e = function(e) {
        for (var n = e.pixels.length, r = new Uint8ClampedArray(n * 4), i = 0; i < n; i++) {
            var s = i * 4,
                o = e.pixels[i],
                a = e.colorTable[o] || [0, 0, 0];
            r[s] = a[0], r[s + 1] = a[1], r[s + 2] = a[2], r[s + 3] = o !== e.transparentIndex ? 255 : 0
        }
        return r
    },
    SF = function(e, n, r) {
        if (!e.image) {
            console.warn("gif frame does not have associated image.");
            return
        }
        var i = e.image,
            s = i.descriptor.width * i.descriptor.height,
            o = (0, P0e.lzw)(i.data.minCodeSize, i.data.blocks, s);
        i.descriptor.lct.interlaced && (o = (0, C0e.deinterlace)(o, i.descriptor.width));
        var a = {
            pixels: o,
            dims: {
                top: e.image.descriptor.top,
                left: e.image.descriptor.left,
                width: e.image.descriptor.width,
                height: e.image.descriptor.height
            }
        };
        return i.descriptor.lct && i.descriptor.lct.exists ? a.colorTable = i.lct : a.colorTable = n, e.gce && (a.delay = (e.gce.delay || 10) * 10, a.disposalType = e.gce.extras.disposal, e.gce.extras.transparentColorGiven && (a.transparentIndex = e.gce.transparentColorIndex)), r && (a.patch = I0e(a)), a
    };
Lo.decompressFrame = SF;
var R0e = function(e, n) {
    return e.frames.filter(function(r) {
        return r.image
    }).map(function(r) {
        return SF(r, e.gct, n)
    })
};
wF = Lo.decompressFrames = R0e;
class am {
    constructor(e) {
        if (!e || !e.length) throw new Error("Invalid frames");
        const [{
            texture: {
                width: n,
                height: r
            }
        }] = e;
        this.width = n, this.height = r, this.frames = e, this.textures = this.frames.map(i => i.texture), this.totalFrames = this.frames.length, this.duration = this.frames[this.totalFrames - 1].end
    }
    destroy() {
        for (const e of this.textures) e.destroy(!0);
        for (const e of this.frames) e.texture = null;
        this.frames.length = 0, this.textures.length = 0, Object.assign(this, {
            frames: null,
            textures: null,
            width: 0,
            height: 0,
            duration: 0,
            totalFrames: 0
        })
    }
    static from(e, n) {
        if (!e || e.byteLength === 0) throw new Error("Invalid buffer");
        const r = y => {
                let m = null;
                for (const g of y.frames) m = g.gce ? ? m, "image" in g && !("gce" in g) && (g.gce = m)
            },
            i = EF(e);
        r(i);
        const s = wF(i, !0),
            o = [],
            a = i.lsd.width,
            l = i.lsd.height,
            c = He.get().createCanvas(a, l),
            u = c.getContext("2d", {
                willReadFrequently: !0
            }),
            d = He.get().createCanvas(),
            f = d.getContext("2d");
        let h = 0,
            p = null;
        const b = 1e3 / ((n == null ? void 0 : n.fps) ? ? 30);
        for (let y = 0; y < s.length; y++) {
            const {
                disposalType: m = 2,
                delay: g = b,
                patch: v,
                dims: {
                    width: _,
                    height: x,
                    left: w,
                    top: S
                }
            } = s[y];
            d.width = _, d.height = x, f.clearRect(0, 0, _, x);
            const C = f.createImageData(_, x);
            C.data.set(v), f.putImageData(C, 0, 0), m === 3 && (p = u.getImageData(0, 0, a, l)), u.drawImage(d, w, S);
            const A = u.getImageData(0, 0, a, l);
            m === 2 ? u.clearRect(0, 0, a, l) : m === 3 && u.putImageData(p, 0, 0);
            const T = He.get().createCanvas(A.width, A.height);
            T.getContext("2d").putImageData(A, 0, 0), o.push({
                start: h,
                end: h + g,
                texture: new we({
                    source: new ni({
                        resource: T
                    })
                })
            }), h += g
        }
        return c.width = c.height = 0, d.width = d.height = 0, new am(o)
    }
}
const M0e = {
        extension: G.Asset,
        detection: {
            test: async () => !0,
            add: async t => [...t, "gif"],
            remove: async t => t.filter(e => e !== "gif")
        },
        loader: {
            name: "gifLoader",
            test: t => Dn.extname(t) === ".gif" || t.startsWith("data:image/gif"),
            load: async (t, e) => {
                const r = await (await He.get().fetch(t)).arrayBuffer();
                return am.from(r, e == null ? void 0 : e.data)
            },
            unload: async t => {
                t.destroy()
            }
        }
    },
    TF = class K0 extends ta {
        constructor(...e) {
            const n = e[0] instanceof am ? {
                    source: e[0]
                } : e[0],
                {
                    scaleMode: r,
                    source: i,
                    fps: s,
                    loop: o,
                    animationSpeed: a,
                    autoPlay: l,
                    autoUpdate: c,
                    onComplete: u,
                    onFrameChange: d,
                    onLoop: f,
                    ...h
                } = Object.assign({}, K0.defaultOptions, n);
            super({
                texture: we.EMPTY,
                ...h
            }), this.animationSpeed = 1, this.loop = !0, this.duration = 0, this.autoPlay = !0, this.dirty = !1, this._currentFrame = 0, this._autoUpdate = !1, this._isConnectedToTicker = !1, this._playing = !1, this._currentTime = 0, this.onRender = () => this._updateFrame(), this.texture = i.textures[0], this.duration = i.frames[i.frames.length - 1].end, this._source = i, this._playing = !1, this._currentTime = 0, this._isConnectedToTicker = !1, Object.assign(this, {
                fps: s,
                loop: o,
                animationSpeed: a,
                autoPlay: l,
                autoUpdate: c,
                onComplete: u,
                onFrameChange: d,
                onLoop: f
            }), this.currentFrame = 0, l && this.play()
        }
        stop() {
            this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (bn.shared.remove(this.update, this), this._isConnectedToTicker = !1))
        }
        play() {
            this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (bn.shared.add(this.update, this, Pl.HIGH), this._isConnectedToTicker = !0), !this.loop && this.currentFrame === this._source.frames.length - 1 && (this._currentTime = 0))
        }
        get progress() {
            return this._currentTime / this.duration
        }
        get playing() {
            return this._playing
        }
        update(e) {
            var o, a;
            if (!this._playing) return;
            const n = this.animationSpeed * e.deltaTime / bn.targetFPMS,
                r = this._currentTime + n,
                i = r % this.duration,
                s = this._source.frames.findIndex(l => l.start <= i && l.end > i);
            r >= this.duration ? this.loop ? (this._currentTime = i, this._updateFrameIndex(s), (o = this.onLoop) == null || o.call(this)) : (this._currentTime = this.duration, this._updateFrameIndex(this.totalFrames - 1), (a = this.onComplete) == null || a.call(this), this.stop()) : (this._currentTime = i, this._updateFrameIndex(s))
        }
        _updateFrame() {
            this.dirty && (this.texture = this._source.frames[this._currentFrame].texture, this.dirty = !1)
        }
        get autoUpdate() {
            return this._autoUpdate
        }
        set autoUpdate(e) {
            e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (bn.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (bn.shared.add(this.update, this), this._isConnectedToTicker = !0))
        }
        get currentFrame() {
            return this._currentFrame
        }
        set currentFrame(e) {
            this._updateFrameIndex(e), this._currentTime = this._source.frames[e].start
        }
        get source() {
            return this._source
        }
        _updateFrameIndex(e) {
            var n;
            if (e < 0 || e >= this.totalFrames) throw new Error(`Frame index out of range, expecting 0 to ${this.totalFrames}, got ${e}`);
            this._currentFrame !== e && (this._currentFrame = e, this.dirty = !0, (n = this.onFrameChange) == null || n.call(this, e))
        }
        get totalFrames() {
            return this._source.totalFrames
        }
        destroy(e = !1) {
            this.stop(), super.destroy(), e && this._source.destroy();
            const n = null;
            this._source = n, this.onComplete = n, this.onFrameChange = n, this.onLoop = n
        }
        clone() {
            const e = new K0({
                source: this._source,
                autoUpdate: this._autoUpdate,
                loop: this.loop,
                autoPlay: this.autoPlay,
                scaleMode: this.texture.source.scaleMode,
                animationSpeed: this.animationSpeed,
                onComplete: this.onComplete,
                onFrameChange: this.onFrameChange,
                onLoop: this.onLoop
            });
            return e.dirty = !0, e
        }
    };
TF.defaultOptions = {
    scaleMode: "linear",
    fps: 30,
    loop: !0,
    animationSpeed: 1,
    autoPlay: !0,
    autoUpdate: !0,
    onComplete: null,
    onFrameChange: null,
    onLoop: null
};
let Obe = TF;
Ie.add(M0e);
var kP = function() {
    return kP = Object.assign || function(e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
            n = arguments[r];
            for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
        }
        return e
    }, kP.apply(this, arguments)
};

function Ibe(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        })
    }
    return new(n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                c(r.next(u))
            } catch (d) {
                o(d)
            }
        }

        function l(u) {
            try {
                c(r.throw(u))
            } catch (d) {
                o(d)
            }
        }

        function c(u) {
            u.done ? s(u.value) : i(u.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    })
}

function Rbe(t, e) {
    var n = {
            label: 0,
            sent: function() {
                if (s[0] & 1) throw s[1];
                return s[1]
            },
            trys: [],
            ops: []
        },
        r, i, s, o = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
    return o.next = a(0), o.throw = a(1), o.return = a(2), typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }), o;

    function a(c) {
        return function(u) {
            return l([c, u])
        }
    }

    function l(c) {
        if (r) throw new TypeError("Generator is already executing.");
        for (; o && (o = 0, c[0] && (n = 0)), n;) try {
            if (r = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
            switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                case 0:
                case 1:
                    s = c;
                    break;
                case 4:
                    return n.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    n.label++, i = c[1], c = [0];
                    continue;
                case 7:
                    c = n.ops.pop(), n.trys.pop();
                    continue;
                default:
                    if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        n = 0;
                        continue
                    }
                    if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                        n.label = c[1];
                        break
                    }
                    if (c[0] === 6 && n.label < s[1]) {
                        n.label = s[1], s = c;
                        break
                    }
                    if (s && n.label < s[2]) {
                        n.label = s[2], n.ops.push(c);
                        break
                    }
                    s[2] && n.ops.pop(), n.trys.pop();
                    continue
            }
            c = e.call(t, n)
        } catch (u) {
            c = [6, u], i = 0
        } finally {
            r = s = 0
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}

function Mbe(t, e, n) {
    if (n || arguments.length === 2)
        for (var r = 0, i = e.length, s; r < i; r++)(s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
    return t.concat(s || Array.prototype.slice.call(e))
}
Ie.add(Zfe);
Ie.mixin(Zn, Qfe);
Ie.add(YD);
Ie.add(XD);
Ie.add(S$);
Ie.mixin(Zn, Pge);
Ie.add(E$);
Ie.add(nF);
Ie.add(Qx);
Ie.add(sF);
Ie.add(aF);
Ie.add(lF);
Ie.add(_F);
Ie.add(yF);
Ie.add(mF);
Ie.add(ww);
Ie.add(gF);
Ie.add(pF);
Ie.add(hF);
Ie.add(O$);
Ie.add(A$);
const k0e = Object.freeze(Object.defineProperty({
        __proto__: null
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    B0e = Object.freeze(Object.defineProperty({
        __proto__: null
    }, Symbol.toStringTag, {
        value: "Module"
    }));
export {
    I as $, $0e as A, cbe as B, abe as C, fbe as D, X0e as E, St as F, Ue as G, zs as H, Ki as I, Yi as J, tt as K, bV as L, pe as M, En as N, ht as O, ne as P, Vb as Q, XO as R, N0e as S, er as T, K0e as U, ye as V, CN as W, gt as X, AN as Y, $L as Z, Ibe as _, Rbe as a, lh as a$, ube as a0, dbe as a1, ua as a2, KY as a3, f_e as a4, X_e as a5, H_e as a6, Z_e as a7, J0e as a8, tbe as a9, gbe as aA, V_e as aB, PN as aC, OQ as aD, Nt as aE, Ec as aF, W_e as aG, j_e as aH, xbe as aI, nbe as aJ, dn as aK, $U as aL, _be as aM, ybe as aN, vbe as aO, Y_e as aP, nd as aQ, bO as aR, vM as aS, jde as aT, G_e as aU, Z0e as aV, zo as aW, Yu as aX, aW as aY, $t as aZ, e_e as a_, Pr as aa, z_e as ab, Q_e as ac, C4 as ad, sbe as ae, Cr as af, Ar as ag, Uu as ah, IN as ai, Gu as aj, AA as ak, bbe as al, J_e as am, T_ as an, p_ as ao, ep as ap, iN as aq, sN as ar, xN as as, nh as at, a2 as au, r2 as av, wU as aw, Fle as ax, lbe as ay, zh as az, kP as b, C_e as b$, __e as b0, W0e as b1, Y0e as b2, EN as b3, fN as b4, bn as b5, Zn as b6, ta as b7, pf as b8, Cbe as b9, H0e as bA, r_e as bB, t_e as bC, S_e as bD, T_e as bE, m_e as bF, g_e as bG, i_e as bH, HW as bI, z0e as bJ, j0e as bK, x_e as bL, h_e as bM, p_e as bN, l_e as bO, c_e as bP, qi as bQ, o_e as bR, d_e as bS, a_e as bT, E_e as bU, P_e as bV, v_e as bW, Q0e as bX, ha as bY, l7 as bZ, u_e as b_, Tbe as ba, $h as bb, ct as bc, Dge as bd, Lhe as be, Abe as bf, Obe as bg, we as bh, Pbe as bi, O_e as bj, Il as bk, qt as bl, ty as bm, it as bn, ebe as bo, S_ as bp, et as bq, wbe as br, pX as bs, ON as bt, Uee as bu, Hre as bv, hbe as bw, pbe as bx, mbe as by, y_e as bz, Mbe as c, I_e as c0, s_e as c1, w_e as c2, vp as c3, b_e as c4, y2 as c5, A_e as c6, TO as c7, D0e as c8, F0e as c9, rbe as ca, fL as cb, oa as cc, q_e as cd, ibe as ce, M_e as d, k_e as e, B_e as f, D_e as g, $_e as h, F_e as i, L_e as j, N_e as k, U_e as l, x4 as m, T4 as n, Zh as o, C_ as p, R_e as q, J as r, _V as s, Vf as t, q0e as u, L0e as v, U0e as w, K_e as x, by as y, obe as z
};
//# sourceMappingURL=common.modules-85a637e4.js.map